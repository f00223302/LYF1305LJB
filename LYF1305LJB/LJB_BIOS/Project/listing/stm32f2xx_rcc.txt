; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\output\stm32f2xx_rcc.o --asm_dir=..\listing\ --list_dir=..\listing\ --depend=..\output\stm32f2xx_rcc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\src -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\STM32F2xx -I..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc -I..\..\Utilities\STM32_EVAL -I..\src\SYSTICK -I..\src\LED -I..\src\GPIO -I..\src\USART -I..\src\FLASH -I..\src\HexFile -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DUSE_CPU_F205RC -DLJB_CPU -W --omf_browse=..\output\stm32f2xx_rcc.crf ..\..\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_rcc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;195      */
;;;196    void RCC_DeInit(void)
000000  48f7              LDR      r0,|L1.992|
;;;197    {
;;;198      /* Set HSION bit */
;;;199      RCC->CR |= (uint32_t)0x00000001;
000002  6800              LDR      r0,[r0,#0]
000004  f0400001          ORR      r0,r0,#1
000008  49f5              LDR      r1,|L1.992|
00000a  6008              STR      r0,[r1,#0]
;;;200    
;;;201      /* Reset CFGR register */
;;;202      RCC->CFGR = 0x00000000;
00000c  f04f0000          MOV      r0,#0
000010  49f4              LDR      r1,|L1.996|
000012  6008              STR      r0,[r1,#0]
;;;203    
;;;204      /* Reset HSEON, CSSON and PLLON bits */
;;;205      RCC->CR &= (uint32_t)0xFEF6FFFF;
000014  48f2              LDR      r0,|L1.992|
000016  6800              LDR      r0,[r0,#0]
000018  49f3              LDR      r1,|L1.1000|
00001a  ea000001          AND      r0,r0,r1
00001e  49f0              LDR      r1,|L1.992|
000020  6008              STR      r0,[r1,#0]
;;;206    
;;;207      /* Reset PLLCFGR register */
;;;208      RCC->PLLCFGR = 0x24003010;
000022  48f2              LDR      r0,|L1.1004|
000024  f1010104          ADD      r1,r1,#4
000028  6008              STR      r0,[r1,#0]
;;;209    
;;;210      /* Reset HSEBYP bit */
;;;211      RCC->CR &= (uint32_t)0xFFFBFFFF;
00002a  48ed              LDR      r0,|L1.992|
00002c  6800              LDR      r0,[r0,#0]
00002e  f4202080          BIC      r0,r0,#0x40000
000032  49eb              LDR      r1,|L1.992|
000034  6008              STR      r0,[r1,#0]
;;;212    
;;;213      /* Disable all interrupts */
;;;214      RCC->CIR = 0x00000000;
000036  f04f0000          MOV      r0,#0
00003a  49ed              LDR      r1,|L1.1008|
00003c  6008              STR      r0,[r1,#0]
;;;215    }
00003e  4770              BX       lr
;;;216    
                          ENDP

                  RCC_HSEConfig PROC
;;;236      */
;;;237    void RCC_HSEConfig(uint8_t RCC_HSE)
000040  f04f0100          MOV      r1,#0
;;;238    {
;;;239      /* Check the parameters */
;;;240      assert_param(IS_RCC_HSE(RCC_HSE));
;;;241    
;;;242      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;243      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
000044  4aeb              LDR      r2,|L1.1012|
000046  7011              STRB     r1,[r2,#0]
;;;244    
;;;245      /* Set the new HSE configuration -------------------------------------------*/
;;;246      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
000048  4611              MOV      r1,r2
00004a  7008              STRB     r0,[r1,#0]
;;;247    }
00004c  4770              BX       lr
;;;248    
                          ENDP

                  RCC_GetFlagStatus PROC
;;;1687     */
;;;1688   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
00004e  b510              PUSH     {r4,lr}
;;;1689   {
000050  4601              MOV      r1,r0
;;;1690     uint32_t tmp = 0;
000052  f04f0200          MOV      r2,#0
;;;1691     uint32_t statusreg = 0;
000056  4613              MOV      r3,r2
;;;1692     FlagStatus bitstatus = RESET;
000058  4610              MOV      r0,r2
;;;1693   
;;;1694     /* Check the parameters */
;;;1695     assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;1696   
;;;1697     /* Get the RCC register index */
;;;1698     tmp = RCC_FLAG >> 5;
00005a  ea4f1261          ASR      r2,r1,#5
;;;1699     if (tmp == 1)               /* The flag to check is in CR register */
00005e  2a01              CMP      r2,#1
000060  d102              BNE      |L1.104|
;;;1700     {
;;;1701       statusreg = RCC->CR;
000062  4cdf              LDR      r4,|L1.992|
000064  6823              LDR      r3,[r4,#0]
000066  e006              B        |L1.118|
                  |L1.104|
;;;1702     }
;;;1703     else if (tmp == 2)          /* The flag to check is in BDCR register */
000068  2a02              CMP      r2,#2
00006a  d102              BNE      |L1.114|
;;;1704     {
;;;1705       statusreg = RCC->BDCR;
00006c  4ce2              LDR      r4,|L1.1016|
00006e  6823              LDR      r3,[r4,#0]
000070  e001              B        |L1.118|
                  |L1.114|
;;;1706     }
;;;1707     else                       /* The flag to check is in CSR register */
;;;1708     {
;;;1709       statusreg = RCC->CSR;
000072  4ce2              LDR      r4,|L1.1020|
000074  6823              LDR      r3,[r4,#0]
                  |L1.118|
;;;1710     }
;;;1711   
;;;1712     /* Get the flag position */
;;;1713     tmp = RCC_FLAG & FLAG_MASK;
000076  f001021f          AND      r2,r1,#0x1f
;;;1714     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
00007a  f04f0401          MOV      r4,#1
00007e  fa04f402          LSL      r4,r4,r2
000082  421c              TST      r4,r3
000084  d002              BEQ      |L1.140|
;;;1715     {
;;;1716       bitstatus = SET;
000086  f04f0001          MOV      r0,#1
00008a  e001              B        |L1.144|
                  |L1.140|
;;;1717     }
;;;1718     else
;;;1719     {
;;;1720       bitstatus = RESET;
00008c  f04f0000          MOV      r0,#0
                  |L1.144|
;;;1721     }
;;;1722     /* Return the flag status */
;;;1723     return bitstatus;
;;;1724   }
000090  bd10              POP      {r4,pc}
;;;1725   
                          ENDP

                  RCC_WaitForHSEStartUp PROC
;;;260      */
;;;261    ErrorStatus RCC_WaitForHSEStartUp(void)
000092  b570              PUSH     {r4-r6,lr}
;;;262    {
;;;263      __IO uint32_t startupcounter = 0;
000094  f04f0400          MOV      r4,#0
;;;264      ErrorStatus status = ERROR;
000098  4625              MOV      r5,r4
;;;265      FlagStatus hsestatus = RESET;
00009a  4626              MOV      r6,r4
;;;266      /* Wait till HSE is ready and if Time out is reached exit */
;;;267      do
00009c  bf00              NOP      
                  |L1.158|
;;;268      {
;;;269        hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
00009e  2031              MOVS     r0,#0x31
0000a0  f7fffffe          BL       RCC_GetFlagStatus
0000a4  4606              MOV      r6,r0
;;;270        startupcounter++;
0000a6  f1040401          ADD      r4,r4,#1
;;;271      } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
0000aa  f5b46fa0          CMP      r4,#0x500
0000ae  d001              BEQ      |L1.180|
0000b0  2e00              CMP      r6,#0
0000b2  d0f4              BEQ      |L1.158|
                  |L1.180|
;;;272    
;;;273      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
0000b4  2031              MOVS     r0,#0x31
0000b6  f7fffffe          BL       RCC_GetFlagStatus
0000ba  b110              CBZ      r0,|L1.194|
;;;274      {
;;;275        status = SUCCESS;
0000bc  f04f0501          MOV      r5,#1
0000c0  e001              B        |L1.198|
                  |L1.194|
;;;276      }
;;;277      else
;;;278      {
;;;279        status = ERROR;
0000c2  f04f0500          MOV      r5,#0
                  |L1.198|
;;;280      }
;;;281      return (status);
0000c6  4628              MOV      r0,r5
;;;282    }
0000c8  bd70              POP      {r4-r6,pc}
;;;283    
                          ENDP

                  RCC_AdjustHSICalibrationValue PROC
;;;291      */
;;;292    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
0000ca  4601              MOV      r1,r0
;;;293    {
;;;294      uint32_t tmpreg = 0;
0000cc  f04f0000          MOV      r0,#0
;;;295      /* Check the parameters */
;;;296      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
;;;297    
;;;298      tmpreg = RCC->CR;
0000d0  4ac3              LDR      r2,|L1.992|
0000d2  6810              LDR      r0,[r2,#0]
;;;299    
;;;300      /* Clear HSITRIM[4:0] bits */
;;;301      tmpreg &= ~RCC_CR_HSITRIM;
0000d4  f02000f8          BIC      r0,r0,#0xf8
;;;302    
;;;303      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;304      tmpreg |= (uint32_t)HSICalibrationValue << 3;
0000d8  ea4000c1          ORR      r0,r0,r1,LSL #3
;;;305    
;;;306      /* Store the new value */
;;;307      RCC->CR = tmpreg;
0000dc  6010              STR      r0,[r2,#0]
;;;308    }
0000de  4770              BX       lr
;;;309    
                          ENDP

                  RCC_HSICmd PROC
;;;327      */
;;;328    void RCC_HSICmd(FunctionalState NewState)
0000e0  49c7              LDR      r1,|L1.1024|
;;;329    {
;;;330      /* Check the parameters */
;;;331      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;332    
;;;333      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
0000e2  6008              STR      r0,[r1,#0]
;;;334    }
0000e4  4770              BX       lr
;;;335    
                          ENDP

                  RCC_LSEConfig PROC
;;;352      */
;;;353    void RCC_LSEConfig(uint8_t RCC_LSE)
0000e6  f04f0100          MOV      r1,#0
;;;354    {
;;;355      /* Check the parameters */
;;;356      assert_param(IS_RCC_LSE(RCC_LSE));
;;;357    
;;;358      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;359      /* Reset LSEON bit */
;;;360      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
0000ea  4ac3              LDR      r2,|L1.1016|
0000ec  7011              STRB     r1,[r2,#0]
;;;361    
;;;362      /* Reset LSEBYP bit */
;;;363      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
0000ee  7011              STRB     r1,[r2,#0]
;;;364    
;;;365      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;366      switch (RCC_LSE)
0000f0  2801              CMP      r0,#1
0000f2  d002              BEQ      |L1.250|
0000f4  2804              CMP      r0,#4
0000f6  d10a              BNE      |L1.270|
0000f8  e004              B        |L1.260|
                  |L1.250|
;;;367      {
;;;368        case RCC_LSE_ON:
;;;369          /* Set LSEON bit */
;;;370          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
0000fa  f04f0101          MOV      r1,#1
0000fe  4abe              LDR      r2,|L1.1016|
000100  7011              STRB     r1,[r2,#0]
;;;371          break;
000102  e005              B        |L1.272|
                  |L1.260|
;;;372        case RCC_LSE_Bypass:
;;;373          /* Set LSEBYP and LSEON bits */
;;;374          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
000104  f04f0105          MOV      r1,#5
000108  4abb              LDR      r2,|L1.1016|
00010a  7011              STRB     r1,[r2,#0]
;;;375          break;
00010c  e000              B        |L1.272|
                  |L1.270|
;;;376        default:
;;;377          break;
00010e  bf00              NOP      
                  |L1.272|
000110  bf00              NOP                            ;371
;;;378      }
;;;379    }
000112  4770              BX       lr
;;;380    
                          ENDP

                  RCC_LSICmd PROC
;;;392      */
;;;393    void RCC_LSICmd(FunctionalState NewState)
000114  49bb              LDR      r1,|L1.1028|
;;;394    {
;;;395      /* Check the parameters */
;;;396      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;397    
;;;398      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
000116  6008              STR      r0,[r1,#0]
;;;399    }
000118  4770              BX       lr
;;;400    
                          ENDP

                  RCC_PLLConfig PROC
;;;435      */
;;;436    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ)
00011a  b570              PUSH     {r4-r6,lr}
;;;437    {
00011c  9c04              LDR      r4,[sp,#0x10]
;;;438      /* Check the parameters */
;;;439      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;440      assert_param(IS_RCC_PLLM_VALUE(PLLM));
;;;441      assert_param(IS_RCC_PLLN_VALUE(PLLN));
;;;442      assert_param(IS_RCC_PLLP_VALUE(PLLP));
;;;443      assert_param(IS_RCC_PLLQ_VALUE(PLLQ));
;;;444    
;;;445      RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
00011e  ea411582          ORR      r5,r1,r2,LSL #6
000122  f04f0601          MOV      r6,#1
000126  ebc60653          RSB      r6,r6,r3,LSR #1
00012a  ea454506          ORR      r5,r5,r6,LSL #16
00012e  ea450500          ORR      r5,r5,r0
000132  ea456504          ORR      r5,r5,r4,LSL #24
000136  4eb4              LDR      r6,|L1.1032|
000138  6035              STR      r5,[r6,#0]
;;;446                     (PLLQ << 24);
;;;447    }
00013a  bd70              POP      {r4-r6,pc}
;;;448    
                          ENDP

                  RCC_PLLCmd PROC
;;;458      */
;;;459    void RCC_PLLCmd(FunctionalState NewState)
00013c  49b0              LDR      r1,|L1.1024|
;;;460    {
;;;461      /* Check the parameters */
;;;462      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;463      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
00013e  6608              STR      r0,[r1,#0x60]
;;;464    }
000140  4770              BX       lr
;;;465    
                          ENDP

                  RCC_PLLI2SConfig PROC
;;;485      */
;;;486    void RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR)
000142  ea4f1280          LSL      r2,r0,#6
;;;487    {
;;;488      /* Check the parameters */
;;;489      assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
;;;490      assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));
;;;491    
;;;492      RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
000146  ea427201          ORR      r2,r2,r1,LSL #28
00014a  4bb0              LDR      r3,|L1.1036|
00014c  601a              STR      r2,[r3,#0]
;;;493    }
00014e  4770              BX       lr
;;;494    
                          ENDP

                  RCC_PLLI2SCmd PROC
;;;501      */
;;;502    void RCC_PLLI2SCmd(FunctionalState NewState)
000150  49ab              LDR      r1,|L1.1024|
;;;503    {
;;;504      /* Check the parameters */
;;;505      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;506      *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
000152  6688              STR      r0,[r1,#0x68]
;;;507    }
000154  4770              BX       lr
;;;508    
                          ENDP

                  RCC_ClockSecuritySystemCmd PROC
;;;519      */
;;;520    void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000156  49aa              LDR      r1,|L1.1024|
;;;521    {
;;;522      /* Check the parameters */
;;;523      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;524      *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
000158  64c8              STR      r0,[r1,#0x4c]
;;;525    }
00015a  4770              BX       lr
;;;526    
                          ENDP

                  RCC_MCO1Config PROC
;;;544      */
;;;545    void RCC_MCO1Config(uint32_t RCC_MCO1Source, uint32_t RCC_MCO1Div)
00015c  4602              MOV      r2,r0
;;;546    {
;;;547      uint32_t tmpreg = 0;
00015e  f04f0000          MOV      r0,#0
;;;548      
;;;549      /* Check the parameters */
;;;550      assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
;;;551      assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  
;;;552    
;;;553      tmpreg = RCC->CFGR;
000162  4ba0              LDR      r3,|L1.996|
000164  6818              LDR      r0,[r3,#0]
;;;554    
;;;555      /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
;;;556      tmpreg &= CFGR_MCO1_RESET_MASK;
000166  f02060ec          BIC      r0,r0,#0x7600000
;;;557    
;;;558      /* Select MCO1 clock source and prescaler */
;;;559      tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
00016a  ea420301          ORR      r3,r2,r1
00016e  ea430000          ORR      r0,r3,r0
;;;560    
;;;561      /* Store the new value */
;;;562      RCC->CFGR = tmpreg;  
000172  4b9c              LDR      r3,|L1.996|
000174  6018              STR      r0,[r3,#0]
;;;563    }
000176  4770              BX       lr
;;;564    
                          ENDP

                  RCC_MCO2Config PROC
;;;582      */
;;;583    void RCC_MCO2Config(uint32_t RCC_MCO2Source, uint32_t RCC_MCO2Div)
000178  4602              MOV      r2,r0
;;;584    {
;;;585      uint32_t tmpreg = 0;
00017a  f04f0000          MOV      r0,#0
;;;586      
;;;587      /* Check the parameters */
;;;588      assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
;;;589      assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
;;;590      
;;;591      tmpreg = RCC->CFGR;
00017e  4b99              LDR      r3,|L1.996|
000180  6818              LDR      r0,[r3,#0]
;;;592      
;;;593      /* Clear MCO2 and MCO2PRE[2:0] bits */
;;;594      tmpreg &= CFGR_MCO2_RESET_MASK;
000182  f0204078          BIC      r0,r0,#0xf8000000
;;;595    
;;;596      /* Select MCO2 clock source and prescaler */
;;;597      tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
000186  ea420301          ORR      r3,r2,r1
00018a  ea430000          ORR      r0,r3,r0
;;;598    
;;;599      /* Store the new value */
;;;600      RCC->CFGR = tmpreg;  
00018e  4b95              LDR      r3,|L1.996|
000190  6018              STR      r0,[r3,#0]
;;;601    }
000192  4770              BX       lr
;;;602    
                          ENDP

                  RCC_SYSCLKConfig PROC
;;;687      */
;;;688    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000194  4601              MOV      r1,r0
;;;689    {
;;;690      uint32_t tmpreg = 0;
000196  f04f0000          MOV      r0,#0
;;;691    
;;;692      /* Check the parameters */
;;;693      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;694    
;;;695      tmpreg = RCC->CFGR;
00019a  4a92              LDR      r2,|L1.996|
00019c  6810              LDR      r0,[r2,#0]
;;;696    
;;;697      /* Clear SW[1:0] bits */
;;;698      tmpreg &= ~RCC_CFGR_SW;
00019e  f0200003          BIC      r0,r0,#3
;;;699    
;;;700      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;701      tmpreg |= RCC_SYSCLKSource;
0001a2  ea400001          ORR      r0,r0,r1
;;;702    
;;;703      /* Store the new value */
;;;704      RCC->CFGR = tmpreg;
0001a6  6010              STR      r0,[r2,#0]
;;;705    }
0001a8  4770              BX       lr
;;;706    
                          ENDP

                  RCC_GetSYSCLKSource PROC
;;;715      */
;;;716    uint8_t RCC_GetSYSCLKSource(void)
0001aa  488e              LDR      r0,|L1.996|
;;;717    {
;;;718      return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
0001ac  6800              LDR      r0,[r0,#0]
0001ae  f000000c          AND      r0,r0,#0xc
;;;719    }
0001b2  4770              BX       lr
;;;720    
                          ENDP

                  RCC_HCLKConfig PROC
;;;740      */
;;;741    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
0001b4  4601              MOV      r1,r0
;;;742    {
;;;743      uint32_t tmpreg = 0;
0001b6  f04f0000          MOV      r0,#0
;;;744      
;;;745      /* Check the parameters */
;;;746      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;747    
;;;748      tmpreg = RCC->CFGR;
0001ba  4a8a              LDR      r2,|L1.996|
0001bc  6810              LDR      r0,[r2,#0]
;;;749    
;;;750      /* Clear HPRE[3:0] bits */
;;;751      tmpreg &= ~RCC_CFGR_HPRE;
0001be  f02000f0          BIC      r0,r0,#0xf0
;;;752    
;;;753      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;754      tmpreg |= RCC_SYSCLK;
0001c2  ea400001          ORR      r0,r0,r1
;;;755    
;;;756      /* Store the new value */
;;;757      RCC->CFGR = tmpreg;
0001c6  6010              STR      r0,[r2,#0]
;;;758    }
0001c8  4770              BX       lr
;;;759    
                          ENDP

                  RCC_PCLK1Config PROC
;;;772      */
;;;773    void RCC_PCLK1Config(uint32_t RCC_HCLK)
0001ca  4601              MOV      r1,r0
;;;774    {
;;;775      uint32_t tmpreg = 0;
0001cc  f04f0000          MOV      r0,#0
;;;776    
;;;777      /* Check the parameters */
;;;778      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;779    
;;;780      tmpreg = RCC->CFGR;
0001d0  4a84              LDR      r2,|L1.996|
0001d2  6810              LDR      r0,[r2,#0]
;;;781    
;;;782      /* Clear PPRE1[2:0] bits */
;;;783      tmpreg &= ~RCC_CFGR_PPRE1;
0001d4  f42050e0          BIC      r0,r0,#0x1c00
;;;784    
;;;785      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;786      tmpreg |= RCC_HCLK;
0001d8  ea400001          ORR      r0,r0,r1
;;;787    
;;;788      /* Store the new value */
;;;789      RCC->CFGR = tmpreg;
0001dc  6010              STR      r0,[r2,#0]
;;;790    }
0001de  4770              BX       lr
;;;791    
                          ENDP

                  RCC_PCLK2Config PROC
;;;803      */
;;;804    void RCC_PCLK2Config(uint32_t RCC_HCLK)
0001e0  4601              MOV      r1,r0
;;;805    {
;;;806      uint32_t tmpreg = 0;
0001e2  f04f0000          MOV      r0,#0
;;;807    
;;;808      /* Check the parameters */
;;;809      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;810    
;;;811      tmpreg = RCC->CFGR;
0001e6  4a7f              LDR      r2,|L1.996|
0001e8  6810              LDR      r0,[r2,#0]
;;;812    
;;;813      /* Clear PPRE2[2:0] bits */
;;;814      tmpreg &= ~RCC_CFGR_PPRE2;
0001ea  f4204060          BIC      r0,r0,#0xe000
;;;815    
;;;816      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;817      tmpreg |= RCC_HCLK << 3;
0001ee  ea4000c1          ORR      r0,r0,r1,LSL #3
;;;818    
;;;819      /* Store the new value */
;;;820      RCC->CFGR = tmpreg;
0001f2  6010              STR      r0,[r2,#0]
;;;821    }
0001f4  4770              BX       lr
;;;822    
                          ENDP

                  RCC_GetClocksFreq PROC
;;;855      */
;;;856    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
0001f6  b5f0              PUSH     {r4-r7,lr}
;;;857    {
;;;858      uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
0001f8  f04f0100          MOV      r1,#0
0001fc  460a              MOV      r2,r1
0001fe  460c              MOV      r4,r1
000200  f04f0502          MOV      r5,#2
000204  460e              MOV      r6,r1
000206  f04f0302          MOV      r3,#2
;;;859    
;;;860      /* Get SYSCLK source -------------------------------------------------------*/
;;;861      tmp = RCC->CFGR & RCC_CFGR_SWS;
00020a  4f76              LDR      r7,|L1.996|
00020c  683f              LDR      r7,[r7,#0]
00020e  f007010c          AND      r1,r7,#0xc
;;;862    
;;;863      switch (tmp)
000212  b121              CBZ      r1,|L1.542|
000214  2904              CMP      r1,#4
000216  d005              BEQ      |L1.548|
000218  2908              CMP      r1,#8
00021a  d132              BNE      |L1.642|
00021c  e005              B        |L1.554|
                  |L1.542|
;;;864      {
;;;865        case 0x00:  /* HSI used as system clock source */
;;;866          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
00021e  4f7c              LDR      r7,|L1.1040|
000220  6007              STR      r7,[r0,#0]
;;;867          break;
000222  e031              B        |L1.648|
                  |L1.548|
;;;868        case 0x04:  /* HSE used as system clock  source */
;;;869          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
000224  4f7b              LDR      r7,|L1.1044|
000226  6007              STR      r7,[r0,#0]
;;;870          break;
000228  e02e              B        |L1.648|
                  |L1.554|
;;;871        case 0x08:  /* PLL used as system clock  source */
;;;872    
;;;873          /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
;;;874             SYSCLK = PLL_VCO / PLLP
;;;875             */    
;;;876          pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
00022a  4f77              LDR      r7,|L1.1032|
00022c  683f              LDR      r7,[r7,#0]
00022e  f3c75680          UBFX     r6,r7,#22,#1
;;;877          pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
000232  4f75              LDR      r7,|L1.1032|
000234  683f              LDR      r7,[r7,#0]
000236  f007033f          AND      r3,r7,#0x3f
;;;878          
;;;879          if (pllsource != 0)
00023a  b15e              CBZ      r6,|L1.596|
;;;880          {
;;;881            /* HSE used as PLL clock source */
;;;882            pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
00023c  4f75              LDR      r7,|L1.1044|
00023e  fbb7f7f3          UDIV     r7,r7,r3
000242  f8dfc1c4          LDR      r12,|L1.1032|
000246  f8dcc000          LDR      r12,[r12,#0]
00024a  f3cc1c88          UBFX     r12,r12,#6,#9
00024e  fb07f40c          MUL      r4,r7,r12
000252  e00a              B        |L1.618|
                  |L1.596|
;;;883          }
;;;884          else
;;;885          {
;;;886            /* HSI used as PLL clock source */
;;;887            pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
000254  4f6e              LDR      r7,|L1.1040|
000256  fbb7f7f3          UDIV     r7,r7,r3
00025a  f8dfc1ac          LDR      r12,|L1.1032|
00025e  f8dcc000          LDR      r12,[r12,#0]
000262  f3cc1c88          UBFX     r12,r12,#6,#9
000266  fb07f40c          MUL      r4,r7,r12
                  |L1.618|
;;;888          }
;;;889    
;;;890          pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
00026a  4f67              LDR      r7,|L1.1032|
00026c  683f              LDR      r7,[r7,#0]
00026e  f3c74701          UBFX     r7,r7,#16,#2
000272  f1070701          ADD      r7,r7,#1
000276  ea4f0547          LSL      r5,r7,#1
;;;891          RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
00027a  fbb4f7f5          UDIV     r7,r4,r5
00027e  6007              STR      r7,[r0,#0]
;;;892          break;
000280  e002              B        |L1.648|
                  |L1.642|
;;;893        default:
;;;894          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
000282  4f63              LDR      r7,|L1.1040|
000284  6007              STR      r7,[r0,#0]
;;;895          break;
000286  bf00              NOP      
                  |L1.648|
000288  bf00              NOP                            ;867
;;;896      }
;;;897      /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/
;;;898    
;;;899      /* Get HCLK prescaler */
;;;900      tmp = RCC->CFGR & RCC_CFGR_HPRE;
00028a  4f56              LDR      r7,|L1.996|
00028c  683f              LDR      r7,[r7,#0]
00028e  f00701f0          AND      r1,r7,#0xf0
;;;901      tmp = tmp >> 4;
000292  ea4f1111          LSR      r1,r1,#4
;;;902      presc = APBAHBPrescTable[tmp];
000296  4f60              LDR      r7,|L1.1048|
000298  5c7a              LDRB     r2,[r7,r1]
;;;903      /* HCLK clock frequency */
;;;904      RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
00029a  6807              LDR      r7,[r0,#0]
00029c  fa27f702          LSR      r7,r7,r2
0002a0  6047              STR      r7,[r0,#4]
;;;905    
;;;906      /* Get PCLK1 prescaler */
;;;907      tmp = RCC->CFGR & RCC_CFGR_PPRE1;
0002a2  4f50              LDR      r7,|L1.996|
0002a4  683f              LDR      r7,[r7,#0]
0002a6  f40751e0          AND      r1,r7,#0x1c00
;;;908      tmp = tmp >> 10;
0002aa  ea4f2191          LSR      r1,r1,#10
;;;909      presc = APBAHBPrescTable[tmp];
0002ae  4f5a              LDR      r7,|L1.1048|
0002b0  5c7a              LDRB     r2,[r7,r1]
;;;910      /* PCLK1 clock frequency */
;;;911      RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
0002b2  6847              LDR      r7,[r0,#4]
0002b4  fa27f702          LSR      r7,r7,r2
0002b8  6087              STR      r7,[r0,#8]
;;;912    
;;;913      /* Get PCLK2 prescaler */
;;;914      tmp = RCC->CFGR & RCC_CFGR_PPRE2;
0002ba  4f4a              LDR      r7,|L1.996|
0002bc  683f              LDR      r7,[r7,#0]
0002be  f4074160          AND      r1,r7,#0xe000
;;;915      tmp = tmp >> 13;
0002c2  ea4f3151          LSR      r1,r1,#13
;;;916      presc = APBAHBPrescTable[tmp];
0002c6  4f54              LDR      r7,|L1.1048|
0002c8  5c7a              LDRB     r2,[r7,r1]
;;;917      /* PCLK2 clock frequency */
;;;918      RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
0002ca  6847              LDR      r7,[r0,#4]
0002cc  fa27f702          LSR      r7,r7,r2
0002d0  60c7              STR      r7,[r0,#0xc]
;;;919    }
0002d2  bdf0              POP      {r4-r7,pc}
;;;920    
                          ENDP

                  RCC_RTCCLKConfig PROC
;;;980      */
;;;981    void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
0002d4  f04f0100          MOV      r1,#0
;;;982    {
;;;983      uint32_t tmpreg = 0;
;;;984    
;;;985      /* Check the parameters */
;;;986      assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;987    
;;;988      if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
0002d8  f4007240          AND      r2,r0,#0x300
0002dc  f5b27f40          CMP      r2,#0x300
0002e0  d10a              BNE      |L1.760|
;;;989      { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
;;;990        tmpreg = RCC->CFGR;
0002e2  4a40              LDR      r2,|L1.996|
0002e4  6811              LDR      r1,[r2,#0]
;;;991    
;;;992        /* Clear RTCPRE[4:0] bits */
;;;993        tmpreg &= ~RCC_CFGR_RTCPRE;
0002e6  f42111f8          BIC      r1,r1,#0x1f0000
;;;994    
;;;995        /* Configure HSE division factor for RTC clock */
;;;996        tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
0002ea  4a4c              LDR      r2,|L1.1052|
0002ec  ea000202          AND      r2,r0,r2
0002f0  ea420101          ORR      r1,r2,r1
;;;997    
;;;998        /* Store the new value */
;;;999        RCC->CFGR = tmpreg;
0002f4  4a3b              LDR      r2,|L1.996|
0002f6  6011              STR      r1,[r2,#0]
                  |L1.760|
;;;1000     }
;;;1001       
;;;1002     /* Select the RTC clock source */
;;;1003     RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
0002f8  4a3f              LDR      r2,|L1.1016|
0002fa  6812              LDR      r2,[r2,#0]
0002fc  f3c0030b          UBFX     r3,r0,#0,#12
000300  ea420203          ORR      r2,r2,r3
000304  4b3c              LDR      r3,|L1.1016|
000306  601a              STR      r2,[r3,#0]
;;;1004   }
000308  4770              BX       lr
;;;1005   
                          ENDP

                  RCC_RTCCLKCmd PROC
;;;1012     */
;;;1013   void RCC_RTCCLKCmd(FunctionalState NewState)
00030a  4945              LDR      r1,|L1.1056|
;;;1014   {
;;;1015     /* Check the parameters */
;;;1016     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1017   
;;;1018     *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
00030c  6008              STR      r0,[r1,#0]
;;;1019   }
00030e  4770              BX       lr
;;;1020   
                          ENDP

                  RCC_BackupResetCmd PROC
;;;1029     */
;;;1030   void RCC_BackupResetCmd(FunctionalState NewState)
000310  4944              LDR      r1,|L1.1060|
;;;1031   {
;;;1032     /* Check the parameters */
;;;1033     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1034     *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
000312  6008              STR      r0,[r1,#0]
;;;1035   }
000314  4770              BX       lr
;;;1036   
                          ENDP

                  RCC_I2SCLKConfig PROC
;;;1049     */
;;;1050   void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
000316  4944              LDR      r1,|L1.1064|
;;;1051   {
;;;1052     /* Check the parameters */
;;;1053     assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));
;;;1054   
;;;1055     *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
000318  6008              STR      r0,[r1,#0]
;;;1056   }
00031a  4770              BX       lr
;;;1057   
                          ENDP

                  RCC_AHB1PeriphClockCmd PROC
;;;1087     */
;;;1088   void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
00031c  b131              CBZ      r1,|L1.812|
;;;1089   {
;;;1090     /* Check the parameters */
;;;1091     assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));
;;;1092   
;;;1093     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1094     if (NewState != DISABLE)
;;;1095     {
;;;1096       RCC->AHB1ENR |= RCC_AHB1Periph;
00031e  4a43              LDR      r2,|L1.1068|
000320  6812              LDR      r2,[r2,#0]
000322  ea420200          ORR      r2,r2,r0
000326  4b41              LDR      r3,|L1.1068|
000328  601a              STR      r2,[r3,#0]
00032a  e005              B        |L1.824|
                  |L1.812|
;;;1097     }
;;;1098     else
;;;1099     {
;;;1100       RCC->AHB1ENR &= ~RCC_AHB1Periph;
00032c  4a3f              LDR      r2,|L1.1068|
00032e  6812              LDR      r2,[r2,#0]
000330  ea220200          BIC      r2,r2,r0
000334  4b3d              LDR      r3,|L1.1068|
000336  601a              STR      r2,[r3,#0]
                  |L1.824|
;;;1101     }
;;;1102   }
000338  4770              BX       lr
;;;1103   
                          ENDP

                  RCC_AHB2PeriphClockCmd PROC
;;;1119     */
;;;1120   void RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
00033a  b131              CBZ      r1,|L1.842|
;;;1121   {
;;;1122     /* Check the parameters */
;;;1123     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1124     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1125   
;;;1126     if (NewState != DISABLE)
;;;1127     {
;;;1128       RCC->AHB2ENR |= RCC_AHB2Periph;
00033c  4a3c              LDR      r2,|L1.1072|
00033e  6812              LDR      r2,[r2,#0]
000340  ea420200          ORR      r2,r2,r0
000344  4b3a              LDR      r3,|L1.1072|
000346  601a              STR      r2,[r3,#0]
000348  e005              B        |L1.854|
                  |L1.842|
;;;1129     }
;;;1130     else
;;;1131     {
;;;1132       RCC->AHB2ENR &= ~RCC_AHB2Periph;
00034a  4a39              LDR      r2,|L1.1072|
00034c  6812              LDR      r2,[r2,#0]
00034e  ea220200          BIC      r2,r2,r0
000352  4b37              LDR      r3,|L1.1072|
000354  601a              STR      r2,[r3,#0]
                  |L1.854|
;;;1133     }
;;;1134   }
000356  4770              BX       lr
;;;1135   
                          ENDP

                  RCC_AHB3PeriphClockCmd PROC
;;;1146     */
;;;1147   void RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000358  b131              CBZ      r1,|L1.872|
;;;1148   {
;;;1149     /* Check the parameters */
;;;1150     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
;;;1151     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1152   
;;;1153     if (NewState != DISABLE)
;;;1154     {
;;;1155       RCC->AHB3ENR |= RCC_AHB3Periph;
00035a  4a36              LDR      r2,|L1.1076|
00035c  6812              LDR      r2,[r2,#0]
00035e  ea420200          ORR      r2,r2,r0
000362  4b34              LDR      r3,|L1.1076|
000364  601a              STR      r2,[r3,#0]
000366  e005              B        |L1.884|
                  |L1.872|
;;;1156     }
;;;1157     else
;;;1158     {
;;;1159       RCC->AHB3ENR &= ~RCC_AHB3Periph;
000368  4a32              LDR      r2,|L1.1076|
00036a  6812              LDR      r2,[r2,#0]
00036c  ea220200          BIC      r2,r2,r0
000370  4b30              LDR      r3,|L1.1076|
000372  601a              STR      r2,[r3,#0]
                  |L1.884|
;;;1160     }
;;;1161   }
000374  4770              BX       lr
;;;1162   
                          ENDP

                  RCC_APB1PeriphClockCmd PROC
;;;1196     */
;;;1197   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000376  b131              CBZ      r1,|L1.902|
;;;1198   {
;;;1199     /* Check the parameters */
;;;1200     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
;;;1201     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1202   
;;;1203     if (NewState != DISABLE)
;;;1204     {
;;;1205       RCC->APB1ENR |= RCC_APB1Periph;
000378  4a2f              LDR      r2,|L1.1080|
00037a  6812              LDR      r2,[r2,#0]
00037c  ea420200          ORR      r2,r2,r0
000380  4b2d              LDR      r3,|L1.1080|
000382  601a              STR      r2,[r3,#0]
000384  e005              B        |L1.914|
                  |L1.902|
;;;1206     }
;;;1207     else
;;;1208     {
;;;1209       RCC->APB1ENR &= ~RCC_APB1Periph;
000386  4a2c              LDR      r2,|L1.1080|
000388  6812              LDR      r2,[r2,#0]
00038a  ea220200          BIC      r2,r2,r0
00038e  4b2a              LDR      r3,|L1.1080|
000390  601a              STR      r2,[r3,#0]
                  |L1.914|
;;;1210     }
;;;1211   }
000392  4770              BX       lr
;;;1212   
                          ENDP

                  RCC_APB2PeriphClockCmd PROC
;;;1236     */
;;;1237   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000394  b131              CBZ      r1,|L1.932|
;;;1238   {
;;;1239     /* Check the parameters */
;;;1240     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1241     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1242   
;;;1243     if (NewState != DISABLE)
;;;1244     {
;;;1245       RCC->APB2ENR |= RCC_APB2Periph;
000396  4a29              LDR      r2,|L1.1084|
000398  6812              LDR      r2,[r2,#0]
00039a  ea420200          ORR      r2,r2,r0
00039e  4b27              LDR      r3,|L1.1084|
0003a0  601a              STR      r2,[r3,#0]
0003a2  e005              B        |L1.944|
                  |L1.932|
;;;1246     }
;;;1247     else
;;;1248     {
;;;1249       RCC->APB2ENR &= ~RCC_APB2Periph;
0003a4  4a25              LDR      r2,|L1.1084|
0003a6  6812              LDR      r2,[r2,#0]
0003a8  ea220200          BIC      r2,r2,r0
0003ac  4b23              LDR      r3,|L1.1084|
0003ae  601a              STR      r2,[r3,#0]
                  |L1.944|
;;;1250     }
;;;1251   }
0003b0  4770              BX       lr
;;;1252   
                          ENDP

                  RCC_AHB1PeriphResetCmd PROC
;;;1275     */
;;;1276   void RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
0003b2  b131              CBZ      r1,|L1.962|
;;;1277   {
;;;1278     /* Check the parameters */
;;;1279     assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
;;;1280     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1281   
;;;1282     if (NewState != DISABLE)
;;;1283     {
;;;1284       RCC->AHB1RSTR |= RCC_AHB1Periph;
0003b4  4a22              LDR      r2,|L1.1088|
0003b6  6812              LDR      r2,[r2,#0]
0003b8  ea420200          ORR      r2,r2,r0
0003bc  4b20              LDR      r3,|L1.1088|
0003be  601a              STR      r2,[r3,#0]
0003c0  e005              B        |L1.974|
                  |L1.962|
;;;1285     }
;;;1286     else
;;;1287     {
;;;1288       RCC->AHB1RSTR &= ~RCC_AHB1Periph;
0003c2  4a1f              LDR      r2,|L1.1088|
0003c4  6812              LDR      r2,[r2,#0]
0003c6  ea220200          BIC      r2,r2,r0
0003ca  4b1d              LDR      r3,|L1.1088|
0003cc  601a              STR      r2,[r3,#0]
                  |L1.974|
;;;1289     }
;;;1290   }
0003ce  4770              BX       lr
;;;1291   
                          ENDP

                  RCC_AHB2PeriphResetCmd PROC
;;;1304     */
;;;1305   void RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
0003d0  b3d1              CBZ      r1,|L1.1096|
;;;1306   {
;;;1307     /* Check the parameters */
;;;1308     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1309     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1310   
;;;1311     if (NewState != DISABLE)
;;;1312     {
;;;1313       RCC->AHB2RSTR |= RCC_AHB2Periph;
0003d2  4a1c              LDR      r2,|L1.1092|
0003d4  6812              LDR      r2,[r2,#0]
0003d6  ea420200          ORR      r2,r2,r0
0003da  4b1a              LDR      r3,|L1.1092|
0003dc  601a              STR      r2,[r3,#0]
0003de  e03a              B        |L1.1110|
                  |L1.992|
                          DCD      0x40023800
                  |L1.996|
                          DCD      0x40023808
                  |L1.1000|
                          DCD      0xfef6ffff
                  |L1.1004|
                          DCD      0x24003010
                  |L1.1008|
                          DCD      0x4002380c
                  |L1.1012|
                          DCD      0x40023802
                  |L1.1016|
                          DCD      0x40023870
                  |L1.1020|
                          DCD      0x40023874
                  |L1.1024|
                          DCD      0x42470000
                  |L1.1028|
                          DCD      0x42470e80
                  |L1.1032|
                          DCD      0x40023804
                  |L1.1036|
                          DCD      0x40023884
                  |L1.1040|
                          DCD      0x00f42400
                  |L1.1044|
                          DCD      0x017d7840
                  |L1.1048|
                          DCD      APBAHBPrescTable
                  |L1.1052|
                          DCD      0x0ffffcff
                  |L1.1056|
                          DCD      0x42470e3c
                  |L1.1060|
                          DCD      0x42470e40
                  |L1.1064|
                          DCD      0x4247015c
                  |L1.1068|
                          DCD      0x40023830
                  |L1.1072|
                          DCD      0x40023834
                  |L1.1076|
                          DCD      0x40023838
                  |L1.1080|
                          DCD      0x40023840
                  |L1.1084|
                          DCD      0x40023844
                  |L1.1088|
                          DCD      0x40023810
                  |L1.1092|
                          DCD      0x40023814
                  |L1.1096|
000448  e7ff              B        |L1.1098|
                  |L1.1098|
;;;1314     }
;;;1315     else
;;;1316     {
;;;1317       RCC->AHB2RSTR &= ~RCC_AHB2Periph;
00044a  4a54              LDR      r2,|L1.1436|
00044c  6812              LDR      r2,[r2,#0]
00044e  ea220200          BIC      r2,r2,r0
000452  4b52              LDR      r3,|L1.1436|
000454  601a              STR      r2,[r3,#0]
                  |L1.1110|
;;;1318     }
;;;1319   }
000456  4770              BX       lr
;;;1320   
                          ENDP

                  RCC_AHB3PeriphResetCmd PROC
;;;1328     */
;;;1329   void RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000458  b131              CBZ      r1,|L1.1128|
;;;1330   {
;;;1331     /* Check the parameters */
;;;1332     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
;;;1333     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1334   
;;;1335     if (NewState != DISABLE)
;;;1336     {
;;;1337       RCC->AHB3RSTR |= RCC_AHB3Periph;
00045a  4a51              LDR      r2,|L1.1440|
00045c  6812              LDR      r2,[r2,#0]
00045e  ea420200          ORR      r2,r2,r0
000462  4b4f              LDR      r3,|L1.1440|
000464  601a              STR      r2,[r3,#0]
000466  e005              B        |L1.1140|
                  |L1.1128|
;;;1338     }
;;;1339     else
;;;1340     {
;;;1341       RCC->AHB3RSTR &= ~RCC_AHB3Periph;
000468  4a4d              LDR      r2,|L1.1440|
00046a  6812              LDR      r2,[r2,#0]
00046c  ea220200          BIC      r2,r2,r0
000470  4b4b              LDR      r3,|L1.1440|
000472  601a              STR      r2,[r3,#0]
                  |L1.1140|
;;;1342     }
;;;1343   }
000474  4770              BX       lr
;;;1344   
                          ENDP

                  RCC_APB1PeriphResetCmd PROC
;;;1375     */
;;;1376   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000476  b131              CBZ      r1,|L1.1158|
;;;1377   {
;;;1378     /* Check the parameters */
;;;1379     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1380     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1381     if (NewState != DISABLE)
;;;1382     {
;;;1383       RCC->APB1RSTR |= RCC_APB1Periph;
000478  4a4a              LDR      r2,|L1.1444|
00047a  6812              LDR      r2,[r2,#0]
00047c  ea420200          ORR      r2,r2,r0
000480  4b48              LDR      r3,|L1.1444|
000482  601a              STR      r2,[r3,#0]
000484  e005              B        |L1.1170|
                  |L1.1158|
;;;1384     }
;;;1385     else
;;;1386     {
;;;1387       RCC->APB1RSTR &= ~RCC_APB1Periph;
000486  4a47              LDR      r2,|L1.1444|
000488  6812              LDR      r2,[r2,#0]
00048a  ea220200          BIC      r2,r2,r0
00048e  4b45              LDR      r3,|L1.1444|
000490  601a              STR      r2,[r3,#0]
                  |L1.1170|
;;;1388     }
;;;1389   }
000492  4770              BX       lr
;;;1390   
                          ENDP

                  RCC_APB2PeriphResetCmd PROC
;;;1411     */
;;;1412   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000494  b131              CBZ      r1,|L1.1188|
;;;1413   {
;;;1414     /* Check the parameters */
;;;1415     assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
;;;1416     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1417     if (NewState != DISABLE)
;;;1418     {
;;;1419       RCC->APB2RSTR |= RCC_APB2Periph;
000496  4a44              LDR      r2,|L1.1448|
000498  6812              LDR      r2,[r2,#0]
00049a  ea420200          ORR      r2,r2,r0
00049e  4b42              LDR      r3,|L1.1448|
0004a0  601a              STR      r2,[r3,#0]
0004a2  e005              B        |L1.1200|
                  |L1.1188|
;;;1420     }
;;;1421     else
;;;1422     {
;;;1423       RCC->APB2RSTR &= ~RCC_APB2Periph;
0004a4  4a40              LDR      r2,|L1.1448|
0004a6  6812              LDR      r2,[r2,#0]
0004a8  ea220200          BIC      r2,r2,r0
0004ac  4b3e              LDR      r3,|L1.1448|
0004ae  601a              STR      r2,[r3,#0]
                  |L1.1200|
;;;1424     }
;;;1425   }
0004b0  4770              BX       lr
;;;1426   
                          ENDP

                  RCC_AHB1PeriphClockLPModeCmd PROC
;;;1457     */
;;;1458   void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
0004b2  b131              CBZ      r1,|L1.1218|
;;;1459   {
;;;1460     /* Check the parameters */
;;;1461     assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
;;;1462     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1463     if (NewState != DISABLE)
;;;1464     {
;;;1465       RCC->AHB1LPENR |= RCC_AHB1Periph;
0004b4  4a3d              LDR      r2,|L1.1452|
0004b6  6812              LDR      r2,[r2,#0]
0004b8  ea420200          ORR      r2,r2,r0
0004bc  4b3b              LDR      r3,|L1.1452|
0004be  601a              STR      r2,[r3,#0]
0004c0  e005              B        |L1.1230|
                  |L1.1218|
;;;1466     }
;;;1467     else
;;;1468     {
;;;1469       RCC->AHB1LPENR &= ~RCC_AHB1Periph;
0004c2  4a3a              LDR      r2,|L1.1452|
0004c4  6812              LDR      r2,[r2,#0]
0004c6  ea220200          BIC      r2,r2,r0
0004ca  4b38              LDR      r3,|L1.1452|
0004cc  601a              STR      r2,[r3,#0]
                  |L1.1230|
;;;1470     }
;;;1471   }
0004ce  4770              BX       lr
;;;1472   
                          ENDP

                  RCC_AHB2PeriphClockLPModeCmd PROC
;;;1489     */
;;;1490   void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
0004d0  b131              CBZ      r1,|L1.1248|
;;;1491   {
;;;1492     /* Check the parameters */
;;;1493     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1494     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1495     if (NewState != DISABLE)
;;;1496     {
;;;1497       RCC->AHB2LPENR |= RCC_AHB2Periph;
0004d2  4a37              LDR      r2,|L1.1456|
0004d4  6812              LDR      r2,[r2,#0]
0004d6  ea420200          ORR      r2,r2,r0
0004da  4b35              LDR      r3,|L1.1456|
0004dc  601a              STR      r2,[r3,#0]
0004de  e005              B        |L1.1260|
                  |L1.1248|
;;;1498     }
;;;1499     else
;;;1500     {
;;;1501       RCC->AHB2LPENR &= ~RCC_AHB2Periph;
0004e0  4a33              LDR      r2,|L1.1456|
0004e2  6812              LDR      r2,[r2,#0]
0004e4  ea220200          BIC      r2,r2,r0
0004e8  4b31              LDR      r3,|L1.1456|
0004ea  601a              STR      r2,[r3,#0]
                  |L1.1260|
;;;1502     }
;;;1503   }
0004ec  4770              BX       lr
;;;1504   
                          ENDP

                  RCC_AHB3PeriphClockLPModeCmd PROC
;;;1516     */
;;;1517   void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
0004ee  b131              CBZ      r1,|L1.1278|
;;;1518   {
;;;1519     /* Check the parameters */
;;;1520     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
;;;1521     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1522     if (NewState != DISABLE)
;;;1523     {
;;;1524       RCC->AHB3LPENR |= RCC_AHB3Periph;
0004f0  4a30              LDR      r2,|L1.1460|
0004f2  6812              LDR      r2,[r2,#0]
0004f4  ea420200          ORR      r2,r2,r0
0004f8  4b2e              LDR      r3,|L1.1460|
0004fa  601a              STR      r2,[r3,#0]
0004fc  e005              B        |L1.1290|
                  |L1.1278|
;;;1525     }
;;;1526     else
;;;1527     {
;;;1528       RCC->AHB3LPENR &= ~RCC_AHB3Periph;
0004fe  4a2d              LDR      r2,|L1.1460|
000500  6812              LDR      r2,[r2,#0]
000502  ea220200          BIC      r2,r2,r0
000506  4b2b              LDR      r3,|L1.1460|
000508  601a              STR      r2,[r3,#0]
                  |L1.1290|
;;;1529     }
;;;1530   }
00050a  4770              BX       lr
;;;1531   
                          ENDP

                  RCC_APB1PeriphClockLPModeCmd PROC
;;;1566     */
;;;1567   void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
00050c  b131              CBZ      r1,|L1.1308|
;;;1568   {
;;;1569     /* Check the parameters */
;;;1570     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1571     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1572     if (NewState != DISABLE)
;;;1573     {
;;;1574       RCC->APB1LPENR |= RCC_APB1Periph;
00050e  4a2a              LDR      r2,|L1.1464|
000510  6812              LDR      r2,[r2,#0]
000512  ea420200          ORR      r2,r2,r0
000516  4b28              LDR      r3,|L1.1464|
000518  601a              STR      r2,[r3,#0]
00051a  e005              B        |L1.1320|
                  |L1.1308|
;;;1575     }
;;;1576     else
;;;1577     {
;;;1578       RCC->APB1LPENR &= ~RCC_APB1Periph;
00051c  4a26              LDR      r2,|L1.1464|
00051e  6812              LDR      r2,[r2,#0]
000520  ea220200          BIC      r2,r2,r0
000524  4b24              LDR      r3,|L1.1464|
000526  601a              STR      r2,[r3,#0]
                  |L1.1320|
;;;1579     }
;;;1580   }
000528  4770              BX       lr
;;;1581   
                          ENDP

                  RCC_APB2PeriphClockLPModeCmd PROC
;;;1606     */
;;;1607   void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
00052a  b131              CBZ      r1,|L1.1338|
;;;1608   {
;;;1609     /* Check the parameters */
;;;1610     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1611     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1612     if (NewState != DISABLE)
;;;1613     {
;;;1614       RCC->APB2LPENR |= RCC_APB2Periph;
00052c  4a23              LDR      r2,|L1.1468|
00052e  6812              LDR      r2,[r2,#0]
000530  ea420200          ORR      r2,r2,r0
000534  4b21              LDR      r3,|L1.1468|
000536  601a              STR      r2,[r3,#0]
000538  e005              B        |L1.1350|
                  |L1.1338|
;;;1615     }
;;;1616     else
;;;1617     {
;;;1618       RCC->APB2LPENR &= ~RCC_APB2Periph;
00053a  4a20              LDR      r2,|L1.1468|
00053c  6812              LDR      r2,[r2,#0]
00053e  ea220200          BIC      r2,r2,r0
000542  4b1e              LDR      r3,|L1.1468|
000544  601a              STR      r2,[r3,#0]
                  |L1.1350|
;;;1619     }
;;;1620   }
000546  4770              BX       lr
;;;1621   
                          ENDP

                  RCC_ITConfig PROC
;;;1651     */
;;;1652   void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000548  b131              CBZ      r1,|L1.1368|
;;;1653   {
;;;1654     /* Check the parameters */
;;;1655     assert_param(IS_RCC_IT(RCC_IT));
;;;1656     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1657     if (NewState != DISABLE)
;;;1658     {
;;;1659       /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
;;;1660       *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
00054a  4a1d              LDR      r2,|L1.1472|
00054c  7812              LDRB     r2,[r2,#0]
00054e  ea420200          ORR      r2,r2,r0
000552  4b1b              LDR      r3,|L1.1472|
000554  701a              STRB     r2,[r3,#0]
000556  e008              B        |L1.1386|
                  |L1.1368|
;;;1661     }
;;;1662     else
;;;1663     {
;;;1664       /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
;;;1665       *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
000558  4a19              LDR      r2,|L1.1472|
00055a  7812              LDRB     r2,[r2,#0]
00055c  ea6f0300          MVN      r3,r0
000560  b2db              UXTB     r3,r3
000562  ea020203          AND      r2,r2,r3
000566  4b16              LDR      r3,|L1.1472|
000568  701a              STRB     r2,[r3,#0]
                  |L1.1386|
;;;1666     }
;;;1667   }
00056a  4770              BX       lr
;;;1668   
                          ENDP

                  RCC_ClearFlag PROC
;;;1732     */
;;;1733   void RCC_ClearFlag(void)
00056c  4815              LDR      r0,|L1.1476|
;;;1734   {
;;;1735     /* Set RMVF bit to clear the reset flags */
;;;1736     RCC->CSR |= RCC_CSR_RMVF;
00056e  6800              LDR      r0,[r0,#0]
000570  f0407080          ORR      r0,r0,#0x1000000
000574  4913              LDR      r1,|L1.1476|
000576  6008              STR      r0,[r1,#0]
;;;1737   }
000578  4770              BX       lr
;;;1738   
                          ENDP

                  RCC_GetITStatus PROC
;;;1751     */
;;;1752   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
00057a  4601              MOV      r1,r0
;;;1753   {
;;;1754     ITStatus bitstatus = RESET;
00057c  f04f0000          MOV      r0,#0
;;;1755   
;;;1756     /* Check the parameters */
;;;1757     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;1758   
;;;1759     /* Check the status of the specified RCC interrupt */
;;;1760     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
000580  4a11              LDR      r2,|L1.1480|
000582  6812              LDR      r2,[r2,#0]
000584  420a              TST      r2,r1
000586  d002              BEQ      |L1.1422|
;;;1761     {
;;;1762       bitstatus = SET;
000588  f04f0001          MOV      r0,#1
00058c  e001              B        |L1.1426|
                  |L1.1422|
;;;1763     }
;;;1764     else
;;;1765     {
;;;1766       bitstatus = RESET;
00058e  f04f0000          MOV      r0,#0
                  |L1.1426|
;;;1767     }
;;;1768     /* Return the RCC_IT status */
;;;1769     return  bitstatus;
;;;1770   }
000592  4770              BX       lr
;;;1771   
                          ENDP

                  RCC_ClearITPendingBit PROC
;;;1784     */
;;;1785   void RCC_ClearITPendingBit(uint8_t RCC_IT)
000594  490d              LDR      r1,|L1.1484|
;;;1786   {
;;;1787     /* Check the parameters */
;;;1788     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;1789   
;;;1790     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1791        pending bits */
;;;1792     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
000596  7008              STRB     r0,[r1,#0]
;;;1793   }
000598  4770              BX       lr
;;;1794   
                          ENDP

00059a  0000              DCW      0x0000
                  |L1.1436|
                          DCD      0x40023814
                  |L1.1440|
                          DCD      0x40023818
                  |L1.1444|
                          DCD      0x40023820
                  |L1.1448|
                          DCD      0x40023824
                  |L1.1452|
                          DCD      0x40023850
                  |L1.1456|
                          DCD      0x40023854
                  |L1.1460|
                          DCD      0x40023858
                  |L1.1464|
                          DCD      0x40023860
                  |L1.1468|
                          DCD      0x40023864
                  |L1.1472|
                          DCD      0x4002380d
                  |L1.1476|
                          DCD      0x40023874
                  |L1.1480|
                          DCD      0x4002380c
                  |L1.1484|
                          DCD      0x4002380e

                          AREA ||.data||, DATA, ALIGN=0

                  APBAHBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  06070809          DCB      0x06,0x07,0x08,0x09
