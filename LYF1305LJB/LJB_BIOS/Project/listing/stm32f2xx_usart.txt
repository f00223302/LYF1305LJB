; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\output\stm32f2xx_usart.o --asm_dir=..\listing\ --list_dir=..\listing\ --depend=..\output\stm32f2xx_usart.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\src -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\STM32F2xx -I..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc -I..\..\Utilities\STM32_EVAL -I..\src\SYSTICK -I..\src\LED -I..\src\GPIO -I..\src\USART -I..\src\FLASH -I..\src\HexFile -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DUSE_CPU_F205RC -DLJB_CPU -W --omf_browse=..\output\stm32f2xx_usart.crf ..\..\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_usart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;177      */
;;;178    void USART_DeInit(USART_TypeDef* USARTx)
000000  b510              PUSH     {r4,lr}
;;;179    {
000002  4604              MOV      r4,r0
;;;180      /* Check the parameters */
;;;181      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;182    
;;;183      if (USARTx == USART1)
000004  48fa              LDR      r0,|L1.1008|
000006  4284              CMP      r4,r0
000008  d108              BNE      |L1.28|
;;;184      {
;;;185        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  2010              MOVS     r0,#0x10
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;186        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
000012  2100              MOVS     r1,#0
000014  2010              MOVS     r0,#0x10
000016  f7fffffe          BL       RCC_APB2PeriphResetCmd
00001a  e03e              B        |L1.154|
                  |L1.28|
;;;187      }
;;;188      else if (USARTx == USART2)
00001c  48f5              LDR      r0,|L1.1012|
00001e  4284              CMP      r4,r0
000020  d109              BNE      |L1.54|
;;;189      {
;;;190        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
000022  2101              MOVS     r1,#1
000024  0448              LSLS     r0,r1,#17
000026  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;191        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
00002a  2100              MOVS     r1,#0
00002c  f44f3000          MOV      r0,#0x20000
000030  f7fffffe          BL       RCC_APB1PeriphResetCmd
000034  e031              B        |L1.154|
                  |L1.54|
;;;192      }
;;;193      else if (USARTx == USART3)
000036  48f0              LDR      r0,|L1.1016|
000038  4284              CMP      r4,r0
00003a  d109              BNE      |L1.80|
;;;194      {
;;;195        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
00003c  2101              MOVS     r1,#1
00003e  0488              LSLS     r0,r1,#18
000040  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;196        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
000044  2100              MOVS     r1,#0
000046  f44f2080          MOV      r0,#0x40000
00004a  f7fffffe          BL       RCC_APB1PeriphResetCmd
00004e  e024              B        |L1.154|
                  |L1.80|
;;;197      }    
;;;198      else if (USARTx == UART4)
000050  48ea              LDR      r0,|L1.1020|
000052  4284              CMP      r4,r0
000054  d109              BNE      |L1.106|
;;;199      {
;;;200        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
000056  2101              MOVS     r1,#1
000058  04c8              LSLS     r0,r1,#19
00005a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;201        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
00005e  2100              MOVS     r1,#0
000060  f44f2000          MOV      r0,#0x80000
000064  f7fffffe          BL       RCC_APB1PeriphResetCmd
000068  e017              B        |L1.154|
                  |L1.106|
;;;202      }
;;;203      else if (USARTx == UART5)
00006a  48e5              LDR      r0,|L1.1024|
00006c  4284              CMP      r4,r0
00006e  d109              BNE      |L1.132|
;;;204      {
;;;205        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
000070  2101              MOVS     r1,#1
000072  0508              LSLS     r0,r1,#20
000074  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;206        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
000078  2100              MOVS     r1,#0
00007a  f44f1080          MOV      r0,#0x100000
00007e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000082  e00a              B        |L1.154|
                  |L1.132|
;;;207      }     
;;;208      else
;;;209      {
;;;210        if (USARTx == USART6)
000084  48df              LDR      r0,|L1.1028|
000086  4284              CMP      r4,r0
000088  d107              BNE      |L1.154|
;;;211        { 
;;;212          RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
00008a  2101              MOVS     r1,#1
00008c  2020              MOVS     r0,#0x20
00008e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;213          RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
000092  2100              MOVS     r1,#0
000094  2020              MOVS     r0,#0x20
000096  f7fffffe          BL       RCC_APB2PeriphResetCmd
                  |L1.154|
;;;214        }
;;;215      }
;;;216    }
00009a  bd10              POP      {r4,pc}
;;;217    
                          ENDP

                  USART_Init PROC
;;;226      */
;;;227    void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
00009c  e92d47ff          PUSH     {r0-r10,lr}
;;;228    {
0000a0  4605              MOV      r5,r0
0000a2  460e              MOV      r6,r1
;;;229      uint32_t tmpreg = 0x00, apbclock = 0x00;
0000a4  f04f0400          MOV      r4,#0
0000a8  46a1              MOV      r9,r4
;;;230      uint32_t integerdivider = 0x00;
0000aa  bf00              NOP      
;;;231      uint32_t fractionaldivider = 0x00;
0000ac  46a0              MOV      r8,r4
;;;232      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;233    
;;;234      /* Check the parameters */
;;;235      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;236      assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
;;;237      assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
;;;238      assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
;;;239      assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
;;;240      assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
;;;241      assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
;;;242    
;;;243      /* The hardware flow control is available only for USART1, USART2, USART3 and USART6 */
;;;244      if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
0000ae  89b0              LDRH     r0,[r6,#0xc]
0000b0  b100              CBZ      r0,|L1.180|
;;;245      {
;;;246        assert_param(IS_USART_1236_PERIPH(USARTx));
0000b2  bf00              NOP      
                  |L1.180|
;;;247      }
;;;248    
;;;249    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;250      tmpreg = USARTx->CR2;
0000b4  8a2c              LDRH     r4,[r5,#0x10]
;;;251    
;;;252      /* Clear STOP[13:12] bits */
;;;253      tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
0000b6  f4245440          BIC      r4,r4,#0x3000
;;;254    
;;;255      /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
;;;256          Set STOP[13:12] bits according to USART_StopBits value */
;;;257      tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
0000ba  88f0              LDRH     r0,[r6,#6]
0000bc  ea400404          ORR      r4,r0,r4
;;;258      
;;;259      /* Write to USART CR2 */
;;;260      USARTx->CR2 = (uint16_t)tmpreg;
0000c0  822c              STRH     r4,[r5,#0x10]
;;;261    
;;;262    /*---------------------------- USART CR1 Configuration -----------------------*/
;;;263      tmpreg = USARTx->CR1;
0000c2  89ac              LDRH     r4,[r5,#0xc]
;;;264    
;;;265      /* Clear M, PCE, PS, TE and RE bits */
;;;266      tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
0000c4  f241600c          MOV      r0,#0x160c
0000c8  ea240400          BIC      r4,r4,r0
;;;267    
;;;268      /* Configure the USART Word Length, Parity and mode: 
;;;269         Set the M bits according to USART_WordLength value 
;;;270         Set PCE and PS bits according to USART_Parity value
;;;271         Set TE and RE bits according to USART_Mode value */
;;;272      tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
0000cc  88b0              LDRH     r0,[r6,#4]
0000ce  8931              LDRH     r1,[r6,#8]
0000d0  ea400001          ORR      r0,r0,r1
0000d4  8971              LDRH     r1,[r6,#0xa]
0000d6  ea400001          ORR      r0,r0,r1
0000da  ea400404          ORR      r4,r0,r4
;;;273                USART_InitStruct->USART_Mode;
;;;274    
;;;275      /* Write to USART CR1 */
;;;276      USARTx->CR1 = (uint16_t)tmpreg;
0000de  81ac              STRH     r4,[r5,#0xc]
;;;277    
;;;278    /*---------------------------- USART CR3 Configuration -----------------------*/  
;;;279      tmpreg = USARTx->CR3;
0000e0  8aac              LDRH     r4,[r5,#0x14]
;;;280    
;;;281      /* Clear CTSE and RTSE bits */
;;;282      tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
0000e2  f4247440          BIC      r4,r4,#0x300
;;;283    
;;;284      /* Configure the USART HFC : 
;;;285          Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;286      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
0000e6  89b0              LDRH     r0,[r6,#0xc]
0000e8  ea400404          ORR      r4,r0,r4
;;;287    
;;;288      /* Write to USART CR3 */
;;;289      USARTx->CR3 = (uint16_t)tmpreg;
0000ec  82ac              STRH     r4,[r5,#0x14]
;;;290    
;;;291    /*---------------------------- USART BRR Configuration -----------------------*/
;;;292      /* Configure the USART Baud Rate */
;;;293      RCC_GetClocksFreq(&RCC_ClocksStatus);
0000ee  4668              MOV      r0,sp
0000f0  f7fffffe          BL       RCC_GetClocksFreq
;;;294    
;;;295      if ((USARTx == USART1) || (USARTx == USART6))
0000f4  48be              LDR      r0,|L1.1008|
0000f6  4285              CMP      r5,r0
0000f8  d002              BEQ      |L1.256|
0000fa  48c2              LDR      r0,|L1.1028|
0000fc  4285              CMP      r5,r0
0000fe  d102              BNE      |L1.262|
                  |L1.256|
;;;296      {
;;;297        apbclock = RCC_ClocksStatus.PCLK2_Frequency;
000100  f8dd900c          LDR      r9,[sp,#0xc]
000104  e001              B        |L1.266|
                  |L1.262|
;;;298      }
;;;299      else
;;;300      {
;;;301        apbclock = RCC_ClocksStatus.PCLK1_Frequency;
000106  f8dd9008          LDR      r9,[sp,#8]
                  |L1.266|
;;;302      }
;;;303      
;;;304      /* Determine the integer part */
;;;305      if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
00010a  89a8              LDRH     r0,[r5,#0xc]
00010c  f4104f00          TST      r0,#0x8000
000110  d009              BEQ      |L1.294|
;;;306      {
;;;307        /* Integer part computing in case Oversampling mode is 8 Samples */
;;;308        integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
000112  eb0900c9          ADD      r0,r9,r9,LSL #3
000116  eb001009          ADD      r0,r0,r9,LSL #4
00011a  6831              LDR      r1,[r6,#0]
00011c  ea4f0141          LSL      r1,r1,#1
000120  fbb0f7f1          UDIV     r7,r0,r1
000124  e008              B        |L1.312|
                  |L1.294|
;;;309      }
;;;310      else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
;;;311      {
;;;312        /* Integer part computing in case Oversampling mode is 16 Samples */
;;;313        integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
000126  eb0900c9          ADD      r0,r9,r9,LSL #3
00012a  eb001009          ADD      r0,r0,r9,LSL #4
00012e  6831              LDR      r1,[r6,#0]
000130  ea4f0181          LSL      r1,r1,#2
000134  fbb0f7f1          UDIV     r7,r0,r1
                  |L1.312|
;;;314      }
;;;315      tmpreg = (integerdivider / 100) << 4;
000138  f04f0064          MOV      r0,#0x64
00013c  fbb7f0f0          UDIV     r0,r7,r0
000140  ea4f1400          LSL      r4,r0,#4
;;;316    
;;;317      /* Determine the fractional part */
;;;318      fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
000144  ea4f1014          LSR      r0,r4,#4
000148  f04f0164          MOV      r1,#0x64
00014c  fb017810          MLS      r8,r1,r0,r7
;;;319    
;;;320      /* Implement the fractional part in the register */
;;;321      if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
000150  89a8              LDRH     r0,[r5,#0xc]
000152  f4104f00          TST      r0,#0x8000
000156  d00a              BEQ      |L1.366|
;;;322      {
;;;323        tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
000158  f04f0032          MOV      r0,#0x32
00015c  eb0000c8          ADD      r0,r0,r8,LSL #3
000160  fbb0f0f1          UDIV     r0,r0,r1
000164  f0000007          AND      r0,r0,#7
000168  ea400404          ORR      r4,r0,r4
00016c  e00b              B        |L1.390|
                  |L1.366|
;;;324      }
;;;325      else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
;;;326      {
;;;327        tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
00016e  f04f0032          MOV      r0,#0x32
000172  eb001008          ADD      r0,r0,r8,LSL #4
000176  f04f0164          MOV      r1,#0x64
00017a  fbb0f0f1          UDIV     r0,r0,r1
00017e  f000000f          AND      r0,r0,#0xf
000182  ea400404          ORR      r4,r0,r4
                  |L1.390|
;;;328      }
;;;329      
;;;330      /* Write to USART BRR register */
;;;331      USARTx->BRR = (uint16_t)tmpreg;
000186  812c              STRH     r4,[r5,#8]
;;;332    }
000188  e8bd87ff          POP      {r0-r10,pc}
;;;333    
                          ENDP

                  USART_StructInit PROC
;;;339      */
;;;340    void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
00018c  f44f5116          MOV      r1,#0x2580
;;;341    {
;;;342      /* USART_InitStruct members default value */
;;;343      USART_InitStruct->USART_BaudRate = 9600;
000190  6001              STR      r1,[r0,#0]
;;;344      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
000192  f04f0100          MOV      r1,#0
000196  8081              STRH     r1,[r0,#4]
;;;345      USART_InitStruct->USART_StopBits = USART_StopBits_1;
000198  80c1              STRH     r1,[r0,#6]
;;;346      USART_InitStruct->USART_Parity = USART_Parity_No ;
00019a  8101              STRH     r1,[r0,#8]
;;;347      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00019c  f04f010c          MOV      r1,#0xc
0001a0  8141              STRH     r1,[r0,#0xa]
;;;348      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
0001a2  f04f0100          MOV      r1,#0
0001a6  8181              STRH     r1,[r0,#0xc]
;;;349    }
0001a8  4770              BX       lr
;;;350    
                          ENDP

                  USART_ClockInit PROC
;;;359      */
;;;360    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
0001aa  b510              PUSH     {r4,lr}
;;;361    {
0001ac  4602              MOV      r2,r0
;;;362      uint32_t tmpreg = 0x00;
0001ae  f04f0000          MOV      r0,#0
;;;363      /* Check the parameters */
;;;364      assert_param(IS_USART_1236_PERIPH(USARTx));
;;;365      assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
;;;366      assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
;;;367      assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
;;;368      assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
;;;369      
;;;370    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;371      tmpreg = USARTx->CR2;
0001b2  8a10              LDRH     r0,[r2,#0x10]
;;;372      /* Clear CLKEN, CPOL, CPHA and LBCL bits */
;;;373      tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
0001b4  f4206070          BIC      r0,r0,#0xf00
;;;374      /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
;;;375      /* Set CLKEN bit according to USART_Clock value */
;;;376      /* Set CPOL bit according to USART_CPOL value */
;;;377      /* Set CPHA bit according to USART_CPHA value */
;;;378      /* Set LBCL bit according to USART_LastBit value */
;;;379      tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
0001b8  880b              LDRH     r3,[r1,#0]
0001ba  884c              LDRH     r4,[r1,#2]
0001bc  ea430304          ORR      r3,r3,r4
0001c0  888c              LDRH     r4,[r1,#4]
0001c2  ea430304          ORR      r3,r3,r4
0001c6  88cc              LDRH     r4,[r1,#6]
0001c8  ea430304          ORR      r3,r3,r4
0001cc  ea430000          ORR      r0,r3,r0
;;;380                     USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
;;;381      /* Write to USART CR2 */
;;;382      USARTx->CR2 = (uint16_t)tmpreg;
0001d0  8210              STRH     r0,[r2,#0x10]
;;;383    }
0001d2  bd10              POP      {r4,pc}
;;;384    
                          ENDP

                  USART_ClockStructInit PROC
;;;390      */
;;;391    void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
0001d4  f04f0100          MOV      r1,#0
;;;392    {
;;;393      /* USART_ClockInitStruct members default value */
;;;394      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
0001d8  8001              STRH     r1,[r0,#0]
;;;395      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
0001da  8041              STRH     r1,[r0,#2]
;;;396      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
0001dc  8081              STRH     r1,[r0,#4]
;;;397      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
0001de  80c1              STRH     r1,[r0,#6]
;;;398    }
0001e0  4770              BX       lr
;;;399    
                          ENDP

                  USART_Cmd PROC
;;;407      */
;;;408    void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
0001e2  b121              CBZ      r1,|L1.494|
;;;409    {
;;;410      /* Check the parameters */
;;;411      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;412      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;413      
;;;414      if (NewState != DISABLE)
;;;415      {
;;;416        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;417        USARTx->CR1 |= USART_CR1_UE;
0001e4  8982              LDRH     r2,[r0,#0xc]
0001e6  f4425200          ORR      r2,r2,#0x2000
0001ea  8182              STRH     r2,[r0,#0xc]
0001ec  e005              B        |L1.506|
                  |L1.494|
;;;418      }
;;;419      else
;;;420      {
;;;421        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;422        USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
0001ee  8982              LDRH     r2,[r0,#0xc]
0001f0  f64d73ff          MOV      r3,#0xdfff
0001f4  ea020203          AND      r2,r2,r3
0001f8  8182              STRH     r2,[r0,#0xc]
                  |L1.506|
;;;423      }
;;;424    }
0001fa  4770              BX       lr
;;;425    
                          ENDP

                  USART_SetPrescaler PROC
;;;433      */
;;;434    void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
0001fc  8b02              LDRH     r2,[r0,#0x18]
;;;435    { 
;;;436      /* Check the parameters */
;;;437      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;438      
;;;439      /* Clear the USART prescaler */
;;;440      USARTx->GTPR &= USART_GTPR_GT;
0001fe  f402427f          AND      r2,r2,#0xff00
000202  8302              STRH     r2,[r0,#0x18]
;;;441      /* Set the USART prescaler */
;;;442      USARTx->GTPR |= USART_Prescaler;
000204  8b02              LDRH     r2,[r0,#0x18]
000206  ea420201          ORR      r2,r2,r1
00020a  8302              STRH     r2,[r0,#0x18]
;;;443    }
00020c  4770              BX       lr
;;;444    
                          ENDP

                  USART_OverSampling8Cmd PROC
;;;454      */
;;;455    void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
00020e  b121              CBZ      r1,|L1.538|
;;;456    {
;;;457      /* Check the parameters */
;;;458      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;459      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;460      
;;;461      if (NewState != DISABLE)
;;;462      {
;;;463        /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
;;;464        USARTx->CR1 |= USART_CR1_OVER8;
000210  8982              LDRH     r2,[r0,#0xc]
000212  f4424200          ORR      r2,r2,#0x8000
000216  8182              STRH     r2,[r0,#0xc]
000218  e003              B        |L1.546|
                  |L1.538|
;;;465      }
;;;466      else
;;;467      {
;;;468        /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
;;;469        USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_OVER8);
00021a  8982              LDRH     r2,[r0,#0xc]
00021c  f3c2020e          UBFX     r2,r2,#0,#15
000220  8182              STRH     r2,[r0,#0xc]
                  |L1.546|
;;;470      }
;;;471    }  
000222  4770              BX       lr
;;;472    
                          ENDP

                  USART_OneBitMethodCmd PROC
;;;480      */
;;;481    void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000224  b121              CBZ      r1,|L1.560|
;;;482    {
;;;483      /* Check the parameters */
;;;484      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;485      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;486      
;;;487      if (NewState != DISABLE)
;;;488      {
;;;489        /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
;;;490        USARTx->CR3 |= USART_CR3_ONEBIT;
000226  8a82              LDRH     r2,[r0,#0x14]
000228  f4426200          ORR      r2,r2,#0x800
00022c  8282              STRH     r2,[r0,#0x14]
00022e  e005              B        |L1.572|
                  |L1.560|
;;;491      }
;;;492      else
;;;493      {
;;;494        /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
;;;495        USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT);
000230  8a82              LDRH     r2,[r0,#0x14]
000232  f24f73ff          MOV      r3,#0xf7ff
000236  ea020203          AND      r2,r2,r3
00023a  8282              STRH     r2,[r0,#0x14]
                  |L1.572|
;;;496      }
;;;497    }
00023c  4770              BX       lr
;;;498    
                          ENDP

                  USART_SendData PROC
;;;537      */
;;;538    void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
00023e  f3c10208          UBFX     r2,r1,#0,#9
;;;539    {
;;;540      /* Check the parameters */
;;;541      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;542      assert_param(IS_USART_DATA(Data)); 
;;;543        
;;;544      /* Transmit Data */
;;;545      USARTx->DR = (Data & (uint16_t)0x01FF);
000242  8082              STRH     r2,[r0,#4]
;;;546    }
000244  4770              BX       lr
;;;547    
                          ENDP

                  USART_ReceiveData PROC
;;;553      */
;;;554    uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
000246  4601              MOV      r1,r0
;;;555    {
;;;556      /* Check the parameters */
;;;557      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;558      
;;;559      /* Receive Data */
;;;560      return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
000248  8888              LDRH     r0,[r1,#4]
00024a  f3c00008          UBFX     r0,r0,#0,#9
;;;561    }
00024e  4770              BX       lr
;;;562    
                          ENDP

                  USART_SetAddress PROC
;;;604      */
;;;605    void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
000250  8a02              LDRH     r2,[r0,#0x10]
;;;606    {
;;;607      /* Check the parameters */
;;;608      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;609      assert_param(IS_USART_ADDRESS(USART_Address)); 
;;;610        
;;;611      /* Clear the USART address */
;;;612      USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_ADD);
000252  f64f73f0          MOV      r3,#0xfff0
000256  ea020203          AND      r2,r2,r3
00025a  8202              STRH     r2,[r0,#0x10]
;;;613      /* Set the USART address node */
;;;614      USARTx->CR2 |= USART_Address;
00025c  8a02              LDRH     r2,[r0,#0x10]
00025e  ea420201          ORR      r2,r2,r1
000262  8202              STRH     r2,[r0,#0x10]
;;;615    }
000264  4770              BX       lr
;;;616    
                          ENDP

                  USART_ReceiverWakeUpCmd PROC
;;;624      */
;;;625    void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000266  b121              CBZ      r1,|L1.626|
;;;626    {
;;;627      /* Check the parameters */
;;;628      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;629      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;630      
;;;631      if (NewState != DISABLE)
;;;632      {
;;;633        /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;634        USARTx->CR1 |= USART_CR1_RWU;
000268  8982              LDRH     r2,[r0,#0xc]
00026a  f0420202          ORR      r2,r2,#2
00026e  8182              STRH     r2,[r0,#0xc]
000270  e005              B        |L1.638|
                  |L1.626|
;;;635      }
;;;636      else
;;;637      {
;;;638        /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;639        USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_RWU);
000272  8982              LDRH     r2,[r0,#0xc]
000274  f64f73fd          MOV      r3,#0xfffd
000278  ea020203          AND      r2,r2,r3
00027c  8182              STRH     r2,[r0,#0xc]
                  |L1.638|
;;;640      }
;;;641    }
00027e  4770              BX       lr
;;;642    /**
                          ENDP

                  USART_WakeUpConfig PROC
;;;651      */
;;;652    void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
000280  8982              LDRH     r2,[r0,#0xc]
;;;653    {
;;;654      /* Check the parameters */
;;;655      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;656      assert_param(IS_USART_WAKEUP(USART_WakeUp));
;;;657      
;;;658      USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_WAKE);
000282  f24f73ff          MOV      r3,#0xf7ff
000286  ea020203          AND      r2,r2,r3
00028a  8182              STRH     r2,[r0,#0xc]
;;;659      USARTx->CR1 |= USART_WakeUp;
00028c  8982              LDRH     r2,[r0,#0xc]
00028e  ea420201          ORR      r2,r2,r1
000292  8182              STRH     r2,[r0,#0xc]
;;;660    }
000294  4770              BX       lr
;;;661    
                          ENDP

                  USART_LINBreakDetectLengthConfig PROC
;;;720      */
;;;721    void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
000296  8a02              LDRH     r2,[r0,#0x10]
;;;722    {
;;;723      /* Check the parameters */
;;;724      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;725      assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
;;;726      
;;;727      USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LBDL);
000298  f64f73df          MOV      r3,#0xffdf
00029c  ea020203          AND      r2,r2,r3
0002a0  8202              STRH     r2,[r0,#0x10]
;;;728      USARTx->CR2 |= USART_LINBreakDetectLength;  
0002a2  8a02              LDRH     r2,[r0,#0x10]
0002a4  ea420201          ORR      r2,r2,r1
0002a8  8202              STRH     r2,[r0,#0x10]
;;;729    }
0002aa  4770              BX       lr
;;;730    
                          ENDP

                  USART_LINCmd PROC
;;;738      */
;;;739    void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
0002ac  b121              CBZ      r1,|L1.696|
;;;740    {
;;;741      /* Check the parameters */
;;;742      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;743      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;744      
;;;745      if (NewState != DISABLE)
;;;746      {
;;;747        /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;748        USARTx->CR2 |= USART_CR2_LINEN;
0002ae  8a02              LDRH     r2,[r0,#0x10]
0002b0  f4424280          ORR      r2,r2,#0x4000
0002b4  8202              STRH     r2,[r0,#0x10]
0002b6  e005              B        |L1.708|
                  |L1.696|
;;;749      }
;;;750      else
;;;751      {
;;;752        /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
;;;753        USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LINEN);
0002b8  8a02              LDRH     r2,[r0,#0x10]
0002ba  f64b73ff          MOV      r3,#0xbfff
0002be  ea020203          AND      r2,r2,r3
0002c2  8202              STRH     r2,[r0,#0x10]
                  |L1.708|
;;;754      }
;;;755    }
0002c4  4770              BX       lr
;;;756    
                          ENDP

                  USART_SendBreak PROC
;;;762      */
;;;763    void USART_SendBreak(USART_TypeDef* USARTx)
0002c6  8981              LDRH     r1,[r0,#0xc]
;;;764    {
;;;765      /* Check the parameters */
;;;766      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;767      
;;;768      /* Send break characters */
;;;769      USARTx->CR1 |= USART_CR1_SBK;
0002c8  f0410101          ORR      r1,r1,#1
0002cc  8181              STRH     r1,[r0,#0xc]
;;;770    }
0002ce  4770              BX       lr
;;;771    
                          ENDP

                  USART_HalfDuplexCmd PROC
;;;815      */
;;;816    void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
0002d0  b121              CBZ      r1,|L1.732|
;;;817    {
;;;818      /* Check the parameters */
;;;819      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;820      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;821      
;;;822      if (NewState != DISABLE)
;;;823      {
;;;824        /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;825        USARTx->CR3 |= USART_CR3_HDSEL;
0002d2  8a82              LDRH     r2,[r0,#0x14]
0002d4  f0420208          ORR      r2,r2,#8
0002d8  8282              STRH     r2,[r0,#0x14]
0002da  e005              B        |L1.744|
                  |L1.732|
;;;826      }
;;;827      else
;;;828      {
;;;829        /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;830        USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_HDSEL);
0002dc  8a82              LDRH     r2,[r0,#0x14]
0002de  f64f73f7          MOV      r3,#0xfff7
0002e2  ea020203          AND      r2,r2,r3
0002e6  8282              STRH     r2,[r0,#0x14]
                  |L1.744|
;;;831      }
;;;832    }
0002e8  4770              BX       lr
;;;833    
                          ENDP

                  USART_SetGuardTime PROC
;;;900      */
;;;901    void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
0002ea  8b02              LDRH     r2,[r0,#0x18]
;;;902    {    
;;;903      /* Check the parameters */
;;;904      assert_param(IS_USART_1236_PERIPH(USARTx));
;;;905      
;;;906      /* Clear the USART Guard time */
;;;907      USARTx->GTPR &= USART_GTPR_PSC;
0002ec  b2d2              UXTB     r2,r2
0002ee  8302              STRH     r2,[r0,#0x18]
;;;908      /* Set the USART guard time */
;;;909      USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
0002f0  8b02              LDRH     r2,[r0,#0x18]
0002f2  ea422201          ORR      r2,r2,r1,LSL #8
0002f6  8302              STRH     r2,[r0,#0x18]
;;;910    }
0002f8  4770              BX       lr
;;;911    
                          ENDP

                  USART_SmartCardCmd PROC
;;;919      */
;;;920    void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
0002fa  b121              CBZ      r1,|L1.774|
;;;921    {
;;;922      /* Check the parameters */
;;;923      assert_param(IS_USART_1236_PERIPH(USARTx));
;;;924      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;925      if (NewState != DISABLE)
;;;926      {
;;;927        /* Enable the SC mode by setting the SCEN bit in the CR3 register */
;;;928        USARTx->CR3 |= USART_CR3_SCEN;
0002fc  8a82              LDRH     r2,[r0,#0x14]
0002fe  f0420220          ORR      r2,r2,#0x20
000302  8282              STRH     r2,[r0,#0x14]
000304  e005              B        |L1.786|
                  |L1.774|
;;;929      }
;;;930      else
;;;931      {
;;;932        /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
;;;933        USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_SCEN);
000306  8a82              LDRH     r2,[r0,#0x14]
000308  f64f73df          MOV      r3,#0xffdf
00030c  ea020203          AND      r2,r2,r3
000310  8282              STRH     r2,[r0,#0x14]
                  |L1.786|
;;;934      }
;;;935    }
000312  4770              BX       lr
;;;936    
                          ENDP

                  USART_SmartCardNACKCmd PROC
;;;944      */
;;;945    void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000314  b121              CBZ      r1,|L1.800|
;;;946    {
;;;947      /* Check the parameters */
;;;948      assert_param(IS_USART_1236_PERIPH(USARTx)); 
;;;949      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;950      if (NewState != DISABLE)
;;;951      {
;;;952        /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
;;;953        USARTx->CR3 |= USART_CR3_NACK;
000316  8a82              LDRH     r2,[r0,#0x14]
000318  f0420210          ORR      r2,r2,#0x10
00031c  8282              STRH     r2,[r0,#0x14]
00031e  e005              B        |L1.812|
                  |L1.800|
;;;954      }
;;;955      else
;;;956      {
;;;957        /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
;;;958        USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_NACK);
000320  8a82              LDRH     r2,[r0,#0x14]
000322  f64f73ef          MOV      r3,#0xffef
000326  ea020203          AND      r2,r2,r3
00032a  8282              STRH     r2,[r0,#0x14]
                  |L1.812|
;;;959      }
;;;960    }
00032c  4770              BX       lr
;;;961    
                          ENDP

                  USART_IrDAConfig PROC
;;;1015     */
;;;1016   void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
00032e  8a82              LDRH     r2,[r0,#0x14]
;;;1017   {
;;;1018     /* Check the parameters */
;;;1019     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1020     assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
;;;1021       
;;;1022     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IRLP);
000330  f64f73fb          MOV      r3,#0xfffb
000334  ea020203          AND      r2,r2,r3
000338  8282              STRH     r2,[r0,#0x14]
;;;1023     USARTx->CR3 |= USART_IrDAMode;
00033a  8a82              LDRH     r2,[r0,#0x14]
00033c  ea420201          ORR      r2,r2,r1
000340  8282              STRH     r2,[r0,#0x14]
;;;1024   }
000342  4770              BX       lr
;;;1025   
                          ENDP

                  USART_IrDACmd PROC
;;;1033     */
;;;1034   void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
000344  b121              CBZ      r1,|L1.848|
;;;1035   {
;;;1036     /* Check the parameters */
;;;1037     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1038     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1039       
;;;1040     if (NewState != DISABLE)
;;;1041     {
;;;1042       /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
;;;1043       USARTx->CR3 |= USART_CR3_IREN;
000346  8a82              LDRH     r2,[r0,#0x14]
000348  f0420202          ORR      r2,r2,#2
00034c  8282              STRH     r2,[r0,#0x14]
00034e  e005              B        |L1.860|
                  |L1.848|
;;;1044     }
;;;1045     else
;;;1046     {
;;;1047       /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
;;;1048       USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IREN);
000350  8a82              LDRH     r2,[r0,#0x14]
000352  f64f73fd          MOV      r3,#0xfffd
000356  ea020203          AND      r2,r2,r3
00035a  8282              STRH     r2,[r0,#0x14]
                  |L1.860|
;;;1049     }
;;;1050   }
00035c  4770              BX       lr
;;;1051   
                          ENDP

                  USART_DMACmd PROC
;;;1079     */
;;;1080   void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
00035e  b510              PUSH     {r4,lr}
;;;1081   {
;;;1082     /* Check the parameters */
;;;1083     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1084     assert_param(IS_USART_DMAREQ(USART_DMAReq));  
;;;1085     assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;1086   
;;;1087     if (NewState != DISABLE)
000360  b122              CBZ      r2,|L1.876|
;;;1088     {
;;;1089       /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;1090          DMAR bits in the USART CR3 register */
;;;1091       USARTx->CR3 |= USART_DMAReq;
000362  8a83              LDRH     r3,[r0,#0x14]
000364  ea430301          ORR      r3,r3,r1
000368  8283              STRH     r3,[r0,#0x14]
00036a  e006              B        |L1.890|
                  |L1.876|
;;;1092     }
;;;1093     else
;;;1094     {
;;;1095       /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;1096          DMAR bits in the USART CR3 register */
;;;1097       USARTx->CR3 &= (uint16_t)~USART_DMAReq;
00036c  8a83              LDRH     r3,[r0,#0x14]
00036e  ea6f0401          MVN      r4,r1
000372  b2a4              UXTH     r4,r4
000374  ea030304          AND      r3,r3,r4
000378  8283              STRH     r3,[r0,#0x14]
                  |L1.890|
;;;1098     }
;;;1099   }
00037a  bd10              POP      {r4,pc}
;;;1100   
                          ENDP

                  USART_ITConfig PROC
;;;1207     */
;;;1208   void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
00037c  b5f0              PUSH     {r4-r7,lr}
;;;1209   {
00037e  4603              MOV      r3,r0
;;;1210     uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
000380  f04f0400          MOV      r4,#0
000384  4626              MOV      r6,r4
000386  4625              MOV      r5,r4
;;;1211     uint32_t usartxbase = 0x00;
000388  4620              MOV      r0,r4
;;;1212     /* Check the parameters */
;;;1213     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1214     assert_param(IS_USART_CONFIG_IT(USART_IT));
;;;1215     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1216   
;;;1217     /* The CTS interrupt is not available for UART4 and UART5 */
;;;1218     if (USART_IT == USART_IT_CTS)
00038a  f5a16710          SUB      r7,r1,#0x900
00038e  3f6a              SUBS     r7,r7,#0x6a
000390  d100              BNE      |L1.916|
;;;1219     {
;;;1220       assert_param(IS_USART_1236_PERIPH(USARTx));
000392  bf00              NOP      
                  |L1.916|
;;;1221     } 
;;;1222       
;;;1223     usartxbase = (uint32_t)USARTx;
000394  4618              MOV      r0,r3
;;;1224   
;;;1225     /* Get the USART register index */
;;;1226     usartreg = (((uint8_t)USART_IT) >> 0x05);
000396  f3c11442          UBFX     r4,r1,#5,#3
;;;1227   
;;;1228     /* Get the interrupt position */
;;;1229     itpos = USART_IT & IT_MASK;
00039a  f001061f          AND      r6,r1,#0x1f
;;;1230     itmask = (((uint32_t)0x01) << itpos);
00039e  f04f0701          MOV      r7,#1
0003a2  fa07f506          LSL      r5,r7,r6
;;;1231       
;;;1232     if (usartreg == 0x01) /* The IT is in CR1 register */
0003a6  2c01              CMP      r4,#1
0003a8  d102              BNE      |L1.944|
;;;1233     {
;;;1234       usartxbase += 0x0C;
0003aa  f100000c          ADD      r0,r0,#0xc
0003ae  e006              B        |L1.958|
                  |L1.944|
;;;1235     }
;;;1236     else if (usartreg == 0x02) /* The IT is in CR2 register */
0003b0  2c02              CMP      r4,#2
0003b2  d102              BNE      |L1.954|
;;;1237     {
;;;1238       usartxbase += 0x10;
0003b4  f1000010          ADD      r0,r0,#0x10
0003b8  e001              B        |L1.958|
                  |L1.954|
;;;1239     }
;;;1240     else /* The IT is in CR3 register */
;;;1241     {
;;;1242       usartxbase += 0x14; 
0003ba  f1000014          ADD      r0,r0,#0x14
                  |L1.958|
;;;1243     }
;;;1244     if (NewState != DISABLE)
0003be  b122              CBZ      r2,|L1.970|
;;;1245     {
;;;1246       *(__IO uint32_t*)usartxbase  |= itmask;
0003c0  6807              LDR      r7,[r0,#0]
0003c2  ea470705          ORR      r7,r7,r5
0003c6  6007              STR      r7,[r0,#0]
0003c8  e003              B        |L1.978|
                  |L1.970|
;;;1247     }
;;;1248     else
;;;1249     {
;;;1250       *(__IO uint32_t*)usartxbase &= ~itmask;
0003ca  6807              LDR      r7,[r0,#0]
0003cc  ea270705          BIC      r7,r7,r5
0003d0  6007              STR      r7,[r0,#0]
                  |L1.978|
;;;1251     }
;;;1252   }
0003d2  bdf0              POP      {r4-r7,pc}
;;;1253   
                          ENDP

                  USART_GetFlagStatus PROC
;;;1271     */
;;;1272   FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
0003d4  4602              MOV      r2,r0
;;;1273   {
;;;1274     FlagStatus bitstatus = RESET;
0003d6  f04f0000          MOV      r0,#0
;;;1275     /* Check the parameters */
;;;1276     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1277     assert_param(IS_USART_FLAG(USART_FLAG));
;;;1278   
;;;1279     /* The CTS flag is not available for UART4 and UART5 */
;;;1280     if (USART_FLAG == USART_FLAG_CTS)
0003da  f5b17f00          CMP      r1,#0x200
0003de  d100              BNE      |L1.994|
;;;1281     {
;;;1282       assert_param(IS_USART_1236_PERIPH(USARTx));
0003e0  bf00              NOP      
                  |L1.994|
;;;1283     } 
;;;1284       
;;;1285     if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
0003e2  8813              LDRH     r3,[r2,#0]
0003e4  420b              TST      r3,r1
0003e6  d00f              BEQ      |L1.1032|
;;;1286     {
;;;1287       bitstatus = SET;
0003e8  f04f0001          MOV      r0,#1
0003ec  e00e              B        |L1.1036|
0003ee  0000              DCW      0x0000
                  |L1.1008|
                          DCD      0x40011000
                  |L1.1012|
                          DCD      0x40004400
                  |L1.1016|
                          DCD      0x40004800
                  |L1.1020|
                          DCD      0x40004c00
                  |L1.1024|
                          DCD      0x40005000
                  |L1.1028|
                          DCD      0x40011400
                  |L1.1032|
;;;1288     }
;;;1289     else
;;;1290     {
;;;1291       bitstatus = RESET;
000408  f04f0000          MOV      r0,#0
                  |L1.1036|
;;;1292     }
;;;1293     return bitstatus;
;;;1294   }
00040c  4770              BX       lr
;;;1295   
                          ENDP

                  USART_ClearFlag PROC
;;;1320     */
;;;1321   void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
00040e  f4017200          AND      r2,r1,#0x200
;;;1322   {
;;;1323     /* Check the parameters */
;;;1324     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1325     assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
;;;1326   
;;;1327     /* The CTS flag is not available for UART4 and UART5 */
;;;1328     if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
000412  f5b27f00          CMP      r2,#0x200
000416  d100              BNE      |L1.1050|
;;;1329     {
;;;1330       assert_param(IS_USART_1236_PERIPH(USARTx));
000418  bf00              NOP      
                  |L1.1050|
;;;1331     } 
;;;1332          
;;;1333     USARTx->SR = (uint16_t)~USART_FLAG;
00041a  ea6f0201          MVN      r2,r1
00041e  8002              STRH     r2,[r0,#0]
;;;1334   }
000420  4770              BX       lr
;;;1335   
                          ENDP

                  USART_GetITStatus PROC
;;;1353     */
;;;1354   ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
000422  b570              PUSH     {r4-r6,lr}
;;;1355   {
000424  4602              MOV      r2,r0
;;;1356     uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
000426  f04f0400          MOV      r4,#0
00042a  4623              MOV      r3,r4
00042c  461d              MOV      r5,r3
;;;1357     ITStatus bitstatus = RESET;
00042e  4618              MOV      r0,r3
;;;1358     /* Check the parameters */
;;;1359     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1360     assert_param(IS_USART_GET_IT(USART_IT)); 
;;;1361   
;;;1362     /* The CTS interrupt is not available for UART4 and UART5 */ 
;;;1363     if (USART_IT == USART_IT_CTS)
000430  f5a16610          SUB      r6,r1,#0x900
000434  3e6a              SUBS     r6,r6,#0x6a
000436  d100              BNE      |L1.1082|
;;;1364     {
;;;1365       assert_param(IS_USART_1236_PERIPH(USARTx));
000438  bf00              NOP      
                  |L1.1082|
;;;1366     } 
;;;1367       
;;;1368     /* Get the USART register index */
;;;1369     usartreg = (((uint8_t)USART_IT) >> 0x05);
00043a  f3c11542          UBFX     r5,r1,#5,#3
;;;1370     /* Get the interrupt position */
;;;1371     itmask = USART_IT & IT_MASK;
00043e  f001031f          AND      r3,r1,#0x1f
;;;1372     itmask = (uint32_t)0x01 << itmask;
000442  f04f0601          MOV      r6,#1
000446  fa06f303          LSL      r3,r6,r3
;;;1373     
;;;1374     if (usartreg == 0x01) /* The IT  is in CR1 register */
00044a  2d01              CMP      r5,#1
00044c  d103              BNE      |L1.1110|
;;;1375     {
;;;1376       itmask &= USARTx->CR1;
00044e  8996              LDRH     r6,[r2,#0xc]
000450  ea060303          AND      r3,r6,r3
000454  e008              B        |L1.1128|
                  |L1.1110|
;;;1377     }
;;;1378     else if (usartreg == 0x02) /* The IT  is in CR2 register */
000456  2d02              CMP      r5,#2
000458  d103              BNE      |L1.1122|
;;;1379     {
;;;1380       itmask &= USARTx->CR2;
00045a  8a16              LDRH     r6,[r2,#0x10]
00045c  ea060303          AND      r3,r6,r3
000460  e002              B        |L1.1128|
                  |L1.1122|
;;;1381     }
;;;1382     else /* The IT  is in CR3 register */
;;;1383     {
;;;1384       itmask &= USARTx->CR3;
000462  8a96              LDRH     r6,[r2,#0x14]
000464  ea060303          AND      r3,r6,r3
                  |L1.1128|
;;;1385     }
;;;1386     
;;;1387     bitpos = USART_IT >> 0x08;
000468  ea4f2421          ASR      r4,r1,#8
;;;1388     bitpos = (uint32_t)0x01 << bitpos;
00046c  f04f0601          MOV      r6,#1
000470  fa06f404          LSL      r4,r6,r4
;;;1389     bitpos &= USARTx->SR;
000474  8816              LDRH     r6,[r2,#0]
000476  ea060404          AND      r4,r6,r4
;;;1390     if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
00047a  b11b              CBZ      r3,|L1.1156|
00047c  b114              CBZ      r4,|L1.1156|
;;;1391     {
;;;1392       bitstatus = SET;
00047e  f04f0001          MOV      r0,#1
000482  e001              B        |L1.1160|
                  |L1.1156|
;;;1393     }
;;;1394     else
;;;1395     {
;;;1396       bitstatus = RESET;
000484  f04f0000          MOV      r0,#0
                  |L1.1160|
;;;1397     }
;;;1398     
;;;1399     return bitstatus;  
;;;1400   }
000488  bd70              POP      {r4-r6,pc}
;;;1401   
                          ENDP

                  USART_ClearITPendingBit PROC
;;;1427     */
;;;1428   void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
00048a  b510              PUSH     {r4,lr}
;;;1429   {
;;;1430     uint16_t bitpos = 0x00, itmask = 0x00;
00048c  f04f0200          MOV      r2,#0
000490  4613              MOV      r3,r2
;;;1431     /* Check the parameters */
;;;1432     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1433     assert_param(IS_USART_CLEAR_IT(USART_IT)); 
;;;1434   
;;;1435     /* The CTS interrupt is not available for UART4 and UART5 */
;;;1436     if (USART_IT == USART_IT_CTS)
000492  f5a16410          SUB      r4,r1,#0x900
000496  3c6a              SUBS     r4,r4,#0x6a
000498  d100              BNE      |L1.1180|
;;;1437     {
;;;1438       assert_param(IS_USART_1236_PERIPH(USARTx));
00049a  bf00              NOP      
                  |L1.1180|
;;;1439     } 
;;;1440       
;;;1441     bitpos = USART_IT >> 0x08;
00049c  ea4f2221          ASR      r2,r1,#8
;;;1442     itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
0004a0  f04f0401          MOV      r4,#1
0004a4  fa04f402          LSL      r4,r4,r2
0004a8  b2a3              UXTH     r3,r4
;;;1443     USARTx->SR = (uint16_t)~itmask;
0004aa  ea6f0403          MVN      r4,r3
0004ae  8004              STRH     r4,[r0,#0]
;;;1444   }
0004b0  bd10              POP      {r4,pc}
;;;1445   
                          ENDP

