; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\output\f205_usart.o --asm_dir=..\listing\ --list_dir=..\listing\ --depend=..\output\f205_usart.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\src -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\STM32F2xx -I..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc -I..\..\Utilities\STM32_EVAL -I..\src\SYSTICK -I..\src\LED -I..\src\GPIO -I..\src\USART -I..\src\FLASH -I..\src\HexFile -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DUSE_CPU_F205RC -DLJB_CPU -W --omf_browse=..\output\f205_usart.crf ..\src\USART\F205_usart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  Calc_CRCByte PROC
;;;92           
;;;93     uint16_t Calc_CRCByte(uint8_t *Buf, uint32_t Len)
000000  b530              PUSH     {r4,r5,lr}
;;;94     {
000002  4602              MOV      r2,r0
;;;95       uint16_t crc = 0,value;
000004  f04f0000          MOV      r0,#0
;;;96       
;;;97       do 
000008  bf00              NOP      
                  |L1.10|
;;;98       {
;;;99         value = *Buf++;
00000a  f8123b01          LDRB     r3,[r2],#1
;;;100        crc = ((crc << 8) ^ CRCTable[((crc >> 8) ^ value) & 0xFF]);
00000e  ea832420          EOR      r4,r3,r0,ASR #8
000012  4dfb              LDR      r5,|L1.1024|
000014  f8354014          LDRH     r4,[r5,r4,LSL #1]
000018  ea842400          EOR      r4,r4,r0,LSL #8
00001c  b2a0              UXTH     r0,r4
;;;101      }while (--Len);
00001e  f1a10401          SUB      r4,r1,#1
000022  0021              MOVS     r1,r4
000024  d1f1              BNE      |L1.10|
;;;102      
;;;103      return (crc);
;;;104    }
000026  bd30              POP      {r4,r5,pc}
;;;105    
                          ENDP

                  Calc_CRCByte_Continue PROC
;;;106    uint16_t Calc_CRCByte_Continue(uint8_t *Buf, uint16_t Len, uint16_t last_crc)
000028  b570              PUSH     {r4-r6,lr}
;;;107    {
00002a  4603              MOV      r3,r0
;;;108    	uint16_t crc = last_crc, value;
00002c  4610              MOV      r0,r2
;;;109      
;;;110    	do 
00002e  bf00              NOP      
                  |L1.48|
;;;111    	{
;;;112    		value = *Buf++;
000030  f8134b01          LDRB     r4,[r3],#1
;;;113    		crc = ((crc << 8) ^ CRCTable[((crc >> 8) ^ value) & 0xFF]);
000034  ea842520          EOR      r5,r4,r0,ASR #8
000038  4ef1              LDR      r6,|L1.1024|
00003a  f8365015          LDRH     r5,[r6,r5,LSL #1]
00003e  ea852500          EOR      r5,r5,r0,LSL #8
000042  b2a8              UXTH     r0,r5
;;;114    	}while (--Len);
000044  f1a10501          SUB      r5,r1,#1
000048  b2ad              UXTH     r5,r5
00004a  0029              MOVS     r1,r5
00004c  d1f0              BNE      |L1.48|
;;;115      
;;;116    	return (crc);
;;;117    }
00004e  bd70              POP      {r4-r6,pc}
;;;118    
                          ENDP

                  F205_InitUSART PROC
;;;123      */
;;;124    void F205_InitUSART(void)
000050  b510              PUSH     {r4,lr}
;;;125    {
;;;126    	memset(&_Info, 0, sizeof(_Info));
000052  218c              MOVS     r1,#0x8c
000054  48eb              LDR      r0,|L1.1028|
000056  f7fffffe          BL       __aeabi_memclr
;;;127    	HexInfo.type = 0xff;
00005a  f04f00ff          MOV      r0,#0xff
00005e  49ea              LDR      r1,|L1.1032|
000060  7108              STRB     r0,[r1,#4]
;;;128    
;;;129    
;;;130    	USART_InitStructure.USART_BaudRate = USART_BAUD_RATE;
000062  f44f30e1          MOV      r0,#0x1c200
000066  49e9              LDR      r1,|L1.1036|
000068  6008              STR      r0,[r1,#0]  ; USART_InitStructure
;;;131    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00006a  f04f0000          MOV      r0,#0
00006e  8088              STRH     r0,[r1,#4]
;;;132    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000070  80c8              STRH     r0,[r1,#6]
;;;133    	USART_InitStructure.USART_Parity = USART_Parity_No;
000072  8108              STRH     r0,[r1,#8]
;;;134    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000074  8188              STRH     r0,[r1,#0xc]
;;;135    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000076  f04f000c          MOV      r0,#0xc
00007a  8148              STRH     r0,[r1,#0xa]
;;;136    
;;;137    	USART_BufStruct.TxBuf = (uint8_t *)&(USART_TxBuf[0]);
00007c  48e4              LDR      r0,|L1.1040|
00007e  49e5              LDR      r1,|L1.1044|
000080  6008              STR      r0,[r1,#0]  ; USART_BufStruct
;;;138    	USART_BufStruct.RxBuf = (uint8_t *)&(USART_RxBuf[0]);
000082  48e5              LDR      r0,|L1.1048|
000084  6048              STR      r0,[r1,#4]  ; USART_BufStruct
;;;139    	
;;;140    	STM_EVAL_COMInit(COM1, &USART_InitStructure, &USART_BufStruct);
000086  460a              MOV      r2,r1
000088  49e0              LDR      r1,|L1.1036|
00008a  f04f0000          MOV      r0,#0
00008e  f7fffffe          BL       STM_EVAL_COMInit
;;;141    	//STM_EVAL_COMInit(COM2, &USART_InitStructure, &USART_BufStruct);
;;;142    }
000092  bd10              POP      {r4,pc}
;;;143    
                          ENDP

                  F205_DisableUSART PROC
;;;144    void F205_DisableUSART(void)
000094  b510              PUSH     {r4,lr}
;;;145    {
;;;146    	F205_DisablePeripherals(COM1);
000096  2000              MOVS     r0,#0
000098  f7fffffe          BL       F205_DisablePeripherals
;;;147    }
00009c  bd10              POP      {r4,pc}
;;;148    
                          ENDP

                  F205_DisableUSART1 PROC
;;;149    void F205_DisableUSART1(void)
00009e  b510              PUSH     {r4,lr}
;;;150    {
;;;151    	F205_DisablePeripherals(COM2);
0000a0  2001              MOVS     r0,#1
0000a2  f7fffffe          BL       F205_DisablePeripherals
;;;152    }
0000a6  bd10              POP      {r4,pc}
;;;153    
                          ENDP

                  F205_PrepareTxData PROC
;;;268    
;;;269    void F205_PrepareTxData(uint8_t type, uint8_t cmd, uint8_t src, uint8_t dst, uint16_t len, uint8_t *data)
0000a8  e92d4fff          PUSH     {r0-r11,lr}
;;;270    {
0000ac  b083              SUB      sp,sp,#0xc
0000ae  4681              MOV      r9,r0
0000b0  468a              MOV      r10,r1
0000b2  4693              MOV      r11,r2
0000b4  9f10              LDR      r7,[sp,#0x40]
;;;271    	uint16_t i, j, crc;
;;;272    	uint8_t buf[8], *p;
;;;273    //	uint32_t status;
;;;274    
;;;275    	///采用 DMA 发送数据：
;;;276    	///等待前次 DMA 完成：两种方法
;;;277    	//while (DMA_GetCmdStatus(DMA2_Stream7) != DISABLE){}
;;;278    	while (!MyInfo.TxRdy){}
0000b6  bf00              NOP      
                  |L1.184|
0000b8  48d8              LDR      r0,|L1.1052|
0000ba  7a00              LDRB     r0,[r0,#8]  ; MyInfo
0000bc  2800              CMP      r0,#0
0000be  d0fb              BEQ      |L1.184|
;;;279    	//允许 TX：最少应等待100us 
;;;280    	F205_EnableUsartTx();
0000c0  f7fffffe          BL       F205_EnableUsartTx
;;;281    
;;;282    	p = &USART_TxBuf[0];
0000c4  4dd2              LDR      r5,|L1.1040|
;;;283    	buf[0] = (len + 8) >> 8;
0000c6  f1070008          ADD      r0,r7,#8
0000ca  ea4f2010          LSR      r0,r0,#8
0000ce  f88d0004          STRB     r0,[sp,#4]
;;;284    	buf[1] = (len + 8) & 0xff;
0000d2  f1070008          ADD      r0,r7,#8
0000d6  b2c0              UXTB     r0,r0
0000d8  f88d0005          STRB     r0,[sp,#5]
;;;285    	buf[2] = src;
0000dc  f88db006          STRB     r11,[sp,#6]
;;;286    	buf[3] = 0;
0000e0  f04f0000          MOV      r0,#0
0000e4  f88d0007          STRB     r0,[sp,#7]
;;;287    	buf[4] = dst;
0000e8  9806              LDR      r0,[sp,#0x18]
0000ea  f88d0008          STRB     r0,[sp,#8]
;;;288    	buf[5] = 0;
0000ee  f04f0000          MOV      r0,#0
0000f2  f88d0009          STRB     r0,[sp,#9]
;;;289    	buf[6] = type;
0000f6  f88d900a          STRB     r9,[sp,#0xa]
;;;290    	buf[7] = cmd;
0000fa  f88da00b          STRB     r10,[sp,#0xb]
;;;291    	crc = Calc_CRCByte(buf, 8);
0000fe  f04f0108          MOV      r1,#8
000102  a801              ADD      r0,sp,#4
000104  f7fffffe          BL       Calc_CRCByte
000108  4680              MOV      r8,r0
;;;292    	crc = Calc_CRCByte_Continue(data, len, crc);
00010a  4642              MOV      r2,r8
00010c  4639              MOV      r1,r7
00010e  9811              LDR      r0,[sp,#0x44]
000110  f7fffffe          BL       Calc_CRCByte_Continue
000114  4680              MOV      r8,r0
;;;293    	p[0] = 0x10;
000116  f04f0010          MOV      r0,#0x10
00011a  7028              STRB     r0,[r5,#0]
;;;294    	p[1] = 0x02;
00011c  f04f0002          MOV      r0,#2
000120  7068              STRB     r0,[r5,#1]
;;;295    	j = 2;
000122  4604              MOV      r4,r0
;;;296    	for (i = 0; i < 8; i++){
000124  f04f0600          MOV      r6,#0
000128  e011              B        |L1.334|
                  |L1.298|
;;;297    
;;;298    		p[j] = buf[i];
00012a  a801              ADD      r0,sp,#4
00012c  5d80              LDRB     r0,[r0,r6]
00012e  5528              STRB     r0,[r5,r4]
;;;299    		if (p[j] == 0x10){
000130  5d28              LDRB     r0,[r5,r4]
000132  2810              CMP      r0,#0x10
000134  d105              BNE      |L1.322|
;;;300    
;;;301    			j++;
000136  f1040001          ADD      r0,r4,#1
00013a  b284              UXTH     r4,r0
;;;302    			p[j] = 0x10;
00013c  f04f0010          MOV      r0,#0x10
000140  5528              STRB     r0,[r5,r4]
                  |L1.322|
;;;303    		}
;;;304    		j++;
000142  f1040001          ADD      r0,r4,#1
000146  b284              UXTH     r4,r0
000148  f1060001          ADD      r0,r6,#1              ;296
00014c  b286              UXTH     r6,r0                 ;296
                  |L1.334|
00014e  2e08              CMP      r6,#8                 ;296
000150  dbeb              BLT      |L1.298|
;;;305    	}
;;;306    
;;;307    	for (i = 0; i < len; i++){
000152  f04f0600          MOV      r6,#0
000156  e011              B        |L1.380|
                  |L1.344|
;;;308    
;;;309    		p[j] = data[i];
000158  9811              LDR      r0,[sp,#0x44]
00015a  5d80              LDRB     r0,[r0,r6]
00015c  5528              STRB     r0,[r5,r4]
;;;310    		if (p[j] == 0x10){
00015e  5d28              LDRB     r0,[r5,r4]
000160  2810              CMP      r0,#0x10
000162  d105              BNE      |L1.368|
;;;311    
;;;312    			j++;
000164  f1040001          ADD      r0,r4,#1
000168  b284              UXTH     r4,r0
;;;313    			p[j] = 0x10;
00016a  f04f0010          MOV      r0,#0x10
00016e  5528              STRB     r0,[r5,r4]
                  |L1.368|
;;;314    		}
;;;315    		j++;
000170  f1040001          ADD      r0,r4,#1
000174  b284              UXTH     r4,r0
000176  f1060001          ADD      r0,r6,#1              ;307
00017a  b286              UXTH     r6,r0                 ;307
                  |L1.380|
00017c  42be              CMP      r6,r7                 ;307
00017e  dbeb              BLT      |L1.344|
;;;316    	}
;;;317    
;;;318    	p[j] = crc >> 8;
000180  ea4f2028          ASR      r0,r8,#8
000184  5528              STRB     r0,[r5,r4]
;;;319    	if (p[j] == 0x10){
000186  5d28              LDRB     r0,[r5,r4]
000188  2810              CMP      r0,#0x10
00018a  d105              BNE      |L1.408|
;;;320    		
;;;321    		j++;
00018c  f1040001          ADD      r0,r4,#1
000190  b284              UXTH     r4,r0
;;;322    		p[j] = 0x10;
000192  f04f0010          MOV      r0,#0x10
000196  5528              STRB     r0,[r5,r4]
                  |L1.408|
;;;323    	}
;;;324    	j++;
000198  f1040001          ADD      r0,r4,#1
00019c  b284              UXTH     r4,r0
;;;325    	p[j] = crc & 0xff;
00019e  f8058004          STRB     r8,[r5,r4]
;;;326    	if (p[j] == 0x10){
0001a2  5d28              LDRB     r0,[r5,r4]
0001a4  2810              CMP      r0,#0x10
0001a6  d105              BNE      |L1.436|
;;;327    		
;;;328    		j++;
0001a8  f1040001          ADD      r0,r4,#1
0001ac  b284              UXTH     r4,r0
;;;329    		p[j] = 0x10;
0001ae  f04f0010          MOV      r0,#0x10
0001b2  5528              STRB     r0,[r5,r4]
                  |L1.436|
;;;330    	}
;;;331    	j++;
0001b4  f1040001          ADD      r0,r4,#1
0001b8  b284              UXTH     r4,r0
;;;332    	p[j++] = 0x10;
0001ba  f04f0210          MOV      r2,#0x10
0001be  4620              MOV      r0,r4
0001c0  f1040101          ADD      r1,r4,#1
0001c4  b28c              UXTH     r4,r1
0001c6  542a              STRB     r2,[r5,r0]
;;;333    	p[j++] = 0x03;
0001c8  f04f0203          MOV      r2,#3
0001cc  4620              MOV      r0,r4
0001ce  f1040101          ADD      r1,r4,#1
0001d2  b28c              UXTH     r4,r1
0001d4  542a              STRB     r2,[r5,r0]
;;;334    
;;;335    	if (MyInfo.TxFlag < 2)
0001d6  4891              LDR      r0,|L1.1052|
0001d8  7900              LDRB     r0,[r0,#4]  ; MyInfo
0001da  2802              CMP      r0,#2
0001dc  da05              BGE      |L1.490|
;;;336    		MyInfo.TxFlag++;
0001de  488f              LDR      r0,|L1.1052|
0001e0  7900              LDRB     r0,[r0,#4]  ; MyInfo
0001e2  f1000001          ADD      r0,r0,#1
0001e6  498d              LDR      r1,|L1.1052|
0001e8  7108              STRB     r0,[r1,#4]
                  |L1.490|
;;;337    
;;;338    	///等待100us
;;;339    	Delay(2000);	
0001ea  f44f60fa          MOV      r0,#0x7d0
0001ee  f7fffffe          BL       Delay
;;;340    
;;;341    #if (USART_TX_USE_DMA)	
;;;342    	///设置 DMA 长度并启动 DMA 发送
;;;343    	DMA_SetCurrDataCounter(DMA_Stream, j);
0001f2  4621              MOV      r1,r4
0001f4  488a              LDR      r0,|L1.1056|
0001f6  f7fffffe          BL       DMA_SetCurrDataCounter
;;;344    	/* DMA2_Stream7 enable */
;;;345      	DMA_Cmd(DMA_Stream, ENABLE);
0001fa  2101              MOVS     r1,#1
0001fc  4888              LDR      r0,|L1.1056|
0001fe  f7fffffe          BL       DMA_Cmd
;;;346    #else
;;;347    	for (i = 0; i < j; i++){
;;;348    
;;;349    		MyInfo.TxRdy = 0;
;;;350    		USART_SendData(COM_USART[COM1], p[i]);  //原来为 COM2
;;;351    		while (!MyInfo.TxRdy){}
;;;352    	}
;;;353    	///关闭发送控制
;;;354    	F205_DisableUsartTx();	
;;;355    #endif	
;;;356    }
000202  b007              ADD      sp,sp,#0x1c
000204  e8bd8ff0          POP      {r4-r11,pc}
;;;357    
                          ENDP

                  _SetUpgradeErr PROC
;;;734    
;;;735    void _SetUpgradeErr(uint8_t err)
000208  f04f0182          MOV      r1,#0x82
;;;736    {
;;;737    	_Info.cmd = CMD_ACK_UPGRADE_FIRMWARE;
00020c  4a7d              LDR      r2,|L1.1028|
00020e  71d1              STRB     r1,[r2,#7]
;;;738    	_Info.ack_len = 3;
000210  f04f0103          MOV      r1,#3
000214  7211              STRB     r1,[r2,#8]
;;;739    	_Info.ack_data[0] = USART_RxBuf[0];
000216  4980              LDR      r1,|L1.1048|
000218  7809              LDRB     r1,[r1,#0]  ; USART_RxBuf
00021a  7251              STRB     r1,[r2,#9]
;;;740    	_Info.ack_data[1] = USART_RxBuf[1];
00021c  497e              LDR      r1,|L1.1048|
00021e  784a              LDRB     r2,[r1,#1]  ; USART_RxBuf
000220  4978              LDR      r1,|L1.1028|
000222  728a              STRB     r2,[r1,#0xa]
;;;741    	_Info.ack_data[2] = err;
000224  72c8              STRB     r0,[r1,#0xb]
;;;742    }
000226  4770              BX       lr
;;;743    
                          ENDP

                  _AckRdyToUpgrade PROC
;;;744    void _AckRdyToUpgrade(uint8_t err)
000228  f04f0102          MOV      r1,#2
;;;745    {
;;;746    	_Info.ack_len = 2;
00022c  4a75              LDR      r2,|L1.1028|
00022e  7211              STRB     r1,[r2,#8]
;;;747    	_Info.ack_data[0] = _Info.cmd;
000230  4611              MOV      r1,r2
000232  79c9              LDRB     r1,[r1,#7]  ; _Info
000234  7251              STRB     r1,[r2,#9]
;;;748    	_Info.ack_data[1] = USART_RxBuf[0];
000236  4978              LDR      r1,|L1.1048|
000238  780a              LDRB     r2,[r1,#0]  ; USART_RxBuf
00023a  4972              LDR      r1,|L1.1028|
00023c  728a              STRB     r2,[r1,#0xa]
;;;749    	
;;;750    	_Info.cmd = CMD_ACK_MISC;
00023e  f04f0101          MOV      r1,#1
000242  4a70              LDR      r2,|L1.1028|
000244  71d1              STRB     r1,[r2,#7]
;;;751    }
000246  4770              BX       lr
;;;752    
                          ENDP

                  F205_RxDataHandler PROC
;;;162    ///8--EOF
;;;163    uint8_t F205_RxDataHandler(void)
000248  e92d5ffc          PUSH     {r2-r12,lr}
;;;164    {
;;;165    	__IO uint8_t err = 0, res, val, ret, OK;
00024c  f04f0700          MOV      r7,#0
;;;166    	uint8_t *p;
;;;167    	__IO uint32_t addr, data;
;;;168    
;;;169    	ret = 0;
000250  46bb              MOV      r11,r7
;;;170    	if (MyInfo.AckFlag != ACK_FLAG_NONE){
000252  4872              LDR      r0,|L1.1052|
000254  79c0              LDRB     r0,[r0,#7]  ; MyInfo
000256  28ff              CMP      r0,#0xff
000258  d072              BEQ      |L1.832|
;;;171    
;;;172    		if (MyInfo.AckFlag == ACK_FLAG_ERASE_APP_SECTORS){
00025a  4870              LDR      r0,|L1.1052|
00025c  79c0              LDRB     r0,[r0,#7]  ; MyInfo
00025e  280a              CMP      r0,#0xa
000260  d122              BNE      |L1.680|
;;;173    
;;;174    			err = F205_WriteProtection(APP_FLASH_SECTORS, 0);
000262  2100              MOVS     r1,#0
000264  2030              MOVS     r0,#0x30
000266  f7fffffe          BL       F205_WriteProtection
00026a  4607              MOV      r7,r0
;;;175    			if (err){///解除写保护错误
00026c  b12f              CBZ      r7,|L1.634|
;;;176    
;;;177    				_SetUpgradeErr(ACK_FLAG_PROTECT_ERR);
00026e  2005              MOVS     r0,#5
000270  f7fffffe          BL       _SetUpgradeErr
;;;178    				ret = ACK_FLAG_PROTECT_ERR;
000274  f04f0b05          MOV      r11,#5
000278  e016              B        |L1.680|
                  |L1.634|
;;;179    			}
;;;180    			else{
;;;181    
;;;182    				///Erase all app flash area for firm data: 
;;;183    				err = F205_EraseSectors(APPLICATION_START_SECTOR, APPLICATION_END_SECTOR);
00027a  2128              MOVS     r1,#0x28
00027c  2020              MOVS     r0,#0x20
00027e  f7fffffe          BL       F205_EraseSectors
000282  4607              MOV      r7,r0
;;;184    				if (err){///擦除错误
000284  b12f              CBZ      r7,|L1.658|
;;;185    
;;;186    					_SetUpgradeErr(ACK_FLAG_ERASE_ERR);
000286  2006              MOVS     r0,#6
000288  f7fffffe          BL       _SetUpgradeErr
;;;187    					ret = ACK_FLAG_ERASE_ERR;
00028c  f04f0b06          MOV      r11,#6
000290  e00a              B        |L1.680|
                  |L1.658|
;;;188    				}
;;;189    				else{
;;;190    					
;;;191    					InitHexVar(&HexInfo);
000292  485d              LDR      r0,|L1.1032|
000294  f7fffffe          BL       InitHexVar
;;;192    					MyInfo.WorkSts = WORK_STATUS_UPGRADE;
000298  f04f0001          MOV      r0,#1
00029c  495f              LDR      r1,|L1.1052|
00029e  7188              STRB     r0,[r1,#6]
;;;193    					_AckRdyToUpgrade(0);
0002a0  f04f0000          MOV      r0,#0
0002a4  f7fffffe          BL       _AckRdyToUpgrade
                  |L1.680|
;;;194    				}
;;;195    			}
;;;196    		}
;;;197    		if (MyInfo.AckFlag == ACK_FLAG_UPGRADE_OK){
0002a8  485c              LDR      r0,|L1.1052|
0002aa  79c0              LDRB     r0,[r0,#7]  ; MyInfo
0002ac  2800              CMP      r0,#0
                  |L1.686|
0002ae  d176              BNE      |L1.926|
;;;198    			
;;;199    			if (!err){
0002b0  2f00              CMP      r7,#0
0002b2  d1fc              BNE      |L1.686|
;;;200    
;;;201    				///check firm data address:
;;;202    				p = &USART_RxBuf[2];
0002b4  4d58              LDR      r5,|L1.1048|
0002b6  1cad              ADDS     r5,r5,#2
;;;203    				OK = 1;
0002b8  f04f0901          MOV      r9,#1
;;;204    				while (_Info.remain && OK){
0002bc  e07c              B        |L1.952|
                  |L1.702|
;;;205    
;;;206    					res = GetDataFromHexFile(&HexInfo, p, _Info.remain);
0002be  4851              LDR      r0,|L1.1028|
0002c0  f8b0208a          LDRH     r2,[r0,#0x8a]  ; _Info
0002c4  4629              MOV      r1,r5
0002c6  4850              LDR      r0,|L1.1032|
0002c8  f7fffffe          BL       GetDataFromHexFile
0002cc  4604              MOV      r4,r0
;;;207    					val = res & HEX_MASK;
0002ce  f00408c0          AND      r8,r4,#0xc0
;;;208    					switch (val){
0002d2  f1b80f00          CMP      r8,#0
0002d6  d011              BEQ      |L1.764|
0002d8  f1b80f40          CMP      r8,#0x40
0002dc  d006              BEQ      |L1.748|
0002de  f1b80f80          CMP      r8,#0x80
0002e2  d05d              BEQ      |L1.928|
0002e4  f1b80fc0          CMP      r8,#0xc0
0002e8  d162              BNE      |L1.944|
0002ea  e015              B        |L1.792|
                  |L1.748|
;;;209    
;;;210    						case HEX_ERR_DATA:///Error
;;;211    							_SetUpgradeErr(ACK_FLAG_DATA_ERR);
0002ec  2003              MOVS     r0,#3
0002ee  f7fffffe          BL       _SetUpgradeErr
;;;212    							ret = ACK_FLAG_DATA_ERR;
0002f2  f04f0b03          MOV      r11,#3
;;;213    							OK = 0;
0002f6  f04f0900          MOV      r9,#0
;;;214    							break;
0002fa  e05c              B        |L1.950|
                  |L1.764|
;;;215    						case HEX_ERR_NONE:
;;;216    							_Info.remain -= (res & 0x3f);
0002fc  4841              LDR      r0,|L1.1028|
0002fe  f8b0008a          LDRH     r0,[r0,#0x8a]  ; _Info
000302  f004013f          AND      r1,r4,#0x3f
000306  eba00001          SUB      r0,r0,r1
00030a  493e              LDR      r1,|L1.1028|
00030c  f8a1008a          STRH     r0,[r1,#0x8a]
;;;217    							p += (res & 0x3f);
000310  f004003f          AND      r0,r4,#0x3f
000314  4405              ADD      r5,r5,r0
;;;218    							break;
000316  e04e              B        |L1.950|
                  |L1.792|
;;;219    						case HEX_VALID_DATA:///valid data to be written to flash
;;;220    							///write to flash: Usart_RxBuf[3]开始
;;;221    							addr = HexInfo.seg_addr + HexInfo.addr;
000318  483b              LDR      r0,|L1.1032|
00031a  6900              LDR      r0,[r0,#0x10]  ; HexInfo
00031c  493a              LDR      r1,|L1.1032|
00031e  8849              LDRH     r1,[r1,#2]  ; HexInfo
000320  eb000601          ADD      r6,r0,r1
;;;222    							if ((addr < APPLICATION_ADDRESS) || (addr > USER_FLASH_END_ADDRESS)){
000324  483f              LDR      r0,|L1.1060|
000326  4286              CMP      r6,r0
000328  d302              BCC      |L1.816|
00032a  483f              LDR      r0,|L1.1064|
00032c  4286              CMP      r6,r0
00032e  d908              BLS      |L1.834|
                  |L1.816|
;;;223    							
;;;224    								_SetUpgradeErr(ACK_FLAG_DATA_ERR);
000330  2003              MOVS     r0,#3
000332  f7fffffe          BL       _SetUpgradeErr
;;;225    								ret = ACK_FLAG_DATA_ERR;
000336  f04f0b03          MOV      r11,#3
;;;226    								OK = 0;
00033a  f04f0900          MOV      r9,#0
00033e  e02d              B        |L1.924|
                  |L1.832|
000340  e05b              B        |L1.1018|
                  |L1.834|
;;;227    							}
;;;228    							else{
;;;229    
;;;230    								data = HexInfo.data[0] + ((uint16_t)HexInfo.data[1] << 8) + ((uint32_t)HexInfo.data[2] << 16) + ((uint32_t)HexInfo.data[3] << 24);
000342  4831              LDR      r0,|L1.1032|
000344  7a01              LDRB     r1,[r0,#8]  ; HexInfo
000346  7a40              LDRB     r0,[r0,#9]
000348  eb012100          ADD      r1,r1,r0,LSL #8
00034c  482e              LDR      r0,|L1.1032|
00034e  7a80              LDRB     r0,[r0,#0xa]
000350  eb014100          ADD      r1,r1,r0,LSL #16
000354  482c              LDR      r0,|L1.1032|
000356  7ac0              LDRB     r0,[r0,#0xb]
000358  eb016a00          ADD      r10,r1,r0,LSL #24
;;;231    								if (F205_ProgramFlash(addr, data)){///Error
00035c  4651              MOV      r1,r10
00035e  4630              MOV      r0,r6
000360  f7fffffe          BL       F205_ProgramFlash
000364  b138              CBZ      r0,|L1.886|
;;;232    
;;;233    									_SetUpgradeErr(ACK_FLAG_PROGRAM_FAIL);
000366  2007              MOVS     r0,#7
000368  f7fffffe          BL       _SetUpgradeErr
;;;234    									ret = ACK_FLAG_PROGRAM_FAIL;
00036c  f04f0b07          MOV      r11,#7
;;;235    									OK = 0;
000370  f04f0900          MOV      r9,#0
000374  e012              B        |L1.924|
                  |L1.886|
;;;236    								}
;;;237    								else{
;;;238    
;;;239    									p += (res & 0x3f);
000376  f004003f          AND      r0,r4,#0x3f
00037a  4405              ADD      r5,r5,r0
;;;240    									_Info.remain -= (res & 0x3f);
00037c  4821              LDR      r0,|L1.1028|
00037e  f8b0008a          LDRH     r0,[r0,#0x8a]  ; _Info
000382  f004013f          AND      r1,r4,#0x3f
000386  eba00001          SUB      r0,r0,r1
00038a  491e              LDR      r1,|L1.1028|
00038c  f8a1008a          STRH     r0,[r1,#0x8a]
;;;241    									HexInfo.addr += 4;
000390  481d              LDR      r0,|L1.1032|
000392  8840              LDRH     r0,[r0,#2]  ; HexInfo
000394  f1000004          ADD      r0,r0,#4
000398  491b              LDR      r1,|L1.1032|
00039a  8048              STRH     r0,[r1,#2]
                  |L1.924|
;;;242    								}
;;;243    							}
;;;244    							break;
00039c  e00b              B        |L1.950|
                  |L1.926|
00039e  e013              B        |L1.968|
                  |L1.928|
;;;245    						case HEX_ERR_EOF:///EOF
;;;246    							_SetUpgradeErr(ACK_FLAG_UPGRADE_OK);
0003a0  2000              MOVS     r0,#0
0003a2  f7fffffe          BL       _SetUpgradeErr
;;;247    							ret = ACK_FLAG_EOF;
0003a6  f04f0b08          MOV      r11,#8
;;;248    							OK = 0;
0003aa  f04f0900          MOV      r9,#0
;;;249    						default:
0003ae  bf00              NOP      
                  |L1.944|
;;;250    							OK = 0;
0003b0  f04f0900          MOV      r9,#0
;;;251    							break;
0003b4  bf00              NOP      
                  |L1.950|
0003b6  bf00              NOP                            ;214
                  |L1.952|
0003b8  4812              LDR      r0,|L1.1028|
0003ba  f8b0008a          LDRH     r0,[r0,#0x8a]         ;204  ; _Info
0003be  b118              CBZ      r0,|L1.968|
0003c0  f1b90f00          CMP      r9,#0                 ;204
0003c4  f47faf7b          BNE      |L1.702|
                  |L1.968|
;;;252    					}
;;;253    				}
;;;254    			}
;;;255    		}
;;;256    
;;;257    		/// ack :
;;;258    		F205_PrepareTxData(_Info.type, _Info.cmd, _Info.dst, _Info.src, _Info.ack_len, &(_Info.ack_data[0]));
0003c8  480e              LDR      r0,|L1.1028|
0003ca  3009              ADDS     r0,r0,#9
0003cc  490d              LDR      r1,|L1.1028|
0003ce  7a09              LDRB     r1,[r1,#8]  ; _Info
0003d0  f8dfc030          LDR      r12,|L1.1028|
0003d4  e9cd1000          STRD     r1,r0,[sp,#0]
0003d8  f89c3002          LDRB     r3,[r12,#2]  ; _Info
0003dc  f89c2004          LDRB     r2,[r12,#4]  ; _Info
0003e0  f89c1007          LDRB     r1,[r12,#7]  ; _Info
0003e4  f89c0006          LDRB     r0,[r12,#6]  ; _Info
0003e8  f7fffffe          BL       F205_PrepareTxData
;;;259    		/// 定时时间清0：
;;;260    		MyInfo.SysTm = 0;
0003ec  f04f0000          MOV      r0,#0
0003f0  490a              LDR      r1,|L1.1052|
0003f2  60c8              STR      r0,[r1,#0xc]  ; MyInfo
;;;261    		///清除发送标志：
;;;262    		MyInfo.AckFlag = ACK_FLAG_NONE;
0003f4  f04f00ff          MOV      r0,#0xff
0003f8  71c8              STRB     r0,[r1,#7]
                  |L1.1018|
;;;263    	}
;;;264    
;;;265    	return ret;
0003fa  4658              MOV      r0,r11
;;;266    }
0003fc  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.1024|
                          DCD      CRCTable
                  |L1.1028|
                          DCD      _Info
                  |L1.1032|
                          DCD      HexInfo
                  |L1.1036|
                          DCD      USART_InitStructure
                  |L1.1040|
                          DCD      USART_TxBuf
                  |L1.1044|
                          DCD      USART_BufStruct
                  |L1.1048|
                          DCD      USART_RxBuf
                  |L1.1052|
                          DCD      MyInfo
                  |L1.1056|
                          DCD      0x400264b8
                  |L1.1060|
                          DCD      0x08010000
                  |L1.1064|
                          DCD      0x0803ffff
                          ENDP

                  _ErrHandler PROC
;;;645    ///帧错误：暂不处理
;;;646    void _ErrHandler(uint8_t Err)
00042c  4770              BX       lr
;;;647    {
;;;648    	
;;;649    }
;;;650    
                          ENDP

                  _CheckProtectData PROC
;;;694    
;;;695    uint8_t _CheckProtectData(void)
00042e  48c1              LDR      r0,|L1.1844|
;;;696    {
;;;697    	uint32_t *p;
;;;698    	uint8_t en;
;;;699    
;;;700    	if (_Info.len != 15)  // 原来为12 + 2 modifiled by me 
000430  8800              LDRH     r0,[r0,#0]  ; _Info
000432  280f              CMP      r0,#0xf
000434  d001              BEQ      |L1.1082|
;;;701    		return 1;
000436  2001              MOVS     r0,#1
                  |L1.1080|
;;;702    
;;;703    	if (_Info.src != 0x80)
;;;704    		return 2;
;;;705    	
;;;706    	if ((USART_RxBuf[0] != 0xAA) && (USART_RxBuf[0] != 0x55))
;;;707    		return 3;
;;;708    
;;;709    	if (USART_RxBuf[6] != USART_RxBuf[0])
;;;710    		return 4;
;;;711    	
;;;712    #if defined USE_CPU_F205RC		
;;;713    	if (USART_RxBuf[1] > 0x3f)
;;;714    		return 5;
;;;715    #endif
;;;716    	
;;;717    	p = (uint32_t*)&(USART_RxBuf[2]);
;;;718    	if (USART_RxBuf[0] == 0xaa){///写保护
;;;719    	
;;;720    		if (*p != WRITE_PROTECTION_ENABLE_ID)
;;;721    			return 6;
;;;722    		en = 0x10;
;;;723    	}
;;;724    	else if (USART_RxBuf[0] == 0x55){
;;;725    
;;;726    		if (*p != WRITE_PROTECTION_DISABLE_ID)
;;;727    			return 7;
;;;728    		en = 0x00;
;;;729    	}
;;;730    
;;;731    	return en;
;;;732    }
000438  4770              BX       lr
                  |L1.1082|
00043a  48be              LDR      r0,|L1.1844|
00043c  7880              LDRB     r0,[r0,#2]            ;703  ; _Info
00043e  2880              CMP      r0,#0x80              ;703
000440  d001              BEQ      |L1.1094|
000442  2002              MOVS     r0,#2                 ;704
000444  e7f8              B        |L1.1080|
                  |L1.1094|
000446  48bc              LDR      r0,|L1.1848|
000448  7800              LDRB     r0,[r0,#0]            ;706  ; USART_RxBuf
00044a  28aa              CMP      r0,#0xaa              ;706
00044c  d005              BEQ      |L1.1114|
00044e  48ba              LDR      r0,|L1.1848|
000450  7800              LDRB     r0,[r0,#0]            ;706  ; USART_RxBuf
000452  2855              CMP      r0,#0x55              ;706
000454  d001              BEQ      |L1.1114|
000456  2003              MOVS     r0,#3                 ;707
000458  e7ee              B        |L1.1080|
                  |L1.1114|
00045a  48b7              LDR      r0,|L1.1848|
00045c  7980              LDRB     r0,[r0,#6]            ;709  ; USART_RxBuf
00045e  4bb6              LDR      r3,|L1.1848|
000460  781b              LDRB     r3,[r3,#0]            ;709  ; USART_RxBuf
000462  4298              CMP      r0,r3                 ;709
000464  d001              BEQ      |L1.1130|
000466  2004              MOVS     r0,#4                 ;710
000468  e7e6              B        |L1.1080|
                  |L1.1130|
00046a  48b3              LDR      r0,|L1.1848|
00046c  7840              LDRB     r0,[r0,#1]            ;713  ; USART_RxBuf
00046e  283f              CMP      r0,#0x3f              ;713
000470  dd01              BLE      |L1.1142|
000472  2005              MOVS     r0,#5                 ;714
000474  e7e0              B        |L1.1080|
                  |L1.1142|
000476  4ab0              LDR      r2,|L1.1848|
000478  1c92              ADDS     r2,r2,#2              ;717
00047a  1e90              SUBS     r0,r2,#2              ;718
00047c  7800              LDRB     r0,[r0,#0]            ;718  ; USART_RxBuf
00047e  28aa              CMP      r0,#0xaa              ;718
000480  d108              BNE      |L1.1172|
000482  4bae              LDR      r3,|L1.1852|
000484  6810              LDR      r0,[r2,#0]            ;720
000486  4298              CMP      r0,r3                 ;720
000488  d001              BEQ      |L1.1166|
00048a  2006              MOVS     r0,#6                 ;721
00048c  e7d4              B        |L1.1080|
                  |L1.1166|
00048e  f04f0110          MOV      r1,#0x10              ;722
000492  e00b              B        |L1.1196|
                  |L1.1172|
000494  48a8              LDR      r0,|L1.1848|
000496  7800              LDRB     r0,[r0,#0]            ;724  ; USART_RxBuf
000498  2855              CMP      r0,#0x55              ;724
00049a  d107              BNE      |L1.1196|
00049c  4ba8              LDR      r3,|L1.1856|
00049e  6810              LDR      r0,[r2,#0]            ;726
0004a0  4298              CMP      r0,r3                 ;726
0004a2  d001              BEQ      |L1.1192|
0004a4  2007              MOVS     r0,#7                 ;727
0004a6  e7c7              B        |L1.1080|
                  |L1.1192|
0004a8  f04f0100          MOV      r1,#0                 ;728
                  |L1.1196|
0004ac  4608              MOV      r0,r1                 ;731
0004ae  e7c3              B        |L1.1080|
;;;733    
                          ENDP

                  _CheckFirmData PROC
;;;652    
;;;653    uint8_t _CheckFirmData(void)
0004b0  48a1              LDR      r0,|L1.1848|
;;;654    {
;;;655    	uint16_t Index;///, crc, len;
;;;656    	
;;;657    	/*if ((USART_RxBuf[2] & 0x7f) != MyInfo.FirmType){
;;;658    	
;;;659    		MyInfo.AckFlag = ACK_FLAG_TYPE_MISMATCH;
;;;660    		return 1;
;;;661    	}*/
;;;662    	/*	
;;;663    	len = _Info.len - 5;
;;;664    	crc = Calc_CRCByte(USART_RxBuf, len - 2);
;;;665    	if (crc != (USART_RxBuf[len - 2] + ((uint16_t)USART_RxBuf[len - 1] << 8))){
;;;666    
;;;667    		MyInfo.AckFlag = ACK_FLAG_CRC_ERR;
;;;668    		return 1;
;;;669    	}	
;;;670    */
;;;671    	Index = USART_RxBuf[0] + ((uint16_t)USART_RxBuf[1] << 8);
0004b2  7800              LDRB     r0,[r0,#0]  ; USART_RxBuf
0004b4  4aa0              LDR      r2,|L1.1848|
0004b6  7852              LDRB     r2,[r2,#1]  ; USART_RxBuf
0004b8  eb002002          ADD      r0,r0,r2,LSL #8
0004bc  b281              UXTH     r1,r0
;;;672    
;;;673    	/*if ((Index & 0x7fff) == 0){
;;;674    
;;;675    		MyInfo.WorkSts = WORK_STATUS_UPGRADE;
;;;676    	}
;;;677    	else*/{
;;;678    
;;;679    		if (MyInfo.WorkSts != WORK_STATUS_UPGRADE){
0004be  48a1              LDR      r0,|L1.1860|
0004c0  7980              LDRB     r0,[r0,#6]  ; MyInfo
0004c2  2801              CMP      r0,#1
0004c4  d006              BEQ      |L1.1236|
;;;680    
;;;681    			MyInfo.AckFlag = ACK_FLAG_DATA_ERR;
0004c6  f04f0003          MOV      r0,#3
0004ca  4a9e              LDR      r2,|L1.1860|
0004cc  71d0              STRB     r0,[r2,#7]
;;;682    			return 1;
0004ce  f04f0001          MOV      r0,#1
                  |L1.1234|
;;;683    		}
;;;684    	}
;;;685    
;;;686    	
;;;687    	///_Info.remain = len - 7;
;;;688    	_Info.remain = _Info.len - 10;
;;;689    
;;;690    	MyInfo.FirmFrameIndex = Index;
;;;691    	MyInfo.AckFlag = ACK_FLAG_UPGRADE_OK;
;;;692    	return 0;
;;;693    }
0004d2  4770              BX       lr
                  |L1.1236|
0004d4  4897              LDR      r0,|L1.1844|
0004d6  8800              LDRH     r0,[r0,#0]            ;688  ; _Info
0004d8  f1a0000a          SUB      r0,r0,#0xa            ;688
0004dc  4a95              LDR      r2,|L1.1844|
0004de  f8a2008a          STRH     r0,[r2,#0x8a]         ;688
0004e2  4898              LDR      r0,|L1.1860|
0004e4  8281              STRH     r1,[r0,#0x14]         ;690
0004e6  f04f0000          MOV      r0,#0                 ;691
0004ea  4a96              LDR      r2,|L1.1860|
0004ec  71d0              STRB     r0,[r2,#7]            ;691
0004ee  bf00              NOP                            ;692
0004f0  e7ef              B        |L1.1234|
;;;694    
                          ENDP

                  _RxDataHandler PROC
;;;529    
;;;530    void _RxDataHandler(void)
0004f2  b510              PUSH     {r4,lr}
;;;531    {
;;;532    	uint8_t err, i;
;;;533    
;;;534    	switch (_Info.cmd){
0004f4  488f              LDR      r0,|L1.1844|
0004f6  79c0              LDRB     r0,[r0,#7]  ; _Info
0004f8  2811              CMP      r0,#0x11
0004fa  d00e              BEQ      |L1.1306|
0004fc  dc06              BGT      |L1.1292|
0004fe  2802              CMP      r0,#2
000500  d03b              BEQ      |L1.1402|
000502  2803              CMP      r0,#3
000504  d03a              BEQ      |L1.1404|
000506  2808              CMP      r0,#8
000508  d167              BNE      |L1.1498|
00050a  e024              B        |L1.1366|
                  |L1.1292|
00050c  2812              CMP      r0,#0x12
00050e  d019              BEQ      |L1.1348|
000510  2814              CMP      r0,#0x14
000512  d01f              BEQ      |L1.1364|
000514  28aa              CMP      r0,#0xaa
000516  d160              BNE      |L1.1498|
000518  e031              B        |L1.1406|
                  |L1.1306|
;;;535    
;;;536    		case CMD_UPGRADE_FIRMWARE:
;;;537    			
;;;538    			if ((USART_RxBuf[3] & 0x7f) != MyInfo.FirmType){
00051a  4887              LDR      r0,|L1.1848|
00051c  78c0              LDRB     r0,[r0,#3]  ; USART_RxBuf
00051e  f000007f          AND      r0,r0,#0x7f
000522  4988              LDR      r1,|L1.1860|
000524  7889              LDRB     r1,[r1,#2]  ; MyInfo
000526  4288              CMP      r0,r1
000528  d007              BEQ      |L1.1338|
;;;539    	
;;;540    				MyInfo.AckFlag = ACK_FLAG_TYPE_MISMATCH;
00052a  f04f0001          MOV      r0,#1
00052e  4985              LDR      r1,|L1.1860|
000530  71c8              STRB     r0,[r1,#7]
;;;541    				_AckRdyToUpgrade(MyInfo.AckFlag);
000532  79c8              LDRB     r0,[r1,#7]  ; MyInfo
000534  f7fffffe          BL       _AckRdyToUpgrade
                  |L1.1336|
;;;542    				return;
;;;543    			}
;;;544    			MyInfo.AckFlag = ACK_FLAG_ERASE_APP_SECTORS;
;;;545    			///MyInfo.DlyTm = BIOS_DELAY_TIME + BIOS_DELAY_TIME;
;;;546    			break;
;;;547    		
;;;548    		case CMD_UPGRADE_DATA_FRAME:
;;;549    			err = _CheckFirmData();	
;;;550    			_SetUpgradeErr(MyInfo.AckFlag);
;;;551    			break;
;;;552    
;;;553    		case CMD_INQUIRY_UPGRADE_STATUS: 
;;;554    			///升级后的应用程序应答查询命令，BIOS 不能应答
;;;555    			break;
;;;556    
;;;557    
;;;558    //Deleted 20140430 BIOS下不应答版本查询
;;;559    #if 0
;;;560    		case CMD_INQUIRY_VERSION:
;;;561    			///BIOS 应答
;;;562    			_Info.type = CMD_TYPE_FIRMWARE;
;;;563    			_Info.cmd = CMD_ACK_VERSION;
;;;564    			_Info.ack_len = 14;
;;;565    
;;;566    			_Info.ack_data[0] = FIRM_BIOS;
;;;567    			for (i = 0; i < 6; i++)
;;;568    				_Info.ack_data[1 + i] = ParamBuf[4 + i];
;;;569    #if 0
;;;570    			_Info.ack_data[0] = FIRM_BIOS;
;;;571    			_Info.ack_data[1] = F205_BIOS_MAIN_VER;
;;;572    			_Info.ack_data[2] = F205_BIOS_SUB_VER;
;;;573    			_Info.ack_data[3] = 0x20;
;;;574    			_Info.ack_data[4] = F205_BIOS_YEAR;
;;;575    			_Info.ack_data[5] = F205_BIOS_MONTH;
;;;576    			_Info.ack_data[6] = F205_BIOS_DATE;
;;;577    #endif		
;;;578    			///APPLICATION:
;;;579    			_Info.ack_data[7] = FIRM_APPLICATION;
;;;580    			for (i = 0; i < 6; i++)
;;;581    				_Info.ack_data[8 + i] = ParamBuf[20 + i];
;;;582    			MyInfo.AckFlag = ACK_FLAG_NORMAL;
;;;583    			///MyInfo.DlyTm = BIOS_DELAY_TIME;
;;;584    			break;
;;;585    #endif
;;;586    
;;;587    		case CMD_RESET:
;;;588    
;;;589    		        *(__IO uint32_t*)UPGRADE_FLAG_ADDRESS = UPGRADE_FLAG_DATA;
;;;590    
;;;591    #if 1
;;;592    			///不应答，直接复位
;;;593    			///写保护：
;;;594    			F205_WriteProtection(APP_FLASH_SECTORS, ENABLE);
;;;595    			///不允许写/擦除 FLASH:
;;;596    			FLASH_Lock();
;;;597    #endif
;;;598    
;;;599    			///关闭打狗程序：
;;;600    			SysTick->CTRL  = 0; /// Disable SysTick IRQ and SysTick Time
;;;601    			while (1)
;;;602    			{
;;;603    
;;;604    			}
;;;605    			//break;
;;;606    
;;;607    		case CMD_WRITE_INFO:
;;;608    			///不应答
;;;609    			break;
;;;610    
;;;611    		case CMD_READ_INFO:
;;;612    			///不应答
;;;613    			break;
;;;614    
;;;615    		case CMD_WRITE_PROTECTION:///写保护
;;;616    
;;;617    			err = _CheckProtectData();
;;;618    			if (err & 0x0f){
;;;619    				
;;;620    				_Info.type = CMD_TYPE_DEBUG;
;;;621    				_Info.cmd = CMD_ACK_WRITE_PROTECTION;
;;;622    				_Info.ack_len = 1;
;;;623    				_Info.ack_data[0] = err;
;;;624    				MyInfo.AckFlag = ACK_FLAG_WRONG_CMD;
;;;625    			}
;;;626    			else{
;;;627    
;;;628    				err = F205_WriteProtection(USART_RxBuf[1], (err>>4));
;;;629    				
;;;630    				_Info.type = CMD_TYPE_DEBUG;
;;;631    				_Info.cmd = CMD_ACK_WRITE_PROTECTION;
;;;632    				_Info.ack_len = 1;
;;;633    				_Info.ack_data[0] = err;
;;;634    				MyInfo.AckFlag = ACK_FLAG_NORMAL;
;;;635    			}
;;;636    			///MyInfo.DlyTm = BIOS_DELAY_TIME;
;;;637    
;;;638    			break;
;;;639    
;;;640    		default:
;;;641    			break;
;;;642    	}
;;;643    }
000538  bd10              POP      {r4,pc}
                  |L1.1338|
00053a  f04f000a          MOV      r0,#0xa               ;544
00053e  4981              LDR      r1,|L1.1860|
000540  71c8              STRB     r0,[r1,#7]            ;544
000542  e04b              B        |L1.1500|
                  |L1.1348|
000544  f7fffffe          BL       _CheckFirmData
000548  4604              MOV      r4,r0                 ;549
00054a  497e              LDR      r1,|L1.1860|
00054c  79c8              LDRB     r0,[r1,#7]            ;550  ; MyInfo
00054e  f7fffffe          BL       _SetUpgradeErr
000552  e043              B        |L1.1500|
                  |L1.1364|
000554  e042              B        |L1.1500|
                  |L1.1366|
000556  487c              LDR      r0,|L1.1864|
000558  497c              LDR      r1,|L1.1868|
00055a  6008              STR      r0,[r1,#0]            ;589
00055c  f04f0101          MOV      r1,#1                 ;594
000560  f04f0030          MOV      r0,#0x30              ;594
000564  f7fffffe          BL       F205_WriteProtection
000568  f7fffffe          BL       FLASH_Lock
00056c  f04f0000          MOV      r0,#0                 ;600
000570  f04f21e0          MOV      r1,#0xe000e000        ;600
000574  6108              STR      r0,[r1,#0x10]         ;600
000576  bf00              NOP                            ;601
                  |L1.1400|
000578  e7fe              B        |L1.1400|
                  |L1.1402|
00057a  e02f              B        |L1.1500|
                  |L1.1404|
00057c  e02e              B        |L1.1500|
                  |L1.1406|
00057e  f7fffffe          BL       _CheckProtectData
000582  4604              MOV      r4,r0                 ;617
000584  f0140f0f          TST      r4,#0xf               ;618
000588  d010              BEQ      |L1.1452|
00058a  f04f000a          MOV      r0,#0xa               ;620
00058e  4969              LDR      r1,|L1.1844|
000590  7188              STRB     r0,[r1,#6]            ;620
000592  f04f00ab          MOV      r0,#0xab              ;621
000596  71c8              STRB     r0,[r1,#7]            ;621
000598  f04f0001          MOV      r0,#1                 ;622
00059c  7208              STRB     r0,[r1,#8]            ;622
00059e  4608              MOV      r0,r1                 ;623
0005a0  7244              STRB     r4,[r0,#9]            ;623
0005a2  f04f0009          MOV      r0,#9                 ;624
0005a6  4967              LDR      r1,|L1.1860|
0005a8  71c8              STRB     r0,[r1,#7]            ;624
0005aa  e015              B        |L1.1496|
                  |L1.1452|
0005ac  1121              ASRS     r1,r4,#4              ;628
0005ae  4a62              LDR      r2,|L1.1848|
0005b0  7850              LDRB     r0,[r2,#1]            ;628  ; USART_RxBuf
0005b2  f7fffffe          BL       F205_WriteProtection
0005b6  4604              MOV      r4,r0                 ;628
0005b8  f04f000a          MOV      r0,#0xa               ;630
0005bc  495d              LDR      r1,|L1.1844|
0005be  7188              STRB     r0,[r1,#6]            ;630
0005c0  f04f00ab          MOV      r0,#0xab              ;631
0005c4  71c8              STRB     r0,[r1,#7]            ;631
0005c6  f04f0001          MOV      r0,#1                 ;632
0005ca  7208              STRB     r0,[r1,#8]            ;632
0005cc  4608              MOV      r0,r1                 ;633
0005ce  7244              STRB     r4,[r0,#9]            ;633
0005d0  f04f00cc          MOV      r0,#0xcc              ;634
0005d4  495b              LDR      r1,|L1.1860|
0005d6  71c8              STRB     r0,[r1,#7]            ;634
                  |L1.1496|
0005d8  e000              B        |L1.1500|
                  |L1.1498|
0005da  bf00              NOP                            ;641
                  |L1.1500|
0005dc  bf00              NOP                            ;546
0005de  bf00              NOP      
0005e0  e7aa              B        |L1.1336|
;;;644    
                          ENDP

                  _CheckRxFrame PROC
;;;495    
;;;496    uint8_t _CheckRxFrame(void)
0005e2  b5f0              PUSH     {r4-r7,lr}
;;;497    {
;;;498    	uint16_t crc, tmp, len;
;;;499    	uint8_t  *p;
;;;500    	
;;;501    	if (RxLen != _Info.len + 2)
0005e4  4853              LDR      r0,|L1.1844|
0005e6  8800              LDRH     r0,[r0,#0]  ; _Info
0005e8  1c80              ADDS     r0,r0,#2
0005ea  4959              LDR      r1,|L1.1872|
0005ec  8809              LDRH     r1,[r1,#0]  ; RxLen
0005ee  4288              CMP      r0,r1
0005f0  d001              BEQ      |L1.1526|
;;;502    		return 3;
0005f2  2003              MOVS     r0,#3
                  |L1.1524|
;;;503    	len = _Info.len;
;;;504    	_Info.len = (len >> 8) + (len << 8);
;;;505    	p = (uint8_t *)&(_Info.len);
;;;506    	crc = Calc_CRCByte(p, 8);
;;;507    	p = USART_RxBuf;
;;;508    	crc = Calc_CRCByte_Continue(p, len - 8, crc);
;;;509    	tmp = ((uint16_t)USART_RxBuf[len - 8] << 8) + USART_RxBuf[len - 8 + 1];
;;;510    	if (crc != tmp)
;;;511    		return 4;
;;;512    	_Info.len = len;
;;;513    	return 0;
;;;514    }
0005f4  bdf0              POP      {r4-r7,pc}
                  |L1.1526|
0005f6  484f              LDR      r0,|L1.1844|
0005f8  8804              LDRH     r4,[r0,#0]            ;503  ; _Info
0005fa  ea4f2024          ASR      r0,r4,#8              ;504
0005fe  eb002004          ADD      r0,r0,r4,LSL #8       ;504
000602  494c              LDR      r1,|L1.1844|
000604  8008              STRH     r0,[r1,#0]            ;504
000606  460f              MOV      r7,r1                 ;505
000608  f04f0108          MOV      r1,#8                 ;506
00060c  4638              MOV      r0,r7                 ;506
00060e  f7fffffe          BL       Calc_CRCByte
000612  4605              MOV      r5,r0                 ;506
000614  4f48              LDR      r7,|L1.1848|
000616  f1a40008          SUB      r0,r4,#8              ;508
00061a  b281              UXTH     r1,r0                 ;508
00061c  462a              MOV      r2,r5                 ;508
00061e  4638              MOV      r0,r7                 ;508
000620  f7fffffe          BL       Calc_CRCByte_Continue
000624  4605              MOV      r5,r0                 ;508
000626  f1a40007          SUB      r0,r4,#7              ;509
00062a  4639              MOV      r1,r7                 ;509
00062c  5c09              LDRB     r1,[r1,r0]            ;509
00062e  f1a40008          SUB      r0,r4,#8              ;509
000632  463a              MOV      r2,r7                 ;509
000634  5c10              LDRB     r0,[r2,r0]            ;509
000636  eb012000          ADD      r0,r1,r0,LSL #8       ;509
00063a  b286              UXTH     r6,r0                 ;509
00063c  42b5              CMP      r5,r6                 ;510
00063e  d001              BEQ      |L1.1604|
000640  2004              MOVS     r0,#4                 ;511
000642  e7d7              B        |L1.1524|
                  |L1.1604|
000644  483b              LDR      r0,|L1.1844|
000646  8004              STRH     r4,[r0,#0]            ;512
000648  2000              MOVS     r0,#0                 ;513
00064a  e7d3              B        |L1.1524|
;;;515    
                          ENDP

                  F205_UsartRxData PROC
;;;359    
;;;360    void F205_UsartRxData(void)
00064c  b570              PUSH     {r4-r6,lr}
;;;361    {
;;;362    	uint8_t ch, err;
;;;363    	uint16_t Index;
;;;364    
;;;365    	Index = USART_RxIndex;
00064e  4841              LDR      r0,|L1.1876|
000650  8806              LDRH     r6,[r0,#0]  ; USART_RxIndex
;;;366    	while (RxHandleIndex != Index ){
000652  e06a              B        |L1.1834|
                  |L1.1620|
;;;367    
;;;368      		ch = USART_tmpRxBuf[RxHandleIndex++];
000654  4840              LDR      r0,|L1.1880|
000656  8801              LDRH     r1,[r0,#0]  ; RxHandleIndex
000658  8800              LDRH     r0,[r0,#0]  ; RxHandleIndex
00065a  f1000001          ADD      r0,r0,#1
00065e  4a3e              LDR      r2,|L1.1880|
000660  8010              STRH     r0,[r2,#0]
000662  483e              LDR      r0,|L1.1884|
000664  5c44              LDRB     r4,[r0,r1]
;;;369    		RxHandleIndex &= USART_RX_BUF_MASK;
000666  4610              MOV      r0,r2
000668  8800              LDRH     r0,[r0,#0]  ; RxHandleIndex
00066a  f3c0000e          UBFX     r0,r0,#0,#15
00066e  4611              MOV      r1,r2
000670  8008              STRH     r0,[r1,#0]
;;;370    
;;;371    		if (StartF){
000672  483b              LDR      r0,|L1.1888|
000674  7800              LDRB     r0,[r0,#0]  ; StartF
000676  2800              CMP      r0,#0
000678  d043              BEQ      |L1.1794|
;;;372    
;;;373    			if (ch == 0x10){
00067a  2c10              CMP      r4,#0x10
00067c  d10e              BNE      |L1.1692|
;;;374    
;;;375    				if (!DLE)
00067e  4839              LDR      r0,|L1.1892|
000680  7800              LDRB     r0,[r0,#0]  ; DLE
000682  b918              CBNZ     r0,|L1.1676|
;;;376    					DLE = 0x10;
000684  4620              MOV      r0,r4
000686  4937              LDR      r1,|L1.1892|
000688  7008              STRB     r0,[r1,#0]
00068a  e04e              B        |L1.1834|
                  |L1.1676|
;;;377    				else{
;;;378    
;;;379    					_SetRxData(ch);
00068c  4620              MOV      r0,r4
00068e  f7fffffe          BL       _SetRxData
;;;380    					DLE = 0;
000692  f04f0000          MOV      r0,#0
000696  4933              LDR      r1,|L1.1892|
000698  7008              STRB     r0,[r1,#0]
00069a  e046              B        |L1.1834|
                  |L1.1692|
;;;381    				}
;;;382    			}
;;;383    			else if (DLE == 0x10){
00069c  4831              LDR      r0,|L1.1892|
00069e  7800              LDRB     r0,[r0,#0]  ; DLE
0006a0  2810              CMP      r0,#0x10
0006a2  d12a              BNE      |L1.1786|
;;;384    
;;;385    				switch (ch){
0006a4  2c02              CMP      r4,#2
0006a6  d002              BEQ      |L1.1710|
0006a8  2c03              CMP      r4,#3
0006aa  d11c              BNE      |L1.1766|
0006ac  e003              B        |L1.1718|
                  |L1.1710|
;;;386    
;;;387    					case 0x02:
;;;388    						_InitRx(1);
0006ae  2001              MOVS     r0,#1
0006b0  f7fffffe          BL       _InitRx
;;;389    						break;
0006b4  e01b              B        |L1.1774|
                  |L1.1718|
;;;390    
;;;391    					case 0x03:
;;;392    						//接收完整帧
;;;393    						err = _CheckRxFrame();
0006b6  f7fffffe          BL       _CheckRxFrame
0006ba  4605              MOV      r5,r0
;;;394    						if (!err){
0006bc  b965              CBNZ     r5,|L1.1752|
;;;395    
;;;396    							if (MyInfo.RxFlag < 2)
0006be  4821              LDR      r0,|L1.1860|
0006c0  78c0              LDRB     r0,[r0,#3]  ; MyInfo
0006c2  2802              CMP      r0,#2
0006c4  da05              BGE      |L1.1746|
;;;397    								MyInfo.RxFlag++;
0006c6  481f              LDR      r0,|L1.1860|
0006c8  78c0              LDRB     r0,[r0,#3]  ; MyInfo
0006ca  f1000001          ADD      r0,r0,#1
0006ce  491d              LDR      r1,|L1.1860|
0006d0  70c8              STRB     r0,[r1,#3]
                  |L1.1746|
;;;398    							_RxDataHandler();
0006d2  f7fffffe          BL       _RxDataHandler
0006d6  e002              B        |L1.1758|
                  |L1.1752|
;;;399    						}
;;;400    						else
;;;401    							_ErrHandler(err);
0006d8  4628              MOV      r0,r5
0006da  f7fffffe          BL       _ErrHandler
                  |L1.1758|
;;;402    
;;;403    						_InitRx(0);
0006de  2000              MOVS     r0,#0
0006e0  f7fffffe          BL       _InitRx
;;;404    						break;
0006e4  e003              B        |L1.1774|
                  |L1.1766|
;;;405    					default:
;;;406    						_SetRxData(ch);
0006e6  4620              MOV      r0,r4
0006e8  f7fffffe          BL       _SetRxData
;;;407    						break;
0006ec  bf00              NOP      
                  |L1.1774|
0006ee  bf00              NOP                            ;389
;;;408    				}
;;;409    					
;;;410    				DLE = 0;
0006f0  f04f0000          MOV      r0,#0
0006f4  491b              LDR      r1,|L1.1892|
0006f6  7008              STRB     r0,[r1,#0]
0006f8  e017              B        |L1.1834|
                  |L1.1786|
;;;411    			}
;;;412    			else
;;;413    				_SetRxData(ch);
0006fa  4620              MOV      r0,r4
0006fc  f7fffffe          BL       _SetRxData
000700  e013              B        |L1.1834|
                  |L1.1794|
;;;414    		}
;;;415    		else{
;;;416    			if (ch == 0x10)
000702  2c10              CMP      r4,#0x10
000704  d103              BNE      |L1.1806|
;;;417    				DLE = 0x10;
000706  4620              MOV      r0,r4
000708  4916              LDR      r1,|L1.1892|
00070a  7008              STRB     r0,[r1,#0]
00070c  e00d              B        |L1.1834|
                  |L1.1806|
;;;418    			else{
;;;419    				if ((ch == 0x02) && (DLE == 0x10))
00070e  2c02              CMP      r4,#2
000710  d107              BNE      |L1.1826|
000712  4814              LDR      r0,|L1.1892|
000714  7800              LDRB     r0,[r0,#0]  ; DLE
000716  2810              CMP      r0,#0x10
000718  d103              BNE      |L1.1826|
;;;420    					_InitRx(1);
00071a  2001              MOVS     r0,#1
00071c  f7fffffe          BL       _InitRx
000720  e003              B        |L1.1834|
                  |L1.1826|
;;;421    				else
;;;422    					DLE = 0;
000722  f04f0000          MOV      r0,#0
000726  490f              LDR      r1,|L1.1892|
000728  7008              STRB     r0,[r1,#0]
                  |L1.1834|
00072a  480b              LDR      r0,|L1.1880|
00072c  8800              LDRH     r0,[r0,#0]            ;366  ; RxHandleIndex
00072e  42b0              CMP      r0,r6                 ;366
000730  d190              BNE      |L1.1620|
;;;423    			}
;;;424    		}
;;;425    	}
;;;426    }
000732  bd70              POP      {r4-r6,pc}
;;;427    
                          ENDP

                  |L1.1844|
                          DCD      _Info
                  |L1.1848|
                          DCD      USART_RxBuf
                  |L1.1852|
                          DCD      0x76546231
                  |L1.1856|
                          DCD      0x54763162
                  |L1.1860|
                          DCD      MyInfo
                  |L1.1864|
                          DCD      0x73625593
                  |L1.1868|
                          DCD      0x20017ffc
                  |L1.1872|
                          DCD      RxLen
                  |L1.1876|
                          DCD      USART_RxIndex
                  |L1.1880|
                          DCD      RxHandleIndex
                  |L1.1884|
                          DCD      USART_tmpRxBuf
                  |L1.1888|
                          DCD      StartF
                  |L1.1892|
                          DCD      ||DLE||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  USART_InitStructure
                          %        16
                  USART_RxBuf
                          %        16384
                  USART_TxBuf
                          %        2048
                  USART_tmpRxBuf
                          %        32768
                  _Info
                          %        140
                  HexInfo
                          %        24

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  CRCTable
000000  00001021          DCW      0x0000,0x1021
000004  20423063          DCW      0x2042,0x3063
000008  408450a5          DCW      0x4084,0x50a5
00000c  60c670e7          DCW      0x60c6,0x70e7
000010  81089129          DCW      0x8108,0x9129
000014  a14ab16b          DCW      0xa14a,0xb16b
000018  c18cd1ad          DCW      0xc18c,0xd1ad
00001c  e1cef1ef          DCW      0xe1ce,0xf1ef
000020  12310210          DCW      0x1231,0x0210
000024  32732252          DCW      0x3273,0x2252
000028  52b54294          DCW      0x52b5,0x4294
00002c  72f762d6          DCW      0x72f7,0x62d6
000030  93398318          DCW      0x9339,0x8318
000034  b37ba35a          DCW      0xb37b,0xa35a
000038  d3bdc39c          DCW      0xd3bd,0xc39c
00003c  f3ffe3de          DCW      0xf3ff,0xe3de
000040  24623443          DCW      0x2462,0x3443
000044  04201401          DCW      0x0420,0x1401
000048  64e674c7          DCW      0x64e6,0x74c7
00004c  44a45485          DCW      0x44a4,0x5485
000050  a56ab54b          DCW      0xa56a,0xb54b
000054  85289509          DCW      0x8528,0x9509
000058  e5eef5cf          DCW      0xe5ee,0xf5cf
00005c  c5acd58d          DCW      0xc5ac,0xd58d
000060  36532672          DCW      0x3653,0x2672
000064  16110630          DCW      0x1611,0x0630
000068  76d766f6          DCW      0x76d7,0x66f6
00006c  569546b4          DCW      0x5695,0x46b4
000070  b75ba77a          DCW      0xb75b,0xa77a
000074  97198738          DCW      0x9719,0x8738
000078  f7dfe7fe          DCW      0xf7df,0xe7fe
00007c  d79dc7bc          DCW      0xd79d,0xc7bc
000080  48c458e5          DCW      0x48c4,0x58e5
000084  688678a7          DCW      0x6886,0x78a7
000088  08401861          DCW      0x0840,0x1861
00008c  28023823          DCW      0x2802,0x3823
000090  c9ccd9ed          DCW      0xc9cc,0xd9ed
000094  e98ef9af          DCW      0xe98e,0xf9af
000098  89489969          DCW      0x8948,0x9969
00009c  a90ab92b          DCW      0xa90a,0xb92b
0000a0  5af54ad4          DCW      0x5af5,0x4ad4
0000a4  7ab76a96          DCW      0x7ab7,0x6a96
0000a8  1a710a50          DCW      0x1a71,0x0a50
0000ac  3a332a12          DCW      0x3a33,0x2a12
0000b0  dbfdcbdc          DCW      0xdbfd,0xcbdc
0000b4  fbbfeb9e          DCW      0xfbbf,0xeb9e
0000b8  9b798b58          DCW      0x9b79,0x8b58
0000bc  bb3bab1a          DCW      0xbb3b,0xab1a
0000c0  6ca67c87          DCW      0x6ca6,0x7c87
0000c4  4ce45cc5          DCW      0x4ce4,0x5cc5
0000c8  2c223c03          DCW      0x2c22,0x3c03
0000cc  0c601c41          DCW      0x0c60,0x1c41
0000d0  edaefd8f          DCW      0xedae,0xfd8f
0000d4  cdecddcd          DCW      0xcdec,0xddcd
0000d8  ad2abd0b          DCW      0xad2a,0xbd0b
0000dc  8d689d49          DCW      0x8d68,0x9d49
0000e0  7e976eb6          DCW      0x7e97,0x6eb6
0000e4  5ed54ef4          DCW      0x5ed5,0x4ef4
0000e8  3e132e32          DCW      0x3e13,0x2e32
0000ec  1e510e70          DCW      0x1e51,0x0e70
0000f0  ff9fefbe          DCW      0xff9f,0xefbe
0000f4  dfddcffc          DCW      0xdfdd,0xcffc
0000f8  bf1baf3a          DCW      0xbf1b,0xaf3a
0000fc  9f598f78          DCW      0x9f59,0x8f78
000100  918881a9          DCW      0x9188,0x81a9
000104  b1caa1eb          DCW      0xb1ca,0xa1eb
000108  d10cc12d          DCW      0xd10c,0xc12d
00010c  f14ee16f          DCW      0xf14e,0xe16f
000110  108000a1          DCW      0x1080,0x00a1
000114  30c220e3          DCW      0x30c2,0x20e3
000118  50044025          DCW      0x5004,0x4025
00011c  70466067          DCW      0x7046,0x6067
000120  83b99398          DCW      0x83b9,0x9398
000124  a3fbb3da          DCW      0xa3fb,0xb3da
000128  c33dd31c          DCW      0xc33d,0xd31c
00012c  e37ff35e          DCW      0xe37f,0xf35e
000130  02b11290          DCW      0x02b1,0x1290
000134  22f332d2          DCW      0x22f3,0x32d2
000138  42355214          DCW      0x4235,0x5214
00013c  62777256          DCW      0x6277,0x7256
000140  b5eaa5cb          DCW      0xb5ea,0xa5cb
000144  95a88589          DCW      0x95a8,0x8589
000148  f56ee54f          DCW      0xf56e,0xe54f
00014c  d52cc50d          DCW      0xd52c,0xc50d
000150  34e224c3          DCW      0x34e2,0x24c3
000154  14a00481          DCW      0x14a0,0x0481
000158  74666447          DCW      0x7466,0x6447
00015c  54244405          DCW      0x5424,0x4405
000160  a7dbb7fa          DCW      0xa7db,0xb7fa
000164  879997b8          DCW      0x8799,0x97b8
000168  e75ff77e          DCW      0xe75f,0xf77e
00016c  c71dd73c          DCW      0xc71d,0xd73c
000170  26d336f2          DCW      0x26d3,0x36f2
000174  069116b0          DCW      0x0691,0x16b0
000178  66577676          DCW      0x6657,0x7676
00017c  46155634          DCW      0x4615,0x5634
000180  d94cc96d          DCW      0xd94c,0xc96d
000184  f90ee92f          DCW      0xf90e,0xe92f
000188  99c889e9          DCW      0x99c8,0x89e9
00018c  b98aa9ab          DCW      0xb98a,0xa9ab
000190  58444865          DCW      0x5844,0x4865
000194  78066827          DCW      0x7806,0x6827
000198  18c008e1          DCW      0x18c0,0x08e1
00019c  388228a3          DCW      0x3882,0x28a3
0001a0  cb7ddb5c          DCW      0xcb7d,0xdb5c
0001a4  eb3ffb1e          DCW      0xeb3f,0xfb1e
0001a8  8bf99bd8          DCW      0x8bf9,0x9bd8
0001ac  abbbbb9a          DCW      0xabbb,0xbb9a
0001b0  4a755a54          DCW      0x4a75,0x5a54
0001b4  6a377a16          DCW      0x6a37,0x7a16
0001b8  0af11ad0          DCW      0x0af1,0x1ad0
0001bc  2ab33a92          DCW      0x2ab3,0x3a92
0001c0  fd2eed0f          DCW      0xfd2e,0xed0f
0001c4  dd6ccd4d          DCW      0xdd6c,0xcd4d
0001c8  bdaaad8b          DCW      0xbdaa,0xad8b
0001cc  9de88dc9          DCW      0x9de8,0x8dc9
0001d0  7c266c07          DCW      0x7c26,0x6c07
0001d4  5c644c45          DCW      0x5c64,0x4c45
0001d8  3ca22c83          DCW      0x3ca2,0x2c83
0001dc  1ce00cc1          DCW      0x1ce0,0x0cc1
0001e0  ef1fff3e          DCW      0xef1f,0xff3e
0001e4  cf5ddf7c          DCW      0xcf5d,0xdf7c
0001e8  af9bbfba          DCW      0xaf9b,0xbfba
0001ec  8fd99ff8          DCW      0x8fd9,0x9ff8
0001f0  6e177e36          DCW      0x6e17,0x7e36
0001f4  4e555e74          DCW      0x4e55,0x5e74
0001f8  2e933eb2          DCW      0x2e93,0x3eb2
0001fc  0ed11ef0          DCW      0x0ed1,0x1ef0

                          AREA ||.data||, DATA, ALIGN=2

                  TxHandleIndex
000000  0000              DCW      0x0000
                  RxHandleIndex
000002  0000              DCW      0x0000
                  RxLen
000004  0000              DCW      0x0000
                  StartF
000006  00                DCB      0x00
                  ||DLE||
000007  00                DCB      0x00
                  CalcCheck
000008  0000              DCW      0x0000
                  CheckUpIndex
00000a  0000              DCB      0x00,0x00
                  USART_BufStruct
                          %        8
                  CheckUp
                          DCD      0x00000000

                          AREA ||i._InitRx||, COMGROUP=_InitRx, CODE, READONLY, ALIGN=2

                  _InitRx PROC
;;;516    
;;;517    __inline void _InitRx(uint8_t start)
000000  f04f0100          MOV      r1,#0
;;;518    {
;;;519    	DLE = 0;
000004  4a08              LDR      r2,|L18.40|
000006  7011              STRB     r1,[r2,#0]
;;;520    	RxLen = 0;
000008  4a08              LDR      r2,|L18.44|
00000a  8011              STRH     r1,[r2,#0]
;;;521    	_Info.len = 0;
00000c  4a08              LDR      r2,|L18.48|
00000e  8011              STRH     r1,[r2,#0]
;;;522    	CalcCheck = 0;
000010  4a08              LDR      r2,|L18.52|
000012  8011              STRH     r1,[r2,#0]
;;;523    	CheckUpIndex = 0;
000014  4a08              LDR      r2,|L18.56|
000016  7011              STRB     r1,[r2,#0]
;;;524    	StartF = 0;
000018  4a08              LDR      r2,|L18.60|
00001a  7011              STRB     r1,[r2,#0]
;;;525    
;;;526    	if (start)
00001c  b110              CBZ      r0,|L18.36|
;;;527    		StartF = 1;
00001e  f04f0101          MOV      r1,#1
000022  7011              STRB     r1,[r2,#0]
                  |L18.36|
;;;528    }
000024  4770              BX       lr
;;;529    
                          ENDP

000026  0000              DCW      0x0000
                  |L18.40|
                          DCD      ||DLE||
                  |L18.44|
                          DCD      RxLen
                  |L18.48|
                          DCD      _Info
                  |L18.52|
                          DCD      CalcCheck
                  |L18.56|
                          DCD      CheckUpIndex
                  |L18.60|
                          DCD      StartF

                          AREA ||i._SetRxData||, COMGROUP=_SetRxData, CODE, READONLY, ALIGN=2

                  _SetRxData PROC
;;;436    //收到的数据处理：从DataLen域开始存储数据
;;;437    __inline void _SetRxData(unsigned char Data)
000000  b510              PUSH     {r4,lr}
;;;438    {
000002  4604              MOV      r4,r0
;;;439    	switch (RxLen){
000004  4833              LDR      r0,|L25.212|
000006  8800              LDRH     r0,[r0,#0]  ; RxLen
000008  2808              CMP      r0,#8
00000a  d246              BCS      |L25.154|
00000c  e8dff000          TBB      [pc,r0]
000010  04091d20          DCB      0x04,0x09,0x1d,0x20
000014  28373f42          DCB      0x28,0x37,0x3f,0x42
;;;440    
;;;441    		case 0:
;;;442    			_Info.len = (uint16_t)Data << 8;
000018  ea4f2004          LSL      r0,r4,#8
00001c  492e              LDR      r1,|L25.216|
00001e  8008              STRH     r0,[r1,#0]
;;;443    			break;
000020  e042              B        |L25.168|
;;;444    		case 1:
;;;445    			_Info.len += Data;
000022  482d              LDR      r0,|L25.216|
000024  8800              LDRH     r0,[r0,#0]  ; _Info
000026  4420              ADD      r0,r0,r4
000028  492b              LDR      r1,|L25.216|
00002a  8008              STRH     r0,[r1,#0]
;;;446    			
;;;447    			//Modifiled by me 20140507 referenced to zg
;;;448    			//if ((_Info.len > (USART_RX_BUF_SIZE >> 1) + 8) || (_Info.len < 8))
;;;449    			if ((_Info.len > (USART_RX_BUF_SIZE >> 1) + 32) || (_Info.len < 8))
00002c  4608              MOV      r0,r1
00002e  8800              LDRH     r0,[r0,#0]  ; _Info
000030  f2440120          MOV      r1,#0x4020
000034  4288              CMP      r0,r1
000036  dc03              BGT      |L25.64|
000038  4827              LDR      r0,|L25.216|
00003a  8800              LDRH     r0,[r0,#0]  ; _Info
00003c  2808              CMP      r0,#8
00003e  da03              BGE      |L25.72|
                  |L25.64|
;;;450    			{
;;;451    				_InitRx(0);
000040  2000              MOVS     r0,#0
000042  f7fffffe          BL       _InitRx
                  |L25.70|
;;;452    				return;
;;;453    			}
;;;454    			break;
;;;455    		case 2:	///源地址：
;;;456    			_Info.src = Data;
;;;457    			break;
;;;458    		case 3:///src addr len			
;;;459    			if (Data != 0){
;;;460    				_InitRx(0);
;;;461    				return;
;;;462    			}
;;;463    			_Info.src_len = Data;
;;;464    			break;
;;;465    		case 4:	///目的地址：必须是本板地址或广播地址
;;;466    			if ((Data != MyInfo.BdAddr) && (Data != 0xff)){
;;;467    				_InitRx(0);
;;;468    				return;
;;;469    			}
;;;470    			_Info.dst = MyInfo.BdAddr;
;;;471    			break;
;;;472    		case 5:///Dst len
;;;473    			if (Data != 0){
;;;474    				_InitRx(0);
;;;475    				return;
;;;476    			}
;;;477    			_Info.dst_len = Data;
;;;478    			break;
;;;479    		case 6:///type
;;;480    			_Info.type = Data;
;;;481    			break;
;;;482    		case 7:
;;;483    			_Info.cmd = Data;
;;;484    			break;
;;;485    		default://赋值
;;;486    			USART_RxBuf[RxLen - 8] = Data;
;;;487    			break;
;;;488    	}
;;;489    
;;;490    	RxLen++;
;;;491    
;;;492    	if ((_Info.len > 0) && (RxLen > _Info.len + 2))//数据太多，帧还未结束：丢弃
;;;493    		_InitRx(0);
;;;494    }
000046  bd10              POP      {r4,pc}
                  |L25.72|
000048  e02e              B        |L25.168|
00004a  4823              LDR      r0,|L25.216|
00004c  7084              STRB     r4,[r0,#2]            ;456
00004e  e02b              B        |L25.168|
000050  b11c              CBZ      r4,|L25.90|
000052  2000              MOVS     r0,#0                 ;460
000054  f7fffffe          BL       _InitRx
000058  e7f5              B        |L25.70|
                  |L25.90|
00005a  481f              LDR      r0,|L25.216|
00005c  70c4              STRB     r4,[r0,#3]            ;463
00005e  e023              B        |L25.168|
000060  481e              LDR      r0,|L25.220|
000062  7800              LDRB     r0,[r0,#0]            ;466  ; MyInfo
000064  42a0              CMP      r0,r4                 ;466
000066  d005              BEQ      |L25.116|
000068  2cff              CMP      r4,#0xff              ;466
00006a  d003              BEQ      |L25.116|
00006c  2000              MOVS     r0,#0                 ;467
00006e  f7fffffe          BL       _InitRx
000072  e7e8              B        |L25.70|
                  |L25.116|
000074  4819              LDR      r0,|L25.220|
000076  7800              LDRB     r0,[r0,#0]            ;470  ; MyInfo
000078  4917              LDR      r1,|L25.216|
00007a  7108              STRB     r0,[r1,#4]            ;470
00007c  e014              B        |L25.168|
00007e  b11c              CBZ      r4,|L25.136|
000080  2000              MOVS     r0,#0                 ;474
000082  f7fffffe          BL       _InitRx
000086  e7de              B        |L25.70|
                  |L25.136|
000088  4813              LDR      r0,|L25.216|
00008a  7144              STRB     r4,[r0,#5]            ;477
00008c  e00c              B        |L25.168|
00008e  4812              LDR      r0,|L25.216|
000090  7184              STRB     r4,[r0,#6]            ;480
000092  e009              B        |L25.168|
000094  4810              LDR      r0,|L25.216|
000096  71c4              STRB     r4,[r0,#7]            ;483
000098  e006              B        |L25.168|
                  |L25.154|
00009a  480e              LDR      r0,|L25.212|
00009c  8800              LDRH     r0,[r0,#0]            ;486  ; RxLen
00009e  f1a00008          SUB      r0,r0,#8              ;486
0000a2  490f              LDR      r1,|L25.224|
0000a4  540c              STRB     r4,[r1,r0]            ;486
0000a6  bf00              NOP                            ;487
                  |L25.168|
0000a8  bf00              NOP                            ;443
0000aa  480a              LDR      r0,|L25.212|
0000ac  8800              LDRH     r0,[r0,#0]            ;490  ; RxLen
0000ae  f1000001          ADD      r0,r0,#1              ;490
0000b2  4908              LDR      r1,|L25.212|
0000b4  8008              STRH     r0,[r1,#0]            ;490
0000b6  4808              LDR      r0,|L25.216|
0000b8  8800              LDRH     r0,[r0,#0]            ;492  ; _Info
0000ba  2800              CMP      r0,#0                 ;492
0000bc  dd08              BLE      |L25.208|
0000be  4806              LDR      r0,|L25.216|
0000c0  8800              LDRH     r0,[r0,#0]            ;492  ; _Info
0000c2  1c80              ADDS     r0,r0,#2              ;492
0000c4  8809              LDRH     r1,[r1,#0]            ;492  ; RxLen
0000c6  4288              CMP      r0,r1                 ;492
0000c8  da02              BGE      |L25.208|
0000ca  2000              MOVS     r0,#0                 ;493
0000cc  f7fffffe          BL       _InitRx
                  |L25.208|
0000d0  bf00              NOP      
0000d2  e7b8              B        |L25.70|
;;;495    
                          ENDP

                  |L25.212|
                          DCD      RxLen
                  |L25.216|
                          DCD      _Info
                  |L25.220|
                          DCD      MyInfo
                  |L25.224|
                          DCD      USART_RxBuf
