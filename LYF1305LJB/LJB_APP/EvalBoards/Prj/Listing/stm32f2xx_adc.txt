; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Output\stm32f2xx_adc.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\Output\stm32f2xx_adc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\BSP -I..\BSP\UCOS-II -I..\BSP\STM32F2xx\inc -I..\BSP\CMSIS -I..\BSP\CMSIS\Device_Support -I..\BSP\UCOS-II -I..\..\uC-CPU -I..\..\uC-CPU\ARM-Cortex-M3 -I..\..\uC-LIB -I..\..\uC-LIB\Ports\ARM-Cortex-M3 -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3 -I..\App -I..\Prj -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DDEBUG -DLJB_CPU_MAIN -DUSE_CPU_F205RC --omf_browse=.\Output\stm32f2xx_adc.crf ..\BSP\STM32F2xx\src\stm32f2xx_adc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ADC_DeInit PROC
;;;205      */
;;;206    void ADC_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;207    {
;;;208      /* Enable all ADCs reset state */
;;;209      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, ENABLE);
000002  2101              MOVS     r1,#1
000004  0208              LSLS     r0,r1,#8
000006  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;210      
;;;211      /* Release all ADCs from reset state */
;;;212      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  f44f7080          MOV      r0,#0x100
000010  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;213    }
000014  bd10              POP      {r4,pc}
;;;214    
                          ENDP

                  ADC_Init PROC
;;;227      */
;;;228    void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
000016  b530              PUSH     {r4,r5,lr}
;;;229    {
000018  4602              MOV      r2,r0
;;;230      uint32_t tmpreg1 = 0;
00001a  f04f0000          MOV      r0,#0
;;;231      uint8_t tmpreg2 = 0;
00001e  4603              MOV      r3,r0
;;;232      /* Check the parameters */
;;;233      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;234      assert_param(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution)); 
;;;235      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
;;;236      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode)); 
;;;237      assert_param(IS_ADC_EXT_TRIG_EDGE(ADC_InitStruct->ADC_ExternalTrigConvEdge)); 
;;;238      assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));    
;;;239      assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
;;;240      assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
;;;241      
;;;242      /*---------------------------- ADCx CR1 Configuration -----------------*/
;;;243      /* Get the ADCx CR1 value */
;;;244      tmpreg1 = ADCx->CR1;
000020  6850              LDR      r0,[r2,#4]
;;;245      
;;;246      /* Clear RES and SCAN bits */
;;;247      tmpreg1 &= CR1_CLEAR_MASK;
000022  4cf8              LDR      r4,|L1.1028|
000024  ea000004          AND      r0,r0,r4
;;;248      
;;;249      /* Configure ADCx: scan conversion mode and resolution */
;;;250      /* Set SCAN bit according to ADC_ScanConvMode value */
;;;251      /* Set RES bit according to ADC_Resolution value */ 
;;;252      tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
000028  790d              LDRB     r5,[r1,#4]
00002a  680c              LDR      r4,[r1,#0]
00002c  ea442405          ORR      r4,r4,r5,LSL #8
000030  ea440000          ORR      r0,r4,r0
;;;253                                       ADC_InitStruct->ADC_Resolution);
;;;254      /* Write to ADCx CR1 */
;;;255      ADCx->CR1 = tmpreg1;
000034  6050              STR      r0,[r2,#4]
;;;256      /*---------------------------- ADCx CR2 Configuration -----------------*/
;;;257      /* Get the ADCx CR2 value */
;;;258      tmpreg1 = ADCx->CR2;
000036  6890              LDR      r0,[r2,#8]
;;;259      
;;;260      /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
;;;261      tmpreg1 &= CR2_CLEAR_MASK;
000038  4cf3              LDR      r4,|L1.1032|
00003a  ea000004          AND      r0,r0,r4
;;;262      
;;;263      /* Configure ADCx: external trigger event and edge, data alignment and 
;;;264         continuous conversion mode */
;;;265      /* Set ALIGN bit according to ADC_DataAlign value */
;;;266      /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
;;;267      /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
;;;268      /* Set CONT bit according to ADC_ContinuousConvMode value */
;;;269      tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
00003e  e9d15403          LDRD     r5,r4,[r1,#0xc]
000042  ea440405          ORR      r4,r4,r5
000046  688d              LDR      r5,[r1,#8]
000048  ea440405          ORR      r4,r4,r5
00004c  794d              LDRB     r5,[r1,#5]
00004e  ea440445          ORR      r4,r4,r5,LSL #1
000052  ea440000          ORR      r0,r4,r0
;;;270                            ADC_InitStruct->ADC_ExternalTrigConv | 
;;;271                            ADC_InitStruct->ADC_ExternalTrigConvEdge | \
;;;272                            ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
;;;273                            
;;;274      /* Write to ADCx CR2 */
;;;275      ADCx->CR2 = tmpreg1;
000056  6090              STR      r0,[r2,#8]
;;;276      /*---------------------------- ADCx SQR1 Configuration -----------------*/
;;;277      /* Get the ADCx SQR1 value */
;;;278      tmpreg1 = ADCx->SQR1;
000058  6ad0              LDR      r0,[r2,#0x2c]
;;;279      
;;;280      /* Clear L bits */
;;;281      tmpreg1 &= SQR1_L_RESET;
00005a  f4200070          BIC      r0,r0,#0xf00000
;;;282      
;;;283      /* Configure ADCx: regular channel sequence length */
;;;284      /* Set L bits according to ADC_NbrOfConversion value */
;;;285      tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
00005e  7d0c              LDRB     r4,[r1,#0x14]
000060  f1a40401          SUB      r4,r4,#1
000064  b2e4              UXTB     r4,r4
000066  ea440303          ORR      r3,r4,r3
;;;286      tmpreg1 |= ((uint32_t)tmpreg2 << 20);
00006a  ea405003          ORR      r0,r0,r3,LSL #20
;;;287      
;;;288      /* Write to ADCx SQR1 */
;;;289      ADCx->SQR1 = tmpreg1;
00006e  62d0              STR      r0,[r2,#0x2c]
;;;290    }
000070  bd30              POP      {r4,r5,pc}
;;;291    
                          ENDP

                  ADC_StructInit PROC
;;;302      */
;;;303    void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
000072  f04f0100          MOV      r1,#0
;;;304    {
;;;305      /* Initialize the ADC_Mode member */
;;;306      ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
000076  6001              STR      r1,[r0,#0]
;;;307    
;;;308      /* initialize the ADC_ScanConvMode member */
;;;309      ADC_InitStruct->ADC_ScanConvMode = DISABLE;
000078  7101              STRB     r1,[r0,#4]
;;;310    
;;;311      /* Initialize the ADC_ContinuousConvMode member */
;;;312      ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
00007a  7141              STRB     r1,[r0,#5]
;;;313    
;;;314      /* Initialize the ADC_ExternalTrigConvEdge member */
;;;315      ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
00007c  6081              STR      r1,[r0,#8]
;;;316    
;;;317      /* Initialize the ADC_ExternalTrigConv member */
;;;318      ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
00007e  60c1              STR      r1,[r0,#0xc]
;;;319    
;;;320      /* Initialize the ADC_DataAlign member */
;;;321      ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
000080  6101              STR      r1,[r0,#0x10]
;;;322    
;;;323      /* Initialize the ADC_NbrOfConversion member */
;;;324      ADC_InitStruct->ADC_NbrOfConversion = 1;
000082  f04f0101          MOV      r1,#1
000086  7501              STRB     r1,[r0,#0x14]
;;;325    }
000088  4770              BX       lr
;;;326    
                          ENDP

                  ADC_CommonInit PROC
;;;333      */
;;;334    void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
00008a  f04f0100          MOV      r1,#0
;;;335    {
;;;336      uint32_t tmpreg1 = 0;
;;;337      /* Check the parameters */
;;;338      assert_param(IS_ADC_MODE(ADC_CommonInitStruct->ADC_Mode));
;;;339      assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
;;;340      assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
;;;341      assert_param(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
;;;342      /*---------------------------- ADC CCR Configuration -----------------*/
;;;343      /* Get the ADC CCR value */
;;;344      tmpreg1 = ADC->CCR;
00008e  4adf              LDR      r2,|L1.1036|
000090  6811              LDR      r1,[r2,#0]
;;;345      
;;;346      /* Clear MULTI, DELAY, DMA and ADCPRE bits */
;;;347      tmpreg1 &= CR_CLEAR_MASK;
000092  4adf              LDR      r2,|L1.1040|
000094  ea010102          AND      r1,r1,r2
;;;348      
;;;349      /* Configure ADCx: Multi mode, Delay between two sampling time, ADC prescaler,
;;;350         and DMA access mode for multimode */
;;;351      /* Set MULTI bits according to ADC_Mode value */
;;;352      /* Set ADCPRE bits according to ADC_Prescaler value */
;;;353      /* Set DMA bits according to ADC_DMAAccessMode value */
;;;354      /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
;;;355      tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
000098  e9d02300          LDRD     r2,r3,[r0,#0]
00009c  ea420203          ORR      r2,r2,r3
0000a0  6883              LDR      r3,[r0,#8]
0000a2  ea420203          ORR      r2,r2,r3
0000a6  68c3              LDR      r3,[r0,#0xc]
0000a8  ea420203          ORR      r2,r2,r3
0000ac  ea420101          ORR      r1,r2,r1
;;;356                            ADC_CommonInitStruct->ADC_Prescaler | 
;;;357                            ADC_CommonInitStruct->ADC_DMAAccessMode | 
;;;358                            ADC_CommonInitStruct->ADC_TwoSamplingDelay);
;;;359                            
;;;360      /* Write to ADC CCR */
;;;361      ADC->CCR = tmpreg1;
0000b0  4ad8              LDR      r2,|L1.1044|
0000b2  f8c21304          STR      r1,[r2,#0x304]
;;;362    }
0000b6  4770              BX       lr
;;;363    
                          ENDP

                  ADC_CommonStructInit PROC
;;;369      */
;;;370    void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
0000b8  f04f0100          MOV      r1,#0
;;;371    {
;;;372      /* Initialize the ADC_Mode member */
;;;373      ADC_CommonInitStruct->ADC_Mode = ADC_Mode_Independent;
0000bc  6001              STR      r1,[r0,#0]
;;;374    
;;;375      /* initialize the ADC_Prescaler member */
;;;376      ADC_CommonInitStruct->ADC_Prescaler = ADC_Prescaler_Div2;
0000be  6041              STR      r1,[r0,#4]
;;;377    
;;;378      /* Initialize the ADC_DMAAccessMode member */
;;;379      ADC_CommonInitStruct->ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
0000c0  6081              STR      r1,[r0,#8]
;;;380    
;;;381      /* Initialize the ADC_TwoSamplingDelay member */
;;;382      ADC_CommonInitStruct->ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
0000c2  60c1              STR      r1,[r0,#0xc]
;;;383    }
0000c4  4770              BX       lr
;;;384    
                          ENDP

                  ADC_Cmd PROC
;;;391      */
;;;392    void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
0000c6  b121              CBZ      r1,|L1.210|
;;;393    {
;;;394      /* Check the parameters */
;;;395      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;396      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;397      if (NewState != DISABLE)
;;;398      {
;;;399        /* Set the ADON bit to wake up the ADC from power down mode */
;;;400        ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
0000c8  6882              LDR      r2,[r0,#8]
0000ca  f0420201          ORR      r2,r2,#1
0000ce  6082              STR      r2,[r0,#8]
0000d0  e003              B        |L1.218|
                  |L1.210|
;;;401      }
;;;402      else
;;;403      {
;;;404        /* Disable the selected ADC peripheral */
;;;405        ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
0000d2  6882              LDR      r2,[r0,#8]
0000d4  f0220201          BIC      r2,r2,#1
0000d8  6082              STR      r2,[r0,#8]
                  |L1.218|
;;;406      }
;;;407    }
0000da  4770              BX       lr
;;;408    /**
                          ENDP

                  ADC_AnalogWatchdogCmd PROC
;;;449      */
;;;450    void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
0000dc  460a              MOV      r2,r1
;;;451    {
;;;452      uint32_t tmpreg = 0;
0000de  f04f0100          MOV      r1,#0
;;;453      /* Check the parameters */
;;;454      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;455      assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
;;;456      
;;;457      /* Get the old register value */
;;;458      tmpreg = ADCx->CR1;
0000e2  6841              LDR      r1,[r0,#4]
;;;459      
;;;460      /* Clear AWDEN, JAWDEN and AWDSGL bits */
;;;461      tmpreg &= CR1_AWDMode_RESET;
0000e4  4bcc              LDR      r3,|L1.1048|
0000e6  ea010103          AND      r1,r1,r3
;;;462      
;;;463      /* Set the analog watchdog enable mode */
;;;464      tmpreg |= ADC_AnalogWatchdog;
0000ea  ea410102          ORR      r1,r1,r2
;;;465      
;;;466      /* Store the new register value */
;;;467      ADCx->CR1 = tmpreg;
0000ee  6041              STR      r1,[r0,#4]
;;;468    }
0000f0  4770              BX       lr
;;;469    
                          ENDP

                  ADC_AnalogWatchdogThresholdsConfig PROC
;;;478      */
;;;479    void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
0000f2  6241              STR      r1,[r0,#0x24]
;;;480                                            uint16_t LowThreshold)
;;;481    {
;;;482      /* Check the parameters */
;;;483      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;484      assert_param(IS_ADC_THRESHOLD(HighThreshold));
;;;485      assert_param(IS_ADC_THRESHOLD(LowThreshold));
;;;486      
;;;487      /* Set the ADCx high threshold */
;;;488      ADCx->HTR = HighThreshold;
;;;489      
;;;490      /* Set the ADCx low threshold */
;;;491      ADCx->LTR = LowThreshold;
0000f4  6282              STR      r2,[r0,#0x28]
;;;492    }
0000f6  4770              BX       lr
;;;493    
                          ENDP

                  ADC_AnalogWatchdogSingleChannelConfig PROC
;;;519      */
;;;520    void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
0000f8  460a              MOV      r2,r1
;;;521    {
;;;522      uint32_t tmpreg = 0;
0000fa  f04f0100          MOV      r1,#0
;;;523      /* Check the parameters */
;;;524      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;525      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;526      
;;;527      /* Get the old register value */
;;;528      tmpreg = ADCx->CR1;
0000fe  6841              LDR      r1,[r0,#4]
;;;529      
;;;530      /* Clear the Analog watchdog channel select bits */
;;;531      tmpreg &= CR1_AWDCH_RESET;
000100  f021011f          BIC      r1,r1,#0x1f
;;;532      
;;;533      /* Set the Analog watchdog channel */
;;;534      tmpreg |= ADC_Channel;
000104  ea410102          ORR      r1,r1,r2
;;;535      
;;;536      /* Store the new register value */
;;;537      ADCx->CR1 = tmpreg;
000108  6041              STR      r1,[r0,#4]
;;;538    }
00010a  4770              BX       lr
;;;539    /**
                          ENDP

                  ADC_TempSensorVrefintCmd PROC
;;;584      */
;;;585    void ADC_TempSensorVrefintCmd(FunctionalState NewState)                
00010c  b138              CBZ      r0,|L1.286|
;;;586    {
;;;587      /* Check the parameters */
;;;588      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;589      if (NewState != DISABLE)
;;;590      {
;;;591        /* Enable the temperature sensor and Vrefint channel*/
;;;592        ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
00010e  49bf              LDR      r1,|L1.1036|
000110  6809              LDR      r1,[r1,#0]
000112  f4410100          ORR      r1,r1,#0x800000
000116  4abf              LDR      r2,|L1.1044|
000118  f8c21304          STR      r1,[r2,#0x304]
00011c  e006              B        |L1.300|
                  |L1.286|
;;;593      }
;;;594      else
;;;595      {
;;;596        /* Disable the temperature sensor and Vrefint channel*/
;;;597        ADC->CCR &= (uint32_t)(~ADC_CCR_TSVREFE);
00011e  49bb              LDR      r1,|L1.1036|
000120  6809              LDR      r1,[r1,#0]
000122  f4210100          BIC      r1,r1,#0x800000
000126  4abb              LDR      r2,|L1.1044|
000128  f8c21304          STR      r1,[r2,#0x304]
                  |L1.300|
;;;598      }
;;;599    }
00012c  4770              BX       lr
;;;600    
                          ENDP

                  ADC_VBATCmd PROC
;;;606      */
;;;607    void ADC_VBATCmd(FunctionalState NewState)                             
00012e  b138              CBZ      r0,|L1.320|
;;;608    {
;;;609      /* Check the parameters */
;;;610      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;611      if (NewState != DISABLE)
;;;612      {
;;;613        /* Enable the VBAT channel*/
;;;614        ADC->CCR |= (uint32_t)ADC_CCR_VBATE;
000130  49b6              LDR      r1,|L1.1036|
000132  6809              LDR      r1,[r1,#0]
000134  f4410180          ORR      r1,r1,#0x400000
000138  4ab6              LDR      r2,|L1.1044|
00013a  f8c21304          STR      r1,[r2,#0x304]
00013e  e006              B        |L1.334|
                  |L1.320|
;;;615      }
;;;616      else
;;;617      {
;;;618        /* Disable the VBAT channel*/
;;;619        ADC->CCR &= (uint32_t)(~ADC_CCR_VBATE);
000140  49b2              LDR      r1,|L1.1036|
000142  6809              LDR      r1,[r1,#0]
000144  f4210180          BIC      r1,r1,#0x400000
000148  4ab2              LDR      r2,|L1.1044|
00014a  f8c21304          STR      r1,[r2,#0x304]
                  |L1.334|
;;;620      }
;;;621    }
00014e  4770              BX       lr
;;;622    
                          ENDP

                  ADC_RegularChannelConfig PROC
;;;707      */
;;;708    void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
000150  b5f0              PUSH     {r4-r7,lr}
;;;709    {
000152  4604              MOV      r4,r0
000154  460d              MOV      r5,r1
;;;710      uint32_t tmpreg1 = 0, tmpreg2 = 0;
000156  f04f0000          MOV      r0,#0
00015a  4601              MOV      r1,r0
;;;711      /* Check the parameters */
;;;712      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;713      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;714      assert_param(IS_ADC_REGULAR_RANK(Rank));
;;;715      assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;716      
;;;717      /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
;;;718      if (ADC_Channel > ADC_Channel_9)
00015c  2d09              CMP      r5,#9
00015e  dd14              BLE      |L1.394|
;;;719      {
;;;720        /* Get the old register value */
;;;721        tmpreg1 = ADCx->SMPR1;
000160  68e0              LDR      r0,[r4,#0xc]
;;;722        
;;;723        /* Calculate the mask to clear */
;;;724        tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
000162  f1a5060a          SUB      r6,r5,#0xa
000166  eb060746          ADD      r7,r6,r6,LSL #1
00016a  f04f0607          MOV      r6,#7
00016e  fa06f107          LSL      r1,r6,r7
;;;725        
;;;726        /* Clear the old sample time */
;;;727        tmpreg1 &= ~tmpreg2;
000172  ea200001          BIC      r0,r0,r1
;;;728        
;;;729        /* Calculate the mask to set */
;;;730        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
000176  f1a5060a          SUB      r6,r5,#0xa
00017a  eb060646          ADD      r6,r6,r6,LSL #1
00017e  fa03f106          LSL      r1,r3,r6
;;;731        
;;;732        /* Set the new sample time */
;;;733        tmpreg1 |= tmpreg2;
000182  ea400001          ORR      r0,r0,r1
;;;734        
;;;735        /* Store the new register value */
;;;736        ADCx->SMPR1 = tmpreg1;
000186  60e0              STR      r0,[r4,#0xc]
000188  e00f              B        |L1.426|
                  |L1.394|
;;;737      }
;;;738      else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;739      {
;;;740        /* Get the old register value */
;;;741        tmpreg1 = ADCx->SMPR2;
00018a  6920              LDR      r0,[r4,#0x10]
;;;742        
;;;743        /* Calculate the mask to clear */
;;;744        tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
00018c  eb050745          ADD      r7,r5,r5,LSL #1
000190  f04f0607          MOV      r6,#7
000194  fa06f107          LSL      r1,r6,r7
;;;745        
;;;746        /* Clear the old sample time */
;;;747        tmpreg1 &= ~tmpreg2;
000198  ea200001          BIC      r0,r0,r1
;;;748        
;;;749        /* Calculate the mask to set */
;;;750        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
00019c  eb050645          ADD      r6,r5,r5,LSL #1
0001a0  fa03f106          LSL      r1,r3,r6
;;;751        
;;;752        /* Set the new sample time */
;;;753        tmpreg1 |= tmpreg2;
0001a4  ea400001          ORR      r0,r0,r1
;;;754        
;;;755        /* Store the new register value */
;;;756        ADCx->SMPR2 = tmpreg1;
0001a8  6120              STR      r0,[r4,#0x10]
                  |L1.426|
;;;757      }
;;;758      /* For Rank 1 to 6 */
;;;759      if (Rank < 7)
0001aa  2a07              CMP      r2,#7
0001ac  da14              BGE      |L1.472|
;;;760      {
;;;761        /* Get the old register value */
;;;762        tmpreg1 = ADCx->SQR3;
0001ae  6b60              LDR      r0,[r4,#0x34]
;;;763        
;;;764        /* Calculate the mask to clear */
;;;765        tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
0001b0  f1a20601          SUB      r6,r2,#1
0001b4  eb060786          ADD      r7,r6,r6,LSL #2
0001b8  f04f061f          MOV      r6,#0x1f
0001bc  fa06f107          LSL      r1,r6,r7
;;;766        
;;;767        /* Clear the old SQx bits for the selected rank */
;;;768        tmpreg1 &= ~tmpreg2;
0001c0  ea200001          BIC      r0,r0,r1
;;;769        
;;;770        /* Calculate the mask to set */
;;;771        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
0001c4  f1a20601          SUB      r6,r2,#1
0001c8  eb060686          ADD      r6,r6,r6,LSL #2
0001cc  fa05f106          LSL      r1,r5,r6
;;;772        
;;;773        /* Set the SQx bits for the selected rank */
;;;774        tmpreg1 |= tmpreg2;
0001d0  ea400001          ORR      r0,r0,r1
;;;775        
;;;776        /* Store the new register value */
;;;777        ADCx->SQR3 = tmpreg1;
0001d4  6360              STR      r0,[r4,#0x34]
0001d6  e02a              B        |L1.558|
                  |L1.472|
;;;778      }
;;;779      /* For Rank 7 to 12 */
;;;780      else if (Rank < 13)
0001d8  2a0d              CMP      r2,#0xd
0001da  da14              BGE      |L1.518|
;;;781      {
;;;782        /* Get the old register value */
;;;783        tmpreg1 = ADCx->SQR2;
0001dc  6b20              LDR      r0,[r4,#0x30]
;;;784        
;;;785        /* Calculate the mask to clear */
;;;786        tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
0001de  f1a20607          SUB      r6,r2,#7
0001e2  eb060786          ADD      r7,r6,r6,LSL #2
0001e6  f04f061f          MOV      r6,#0x1f
0001ea  fa06f107          LSL      r1,r6,r7
;;;787        
;;;788        /* Clear the old SQx bits for the selected rank */
;;;789        tmpreg1 &= ~tmpreg2;
0001ee  ea200001          BIC      r0,r0,r1
;;;790        
;;;791        /* Calculate the mask to set */
;;;792        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
0001f2  f1a20607          SUB      r6,r2,#7
0001f6  eb060686          ADD      r6,r6,r6,LSL #2
0001fa  fa05f106          LSL      r1,r5,r6
;;;793        
;;;794        /* Set the SQx bits for the selected rank */
;;;795        tmpreg1 |= tmpreg2;
0001fe  ea400001          ORR      r0,r0,r1
;;;796        
;;;797        /* Store the new register value */
;;;798        ADCx->SQR2 = tmpreg1;
000202  6320              STR      r0,[r4,#0x30]
000204  e013              B        |L1.558|
                  |L1.518|
;;;799      }
;;;800      /* For Rank 13 to 16 */
;;;801      else
;;;802      {
;;;803        /* Get the old register value */
;;;804        tmpreg1 = ADCx->SQR1;
000206  6ae0              LDR      r0,[r4,#0x2c]
;;;805        
;;;806        /* Calculate the mask to clear */
;;;807        tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
000208  f1a2060d          SUB      r6,r2,#0xd
00020c  eb060786          ADD      r7,r6,r6,LSL #2
000210  f04f061f          MOV      r6,#0x1f
000214  fa06f107          LSL      r1,r6,r7
;;;808        
;;;809        /* Clear the old SQx bits for the selected rank */
;;;810        tmpreg1 &= ~tmpreg2;
000218  ea200001          BIC      r0,r0,r1
;;;811        
;;;812        /* Calculate the mask to set */
;;;813        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
00021c  f1a2060d          SUB      r6,r2,#0xd
000220  eb060686          ADD      r6,r6,r6,LSL #2
000224  fa05f106          LSL      r1,r5,r6
;;;814        
;;;815        /* Set the SQx bits for the selected rank */
;;;816        tmpreg1 |= tmpreg2;
000228  ea400001          ORR      r0,r0,r1
;;;817        
;;;818        /* Store the new register value */
;;;819        ADCx->SQR1 = tmpreg1;
00022c  62e0              STR      r0,[r4,#0x2c]
                  |L1.558|
;;;820      }
;;;821    }
00022e  bdf0              POP      {r4-r7,pc}
;;;822    
                          ENDP

                  ADC_SoftwareStartConv PROC
;;;827      */
;;;828    void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
000230  6881              LDR      r1,[r0,#8]
;;;829    {
;;;830      /* Check the parameters */
;;;831      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;832      
;;;833      /* Enable the selected ADC conversion for regular group */
;;;834      ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
000232  f0414180          ORR      r1,r1,#0x40000000
000236  6081              STR      r1,[r0,#8]
;;;835    }
000238  4770              BX       lr
;;;836    
                          ENDP

                  ADC_GetSoftwareStartConvStatus PROC
;;;841      */
;;;842    FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
00023a  4601              MOV      r1,r0
;;;843    {
;;;844      FlagStatus bitstatus = RESET;
00023c  f04f0000          MOV      r0,#0
;;;845      /* Check the parameters */
;;;846      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;847      
;;;848      /* Check the status of SWSTART bit */
;;;849      if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
000240  688a              LDR      r2,[r1,#8]
000242  f4120f80          TST      r2,#0x400000
000246  d002              BEQ      |L1.590|
;;;850      {
;;;851        /* SWSTART bit is set */
;;;852        bitstatus = SET;
000248  f04f0001          MOV      r0,#1
00024c  e001              B        |L1.594|
                  |L1.590|
;;;853      }
;;;854      else
;;;855      {
;;;856        /* SWSTART bit is reset */
;;;857        bitstatus = RESET;
00024e  f04f0000          MOV      r0,#0
                  |L1.594|
;;;858      }
;;;859      
;;;860      /* Return the SWSTART bit status */
;;;861      return  bitstatus;
;;;862    }
000252  4770              BX       lr
;;;863    
                          ENDP

                  ADC_EOCOnEachRegularChannelCmd PROC
;;;871      */
;;;872    void ADC_EOCOnEachRegularChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000254  b121              CBZ      r1,|L1.608|
;;;873    {
;;;874      /* Check the parameters */
;;;875      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;876      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;877      
;;;878      if (NewState != DISABLE)
;;;879      {
;;;880        /* Enable the selected ADC EOC rising on each regular channel conversion */
;;;881        ADCx->CR2 |= (uint32_t)ADC_CR2_EOCS;
000256  6882              LDR      r2,[r0,#8]
000258  f4426280          ORR      r2,r2,#0x400
00025c  6082              STR      r2,[r0,#8]
00025e  e003              B        |L1.616|
                  |L1.608|
;;;882      }
;;;883      else
;;;884      {
;;;885        /* Disable the selected ADC EOC rising on each regular channel conversion */
;;;886        ADCx->CR2 &= (uint32_t)(~ADC_CR2_EOCS);
000260  6882              LDR      r2,[r0,#8]
000262  f4226280          BIC      r2,r2,#0x400
000266  6082              STR      r2,[r0,#8]
                  |L1.616|
;;;887      }
;;;888    }
000268  4770              BX       lr
;;;889    
                          ENDP

                  ADC_ContinuousModeCmd PROC
;;;896      */
;;;897    void ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
00026a  b121              CBZ      r1,|L1.630|
;;;898    {
;;;899      /* Check the parameters */
;;;900      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;901      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;902      
;;;903      if (NewState != DISABLE)
;;;904      {
;;;905        /* Enable the selected ADC continuous conversion mode */
;;;906        ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;
00026c  6882              LDR      r2,[r0,#8]
00026e  f0420202          ORR      r2,r2,#2
000272  6082              STR      r2,[r0,#8]
000274  e003              B        |L1.638|
                  |L1.630|
;;;907      }
;;;908      else
;;;909      {
;;;910        /* Disable the selected ADC continuous conversion mode */
;;;911        ADCx->CR2 &= (uint32_t)(~ADC_CR2_CONT);
000276  6882              LDR      r2,[r0,#8]
000278  f0220202          BIC      r2,r2,#2
00027c  6082              STR      r2,[r0,#8]
                  |L1.638|
;;;912      }
;;;913    }
00027e  4770              BX       lr
;;;914    
                          ENDP

                  ADC_DiscModeChannelCountConfig PROC
;;;922      */
;;;923    void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
000280  b510              PUSH     {r4,lr}
;;;924    {
000282  460a              MOV      r2,r1
;;;925      uint32_t tmpreg1 = 0;
000284  f04f0100          MOV      r1,#0
;;;926      uint32_t tmpreg2 = 0;
000288  460b              MOV      r3,r1
;;;927      
;;;928      /* Check the parameters */
;;;929      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;930      assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
;;;931      
;;;932      /* Get the old register value */
;;;933      tmpreg1 = ADCx->CR1;
00028a  6841              LDR      r1,[r0,#4]
;;;934      
;;;935      /* Clear the old discontinuous mode channel count */
;;;936      tmpreg1 &= CR1_DISCNUM_RESET;
00028c  f4214160          BIC      r1,r1,#0xe000
;;;937      
;;;938      /* Set the discontinuous mode channel count */
;;;939      tmpreg2 = Number - 1;
000290  f1a20301          SUB      r3,r2,#1
;;;940      tmpreg1 |= tmpreg2 << 13;
000294  ea413143          ORR      r1,r1,r3,LSL #13
;;;941      
;;;942      /* Store the new register value */
;;;943      ADCx->CR1 = tmpreg1;
000298  6041              STR      r1,[r0,#4]
;;;944    }
00029a  bd10              POP      {r4,pc}
;;;945    
                          ENDP

                  ADC_DiscModeCmd PROC
;;;954      */
;;;955    void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
00029c  b121              CBZ      r1,|L1.680|
;;;956    {
;;;957      /* Check the parameters */
;;;958      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;959      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;960      
;;;961      if (NewState != DISABLE)
;;;962      {
;;;963        /* Enable the selected ADC regular discontinuous mode */
;;;964        ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;
00029e  6842              LDR      r2,[r0,#4]
0002a0  f4426200          ORR      r2,r2,#0x800
0002a4  6042              STR      r2,[r0,#4]
0002a6  e003              B        |L1.688|
                  |L1.680|
;;;965      }
;;;966      else
;;;967      {
;;;968        /* Disable the selected ADC regular discontinuous mode */
;;;969        ADCx->CR1 &= (uint32_t)(~ADC_CR1_DISCEN);
0002a8  6842              LDR      r2,[r0,#4]
0002aa  f4226200          BIC      r2,r2,#0x800
0002ae  6042              STR      r2,[r0,#4]
                  |L1.688|
;;;970      }
;;;971    }
0002b0  4770              BX       lr
;;;972    
                          ENDP

                  ADC_GetConversionValue PROC
;;;977      */
;;;978    uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
0002b2  4601              MOV      r1,r0
;;;979    {
;;;980      /* Check the parameters */
;;;981      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;982      
;;;983      /* Return the selected ADC conversion value */
;;;984      return (uint16_t) ADCx->DR;
0002b4  6cc8              LDR      r0,[r1,#0x4c]
0002b6  b280              UXTH     r0,r0
;;;985    }
0002b8  4770              BX       lr
;;;986    
                          ENDP

                  ADC_GetMultiModeConversionValue PROC
;;;998      */
;;;999    uint32_t ADC_GetMultiModeConversionValue(void)
0002ba  4858              LDR      r0,|L1.1052|
;;;1000   {
;;;1001     /* Return the multi mode conversion value */
;;;1002     return (*(__IO uint32_t *) CDR_ADDRESS);
0002bc  6800              LDR      r0,[r0,#0]
;;;1003   }
0002be  4770              BX       lr
;;;1004   /**
                          ENDP

                  ADC_DMACmd PROC
;;;1047     */
;;;1048   void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
0002c0  b121              CBZ      r1,|L1.716|
;;;1049   {
;;;1050     /* Check the parameters */
;;;1051     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1052     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1053     if (NewState != DISABLE)
;;;1054     {
;;;1055       /* Enable the selected ADC DMA request */
;;;1056       ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
0002c2  6882              LDR      r2,[r0,#8]
0002c4  f4427280          ORR      r2,r2,#0x100
0002c8  6082              STR      r2,[r0,#8]
0002ca  e003              B        |L1.724|
                  |L1.716|
;;;1057     }
;;;1058     else
;;;1059     {
;;;1060       /* Disable the selected ADC DMA request */
;;;1061       ADCx->CR2 &= (uint32_t)(~ADC_CR2_DMA);
0002cc  6882              LDR      r2,[r0,#8]
0002ce  f4227280          BIC      r2,r2,#0x100
0002d2  6082              STR      r2,[r0,#8]
                  |L1.724|
;;;1062     }
;;;1063   }
0002d4  4770              BX       lr
;;;1064   
                          ENDP

                  ADC_DMARequestAfterLastTransferCmd PROC
;;;1071     */
;;;1072   void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
0002d6  b121              CBZ      r1,|L1.738|
;;;1073   {
;;;1074     /* Check the parameters */
;;;1075     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1076     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1077     if (NewState != DISABLE)
;;;1078     {
;;;1079       /* Enable the selected ADC DMA request after last transfer */
;;;1080       ADCx->CR2 |= (uint32_t)ADC_CR2_DDS;
0002d8  6882              LDR      r2,[r0,#8]
0002da  f4427200          ORR      r2,r2,#0x200
0002de  6082              STR      r2,[r0,#8]
0002e0  e003              B        |L1.746|
                  |L1.738|
;;;1081     }
;;;1082     else
;;;1083     {
;;;1084       /* Disable the selected ADC DMA request after last transfer */
;;;1085       ADCx->CR2 &= (uint32_t)(~ADC_CR2_DDS);
0002e2  6882              LDR      r2,[r0,#8]
0002e4  f4227200          BIC      r2,r2,#0x200
0002e8  6082              STR      r2,[r0,#8]
                  |L1.746|
;;;1086     }
;;;1087   }
0002ea  4770              BX       lr
;;;1088   
                          ENDP

                  ADC_MultiModeDMARequestAfterLastTransferCmd PROC
;;;1098     */
;;;1099   void ADC_MultiModeDMARequestAfterLastTransferCmd(FunctionalState NewState)
0002ec  b138              CBZ      r0,|L1.766|
;;;1100   {
;;;1101     /* Check the parameters */
;;;1102     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1103     if (NewState != DISABLE)
;;;1104     {
;;;1105       /* Enable the selected ADC DMA request after last transfer */
;;;1106       ADC->CCR |= (uint32_t)ADC_CCR_DDS;
0002ee  4947              LDR      r1,|L1.1036|
0002f0  6809              LDR      r1,[r1,#0]
0002f2  f4415100          ORR      r1,r1,#0x2000
0002f6  4a47              LDR      r2,|L1.1044|
0002f8  f8c21304          STR      r1,[r2,#0x304]
0002fc  e006              B        |L1.780|
                  |L1.766|
;;;1107     }
;;;1108     else
;;;1109     {
;;;1110       /* Disable the selected ADC DMA request after last transfer */
;;;1111       ADC->CCR &= (uint32_t)(~ADC_CCR_DDS);
0002fe  4943              LDR      r1,|L1.1036|
000300  6809              LDR      r1,[r1,#0]
000302  f4215100          BIC      r1,r1,#0x2000
000306  4a43              LDR      r2,|L1.1044|
000308  f8c21304          STR      r1,[r2,#0x304]
                  |L1.780|
;;;1112     }
;;;1113   }
00030c  4770              BX       lr
;;;1114   /**
                          ENDP

                  ADC_InjectedChannelConfig PROC
;;;1185     */
;;;1186   void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
00030e  b5f0              PUSH     {r4-r7,lr}
;;;1187   {
000310  4604              MOV      r4,r0
000312  4615              MOV      r5,r2
;;;1188     uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
000314  f04f0000          MOV      r0,#0
000318  4602              MOV      r2,r0
00031a  4606              MOV      r6,r0
;;;1189     /* Check the parameters */
;;;1190     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1191     assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;1192     assert_param(IS_ADC_INJECTED_RANK(Rank));
;;;1193     assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;1194     /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
;;;1195     if (ADC_Channel > ADC_Channel_9)
00031c  2909              CMP      r1,#9
00031e  dd14              BLE      |L1.842|
;;;1196     {
;;;1197       /* Get the old register value */
;;;1198       tmpreg1 = ADCx->SMPR1;
000320  68e0              LDR      r0,[r4,#0xc]
;;;1199       /* Calculate the mask to clear */
;;;1200       tmpreg2 = SMPR1_SMP_SET << (3*(ADC_Channel - 10));
000322  f1a1070a          SUB      r7,r1,#0xa
000326  eb070c47          ADD      r12,r7,r7,LSL #1
00032a  f04f0707          MOV      r7,#7
00032e  fa07f20c          LSL      r2,r7,r12
;;;1201       /* Clear the old sample time */
;;;1202       tmpreg1 &= ~tmpreg2;
000332  ea200002          BIC      r0,r0,r2
;;;1203       /* Calculate the mask to set */
;;;1204       tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
000336  f1a1070a          SUB      r7,r1,#0xa
00033a  eb070747          ADD      r7,r7,r7,LSL #1
00033e  fa03f207          LSL      r2,r3,r7
;;;1205       /* Set the new sample time */
;;;1206       tmpreg1 |= tmpreg2;
000342  ea400002          ORR      r0,r0,r2
;;;1207       /* Store the new register value */
;;;1208       ADCx->SMPR1 = tmpreg1;
000346  60e0              STR      r0,[r4,#0xc]
000348  e00f              B        |L1.874|
                  |L1.842|
;;;1209     }
;;;1210     else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;1211     {
;;;1212       /* Get the old register value */
;;;1213       tmpreg1 = ADCx->SMPR2;
00034a  6920              LDR      r0,[r4,#0x10]
;;;1214       /* Calculate the mask to clear */
;;;1215       tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
00034c  eb010c41          ADD      r12,r1,r1,LSL #1
000350  f04f0707          MOV      r7,#7
000354  fa07f20c          LSL      r2,r7,r12
;;;1216       /* Clear the old sample time */
;;;1217       tmpreg1 &= ~tmpreg2;
000358  ea200002          BIC      r0,r0,r2
;;;1218       /* Calculate the mask to set */
;;;1219       tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
00035c  eb010741          ADD      r7,r1,r1,LSL #1
000360  fa03f207          LSL      r2,r3,r7
;;;1220       /* Set the new sample time */
;;;1221       tmpreg1 |= tmpreg2;
000364  ea400002          ORR      r0,r0,r2
;;;1222       /* Store the new register value */
;;;1223       ADCx->SMPR2 = tmpreg1;
000368  6120              STR      r0,[r4,#0x10]
                  |L1.874|
;;;1224     }
;;;1225     /* Rank configuration */
;;;1226     /* Get the old register value */
;;;1227     tmpreg1 = ADCx->JSQR;
00036a  6ba0              LDR      r0,[r4,#0x38]
;;;1228     /* Get JL value: Number = JL+1 */
;;;1229     tmpreg3 =  (tmpreg1 & JSQR_JL_SET)>> 20;
00036c  f3c05601          UBFX     r6,r0,#20,#2
;;;1230     /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
;;;1231     tmpreg2 = JSQR_JSQ_SET << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
000370  f1050703          ADD      r7,r5,#3
000374  f1060c01          ADD      r12,r6,#1
000378  eba7070c          SUB      r7,r7,r12
00037c  eb070c87          ADD      r12,r7,r7,LSL #2
000380  f04f071f          MOV      r7,#0x1f
000384  fa07f20c          LSL      r2,r7,r12
;;;1232     /* Clear the old JSQx bits for the selected rank */
;;;1233     tmpreg1 &= ~tmpreg2;
000388  ea200002          BIC      r0,r0,r2
;;;1234     /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
;;;1235     tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
00038c  f1050703          ADD      r7,r5,#3
000390  f1060c01          ADD      r12,r6,#1
000394  eba7070c          SUB      r7,r7,r12
000398  eb070787          ADD      r7,r7,r7,LSL #2
00039c  fa01f207          LSL      r2,r1,r7
;;;1236     /* Set the JSQx bits for the selected rank */
;;;1237     tmpreg1 |= tmpreg2;
0003a0  ea400002          ORR      r0,r0,r2
;;;1238     /* Store the new register value */
;;;1239     ADCx->JSQR = tmpreg1;
0003a4  63a0              STR      r0,[r4,#0x38]
;;;1240   }
0003a6  bdf0              POP      {r4-r7,pc}
;;;1241   
                          ENDP

                  ADC_InjectedSequencerLengthConfig PROC
;;;1248     */
;;;1249   void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
0003a8  b510              PUSH     {r4,lr}
;;;1250   {
0003aa  460a              MOV      r2,r1
;;;1251     uint32_t tmpreg1 = 0;
0003ac  f04f0100          MOV      r1,#0
;;;1252     uint32_t tmpreg2 = 0;
0003b0  460b              MOV      r3,r1
;;;1253     /* Check the parameters */
;;;1254     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1255     assert_param(IS_ADC_INJECTED_LENGTH(Length));
;;;1256     
;;;1257     /* Get the old register value */
;;;1258     tmpreg1 = ADCx->JSQR;
0003b2  6b81              LDR      r1,[r0,#0x38]
;;;1259     
;;;1260     /* Clear the old injected sequence length JL bits */
;;;1261     tmpreg1 &= JSQR_JL_RESET;
0003b4  f4211140          BIC      r1,r1,#0x300000
;;;1262     
;;;1263     /* Set the injected sequence length JL bits */
;;;1264     tmpreg2 = Length - 1; 
0003b8  f1a20301          SUB      r3,r2,#1
;;;1265     tmpreg1 |= tmpreg2 << 20;
0003bc  ea415103          ORR      r1,r1,r3,LSL #20
;;;1266     
;;;1267     /* Store the new register value */
;;;1268     ADCx->JSQR = tmpreg1;
0003c0  6381              STR      r1,[r0,#0x38]
;;;1269   }
0003c2  bd10              POP      {r4,pc}
;;;1270   
                          ENDP

                  ADC_SetInjectedOffset PROC
;;;1283     */
;;;1284   void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
0003c4  b510              PUSH     {r4,lr}
;;;1285   {
;;;1286       __IO uint32_t tmp = 0;
0003c6  f04f0300          MOV      r3,#0
;;;1287     /* Check the parameters */
;;;1288     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1289     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
;;;1290     assert_param(IS_ADC_OFFSET(Offset));
;;;1291     
;;;1292     tmp = (uint32_t)ADCx;
0003ca  4603              MOV      r3,r0
;;;1293     tmp += ADC_InjectedChannel;
0003cc  440b              ADD      r3,r3,r1
;;;1294     
;;;1295     /* Set the selected injected channel data offset */
;;;1296    *(__IO uint32_t *) tmp = (uint32_t)Offset;
0003ce  601a              STR      r2,[r3,#0]
;;;1297   }
0003d0  bd10              POP      {r4,pc}
;;;1298   
                          ENDP

                  ADC_ExternalTrigInjectedConvConfig PROC
;;;1321     */
;;;1322   void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
0003d2  460a              MOV      r2,r1
;;;1323   {
;;;1324     uint32_t tmpreg = 0;
0003d4  f04f0100          MOV      r1,#0
;;;1325     /* Check the parameters */
;;;1326     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1327     assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
;;;1328     
;;;1329     /* Get the old register value */
;;;1330     tmpreg = ADCx->CR2;
0003d8  6881              LDR      r1,[r0,#8]
;;;1331     
;;;1332     /* Clear the old external event selection for injected group */
;;;1333     tmpreg &= CR2_JEXTSEL_RESET;
0003da  f4212170          BIC      r1,r1,#0xf0000
;;;1334     
;;;1335     /* Set the external event selection for injected group */
;;;1336     tmpreg |= ADC_ExternalTrigInjecConv;
0003de  ea410102          ORR      r1,r1,r2
;;;1337     
;;;1338     /* Store the new register value */
;;;1339     ADCx->CR2 = tmpreg;
0003e2  6081              STR      r1,[r0,#8]
;;;1340   }
0003e4  4770              BX       lr
;;;1341   
                          ENDP

                  ADC_ExternalTrigInjectedConvEdgeConfig PROC
;;;1355     */
;;;1356   void ADC_ExternalTrigInjectedConvEdgeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConvEdge)
0003e6  460a              MOV      r2,r1
;;;1357   {
;;;1358     uint32_t tmpreg = 0;
0003e8  f04f0100          MOV      r1,#0
;;;1359     /* Check the parameters */
;;;1360     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1361     assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(ADC_ExternalTrigInjecConvEdge));
;;;1362     /* Get the old register value */
;;;1363     tmpreg = ADCx->CR2;
0003ec  6881              LDR      r1,[r0,#8]
;;;1364     /* Clear the old external trigger edge for injected group */
;;;1365     tmpreg &= CR2_JEXTEN_RESET;
0003ee  f4211140          BIC      r1,r1,#0x300000
;;;1366     /* Set the new external trigger edge for injected group */
;;;1367     tmpreg |= ADC_ExternalTrigInjecConvEdge;
0003f2  ea410102          ORR      r1,r1,r2
;;;1368     /* Store the new register value */
;;;1369     ADCx->CR2 = tmpreg;
0003f6  6081              STR      r1,[r0,#8]
;;;1370   }
0003f8  4770              BX       lr
;;;1371   
                          ENDP

                  ADC_SoftwareStartInjectedConv PROC
;;;1376     */
;;;1377   void ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx)
0003fa  6881              LDR      r1,[r0,#8]
;;;1378   {
;;;1379     /* Check the parameters */
;;;1380     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1381     /* Enable the selected ADC conversion for injected group */
;;;1382     ADCx->CR2 |= (uint32_t)ADC_CR2_JSWSTART;
0003fc  f4410180          ORR      r1,r1,#0x400000
000400  6081              STR      r1,[r0,#8]
;;;1383   }
000402  4770              BX       lr
                  |L1.1028|
                          DCD      0xfcfffeff
                  |L1.1032|
                          DCD      0xc0fff7fd
                  |L1.1036|
                          DCD      0x40012304
                  |L1.1040|
                          DCD      0xfffc30e0
                  |L1.1044|
                          DCD      0x40012000
                  |L1.1048|
                          DCD      0xff3ffdff
                  |L1.1052|
                          DCD      0x40012308
                          ENDP

                  ADC_GetSoftwareStartInjectedConvCmdStatus PROC
;;;1389     */
;;;1390   FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
000420  4601              MOV      r1,r0
;;;1391   {
;;;1392     FlagStatus bitstatus = RESET;
000422  f04f0000          MOV      r0,#0
;;;1393     /* Check the parameters */
;;;1394     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1395     
;;;1396     /* Check the status of JSWSTART bit */
;;;1397     if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
000426  688a              LDR      r2,[r1,#8]
000428  f4120f80          TST      r2,#0x400000
00042c  d002              BEQ      |L1.1076|
;;;1398     {
;;;1399       /* JSWSTART bit is set */
;;;1400       bitstatus = SET;
00042e  f04f0001          MOV      r0,#1
000432  e001              B        |L1.1080|
                  |L1.1076|
;;;1401     }
;;;1402     else
;;;1403     {
;;;1404       /* JSWSTART bit is reset */
;;;1405       bitstatus = RESET;
000434  f04f0000          MOV      r0,#0
                  |L1.1080|
;;;1406     }
;;;1407     /* Return the JSWSTART bit status */
;;;1408     return  bitstatus;
;;;1409   }
000438  4770              BX       lr
;;;1410   
                          ENDP

                  ADC_AutoInjectedConvCmd PROC
;;;1418     */
;;;1419   void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
00043a  b121              CBZ      r1,|L1.1094|
;;;1420   {
;;;1421     /* Check the parameters */
;;;1422     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1423     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1424     if (NewState != DISABLE)
;;;1425     {
;;;1426       /* Enable the selected ADC automatic injected group conversion */
;;;1427       ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;
00043c  6842              LDR      r2,[r0,#4]
00043e  f4426280          ORR      r2,r2,#0x400
000442  6042              STR      r2,[r0,#4]
000444  e003              B        |L1.1102|
                  |L1.1094|
;;;1428     }
;;;1429     else
;;;1430     {
;;;1431       /* Disable the selected ADC automatic injected group conversion */
;;;1432       ADCx->CR1 &= (uint32_t)(~ADC_CR1_JAUTO);
000446  6842              LDR      r2,[r0,#4]
000448  f4226280          BIC      r2,r2,#0x400
00044c  6042              STR      r2,[r0,#4]
                  |L1.1102|
;;;1433     }
;;;1434   }
00044e  4770              BX       lr
;;;1435   
                          ENDP

                  ADC_InjectedDiscModeCmd PROC
;;;1444     */
;;;1445   void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000450  b121              CBZ      r1,|L1.1116|
;;;1446   {
;;;1447     /* Check the parameters */
;;;1448     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1449     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1450     if (NewState != DISABLE)
;;;1451     {
;;;1452       /* Enable the selected ADC injected discontinuous mode */
;;;1453       ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;
000452  6842              LDR      r2,[r0,#4]
000454  f4425280          ORR      r2,r2,#0x1000
000458  6042              STR      r2,[r0,#4]
00045a  e003              B        |L1.1124|
                  |L1.1116|
;;;1454     }
;;;1455     else
;;;1456     {
;;;1457       /* Disable the selected ADC injected discontinuous mode */
;;;1458       ADCx->CR1 &= (uint32_t)(~ADC_CR1_JDISCEN);
00045c  6842              LDR      r2,[r0,#4]
00045e  f4225280          BIC      r2,r2,#0x1000
000462  6042              STR      r2,[r0,#4]
                  |L1.1124|
;;;1459     }
;;;1460   }
000464  4770              BX       lr
;;;1461   
                          ENDP

                  ADC_GetInjectedConversionValue PROC
;;;1472     */
;;;1473   uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
000466  4602              MOV      r2,r0
;;;1474   {
;;;1475     __IO uint32_t tmp = 0;
000468  f04f0300          MOV      r3,#0
;;;1476     
;;;1477     /* Check the parameters */
;;;1478     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1479     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
;;;1480   
;;;1481     tmp = (uint32_t)ADCx;
00046c  4613              MOV      r3,r2
;;;1482     tmp += ADC_InjectedChannel + JDR_OFFSET;
00046e  f1010028          ADD      r0,r1,#0x28
000472  4403              ADD      r3,r3,r0
;;;1483     
;;;1484     /* Returns the selected injected channel conversion data value */
;;;1485     return (uint16_t) (*(__IO uint32_t*)  tmp); 
000474  6818              LDR      r0,[r3,#0]
000476  b280              UXTH     r0,r0
;;;1486   }
000478  4770              BX       lr
;;;1487   /**
                          ENDP

                  ADC_ITConfig PROC
;;;1580     */
;;;1581   void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)  
00047a  b510              PUSH     {r4,lr}
;;;1582   {
00047c  460b              MOV      r3,r1
;;;1583     uint32_t itmask = 0;
00047e  f04f0100          MOV      r1,#0
;;;1584     /* Check the parameters */
;;;1585     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1586     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1587     assert_param(IS_ADC_IT(ADC_IT)); 
;;;1588   
;;;1589     /* Get the ADC IT index */
;;;1590     itmask = (uint8_t)ADC_IT;
000482  b2d9              UXTB     r1,r3
;;;1591     itmask = (uint32_t)0x01 << itmask;    
000484  f04f0401          MOV      r4,#1
000488  fa04f101          LSL      r1,r4,r1
;;;1592   
;;;1593     if (NewState != DISABLE)
00048c  b122              CBZ      r2,|L1.1176|
;;;1594     {
;;;1595       /* Enable the selected ADC interrupts */
;;;1596       ADCx->CR1 |= itmask;
00048e  6844              LDR      r4,[r0,#4]
000490  ea440401          ORR      r4,r4,r1
000494  6044              STR      r4,[r0,#4]
000496  e003              B        |L1.1184|
                  |L1.1176|
;;;1597     }
;;;1598     else
;;;1599     {
;;;1600       /* Disable the selected ADC interrupts */
;;;1601       ADCx->CR1 &= (~(uint32_t)itmask);
000498  6844              LDR      r4,[r0,#4]
00049a  ea240401          BIC      r4,r4,r1
00049e  6044              STR      r4,[r0,#4]
                  |L1.1184|
;;;1602     }
;;;1603   }
0004a0  bd10              POP      {r4,pc}
;;;1604   
                          ENDP

                  ADC_GetFlagStatus PROC
;;;1617     */
;;;1618   FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
0004a2  4602              MOV      r2,r0
;;;1619   {
;;;1620     FlagStatus bitstatus = RESET;
0004a4  f04f0000          MOV      r0,#0
;;;1621     /* Check the parameters */
;;;1622     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1623     assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
;;;1624   
;;;1625     /* Check the status of the specified ADC flag */
;;;1626     if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
0004a8  6813              LDR      r3,[r2,#0]
0004aa  420b              TST      r3,r1
0004ac  d002              BEQ      |L1.1204|
;;;1627     {
;;;1628       /* ADC_FLAG is set */
;;;1629       bitstatus = SET;
0004ae  f04f0001          MOV      r0,#1
0004b2  e001              B        |L1.1208|
                  |L1.1204|
;;;1630     }
;;;1631     else
;;;1632     {
;;;1633       /* ADC_FLAG is reset */
;;;1634       bitstatus = RESET;
0004b4  f04f0000          MOV      r0,#0
                  |L1.1208|
;;;1635     }
;;;1636     /* Return the ADC_FLAG status */
;;;1637     return  bitstatus;
;;;1638   }
0004b8  4770              BX       lr
;;;1639   
                          ENDP

                  ADC_ClearFlag PROC
;;;1652     */
;;;1653   void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
0004ba  ea6f0201          MVN      r2,r1
;;;1654   {
;;;1655     /* Check the parameters */
;;;1656     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1657     assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
;;;1658   
;;;1659     /* Clear the selected ADC flags */
;;;1660     ADCx->SR = ~(uint32_t)ADC_FLAG;
0004be  6002              STR      r2,[r0,#0]
;;;1661   }
0004c0  4770              BX       lr
;;;1662   
                          ENDP

                  ADC_GetITStatus PROC
;;;1673     */
;;;1674   ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
0004c2  b570              PUSH     {r4-r6,lr}
;;;1675   {
0004c4  4602              MOV      r2,r0
;;;1676     ITStatus bitstatus = RESET;
0004c6  f04f0000          MOV      r0,#0
;;;1677     uint32_t itmask = 0, enablestatus = 0;
0004ca  4603              MOV      r3,r0
0004cc  4604              MOV      r4,r0
;;;1678   
;;;1679     /* Check the parameters */
;;;1680     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1681     assert_param(IS_ADC_IT(ADC_IT));
;;;1682   
;;;1683     /* Get the ADC IT index */
;;;1684     itmask = ADC_IT >> 8;
0004ce  ea4f2321          ASR      r3,r1,#8
;;;1685   
;;;1686     /* Get the ADC_IT enable bit status */
;;;1687     enablestatus = (ADCx->CR1 & ((uint32_t)0x01 << (uint8_t)ADC_IT)) ;
0004d2  6855              LDR      r5,[r2,#4]
0004d4  f04f0601          MOV      r6,#1
0004d8  fa06f601          LSL      r6,r6,r1
0004dc  ea050406          AND      r4,r5,r6
;;;1688   
;;;1689     /* Check the status of the specified ADC interrupt */
;;;1690     if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
0004e0  6815              LDR      r5,[r2,#0]
0004e2  421d              TST      r5,r3
0004e4  d003              BEQ      |L1.1262|
0004e6  b114              CBZ      r4,|L1.1262|
;;;1691     {
;;;1692       /* ADC_IT is set */
;;;1693       bitstatus = SET;
0004e8  f04f0001          MOV      r0,#1
0004ec  e001              B        |L1.1266|
                  |L1.1262|
;;;1694     }
;;;1695     else
;;;1696     {
;;;1697       /* ADC_IT is reset */
;;;1698       bitstatus = RESET;
0004ee  f04f0000          MOV      r0,#0
                  |L1.1266|
;;;1699     }
;;;1700     /* Return the ADC_IT status */
;;;1701     return  bitstatus;
;;;1702   }
0004f2  bd70              POP      {r4-r6,pc}
;;;1703   
                          ENDP

                  ADC_ClearITPendingBit PROC
;;;1714     */
;;;1715   void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
0004f4  f04f0200          MOV      r2,#0
;;;1716   {
;;;1717     uint8_t itmask = 0;
;;;1718     /* Check the parameters */
;;;1719     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1720     assert_param(IS_ADC_IT(ADC_IT)); 
;;;1721     /* Get the ADC IT index */
;;;1722     itmask = (uint8_t)(ADC_IT >> 8);
0004f8  ea4f2221          ASR      r2,r1,#8
;;;1723     /* Clear the selected ADC interrupt pending bits */
;;;1724     ADCx->SR = ~(uint32_t)itmask;
0004fc  ea6f0302          MVN      r3,r2
000500  6003              STR      r3,[r0,#0]
;;;1725   }                    
000502  4770              BX       lr
;;;1726   /**
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\BSP\\STM32F2xx\\src\\stm32f2xx_adc.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f2xx_adc_c_e11a2ea2____REV16|
#line 112 "..\\BSP\\CMSIS\\core_cmInstr.h"
|__asm___15_stm32f2xx_adc_c_e11a2ea2____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f2xx_adc_c_e11a2ea2____REVSH|
#line 130
|__asm___15_stm32f2xx_adc_c_e11a2ea2____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
