; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Output\bsp_i2c.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\Output\bsp_i2c.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\BSP -I..\BSP\UCOS-II -I..\BSP\STM32F2xx\inc -I..\BSP\CMSIS -I..\BSP\CMSIS\Device_Support -I..\BSP\UCOS-II -I..\..\uC-CPU -I..\..\uC-CPU\ARM-Cortex-M3 -I..\..\uC-LIB -I..\..\uC-LIB\Ports\ARM-Cortex-M3 -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3 -I..\App -I..\Prj -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DDEBUG -DLJB_CPU_MAIN -DUSE_CPU_F205RC --omf_browse=.\Output\bsp_i2c.crf ..\BSP\bsp_i2c.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  sEE_I2C_DMA_RX_IRQHandler PROC
;;;1035     */
;;;1036   void sEE_I2C_DMA_RX_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1037   {
;;;1038   	/* Check if the DMA transfer is complete */
;;;1039   	if(DMA_GetFlagStatus(sEE_I2C_DMA_STREAM_RX, sEE_RX_DMA_FLAG_TCIF) != RESET)
000002  49fe              LDR      r1,|L1.1020|
000004  48fe              LDR      r0,|L1.1024|
000006  f7fffffe          BL       DMA_GetFlagStatus
00000a  b180              CBZ      r0,|L1.46|
;;;1040   	{      
;;;1041   		/*!< Send STOP Condition */
;;;1042   		I2C_GenerateSTOP(sEE_I2C, ENABLE);    
00000c  2101              MOVS     r1,#1
00000e  48fd              LDR      r0,|L1.1028|
000010  f7fffffe          BL       I2C_GenerateSTOP
;;;1043       
;;;1044   		/* Disable the DMA Rx Stream and Clear TC Flag */  
;;;1045   		DMA_Cmd(sEE_I2C_DMA_STREAM_RX, DISABLE);
000014  2100              MOVS     r1,#0
000016  48fa              LDR      r0,|L1.1024|
000018  f7fffffe          BL       DMA_Cmd
;;;1046   		DMA_ClearFlag(sEE_I2C_DMA_STREAM_RX, sEE_RX_DMA_FLAG_TCIF);
00001c  49f7              LDR      r1,|L1.1020|
00001e  48f8              LDR      r0,|L1.1024|
000020  f7fffffe          BL       DMA_ClearFlag
;;;1047       
;;;1048   		/* Reset the variable holding the number of data to be read */
;;;1049   		*sEEDataReadPointer = 0;
000024  f04f0000          MOV      r0,#0
000028  49f7              LDR      r1,|L1.1032|
00002a  6809              LDR      r1,[r1,#0]  ; sEEDataReadPointer
00002c  8008              STRH     r0,[r1,#0]
                  |L1.46|
;;;1050   	}
;;;1051   }
00002e  bd10              POP      {r4,pc}
;;;1052   
                          ENDP

                  sEE_TIMEOUT_UserCallback PROC
;;;807      */
;;;808    uint32_t sEE_TIMEOUT_UserCallback(void)
000030  2000              MOVS     r0,#0
;;;809    {
;;;810    	/* Block communication and all processes */
;;;811    	///while (1)
;;;812    	{   
;;;813    	}
;;;814    	return 0;
;;;815    }
000032  4770              BX       lr
;;;816    
                          ENDP

                  sEE_I2C_DMA_TX_IRQHandler PROC
;;;1006     */
;;;1007   void sEE_I2C_DMA_TX_IRQHandler(void)
000034  b510              PUSH     {r4,lr}
;;;1008   {
;;;1009   	/* Check if the DMA transfer is complete */
;;;1010   	if(DMA_GetFlagStatus(sEE_I2C_DMA_STREAM_TX, sEE_TX_DMA_FLAG_TCIF) != RESET)
000036  49f5              LDR      r1,|L1.1036|
000038  48f1              LDR      r0,|L1.1024|
00003a  3090              ADDS     r0,r0,#0x90
00003c  f7fffffe          BL       DMA_GetFlagStatus
000040  b330              CBZ      r0,|L1.144|
;;;1011   	{  
;;;1012   		/* Disable the DMA Tx Stream and Clear TC flag */  
;;;1013   		DMA_Cmd(sEE_I2C_DMA_STREAM_TX, DISABLE);
000042  2100              MOVS     r1,#0
000044  48ee              LDR      r0,|L1.1024|
000046  3090              ADDS     r0,r0,#0x90
000048  f7fffffe          BL       DMA_Cmd
;;;1014   		DMA_ClearFlag(sEE_I2C_DMA_STREAM_TX, sEE_TX_DMA_FLAG_TCIF);
00004c  49ef              LDR      r1,|L1.1036|
00004e  48ec              LDR      r0,|L1.1024|
000050  3090              ADDS     r0,r0,#0x90
000052  f7fffffe          BL       DMA_ClearFlag
;;;1015   
;;;1016   		/*!< Wait till all data have been physically transferred on the bus */
;;;1017   		sEETimeout = sEE_LONG_TIMEOUT;
000056  f44f4020          MOV      r0,#0xa000
00005a  49ed              LDR      r1,|L1.1040|
00005c  6008              STR      r0,[r1,#0]  ; sEETimeout
;;;1018   		while(!I2C_GetFlagStatus(sEE_I2C, I2C_FLAG_BTF))
00005e  e007              B        |L1.112|
                  |L1.96|
;;;1019   		{
;;;1020   			if((sEETimeout--) == 0) sEE_TIMEOUT_UserCallback();
000060  49eb              LDR      r1,|L1.1040|
000062  6808              LDR      r0,[r1,#0]  ; sEETimeout
000064  1e41              SUBS     r1,r0,#1
000066  4aea              LDR      r2,|L1.1040|
000068  6011              STR      r1,[r2,#0]  ; sEETimeout
00006a  b908              CBNZ     r0,|L1.112|
00006c  f7fffffe          BL       sEE_TIMEOUT_UserCallback
                  |L1.112|
000070  49e2              LDR      r1,|L1.1020|
000072  391c              SUBS     r1,r1,#0x1c           ;1018
000074  48e3              LDR      r0,|L1.1028|
000076  f7fffffe          BL       I2C_GetFlagStatus
00007a  2800              CMP      r0,#0                 ;1018
00007c  d0f0              BEQ      |L1.96|
;;;1021   		}
;;;1022       
;;;1023   		/*!< Send STOP condition */
;;;1024   		I2C_GenerateSTOP(sEE_I2C, ENABLE);
00007e  2101              MOVS     r1,#1
000080  48e0              LDR      r0,|L1.1028|
000082  f7fffffe          BL       I2C_GenerateSTOP
;;;1025       
;;;1026   		/* Reset the variable holding the number of data to be written */
;;;1027   		*sEEDataWritePointer = 0;  
000086  f04f0000          MOV      r0,#0
00008a  49e2              LDR      r1,|L1.1044|
00008c  6809              LDR      r1,[r1,#0]  ; sEEDataWritePointer
00008e  8008              STRH     r0,[r1,#0]
                  |L1.144|
;;;1028   	}
;;;1029   }
000090  bd10              POP      {r4,pc}
;;;1030   
                          ENDP

                  sEE_LowLevel_Init PROC
;;;859      */
;;;860    void sEE_LowLevel_Init(void)
000092  b51c              PUSH     {r2-r4,lr}
;;;861    {
;;;862    	GPIO_InitTypeDef  GPIO_InitStructure; 
;;;863       
;;;864    	/*!< sEE_I2C Periph clock enable */
;;;865    	RCC_APB1PeriphClockCmd(sEE_I2C_CLK, ENABLE);
000094  2101              MOVS     r1,#1
000096  0548              LSLS     r0,r1,#21
000098  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;866      
;;;867    	/*!< sEE_I2C_SCL_GPIO_CLK and sEE_I2C_SDA_GPIO_CLK Periph clock enable */
;;;868    	RCC_AHB1PeriphClockCmd(sEE_I2C_SCL_GPIO_CLK | sEE_I2C_SDA_GPIO_CLK, ENABLE);
00009c  2101              MOVS     r1,#1
00009e  2002              MOVS     r0,#2
0000a0  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;869    
;;;870    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
0000a4  2101              MOVS     r1,#1
0000a6  0388              LSLS     r0,r1,#14
0000a8  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;871      
;;;872    	/* Reset sEE_I2C IP */
;;;873    	RCC_APB1PeriphResetCmd(sEE_I2C_CLK, ENABLE);
0000ac  2101              MOVS     r1,#1
0000ae  0548              LSLS     r0,r1,#21
0000b0  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;874      
;;;875    	/* Release reset signal of sEE_I2C IP */
;;;876    	RCC_APB1PeriphResetCmd(sEE_I2C_CLK, DISABLE);
0000b4  2100              MOVS     r1,#0
0000b6  f44f1000          MOV      r0,#0x200000
0000ba  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;877        
;;;878    	/*!< GPIO configuration */  
;;;879    	/*!< Configure sEE_I2C pins: SCL */   
;;;880    	GPIO_InitStructure.GPIO_Pin = sEE_I2C_SCL_PIN;
0000be  f04f0040          MOV      r0,#0x40
0000c2  9000              STR      r0,[sp,#0]
;;;881    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
0000c4  f04f0002          MOV      r0,#2
0000c8  f88d0004          STRB     r0,[sp,#4]
;;;882    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000cc  f88d0005          STRB     r0,[sp,#5]
;;;883    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
0000d0  f04f0001          MOV      r0,#1
0000d4  f88d0006          STRB     r0,[sp,#6]
;;;884    	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
0000d8  f04f0000          MOV      r0,#0
0000dc  f88d0007          STRB     r0,[sp,#7]
;;;885    	GPIO_Init(sEE_I2C_SCL_GPIO_PORT, &GPIO_InitStructure);
0000e0  4669              MOV      r1,sp
0000e2  48cd              LDR      r0,|L1.1048|
0000e4  f7fffffe          BL       GPIO_Init
;;;886    
;;;887    	/*!< Configure sEE_I2C pins: SDA */
;;;888    	GPIO_InitStructure.GPIO_Pin = sEE_I2C_SDA_PIN;
0000e8  f04f0080          MOV      r0,#0x80
0000ec  9000              STR      r0,[sp,#0]
;;;889    	GPIO_Init(sEE_I2C_SDA_GPIO_PORT, &GPIO_InitStructure);
0000ee  4669              MOV      r1,sp
0000f0  48c9              LDR      r0,|L1.1048|
0000f2  f7fffffe          BL       GPIO_Init
;;;890    
;;;891    	/* Connect PXx to I2C_SCL*/
;;;892    	GPIO_PinAFConfig(sEE_I2C_SCL_GPIO_PORT, sEE_I2C_SCL_SOURCE, sEE_I2C_SCL_AF);
0000f6  2204              MOVS     r2,#4
0000f8  2106              MOVS     r1,#6
0000fa  48c7              LDR      r0,|L1.1048|
0000fc  f7fffffe          BL       GPIO_PinAFConfig
;;;893    
;;;894    	/* Connect PXx to I2C_SDA*/
;;;895    	GPIO_PinAFConfig(sEE_I2C_SDA_GPIO_PORT, sEE_I2C_SDA_SOURCE, sEE_I2C_SDA_AF);  
000100  2204              MOVS     r2,#4
000102  2107              MOVS     r1,#7
000104  48c4              LDR      r0,|L1.1048|
000106  f7fffffe          BL       GPIO_PinAFConfig
;;;896    
;;;897    
;;;898    /*********************************START 此处是参照开发板添加的***************************************/
;;;899    #if 0
;;;900    
;;;901    	/* Configure and enable I2C DMA TX Channel interrupt */
;;;902    	NVIC_InitStructure.NVIC_IRQChannel = sEE_I2C_DMA_TX_IRQn;
;;;903    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = sEE_I2C_DMA_PREPRIO;
;;;904    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = sEE_I2C_DMA_SUBPRIO;
;;;905    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;906    	NVIC_Init(&NVIC_InitStructure);
;;;907    	
;;;908    	/* Configure and enable I2C DMA RX Channel interrupt */
;;;909    	NVIC_InitStructure.NVIC_IRQChannel = sEE_I2C_DMA_RX_IRQn;
;;;910    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = sEE_I2C_DMA_PREPRIO;
;;;911    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = sEE_I2C_DMA_SUBPRIO;
;;;912    	NVIC_Init(&NVIC_InitStructure);
;;;913    
;;;914    #endif
;;;915    /***********************************END 此处是参照开发板添加的***************************************/
;;;916    
;;;917    	
;;;918      
;;;919    	/*!< I2C DMA TX and RX channels configuration */
;;;920    	/* Enable the DMA clock */
;;;921    	RCC_AHB1PeriphClockCmd(sEE_I2C_DMA_CLK, ENABLE);
00010a  2101              MOVS     r1,#1
00010c  0548              LSLS     r0,r1,#21
00010e  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;922      
;;;923    	/* Clear any pending flag on Rx Stream  */
;;;924    	DMA_ClearFlag(sEE_I2C_DMA_STREAM_TX, sEE_TX_DMA_FLAG_FEIF | sEE_TX_DMA_FLAG_DMEIF | sEE_TX_DMA_FLAG_TEIF | \
000112  49c2              LDR      r1,|L1.1052|
000114  48ba              LDR      r0,|L1.1024|
000116  3090              ADDS     r0,r0,#0x90
000118  f7fffffe          BL       DMA_ClearFlag
;;;925                                           sEE_TX_DMA_FLAG_HTIF | sEE_TX_DMA_FLAG_TCIF);
;;;926    	/* Disable the EE I2C Tx DMA stream */
;;;927    	DMA_Cmd(sEE_I2C_DMA_STREAM_TX, DISABLE);
00011c  2100              MOVS     r1,#0
00011e  48b8              LDR      r0,|L1.1024|
000120  3090              ADDS     r0,r0,#0x90
000122  f7fffffe          BL       DMA_Cmd
;;;928    	/* Configure the DMA stream for the EE I2C peripheral TX direction */
;;;929    	DMA_DeInit(sEE_I2C_DMA_STREAM_TX);
000126  48b6              LDR      r0,|L1.1024|
000128  3090              ADDS     r0,r0,#0x90
00012a  f7fffffe          BL       DMA_DeInit
;;;930    	sEEDMA_InitStructure.DMA_Channel = sEE_I2C_DMA_CHANNEL;
00012e  f04f7000          MOV      r0,#0x2000000
000132  49bb              LDR      r1,|L1.1056|
000134  6008              STR      r0,[r1,#0]  ; sEEDMA_InitStructure
;;;931    	sEEDMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)sEE_I2C_DR_Address;
000136  48bb              LDR      r0,|L1.1060|
000138  6048              STR      r0,[r1,#4]  ; sEEDMA_InitStructure
;;;932    	sEEDMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)0;    /* This parameter will be configured durig communication */;
00013a  f04f0000          MOV      r0,#0
00013e  6088              STR      r0,[r1,#8]  ; sEEDMA_InitStructure
;;;933    	sEEDMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral; /* This parameter will be configured durig communication */
000140  f04f0040          MOV      r0,#0x40
000144  60c8              STR      r0,[r1,#0xc]  ; sEEDMA_InitStructure
;;;934    	sEEDMA_InitStructure.DMA_BufferSize = 0xFFFF;              /* This parameter will be configured durig communication */
000146  f64f70ff          MOV      r0,#0xffff
00014a  6108              STR      r0,[r1,#0x10]  ; sEEDMA_InitStructure
;;;935    	sEEDMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
00014c  f04f0000          MOV      r0,#0
000150  6148              STR      r0,[r1,#0x14]  ; sEEDMA_InitStructure
;;;936    	sEEDMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
000152  f44f6080          MOV      r0,#0x400
000156  6188              STR      r0,[r1,#0x18]  ; sEEDMA_InitStructure
;;;937    	sEEDMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
000158  f04f0000          MOV      r0,#0
00015c  61c8              STR      r0,[r1,#0x1c]  ; sEEDMA_InitStructure
;;;938    	sEEDMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
00015e  6208              STR      r0,[r1,#0x20]  ; sEEDMA_InitStructure
;;;939    	sEEDMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
000160  6248              STR      r0,[r1,#0x24]  ; sEEDMA_InitStructure
;;;940    	sEEDMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
000162  f44f3040          MOV      r0,#0x30000
000166  6288              STR      r0,[r1,#0x28]  ; sEEDMA_InitStructure
;;;941    	sEEDMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Enable;
000168  f04f0004          MOV      r0,#4
00016c  62c8              STR      r0,[r1,#0x2c]  ; sEEDMA_InitStructure
;;;942    	sEEDMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_Full;
00016e  f04f0003          MOV      r0,#3
000172  6308              STR      r0,[r1,#0x30]  ; sEEDMA_InitStructure
;;;943    	sEEDMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
000174  f04f0000          MOV      r0,#0
000178  6348              STR      r0,[r1,#0x34]  ; sEEDMA_InitStructure
;;;944    	sEEDMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
00017a  6388              STR      r0,[r1,#0x38]  ; sEEDMA_InitStructure
;;;945    	DMA_Init(sEE_I2C_DMA_STREAM_TX, &sEEDMA_InitStructure);
00017c  48aa              LDR      r0,|L1.1064|
00017e  f7fffffe          BL       DMA_Init
;;;946    
;;;947    	/* Clear any pending flag on Rx Stream */
;;;948    //  DMA_ClearFlag(sEE_I2C_DMA_STREAM_RX, sEE_RX_DMA_FLAG_FEIF | sEE_RX_DMA_FLAG_DMEIF | sEE_RX_DMA_FLAG_TEIF | \
;;;949    //                                       sEE_RX_DMA_FLAG_HTIF | sEE_RX_DMA_FLAG_TCIF);
;;;950    	/* Disable the EE I2C DMA Rx stream */
;;;951    	DMA_Cmd(sEE_I2C_DMA_STREAM_RX, DISABLE);
000182  2100              MOVS     r1,#0
000184  489e              LDR      r0,|L1.1024|
000186  f7fffffe          BL       DMA_Cmd
;;;952    	/* Configure the DMA stream for the EE I2C peripheral RX direction */
;;;953    	DMA_DeInit(sEE_I2C_DMA_STREAM_RX);
00018a  489d              LDR      r0,|L1.1024|
00018c  f7fffffe          BL       DMA_DeInit
;;;954    	DMA_Init(sEE_I2C_DMA_STREAM_RX, &sEEDMA_InitStructure);
000190  49a3              LDR      r1,|L1.1056|
000192  489b              LDR      r0,|L1.1024|
000194  f7fffffe          BL       DMA_Init
;;;955      
;;;956    	/* Enable the DMA Channels Interrupts */
;;;957    	DMA_ITConfig(sEE_I2C_DMA_STREAM_TX, DMA_IT_TC, ENABLE);
000198  2201              MOVS     r2,#1
00019a  2110              MOVS     r1,#0x10
00019c  48a2              LDR      r0,|L1.1064|
00019e  f7fffffe          BL       DMA_ITConfig
;;;958    	DMA_ITConfig(sEE_I2C_DMA_STREAM_RX, DMA_IT_TC, ENABLE);  
0001a2  2201              MOVS     r2,#1
0001a4  2110              MOVS     r1,#0x10
0001a6  4896              LDR      r0,|L1.1024|
0001a8  f7fffffe          BL       DMA_ITConfig
;;;959    
;;;960    
;;;961    //暂时屏蔽掉，前面根据开发板的例子已经实现，故这里不再需要，调试中
;;;962    #if 1
;;;963    	/* Configure and enable I2C DMA TX Channel interrupt */
;;;964    	BSP_IntVectSet(sEE_I2C_DMA_TX_IRQn, sEE_I2C_DMA_TX_IRQHandler);
0001ac  f2af117b          ADR      r1,sEE_I2C_DMA_TX_IRQHandler + 1
0001b0  2011              MOVS     r0,#0x11
0001b2  f7fffffe          BL       BSP_IntVectSet
;;;965        BSP_IntEn(sEE_I2C_DMA_TX_IRQn);
0001b6  2011              MOVS     r0,#0x11
0001b8  f7fffffe          BL       BSP_IntEn
;;;966    	
;;;967    
;;;968    	/* Configure and enable I2C DMA RX Channel interrupt */
;;;969    	BSP_IntVectSet(sEE_I2C_DMA_RX_IRQn, sEE_I2C_DMA_RX_IRQHandler);
0001bc  f2af11bf          ADR      r1,sEE_I2C_DMA_RX_IRQHandler + 1
0001c0  200b              MOVS     r0,#0xb
0001c2  f7fffffe          BL       BSP_IntVectSet
;;;970        BSP_IntEn(sEE_I2C_DMA_RX_IRQn);
0001c6  200b              MOVS     r0,#0xb
0001c8  f7fffffe          BL       BSP_IntEn
;;;971    #endif 
;;;972    }
0001cc  bd1c              POP      {r2-r4,pc}
;;;973    
                          ENDP

                  sEE_Init PROC
;;;187      */
;;;188    void sEE_Init(void)
0001ce  b51f              PUSH     {r0-r4,lr}
;;;189    { 
;;;190    	I2C_InitTypeDef  I2C_InitStructure;
;;;191      
;;;192    	sEE_LowLevel_Init();
0001d0  f7fffffe          BL       sEE_LowLevel_Init
;;;193      
;;;194    	/*!< I2C configuration */
;;;195    	/* sEE_I2C configuration */
;;;196    	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
0001d4  f04f0000          MOV      r0,#0
0001d8  f8ad0004          STRH     r0,[sp,#4]
;;;197    	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
0001dc  f64b70ff          MOV      r0,#0xbfff
0001e0  f8ad0006          STRH     r0,[sp,#6]
;;;198    	I2C_InitStructure.I2C_OwnAddress1 = I2C_SLAVE_ADDRESS7;
0001e4  f04f00af          MOV      r0,#0xaf
0001e8  f8ad0008          STRH     r0,[sp,#8]
;;;199    	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
0001ec  f44f6080          MOV      r0,#0x400
0001f0  f8ad000a          STRH     r0,[sp,#0xa]
;;;200    	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
0001f4  f44f4080          MOV      r0,#0x4000
0001f8  f8ad000c          STRH     r0,[sp,#0xc]
;;;201    	I2C_InitStructure.I2C_ClockSpeed = I2C_SPEED;
0001fc  488b              LDR      r0,|L1.1068|
0001fe  9000              STR      r0,[sp,#0]
;;;202      
;;;203    	/* sEE_I2C Peripheral Enable */
;;;204    	I2C_Cmd(sEE_I2C, ENABLE);
000200  f04f0101          MOV      r1,#1
000204  487f              LDR      r0,|L1.1028|
000206  f7fffffe          BL       I2C_Cmd
;;;205    	/* Apply sEE_I2C configuration after enabling it */
;;;206    	I2C_Init(sEE_I2C, &I2C_InitStructure);
00020a  4669              MOV      r1,sp
00020c  487d              LDR      r0,|L1.1028|
00020e  f7fffffe          BL       I2C_Init
;;;207    
;;;208    	/* Enable the sEE_I2C peripheral DMA requests */
;;;209    	I2C_DMACmd(sEE_I2C, ENABLE);
000212  2101              MOVS     r1,#1
000214  487b              LDR      r0,|L1.1028|
000216  f7fffffe          BL       I2C_DMACmd
;;;210      
;;;211    #if 0
;;;212    #if defined (sEE_M24C64_32)
;;;213    	/*!< Select the EEPROM address according to the state of E0, E1, E2 pins */
;;;214    	sEEAddress = sEE_HW_ADDRESS;  
;;;215    #elif defined (sEE_M24C08)
;;;216    	/*!< depending on the sEE Address selected in the stm322xg_eval_i2c_ee.h file */
;;;217    	#ifdef sEE_Block0_ADDRESS
;;;218    		/*!< Select the sEE Block0 to write on */
;;;219    		sEEAddress = sEE_Block0_ADDRESS;
;;;220    	#elif defined (sEE_AT24C02)
;;;221    		sEEAddress = 0xA0;
;;;222    	#elif defined (sEE_FM24CL04B)
;;;223    		sEEAddress = 0xA0;
;;;224    	#endif	    
;;;225    
;;;226    	#ifdef sEE_Block1_ADDRESS
;;;227    		/*!< Select the sEE Block1 to write on */
;;;228    		sEEAddress = sEE_Block1_ADDRESS;
;;;229    	#endif
;;;230    
;;;231    	#ifdef sEE_Block2_ADDRESS
;;;232    		/*!< Select the sEE Block2 to write on */
;;;233    		sEEAddress = sEE_Block2_ADDRESS;
;;;234    	#endif
;;;235      
;;;236    	#ifdef sEE_Block3_ADDRESS
;;;237    		/*!< Select the sEE Block3 to write on */
;;;238    		sEEAddress = sEE_Block3_ADDRESS;
;;;239    	#endif 
;;;240    #endif /*!< sEE_M24C64_32 */    
;;;241    #endif
;;;242    
;;;243    	///无论 AT24Cxx、M24Cxx 及 FM24CLxx，地址均为 A0
;;;244    	sEEAddress = 0xA0;
00021a  f04f00a0          MOV      r0,#0xa0
00021e  4984              LDR      r1,|L1.1072|
000220  8008              STRH     r0,[r1,#0]
;;;245    }
000222  bd1f              POP      {r0-r4,pc}
;;;246    
                          ENDP

                  BSP_InitI2C1 PROC
;;;118    ///////////////////////////////////////////////////////////////////////////////////////
;;;119    void BSP_InitI2C1(void)
000224  b510              PUSH     {r4,lr}
;;;120    {
;;;121    	sEE_Init();
000226  f7fffffe          BL       sEE_Init
;;;122    }
00022a  bd10              POP      {r4,pc}
;;;123    
                          ENDP

                  sEE_LowLevel_DMAConfig PROC
;;;978      */
;;;979    void sEE_LowLevel_DMAConfig(uint32_t pBuffer, uint32_t BufferSize, uint32_t Direction)
00022c  b570              PUSH     {r4-r6,lr}
;;;980    {	
00022e  4604              MOV      r4,r0
000230  460d              MOV      r5,r1
000232  4616              MOV      r6,r2
;;;981    	/* Initialize the DMA with the new parameters */
;;;982    	if (Direction == sEE_DIRECTION_TX)
000234  b95e              CBNZ     r6,|L1.590|
;;;983    	{
;;;984    		/* Configure the DMA Tx Stream with the buffer address and the buffer size */
;;;985    		sEEDMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)pBuffer;
000236  487a              LDR      r0,|L1.1056|
000238  6084              STR      r4,[r0,#8]  ; sEEDMA_InitStructure
;;;986    		sEEDMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;    
00023a  f04f0040          MOV      r0,#0x40
00023e  4978              LDR      r1,|L1.1056|
000240  60c8              STR      r0,[r1,#0xc]  ; sEEDMA_InitStructure
;;;987    		sEEDMA_InitStructure.DMA_BufferSize = (uint32_t)BufferSize;  
000242  4608              MOV      r0,r1
000244  6105              STR      r5,[r0,#0x10]  ; sEEDMA_InitStructure
;;;988    		DMA_Init(sEE_I2C_DMA_STREAM_TX, &sEEDMA_InitStructure);  
000246  4878              LDR      r0,|L1.1064|
000248  f7fffffe          BL       DMA_Init
00024c  e00a              B        |L1.612|
                  |L1.590|
;;;989    	}
;;;990    	else
;;;991    	{ 
;;;992    		/* Configure the DMA Rx Stream with the buffer address and the buffer size */
;;;993    		sEEDMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)pBuffer;
00024e  4874              LDR      r0,|L1.1056|
000250  6084              STR      r4,[r0,#8]  ; sEEDMA_InitStructure
;;;994    		sEEDMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
000252  f04f0000          MOV      r0,#0
000256  4972              LDR      r1,|L1.1056|
000258  60c8              STR      r0,[r1,#0xc]  ; sEEDMA_InitStructure
;;;995    		sEEDMA_InitStructure.DMA_BufferSize = (uint32_t)BufferSize;      
00025a  4608              MOV      r0,r1
00025c  6105              STR      r5,[r0,#0x10]  ; sEEDMA_InitStructure
;;;996    		DMA_Init(sEE_I2C_DMA_STREAM_RX, &sEEDMA_InitStructure);    
00025e  4868              LDR      r0,|L1.1024|
000260  f7fffffe          BL       DMA_Init
                  |L1.612|
;;;997    	}
;;;998    }
000264  bd70              POP      {r4-r6,pc}
;;;999    
                          ENDP

                  sEE_ReadBuffer PROC
;;;267      */
;;;268    uint32_t sEE_ReadBuffer(uint8_t* pBuffer, uint16_t ReadAddr, uint16_t* NumByteToRead)
000266  b570              PUSH     {r4-r6,lr}
;;;269    {  
000268  4605              MOV      r5,r0
00026a  460e              MOV      r6,r1
00026c  4614              MOV      r4,r2
;;;270    	/* Set the pointer to the Number of data to be read. This pointer will be used 
;;;271          by the DMA Transfer Completer interrupt Handler in order to reset the 
;;;272          variable to 0. User should check on this variable in order to know if the 
;;;273          DMA transfer has been complete or not. */
;;;274    	sEEDataReadPointer = NumByteToRead;
00026e  4866              LDR      r0,|L1.1032|
000270  6004              STR      r4,[r0,#0]  ; sEEDataReadPointer
;;;275      
;;;276    	/*!< While the bus is busy */
;;;277    	sEETimeout = sEE_LONG_TIMEOUT;
000272  f44f4020          MOV      r0,#0xa000
000276  4966              LDR      r1,|L1.1040|
000278  6008              STR      r0,[r1,#0]  ; sEETimeout
;;;278    	while(I2C_GetFlagStatus(sEE_I2C, I2C_FLAG_BUSY))
00027a  e008              B        |L1.654|
                  |L1.636|
;;;279    	{
;;;280    		if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
00027c  4964              LDR      r1,|L1.1040|
00027e  6808              LDR      r0,[r1,#0]  ; sEETimeout
000280  1e41              SUBS     r1,r0,#1
000282  4a63              LDR      r2,|L1.1040|
000284  6011              STR      r1,[r2,#0]  ; sEETimeout
000286  b910              CBNZ     r0,|L1.654|
000288  f7fffffe          BL       sEE_TIMEOUT_UserCallback
                  |L1.652|
;;;281    	}
;;;282      
;;;283    	/*!< Send START condition */
;;;284    	I2C_GenerateSTART(sEE_I2C, ENABLE);
;;;285      
;;;286    	/*!< Test on EV5 and clear it (cleared by reading SR1 then writing to DR) */
;;;287    	sEETimeout = sEE_FLAG_TIMEOUT;
;;;288    	while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_MODE_SELECT))
;;;289    	{
;;;290    		if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
;;;291    	}
;;;292      
;;;293    	/*!< Send EEPROM address for write */
;;;294    	I2C_Send7bitAddress(sEE_I2C, sEEAddress, I2C_Direction_Transmitter);
;;;295    
;;;296    	/*!< Test on EV6 and clear it */
;;;297    	sEETimeout = sEE_FLAG_TIMEOUT;
;;;298    	while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
;;;299    	{
;;;300    		if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
;;;301    	} 
;;;302    
;;;303    #if  defined sEE_M24C08 || defined sEE_AT24C02 || defined sEE_FM24CL04B
;;;304      
;;;305    	/*!< Send the EEPROM's internal address to read from: Only one byte address */
;;;306    	I2C_SendData(sEE_I2C, ReadAddr);  
;;;307    
;;;308    #elif defined (sEE_M24C64_32)
;;;309    
;;;310    	/*!< Send the EEPROM's internal address to read from: MSB of the address first */
;;;311    	I2C_SendData(sEE_I2C, (uint8_t)((ReadAddr & 0xFF00) >> 8));    
;;;312    
;;;313    	/*!< Test on EV8 and clear it */
;;;314    	sEETimeout = sEE_FLAG_TIMEOUT;
;;;315    	while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING))
;;;316    	{
;;;317    		if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
;;;318    	}
;;;319    
;;;320    	/*!< Send the EEPROM's internal address to read from: LSB of the address */
;;;321    	I2C_SendData(sEE_I2C, (uint8_t)(ReadAddr & 0x00FF));    
;;;322      
;;;323    #endif /*!< sEE_M24C08 */
;;;324    
;;;325    	/*!< Test on EV8 and clear it */
;;;326    	sEETimeout = sEE_FLAG_TIMEOUT;
;;;327    	while(I2C_GetFlagStatus(sEE_I2C, I2C_FLAG_BTF) == RESET)
;;;328    	{
;;;329    		if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
;;;330    	}
;;;331      
;;;332    	/*!< Send STRAT condition a second time */  
;;;333    	I2C_GenerateSTART(sEE_I2C, ENABLE);
;;;334      
;;;335    	/*!< Test on EV5 and clear it (cleared by reading SR1 then writing to DR) */
;;;336    	sEETimeout = sEE_FLAG_TIMEOUT;
;;;337    	while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_MODE_SELECT))
;;;338    	{
;;;339    		if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
;;;340    	} 
;;;341      
;;;342    	/*!< Send EEPROM address for read */
;;;343    	I2C_Send7bitAddress(sEE_I2C, sEEAddress, I2C_Direction_Receiver);  
;;;344      
;;;345    	/* If number of data to be read is 1, then DMA couldn't be used */
;;;346    	/* One Byte Master Reception procedure (POLLING) ---------------------------*/
;;;347    	if ((uint16_t)(*NumByteToRead) < 2)
;;;348    	{
;;;349    		/* Wait on ADDR flag to be set (ADDR is still not cleared at this level */
;;;350    		sEETimeout = sEE_FLAG_TIMEOUT;
;;;351    		while(I2C_GetFlagStatus(sEE_I2C, I2C_FLAG_ADDR) == RESET)
;;;352    		{
;;;353    			if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
;;;354    		}     
;;;355        
;;;356    		/*!< Disable Acknowledgment */
;;;357    		I2C_AcknowledgeConfig(sEE_I2C, DISABLE);   
;;;358    		
;;;359    		/* Clear ADDR register by reading SR1 then SR2 register (SR1 has already been read) */
;;;360    		(void)sEE_I2C->SR2;
;;;361    
;;;362    		/*!< Send STOP Condition */
;;;363    		I2C_GenerateSTOP(sEE_I2C, ENABLE);
;;;364        
;;;365    		/* Wait for the byte to be received */
;;;366    		sEETimeout = sEE_FLAG_TIMEOUT;
;;;367    		while(I2C_GetFlagStatus(sEE_I2C, I2C_FLAG_RXNE) == RESET)
;;;368    		{
;;;369    			if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
;;;370    		}
;;;371        
;;;372    		/*!< Read the byte received from the EEPROM */
;;;373    		*pBuffer = I2C_ReceiveData(sEE_I2C);
;;;374        
;;;375    		/*!< Decrement the read bytes counter */
;;;376    		(uint16_t)(*NumByteToRead)--;        
;;;377        
;;;378    		/* Wait to make sure that STOP control bit has been cleared */
;;;379    		sEETimeout = sEE_FLAG_TIMEOUT;
;;;380    		while(sEE_I2C->CR1 & I2C_CR1_STOP)
;;;381    		{
;;;382    			if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
;;;383    		}  
;;;384        
;;;385    		/*!< Re-Enable Acknowledgment to be ready for another reception */
;;;386    		I2C_AcknowledgeConfig(sEE_I2C, ENABLE);    
;;;387    	}
;;;388    	else/* More than one Byte Master Reception procedure (DMA) -----------------*/
;;;389    	{
;;;390    		/*!< Test on EV6 and clear it */
;;;391    		sEETimeout = sEE_FLAG_TIMEOUT;
;;;392    		while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
;;;393    		{
;;;394    			if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
;;;395    		}  
;;;396        
;;;397    		/* Configure the DMA Rx Channel with the buffer address and the buffer size */
;;;398    		sEE_LowLevel_DMAConfig((uint32_t)pBuffer, (uint16_t)(*NumByteToRead), sEE_DIRECTION_RX);
;;;399        
;;;400    		/* Inform the DMA that the next End Of Transfer Signal will be the last one */
;;;401    		I2C_DMALastTransferCmd(sEE_I2C, ENABLE); 
;;;402        
;;;403    		/* Enable the DMA Rx Stream */
;;;404    		DMA_Cmd(sEE_I2C_DMA_STREAM_RX, ENABLE);    
;;;405    	}
;;;406      
;;;407    	/* If all operations OK, return sEE_OK (0) */
;;;408    	return sEE_OK;
;;;409    }
00028c  bd70              POP      {r4-r6,pc}
                  |L1.654|
00028e  f44f3100          MOV      r1,#0x20000           ;278
000292  485c              LDR      r0,|L1.1028|
000294  f7fffffe          BL       I2C_GetFlagStatus
000298  2800              CMP      r0,#0                 ;278
00029a  d1ef              BNE      |L1.636|
00029c  2101              MOVS     r1,#1                 ;284
00029e  4859              LDR      r0,|L1.1028|
0002a0  f7fffffe          BL       I2C_GenerateSTART
0002a4  f44f5080          MOV      r0,#0x1000            ;287
0002a8  4959              LDR      r1,|L1.1040|
0002aa  6008              STR      r0,[r1,#0]            ;287  ; sEETimeout
0002ac  e008              B        |L1.704|
                  |L1.686|
0002ae  4958              LDR      r1,|L1.1040|
0002b0  6808              LDR      r0,[r1,#0]            ;290  ; sEETimeout
0002b2  1e41              SUBS     r1,r0,#1              ;290
0002b4  4a56              LDR      r2,|L1.1040|
0002b6  6011              STR      r1,[r2,#0]            ;290  ; sEETimeout
0002b8  b910              CBNZ     r0,|L1.704|
0002ba  f7fffffe          BL       sEE_TIMEOUT_UserCallback
0002be  e7e5              B        |L1.652|
                  |L1.704|
0002c0  495c              LDR      r1,|L1.1076|
0002c2  4850              LDR      r0,|L1.1028|
0002c4  f7fffffe          BL       I2C_CheckEvent
0002c8  2800              CMP      r0,#0                 ;288
0002ca  d0f0              BEQ      |L1.686|
0002cc  2200              MOVS     r2,#0                 ;294
0002ce  4858              LDR      r0,|L1.1072|
0002d0  8800              LDRH     r0,[r0,#0]            ;294  ; sEEAddress
0002d2  b2c1              UXTB     r1,r0                 ;294
0002d4  484b              LDR      r0,|L1.1028|
0002d6  f7fffffe          BL       I2C_Send7bitAddress
0002da  f44f5080          MOV      r0,#0x1000            ;297
0002de  494c              LDR      r1,|L1.1040|
0002e0  6008              STR      r0,[r1,#0]            ;297  ; sEETimeout
0002e2  e008              B        |L1.758|
                  |L1.740|
0002e4  494a              LDR      r1,|L1.1040|
0002e6  6808              LDR      r0,[r1,#0]            ;300  ; sEETimeout
0002e8  1e41              SUBS     r1,r0,#1              ;300
0002ea  4a49              LDR      r2,|L1.1040|
0002ec  6011              STR      r1,[r2,#0]            ;300  ; sEETimeout
0002ee  b910              CBNZ     r0,|L1.758|
0002f0  f7fffffe          BL       sEE_TIMEOUT_UserCallback
0002f4  e7ca              B        |L1.652|
                  |L1.758|
0002f6  4950              LDR      r1,|L1.1080|
0002f8  4842              LDR      r0,|L1.1028|
0002fa  f7fffffe          BL       I2C_CheckEvent
0002fe  2800              CMP      r0,#0                 ;298
000300  d0f0              BEQ      |L1.740|
000302  b2f1              UXTB     r1,r6                 ;306
000304  483f              LDR      r0,|L1.1028|
000306  f7fffffe          BL       I2C_SendData
00030a  f44f5080          MOV      r0,#0x1000            ;326
00030e  4940              LDR      r1,|L1.1040|
000310  6008              STR      r0,[r1,#0]            ;326  ; sEETimeout
000312  e008              B        |L1.806|
                  |L1.788|
000314  493e              LDR      r1,|L1.1040|
000316  6808              LDR      r0,[r1,#0]            ;329  ; sEETimeout
000318  1e41              SUBS     r1,r0,#1              ;329
00031a  4a3d              LDR      r2,|L1.1040|
00031c  6011              STR      r1,[r2,#0]            ;329  ; sEETimeout
00031e  b910              CBNZ     r0,|L1.806|
000320  f7fffffe          BL       sEE_TIMEOUT_UserCallback
000324  e7b2              B        |L1.652|
                  |L1.806|
000326  4935              LDR      r1,|L1.1020|
000328  391c              SUBS     r1,r1,#0x1c           ;327
00032a  4836              LDR      r0,|L1.1028|
00032c  f7fffffe          BL       I2C_GetFlagStatus
000330  2800              CMP      r0,#0                 ;327
000332  d0ef              BEQ      |L1.788|
000334  2101              MOVS     r1,#1                 ;333
000336  4833              LDR      r0,|L1.1028|
000338  f7fffffe          BL       I2C_GenerateSTART
00033c  f44f5080          MOV      r0,#0x1000            ;336
000340  4933              LDR      r1,|L1.1040|
000342  6008              STR      r0,[r1,#0]            ;336  ; sEETimeout
000344  e008              B        |L1.856|
                  |L1.838|
000346  4932              LDR      r1,|L1.1040|
000348  6808              LDR      r0,[r1,#0]            ;339  ; sEETimeout
00034a  1e41              SUBS     r1,r0,#1              ;339
00034c  4a30              LDR      r2,|L1.1040|
00034e  6011              STR      r1,[r2,#0]            ;339  ; sEETimeout
000350  b910              CBNZ     r0,|L1.856|
000352  f7fffffe          BL       sEE_TIMEOUT_UserCallback
000356  e799              B        |L1.652|
                  |L1.856|
000358  4936              LDR      r1,|L1.1076|
00035a  482a              LDR      r0,|L1.1028|
00035c  f7fffffe          BL       I2C_CheckEvent
000360  2800              CMP      r0,#0                 ;337
000362  d0f0              BEQ      |L1.838|
000364  2201              MOVS     r2,#1                 ;343
000366  4832              LDR      r0,|L1.1072|
000368  8800              LDRH     r0,[r0,#0]            ;343  ; sEEAddress
00036a  b2c1              UXTB     r1,r0                 ;343
00036c  4825              LDR      r0,|L1.1028|
00036e  f7fffffe          BL       I2C_Send7bitAddress
000372  8820              LDRH     r0,[r4,#0]            ;347
000374  2802              CMP      r0,#2                 ;347
000376  da77              BGE      |L1.1128|
000378  f44f5080          MOV      r0,#0x1000            ;350
00037c  4924              LDR      r1,|L1.1040|
00037e  6008              STR      r0,[r1,#0]            ;350  ; sEETimeout
000380  e008              B        |L1.916|
                  |L1.898|
000382  4923              LDR      r1,|L1.1040|
000384  6808              LDR      r0,[r1,#0]            ;353  ; sEETimeout
000386  1e41              SUBS     r1,r0,#1              ;353
000388  4a21              LDR      r2,|L1.1040|
00038a  6011              STR      r1,[r2,#0]            ;353  ; sEETimeout
00038c  b910              CBNZ     r0,|L1.916|
00038e  f7fffffe          BL       sEE_TIMEOUT_UserCallback
000392  e77b              B        |L1.652|
                  |L1.916|
000394  4919              LDR      r1,|L1.1020|
000396  391e              SUBS     r1,r1,#0x1e           ;351
000398  481a              LDR      r0,|L1.1028|
00039a  f7fffffe          BL       I2C_GetFlagStatus
00039e  2800              CMP      r0,#0                 ;351
0003a0  d0ef              BEQ      |L1.898|
0003a2  2100              MOVS     r1,#0                 ;357
0003a4  4817              LDR      r0,|L1.1028|
0003a6  f7fffffe          BL       I2C_AcknowledgeConfig
0003aa  4824              LDR      r0,|L1.1084|
0003ac  8800              LDRH     r0,[r0,#0]            ;360
0003ae  f04f0101          MOV      r1,#1                 ;363
0003b2  4814              LDR      r0,|L1.1028|
0003b4  f7fffffe          BL       I2C_GenerateSTOP
0003b8  f44f5080          MOV      r0,#0x1000            ;366
0003bc  4914              LDR      r1,|L1.1040|
0003be  6008              STR      r0,[r1,#0]            ;366  ; sEETimeout
0003c0  e008              B        |L1.980|
                  |L1.962|
0003c2  4913              LDR      r1,|L1.1040|
0003c4  6808              LDR      r0,[r1,#0]            ;369  ; sEETimeout
0003c6  1e41              SUBS     r1,r0,#1              ;369
0003c8  4a11              LDR      r2,|L1.1040|
0003ca  6011              STR      r1,[r2,#0]            ;369  ; sEETimeout
0003cc  b910              CBNZ     r0,|L1.980|
0003ce  f7fffffe          BL       sEE_TIMEOUT_UserCallback
0003d2  e75b              B        |L1.652|
                  |L1.980|
0003d4  4909              LDR      r1,|L1.1020|
0003d6  3120              ADDS     r1,r1,#0x20           ;367
0003d8  480a              LDR      r0,|L1.1028|
0003da  f7fffffe          BL       I2C_GetFlagStatus
0003de  2800              CMP      r0,#0                 ;367
0003e0  d0ef              BEQ      |L1.962|
0003e2  4808              LDR      r0,|L1.1028|
0003e4  f7fffffe          BL       I2C_ReceiveData
0003e8  7028              STRB     r0,[r5,#0]            ;373
0003ea  8820              LDRH     r0,[r4,#0]            ;376
0003ec  f1a00001          SUB      r0,r0,#1              ;376
0003f0  8020              STRH     r0,[r4,#0]            ;376
0003f2  f44f5080          MOV      r0,#0x1000            ;379
0003f6  4906              LDR      r1,|L1.1040|
0003f8  6008              STR      r0,[r1,#0]            ;379  ; sEETimeout
0003fa  e02a              B        |L1.1106|
                  |L1.1020|
                          DCD      0x10000020
                  |L1.1024|
                          DCD      0x40026010
                  |L1.1028|
                          DCD      0x40005400
                  |L1.1032|
                          DCD      sEEDataReadPointer
                  |L1.1036|
                          DCD      0x20200000
                  |L1.1040|
                          DCD      sEETimeout
                  |L1.1044|
                          DCD      sEEDataWritePointer
                  |L1.1048|
                          DCD      0x40020400
                  |L1.1052|
                          DCD      0x203d0000
                  |L1.1056|
                          DCD      sEEDMA_InitStructure
                  |L1.1060|
                          DCD      0x40005410
                  |L1.1064|
                          DCD      0x400260a0
                  |L1.1068|
                          DCD      0x00061a80
                  |L1.1072|
                          DCD      sEEAddress
                  |L1.1076|
                          DCD      0x00030001
                  |L1.1080|
                          DCD      0x00070082
                  |L1.1084|
                          DCD      0x40005418
                  |L1.1088|
000440  49fe              LDR      r1,|L1.2108|
000442  6808              LDR      r0,[r1,#0]            ;382  ; sEETimeout
000444  1e41              SUBS     r1,r0,#1              ;382
000446  4afd              LDR      r2,|L1.2108|
000448  6011              STR      r1,[r2,#0]            ;382  ; sEETimeout
00044a  b910              CBNZ     r0,|L1.1106|
00044c  f7fffffe          BL       sEE_TIMEOUT_UserCallback
000450  e71c              B        |L1.652|
                  |L1.1106|
000452  48fb              LDR      r0,|L1.2112|
000454  8800              LDRH     r0,[r0,#0]            ;380
000456  f4107f00          TST      r0,#0x200             ;380
00045a  d1f1              BNE      |L1.1088|
00045c  2101              MOVS     r1,#1                 ;386
00045e  48f8              LDR      r0,|L1.2112|
000460  f7fffffe          BL       I2C_AcknowledgeConfig
000464  e021              B        |L1.1194|
000466  e7ff              B        |L1.1128|
                  |L1.1128|
000468  f44f5080          MOV      r0,#0x1000            ;391
00046c  49f3              LDR      r1,|L1.2108|
00046e  6008              STR      r0,[r1,#0]            ;391  ; sEETimeout
000470  e008              B        |L1.1156|
                  |L1.1138|
000472  49f2              LDR      r1,|L1.2108|
000474  6808              LDR      r0,[r1,#0]            ;394  ; sEETimeout
000476  1e41              SUBS     r1,r0,#1              ;394
000478  4af0              LDR      r2,|L1.2108|
00047a  6011              STR      r1,[r2,#0]            ;394  ; sEETimeout
00047c  b910              CBNZ     r0,|L1.1156|
00047e  f7fffffe          BL       sEE_TIMEOUT_UserCallback
000482  e703              B        |L1.652|
                  |L1.1156|
000484  49ef              LDR      r1,|L1.2116|
000486  48ee              LDR      r0,|L1.2112|
000488  f7fffffe          BL       I2C_CheckEvent
00048c  2800              CMP      r0,#0                 ;392
00048e  d0f0              BEQ      |L1.1138|
000490  8821              LDRH     r1,[r4,#0]            ;398
000492  2201              MOVS     r2,#1                 ;398
000494  4628              MOV      r0,r5                 ;398
000496  f7fffffe          BL       sEE_LowLevel_DMAConfig
00049a  2101              MOVS     r1,#1                 ;401
00049c  48e8              LDR      r0,|L1.2112|
00049e  f7fffffe          BL       I2C_DMALastTransferCmd
0004a2  2101              MOVS     r1,#1                 ;404
0004a4  48e8              LDR      r0,|L1.2120|
0004a6  f7fffffe          BL       DMA_Cmd
                  |L1.1194|
0004aa  2000              MOVS     r0,#0                 ;408
0004ac  e6ee              B        |L1.652|
;;;410    
                          ENDP

                  BSP_ReadI2C1 PROC
;;;123    
;;;124    uint8_t BSP_ReadI2C1(uint8_t *buf, uint16_t ReadAddr, uint16_t *NumByteToRead)
0004ae  e92d41f0          PUSH     {r4-r8,lr}
;;;125    {
0004b2  4606              MOV      r6,r0
0004b4  460f              MOV      r7,r1
0004b6  4614              MOV      r4,r2
;;;126    #if USE_UCOSII
;;;127    	uint8_t timeout = 3;
0004b8  f04f0503          MOV      r5,#3
;;;128    #else
;;;129    	uint32_t timeout = 0x40000;
;;;130    #endif
;;;131    	
;;;132    	sEE_ReadBuffer(buf, ReadAddr, NumByteToRead);
0004bc  4622              MOV      r2,r4
0004be  4639              MOV      r1,r7
0004c0  4630              MOV      r0,r6
0004c2  f7fffffe          BL       sEE_ReadBuffer
;;;133    	while (*NumByteToRead != 0){
0004c6  e009              B        |L1.1244|
                  |L1.1224|
;;;134    		
;;;135    		timeout--;
0004c8  f1a50001          SUB      r0,r5,#1
0004cc  b2c5              UXTB     r5,r0
;;;136    		if (timeout == 0)
0004ce  b915              CBNZ     r5,|L1.1238|
;;;137    			return 1;
0004d0  2001              MOVS     r0,#1
                  |L1.1234|
;;;138    #if USE_UCOSII
;;;139    		OSTimeDly(2);
;;;140    #endif
;;;141    	}
;;;142    	return 0;
;;;143    }
0004d2  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1238|
0004d6  2002              MOVS     r0,#2                 ;139
0004d8  f7fffffe          BL       OSTimeDly
                  |L1.1244|
0004dc  8820              LDRH     r0,[r4,#0]            ;133
0004de  2800              CMP      r0,#0                 ;133
0004e0  d1f2              BNE      |L1.1224|
0004e2  bf00              NOP                            ;142
0004e4  e7f5              B        |L1.1234|
;;;144    
                          ENDP

                  sEE_WaitEepromStandbyState PROC
;;;700      */
;;;701    uint32_t sEE_WaitEepromStandbyState(void)      
0004e6  2000              MOVS     r0,#0
;;;702    {
;;;703    #if defined sEE_FM24CL04B
;;;704    		return sEE_OK;///
;;;705    #else
;;;706    
;;;707    	__IO uint16_t tmpSR1 = 0;
;;;708    	__IO uint32_t sEETrials = 0;
;;;709    
;;;710    	/*!< While the bus is busy */
;;;711    #if (USE_UCOSII)
;;;712    	sEETimeout = 3;
;;;713    #else
;;;714    	sEETimeout = sEE_LONG_TIMEOUT;
;;;715    #endif
;;;716    	while(I2C_GetFlagStatus(sEE_I2C, I2C_FLAG_BUSY))
;;;717    	{
;;;718    		if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
;;;719    		
;;;720    #if USE_UCOSII
;;;721    		OSTimeDly(2);
;;;722    #endif
;;;723    	}
;;;724    
;;;725    	/* Keep looping till the slave acknowledge his address or maximum number 
;;;726    		of trials is reached (this number is defined by sEE_MAX_TRIALS_NUMBER define
;;;727    		in stm322xg_eval_i2c_ee.h file) */
;;;728    	while (1)
;;;729    	{
;;;730    		/*!< Send START condition */
;;;731    		I2C_GenerateSTART(sEE_I2C, ENABLE);
;;;732    
;;;733    		/*!< Test on EV5 and clear it */
;;;734    #if (USE_UCOSII)
;;;735    		sEETimeout = 3;
;;;736    #else
;;;737    		sEETimeout = sEE_LONG_TIMEOUT;
;;;738    #endif
;;;739    		while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_MODE_SELECT))
;;;740    		{
;;;741    			if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
;;;742    			
;;;743    #if USE_UCOSII
;;;744    				OSTimeDly(2);
;;;745    #endif
;;;746    		}    
;;;747    
;;;748    		/*!< Send EEPROM address for write */
;;;749    		I2C_Send7bitAddress(sEE_I2C, sEEAddress, I2C_Direction_Transmitter);
;;;750        
;;;751    		/* Wait for ADDR flag to be set (Slave acknowledged his address) */
;;;752    #if (USE_UCOSII)
;;;753    		sEETimeout = 3;
;;;754    #else
;;;755    		sEETimeout = sEE_LONG_TIMEOUT;
;;;756    #endif
;;;757    		do
;;;758    		{     
;;;759    			/* Get the current value of the SR1 register */
;;;760    			tmpSR1 = sEE_I2C->SR1;
;;;761          
;;;762    			/* Update the timeout value and exit if it reach 0 */
;;;763    			if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
;;;764    			
;;;765    #if USE_UCOSII
;;;766    				OSTimeDly(2);
;;;767    #endif
;;;768    		}
;;;769    		/* Keep looping till the Address is acknowledged or the AF flag is 
;;;770    			set (address not acknowledged at time) */
;;;771    		while((tmpSR1 & (I2C_SR1_ADDR | I2C_SR1_AF)) == 0);
;;;772         
;;;773    		/* Check if the ADDR flag has been set */
;;;774    		if (tmpSR1 & I2C_SR1_ADDR)
;;;775    		{	
;;;776    			/* Clear ADDR Flag by reading SR1 then SR2 registers (SR1 have already been read) */
;;;777    			(void)sEE_I2C->SR2;
;;;778          
;;;779    			/*!< STOP condition */    
;;;780    			I2C_GenerateSTOP(sEE_I2C, ENABLE);
;;;781            
;;;782    			/* Exit the function */
;;;783    			return sEE_OK;
;;;784    		}
;;;785    		else
;;;786    		{
;;;787    			/*!< Clear AF flag */
;;;788    			I2C_ClearFlag(sEE_I2C, I2C_FLAG_AF);                  
;;;789    		}
;;;790        
;;;791    		/* Check if the maximum allowed number of trials has bee reached */
;;;792    		if (sEETrials++ == sEE_MAX_TRIALS_NUMBER)
;;;793    		{
;;;794    			/* If the maximum number of trials has been reached, exit the function */
;;;795    			return sEE_TIMEOUT_UserCallback();
;;;796    		}
;;;797    	}
;;;798    #endif
;;;799    }
0004e8  4770              BX       lr
;;;800    
                          ENDP

                  sEE_WritePage PROC
;;;437      */
;;;438    uint32_t sEE_WritePage(uint8_t* pBuffer, uint16_t WriteAddr, uint16_t* NumByteToWrite)
0004ea  b570              PUSH     {r4-r6,lr}
;;;439    { 
0004ec  4606              MOV      r6,r0
0004ee  460d              MOV      r5,r1
0004f0  4614              MOV      r4,r2
;;;440    	/*	Set the pointer to the Number of data to be written. This pointer will be used 
;;;441    		by the DMA Transfer Completer interrupt Handler in order to reset the 
;;;442    		variable to 0. User should check on this variable in order to know if the 
;;;443    		DMA transfer has been complete or not. */
;;;444    	sEEDataWritePointer = NumByteToWrite;  
0004f2  48d6              LDR      r0,|L1.2124|
0004f4  6004              STR      r4,[r0,#0]  ; sEEDataWritePointer
;;;445      
;;;446    	/*!< While the bus is busy */
;;;447    	sEETimeout = sEE_LONG_TIMEOUT;
0004f6  f44f4020          MOV      r0,#0xa000
0004fa  49d0              LDR      r1,|L1.2108|
0004fc  6008              STR      r0,[r1,#0]  ; sEETimeout
;;;448    	while(I2C_GetFlagStatus(sEE_I2C, I2C_FLAG_BUSY))
0004fe  e008              B        |L1.1298|
                  |L1.1280|
;;;449    	{
;;;450    		if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
000500  49ce              LDR      r1,|L1.2108|
000502  6808              LDR      r0,[r1,#0]  ; sEETimeout
000504  1e41              SUBS     r1,r0,#1
000506  4acd              LDR      r2,|L1.2108|
000508  6011              STR      r1,[r2,#0]  ; sEETimeout
00050a  b910              CBNZ     r0,|L1.1298|
00050c  f7fffffe          BL       sEE_TIMEOUT_UserCallback
                  |L1.1296|
;;;451    	}
;;;452      
;;;453    	/*!< Send START condition */
;;;454    	I2C_GenerateSTART(sEE_I2C, ENABLE);
;;;455      
;;;456    	/*!< Test on EV5 and clear it */
;;;457    	sEETimeout = sEE_FLAG_TIMEOUT;
;;;458    	while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_MODE_SELECT))
;;;459    	{
;;;460    		if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
;;;461    	}
;;;462      
;;;463    	/*!< Send EEPROM address for write */
;;;464    	sEETimeout = sEE_FLAG_TIMEOUT;
;;;465    	I2C_Send7bitAddress(sEE_I2C, sEEAddress, I2C_Direction_Transmitter);
;;;466    
;;;467    	/*!< Test on EV6 and clear it */
;;;468    	sEETimeout = sEE_FLAG_TIMEOUT;
;;;469    	while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
;;;470    	{
;;;471    		if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
;;;472    	}
;;;473    
;;;474    #if defined sEE_M24C08 || defined sEE_AT24C02 || defined sEE_FM24CL04B
;;;475      
;;;476    	/*!< Send the EEPROM's internal address to write to : only one byte Address */
;;;477    	I2C_SendData(sEE_I2C, WriteAddr);
;;;478      
;;;479    #elif defined(sEE_M24C64_32)
;;;480      
;;;481    	/*!< Send the EEPROM's internal address to write to : MSB of the address first */
;;;482    	I2C_SendData(sEE_I2C, (uint8_t)((WriteAddr & 0xFF00) >> 8));
;;;483    
;;;484    	/*!< Test on EV8 and clear it */
;;;485    	sEETimeout = sEE_FLAG_TIMEOUT;  
;;;486    	while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING))
;;;487    	{
;;;488    		if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
;;;489    	}  
;;;490      
;;;491    	/*!< Send the EEPROM's internal address to write to : LSB of the address */
;;;492    	I2C_SendData(sEE_I2C, (uint8_t)(WriteAddr & 0x00FF));
;;;493      
;;;494    #endif /*!< sEE_M24C08 */  
;;;495      
;;;496    	/*!< Test on EV8 and clear it */
;;;497    	sEETimeout = sEE_FLAG_TIMEOUT; 
;;;498    	while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING))
;;;499    	{
;;;500    		if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
;;;501    	}  
;;;502      
;;;503    	/* Configure the DMA Tx Channel with the buffer address and the buffer size */
;;;504    	sEE_LowLevel_DMAConfig((uint32_t)pBuffer, (uint8_t)(*NumByteToWrite), sEE_DIRECTION_TX);
;;;505      
;;;506    	/* Enable the DMA Tx Stream */
;;;507    	DMA_Cmd(sEE_I2C_DMA_STREAM_TX, ENABLE);
;;;508      
;;;509    	/* If all operations OK, return sEE_OK (0) */
;;;510    	return sEE_OK;
;;;511    }
000510  bd70              POP      {r4-r6,pc}
                  |L1.1298|
000512  f44f3100          MOV      r1,#0x20000           ;448
000516  48ca              LDR      r0,|L1.2112|
000518  f7fffffe          BL       I2C_GetFlagStatus
00051c  2800              CMP      r0,#0                 ;448
00051e  d1ef              BNE      |L1.1280|
000520  2101              MOVS     r1,#1                 ;454
000522  48c7              LDR      r0,|L1.2112|
000524  f7fffffe          BL       I2C_GenerateSTART
000528  f44f5080          MOV      r0,#0x1000            ;457
00052c  49c3              LDR      r1,|L1.2108|
00052e  6008              STR      r0,[r1,#0]            ;457  ; sEETimeout
000530  e008              B        |L1.1348|
                  |L1.1330|
000532  49c2              LDR      r1,|L1.2108|
000534  6808              LDR      r0,[r1,#0]            ;460  ; sEETimeout
000536  1e41              SUBS     r1,r0,#1              ;460
000538  4ac0              LDR      r2,|L1.2108|
00053a  6011              STR      r1,[r2,#0]            ;460  ; sEETimeout
00053c  b910              CBNZ     r0,|L1.1348|
00053e  f7fffffe          BL       sEE_TIMEOUT_UserCallback
000542  e7e5              B        |L1.1296|
                  |L1.1348|
000544  49bf              LDR      r1,|L1.2116|
000546  1e49              SUBS     r1,r1,#1              ;458
000548  48bd              LDR      r0,|L1.2112|
00054a  f7fffffe          BL       I2C_CheckEvent
00054e  2800              CMP      r0,#0                 ;458
000550  d0ef              BEQ      |L1.1330|
000552  f44f5080          MOV      r0,#0x1000            ;464
000556  49b9              LDR      r1,|L1.2108|
000558  6008              STR      r0,[r1,#0]            ;464  ; sEETimeout
00055a  f04f0200          MOV      r2,#0                 ;465
00055e  48bc              LDR      r0,|L1.2128|
000560  8800              LDRH     r0,[r0,#0]            ;465  ; sEEAddress
000562  b2c1              UXTB     r1,r0                 ;465
000564  48b6              LDR      r0,|L1.2112|
000566  f7fffffe          BL       I2C_Send7bitAddress
00056a  f44f5080          MOV      r0,#0x1000            ;468
00056e  49b3              LDR      r1,|L1.2108|
000570  6008              STR      r0,[r1,#0]            ;468  ; sEETimeout
000572  e008              B        |L1.1414|
                  |L1.1396|
000574  49b1              LDR      r1,|L1.2108|
000576  6808              LDR      r0,[r1,#0]            ;471  ; sEETimeout
000578  1e41              SUBS     r1,r0,#1              ;471
00057a  4ab0              LDR      r2,|L1.2108|
00057c  6011              STR      r1,[r2,#0]            ;471  ; sEETimeout
00057e  b910              CBNZ     r0,|L1.1414|
000580  f7fffffe          BL       sEE_TIMEOUT_UserCallback
000584  e7c4              B        |L1.1296|
                  |L1.1414|
000586  49b3              LDR      r1,|L1.2132|
000588  48ad              LDR      r0,|L1.2112|
00058a  f7fffffe          BL       I2C_CheckEvent
00058e  2800              CMP      r0,#0                 ;469
000590  d0f0              BEQ      |L1.1396|
000592  b2e9              UXTB     r1,r5                 ;477
000594  48aa              LDR      r0,|L1.2112|
000596  f7fffffe          BL       I2C_SendData
00059a  f44f5080          MOV      r0,#0x1000            ;497
00059e  49a7              LDR      r1,|L1.2108|
0005a0  6008              STR      r0,[r1,#0]            ;497  ; sEETimeout
0005a2  e008              B        |L1.1462|
                  |L1.1444|
0005a4  49a5              LDR      r1,|L1.2108|
0005a6  6808              LDR      r0,[r1,#0]            ;500  ; sEETimeout
0005a8  1e41              SUBS     r1,r0,#1              ;500
0005aa  4aa4              LDR      r2,|L1.2108|
0005ac  6011              STR      r1,[r2,#0]            ;500  ; sEETimeout
0005ae  b910              CBNZ     r0,|L1.1462|
0005b0  f7fffffe          BL       sEE_TIMEOUT_UserCallback
0005b4  e7ac              B        |L1.1296|
                  |L1.1462|
0005b6  49a7              LDR      r1,|L1.2132|
0005b8  1e89              SUBS     r1,r1,#2              ;498
0005ba  48a1              LDR      r0,|L1.2112|
0005bc  f7fffffe          BL       I2C_CheckEvent
0005c0  2800              CMP      r0,#0                 ;498
0005c2  d0ef              BEQ      |L1.1444|
0005c4  8820              LDRH     r0,[r4,#0]            ;504
0005c6  b2c1              UXTB     r1,r0                 ;504
0005c8  2200              MOVS     r2,#0                 ;504
0005ca  4630              MOV      r0,r6                 ;504
0005cc  f7fffffe          BL       sEE_LowLevel_DMAConfig
0005d0  2101              MOVS     r1,#1                 ;507
0005d2  489d              LDR      r0,|L1.2120|
0005d4  3090              ADDS     r0,r0,#0x90           ;507
0005d6  f7fffffe          BL       DMA_Cmd
0005da  2000              MOVS     r0,#0                 ;510
0005dc  e798              B        |L1.1296|
;;;512    
                          ENDP

                  sEE_WriteBuffer PROC
;;;520      */
;;;521    void sEE_WriteBuffer(uint8_t* pBuffer, uint16_t WriteAddr, uint16_t NumByteToWrite)
0005de  e92d47f0          PUSH     {r4-r10,lr}
;;;522    {
0005e2  4680              MOV      r8,r0
0005e4  460e              MOV      r6,r1
0005e6  4615              MOV      r5,r2
;;;523    	uint8_t NumOfPage = 0, NumOfSingle = 0, count = 0;
0005e8  f04f0900          MOV      r9,#0
0005ec  464f              MOV      r7,r9
0005ee  463c              MOV      r4,r7
;;;524    	uint16_t Addr = 0;
0005f0  46a2              MOV      r10,r4
;;;525    
;;;526    	Addr = WriteAddr % sEE_PAGESIZE;
0005f2  f0060aff          AND      r10,r6,#0xff
;;;527    	count = sEE_PAGESIZE - Addr;
0005f6  f1ca0000          RSB      r0,r10,#0
0005fa  b2c4              UXTB     r4,r0
;;;528    	NumOfPage =  NumByteToWrite / sEE_PAGESIZE;
0005fc  ea4f2915          LSR      r9,r5,#8
;;;529    	NumOfSingle = NumByteToWrite % sEE_PAGESIZE;
000600  b2ef              UXTB     r7,r5
;;;530     
;;;531    	/*!< If WriteAddr is sEE_PAGESIZE aligned  */
;;;532    	if(Addr == 0) 
000602  f1ba0f00          CMP      r10,#0
000606  d167              BNE      |L1.1752|
;;;533    	{
;;;534    		/*!< If NumByteToWrite < sEE_PAGESIZE */
;;;535    		if(NumOfPage == 0) 
000608  f1b90f00          CMP      r9,#0
00060c  d11c              BNE      |L1.1608|
;;;536    		{
;;;537    			/* Store the number of data to be written */
;;;538    			sEEDataNum = NumOfSingle;
00060e  4892              LDR      r0,|L1.2136|
000610  8007              STRH     r7,[r0,#0]
;;;539    			/* Start writing data */
;;;540    			sEE_WritePage(pBuffer, WriteAddr, (uint16_t*)(&sEEDataNum));
000612  4602              MOV      r2,r0
000614  4631              MOV      r1,r6
000616  4640              MOV      r0,r8
000618  f7fffffe          BL       sEE_WritePage
;;;541    			/* Wait transfer through DMA to be complete */
;;;542    
;;;543    			sEETimeout = sEE_LONG_TIMEOUT;
00061c  f44f4020          MOV      r0,#0xa000
000620  4986              LDR      r1,|L1.2108|
000622  6008              STR      r0,[r1,#0]  ; sEETimeout
;;;544    			while (sEEDataNum > 0)
000624  e009              B        |L1.1594|
                  |L1.1574|
;;;545    			{
;;;546    				if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
000626  4985              LDR      r1,|L1.2108|
000628  6808              LDR      r0,[r1,#0]  ; sEETimeout
00062a  1e41              SUBS     r1,r0,#1
00062c  4a83              LDR      r2,|L1.2108|
00062e  6011              STR      r1,[r2,#0]  ; sEETimeout
000630  b918              CBNZ     r0,|L1.1594|
000632  f7fffffe          BL       sEE_TIMEOUT_UserCallback
                  |L1.1590|
;;;547    			}
;;;548    			sEE_WaitEepromStandbyState();
;;;549    		}
;;;550    		/*!< If NumByteToWrite > sEE_PAGESIZE */
;;;551    		else  
;;;552    		{
;;;553    			while(NumOfPage--)
;;;554    			{
;;;555    				/* Store the number of data to be written */
;;;556    				sEEDataNum = sEE_PAGESIZE;        
;;;557    				sEE_WritePage(pBuffer, WriteAddr, (uint16_t*)(&sEEDataNum)); 
;;;558    				/* Wait transfer through DMA to be complete */
;;;559    				sEETimeout = sEE_LONG_TIMEOUT;
;;;560    				while (sEEDataNum > 0)
;;;561    				{
;;;562    					if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
;;;563    				}      
;;;564    				sEE_WaitEepromStandbyState();
;;;565    				WriteAddr +=  sEE_PAGESIZE;
;;;566    				pBuffer += sEE_PAGESIZE;
;;;567    			}
;;;568    
;;;569    			if(NumOfSingle!=0)
;;;570    			{
;;;571    				/* Store the number of data to be written */
;;;572    				sEEDataNum = NumOfSingle;          
;;;573    				sEE_WritePage(pBuffer, WriteAddr, (uint16_t*)(&sEEDataNum));
;;;574    				/* Wait transfer through DMA to be complete */
;;;575    				sEETimeout = sEE_LONG_TIMEOUT;
;;;576    				while (sEEDataNum > 0)
;;;577    				{
;;;578    					if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
;;;579    				}    
;;;580    				sEE_WaitEepromStandbyState();
;;;581    			}
;;;582    		}
;;;583    	}
;;;584    	/*!< If WriteAddr is not sEE_PAGESIZE aligned  */
;;;585    	else 
;;;586    	{
;;;587    		/*!< If NumByteToWrite < sEE_PAGESIZE */
;;;588    		if(NumOfPage== 0) 
;;;589    		{
;;;590    			/*!< If the number of data to be written is more than the remaining space 
;;;591    				in the current page: */
;;;592    			if (NumByteToWrite > count)
;;;593    			{
;;;594    				/* Store the number of data to be written */
;;;595    				sEEDataNum = count;        
;;;596    				/*!< Write the data contained in same page */
;;;597    				sEE_WritePage(pBuffer, WriteAddr, (uint16_t*)(&sEEDataNum));
;;;598    				/* Wait transfer through DMA to be complete */
;;;599    				sEETimeout = sEE_LONG_TIMEOUT;
;;;600    				while (sEEDataNum > 0)
;;;601    				{
;;;602    					if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
;;;603    				}          
;;;604    				sEE_WaitEepromStandbyState();      
;;;605            
;;;606    				/* Store the number of data to be written */
;;;607    				sEEDataNum = (NumByteToWrite - count);          
;;;608    				/*!< Write the remaining data in the following page */
;;;609    				sEE_WritePage((uint8_t*)(pBuffer + count), (WriteAddr + count), (uint16_t*)(&sEEDataNum));
;;;610    				/* Wait transfer through DMA to be complete */
;;;611    				sEETimeout = sEE_LONG_TIMEOUT;
;;;612    				while (sEEDataNum > 0)
;;;613    				{
;;;614    					if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
;;;615    				}     
;;;616    				sEE_WaitEepromStandbyState();        
;;;617    			}      
;;;618    			else      
;;;619    			{
;;;620    				/* Store the number of data to be written */
;;;621    				sEEDataNum = NumOfSingle;         
;;;622    				sEE_WritePage(pBuffer, WriteAddr, (uint16_t*)(&sEEDataNum));
;;;623    				/* Wait transfer through DMA to be complete */
;;;624    				sEETimeout = sEE_LONG_TIMEOUT;
;;;625    				while (sEEDataNum > 0)
;;;626    				{
;;;627    					if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
;;;628    				}          
;;;629    				sEE_WaitEepromStandbyState();        
;;;630    			}     
;;;631    		}
;;;632    		/*!< If NumByteToWrite > sEE_PAGESIZE */
;;;633    		else
;;;634    		{
;;;635    			NumByteToWrite -= count;
;;;636    			NumOfPage =  NumByteToWrite / sEE_PAGESIZE;
;;;637    			NumOfSingle = NumByteToWrite % sEE_PAGESIZE;
;;;638          
;;;639    			if(count != 0)
;;;640    			{  
;;;641    				/* Store the number of data to be written */
;;;642    				sEEDataNum = count;         
;;;643    				sEE_WritePage(pBuffer, WriteAddr, (uint16_t*)(&sEEDataNum));
;;;644    				/* Wait transfer through DMA to be complete */
;;;645    				sEETimeout = sEE_LONG_TIMEOUT;
;;;646    				while (sEEDataNum > 0)
;;;647    				{
;;;648    					if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
;;;649    				}     
;;;650    				sEE_WaitEepromStandbyState();
;;;651    				WriteAddr += count;
;;;652    				pBuffer += count;
;;;653    			} 
;;;654          
;;;655    			while(NumOfPage--)
;;;656    			{
;;;657    				/* Store the number of data to be written */
;;;658    				sEEDataNum = sEE_PAGESIZE;          
;;;659    				sEE_WritePage(pBuffer, WriteAddr, (uint16_t*)(&sEEDataNum));
;;;660    				/* Wait transfer through DMA to be complete */
;;;661    				sEETimeout = sEE_LONG_TIMEOUT;
;;;662    				while (sEEDataNum > 0)
;;;663    				{
;;;664    					if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
;;;665    				}        
;;;666    				sEE_WaitEepromStandbyState();
;;;667    				WriteAddr +=  sEE_PAGESIZE;
;;;668    				pBuffer += sEE_PAGESIZE;  
;;;669    			}
;;;670    			if(NumOfSingle != 0)
;;;671    			{
;;;672    				/* Store the number of data to be written */
;;;673    				sEEDataNum = NumOfSingle;           
;;;674    				sEE_WritePage(pBuffer, WriteAddr, (uint16_t*)(&sEEDataNum)); 
;;;675    				/* Wait transfer through DMA to be complete */
;;;676    				sEETimeout = sEE_LONG_TIMEOUT;
;;;677    				while (sEEDataNum > 0)
;;;678    				{
;;;679    					if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
;;;680    				}         
;;;681    				sEE_WaitEepromStandbyState();
;;;682    			}
;;;683    		}
;;;684    	}  
;;;685    }
000636  e8bd87f0          POP      {r4-r10,pc}
                  |L1.1594|
00063a  4887              LDR      r0,|L1.2136|
00063c  8800              LDRH     r0,[r0,#0]            ;544  ; sEEDataNum
00063e  2800              CMP      r0,#0                 ;544
000640  dcf1              BGT      |L1.1574|
000642  f7fffffe          BL       sEE_WaitEepromStandbyState
                  |L1.1606|
000646  e121              B        |L1.2188|
                  |L1.1608|
000648  e021              B        |L1.1678|
                  |L1.1610|
00064a  f44f7080          MOV      r0,#0x100             ;556
00064e  4982              LDR      r1,|L1.2136|
000650  8008              STRH     r0,[r1,#0]            ;556
000652  460a              MOV      r2,r1                 ;557
000654  4631              MOV      r1,r6                 ;557
000656  4640              MOV      r0,r8                 ;557
000658  f7fffffe          BL       sEE_WritePage
00065c  f44f4020          MOV      r0,#0xa000            ;559
000660  4976              LDR      r1,|L1.2108|
000662  6008              STR      r0,[r1,#0]            ;559  ; sEETimeout
000664  e008              B        |L1.1656|
                  |L1.1638|
000666  4975              LDR      r1,|L1.2108|
000668  6808              LDR      r0,[r1,#0]            ;562  ; sEETimeout
00066a  1e41              SUBS     r1,r0,#1              ;562
00066c  4a73              LDR      r2,|L1.2108|
00066e  6011              STR      r1,[r2,#0]            ;562  ; sEETimeout
000670  b910              CBNZ     r0,|L1.1656|
000672  f7fffffe          BL       sEE_TIMEOUT_UserCallback
000676  e7de              B        |L1.1590|
                  |L1.1656|
000678  4877              LDR      r0,|L1.2136|
00067a  8800              LDRH     r0,[r0,#0]            ;560  ; sEEDataNum
00067c  2800              CMP      r0,#0                 ;560
00067e  dcf2              BGT      |L1.1638|
000680  f7fffffe          BL       sEE_WaitEepromStandbyState
000684  f5067080          ADD      r0,r6,#0x100          ;565
000688  b286              UXTH     r6,r0                 ;565
00068a  f5087880          ADD      r8,r8,#0x100          ;566
                  |L1.1678|
00068e  ea5f0009          MOVS     r0,r9                 ;553
000692  f1a90101          SUB      r1,r9,#1              ;553
000696  f00109ff          AND      r9,r1,#0xff           ;553
00069a  d1d6              BNE      |L1.1610|
00069c  2f00              CMP      r7,#0                 ;569
00069e  d0d2              BEQ      |L1.1606|
0006a0  486d              LDR      r0,|L1.2136|
0006a2  8007              STRH     r7,[r0,#0]            ;572
0006a4  4602              MOV      r2,r0                 ;573
0006a6  4631              MOV      r1,r6                 ;573
0006a8  4640              MOV      r0,r8                 ;573
0006aa  f7fffffe          BL       sEE_WritePage
0006ae  f44f4020          MOV      r0,#0xa000            ;575
0006b2  4962              LDR      r1,|L1.2108|
0006b4  6008              STR      r0,[r1,#0]            ;575  ; sEETimeout
0006b6  e008              B        |L1.1738|
                  |L1.1720|
0006b8  4960              LDR      r1,|L1.2108|
0006ba  6808              LDR      r0,[r1,#0]            ;578  ; sEETimeout
0006bc  1e41              SUBS     r1,r0,#1              ;578
0006be  4a5f              LDR      r2,|L1.2108|
0006c0  6011              STR      r1,[r2,#0]            ;578  ; sEETimeout
0006c2  b910              CBNZ     r0,|L1.1738|
0006c4  f7fffffe          BL       sEE_TIMEOUT_UserCallback
0006c8  e7b5              B        |L1.1590|
                  |L1.1738|
0006ca  4863              LDR      r0,|L1.2136|
0006cc  8800              LDRH     r0,[r0,#0]            ;576  ; sEEDataNum
0006ce  2800              CMP      r0,#0                 ;576
0006d0  dcf2              BGT      |L1.1720|
0006d2  f7fffffe          BL       sEE_WaitEepromStandbyState
0006d6  e0d9              B        |L1.2188|
                  |L1.1752|
0006d8  f1b90f00          CMP      r9,#0                 ;588
0006dc  d159              BNE      |L1.1938|
0006de  42a5              CMP      r5,r4                 ;592
0006e0  dd3b              BLE      |L1.1882|
0006e2  485d              LDR      r0,|L1.2136|
0006e4  8004              STRH     r4,[r0,#0]            ;595
0006e6  4602              MOV      r2,r0                 ;597
0006e8  4631              MOV      r1,r6                 ;597
0006ea  4640              MOV      r0,r8                 ;597
0006ec  f7fffffe          BL       sEE_WritePage
0006f0  f44f4020          MOV      r0,#0xa000            ;599
0006f4  4951              LDR      r1,|L1.2108|
0006f6  6008              STR      r0,[r1,#0]            ;599  ; sEETimeout
0006f8  e008              B        |L1.1804|
                  |L1.1786|
0006fa  4950              LDR      r1,|L1.2108|
0006fc  6808              LDR      r0,[r1,#0]            ;602  ; sEETimeout
0006fe  1e41              SUBS     r1,r0,#1              ;602
000700  4a4e              LDR      r2,|L1.2108|
000702  6011              STR      r1,[r2,#0]            ;602  ; sEETimeout
000704  b910              CBNZ     r0,|L1.1804|
000706  f7fffffe          BL       sEE_TIMEOUT_UserCallback
00070a  e794              B        |L1.1590|
                  |L1.1804|
00070c  4852              LDR      r0,|L1.2136|
00070e  8800              LDRH     r0,[r0,#0]            ;600  ; sEEDataNum
000710  2800              CMP      r0,#0                 ;600
000712  dcf2              BGT      |L1.1786|
000714  f7fffffe          BL       sEE_WaitEepromStandbyState
000718  eba50004          SUB      r0,r5,r4              ;607
00071c  494e              LDR      r1,|L1.2136|
00071e  8008              STRH     r0,[r1,#0]            ;607
000720  eb060204          ADD      r2,r6,r4              ;609
000724  b291              UXTH     r1,r2                 ;609
000726  eb080004          ADD      r0,r8,r4              ;609
00072a  4a4b              LDR      r2,|L1.2136|
00072c  f7fffffe          BL       sEE_WritePage
000730  f44f4020          MOV      r0,#0xa000            ;611
000734  4941              LDR      r1,|L1.2108|
000736  6008              STR      r0,[r1,#0]            ;611  ; sEETimeout
000738  e008              B        |L1.1868|
                  |L1.1850|
00073a  4940              LDR      r1,|L1.2108|
00073c  6808              LDR      r0,[r1,#0]            ;614  ; sEETimeout
00073e  1e41              SUBS     r1,r0,#1              ;614
000740  4a3e              LDR      r2,|L1.2108|
000742  6011              STR      r1,[r2,#0]            ;614  ; sEETimeout
000744  b910              CBNZ     r0,|L1.1868|
000746  f7fffffe          BL       sEE_TIMEOUT_UserCallback
00074a  e774              B        |L1.1590|
                  |L1.1868|
00074c  4842              LDR      r0,|L1.2136|
00074e  8800              LDRH     r0,[r0,#0]            ;612  ; sEEDataNum
000750  2800              CMP      r0,#0                 ;612
000752  dcf2              BGT      |L1.1850|
000754  f7fffffe          BL       sEE_WaitEepromStandbyState
000758  e098              B        |L1.2188|
                  |L1.1882|
00075a  483f              LDR      r0,|L1.2136|
00075c  8007              STRH     r7,[r0,#0]            ;621
00075e  4602              MOV      r2,r0                 ;622
000760  4631              MOV      r1,r6                 ;622
000762  4640              MOV      r0,r8                 ;622
000764  f7fffffe          BL       sEE_WritePage
000768  f44f4020          MOV      r0,#0xa000            ;624
00076c  4933              LDR      r1,|L1.2108|
00076e  6008              STR      r0,[r1,#0]            ;624  ; sEETimeout
000770  e008              B        |L1.1924|
                  |L1.1906|
000772  4932              LDR      r1,|L1.2108|
000774  6808              LDR      r0,[r1,#0]            ;627  ; sEETimeout
000776  1e41              SUBS     r1,r0,#1              ;627
000778  4a30              LDR      r2,|L1.2108|
00077a  6011              STR      r1,[r2,#0]            ;627  ; sEETimeout
00077c  b910              CBNZ     r0,|L1.1924|
00077e  f7fffffe          BL       sEE_TIMEOUT_UserCallback
000782  e758              B        |L1.1590|
                  |L1.1924|
000784  4834              LDR      r0,|L1.2136|
000786  8800              LDRH     r0,[r0,#0]            ;625  ; sEEDataNum
000788  2800              CMP      r0,#0                 ;625
00078a  dcf2              BGT      |L1.1906|
00078c  f7fffffe          BL       sEE_WaitEepromStandbyState
000790  e07c              B        |L1.2188|
                  |L1.1938|
000792  eba50004          SUB      r0,r5,r4              ;635
000796  b285              UXTH     r5,r0                 ;635
000798  ea4f2915          LSR      r9,r5,#8              ;636
00079c  b2ef              UXTB     r7,r5                 ;637
00079e  b1f4              CBZ      r4,|L1.2014|
0007a0  482d              LDR      r0,|L1.2136|
0007a2  8004              STRH     r4,[r0,#0]            ;642
0007a4  4602              MOV      r2,r0                 ;643
0007a6  4631              MOV      r1,r6                 ;643
0007a8  4640              MOV      r0,r8                 ;643
0007aa  f7fffffe          BL       sEE_WritePage
0007ae  f44f4020          MOV      r0,#0xa000            ;645
0007b2  4922              LDR      r1,|L1.2108|
0007b4  6008              STR      r0,[r1,#0]            ;645  ; sEETimeout
0007b6  e008              B        |L1.1994|
                  |L1.1976|
0007b8  4920              LDR      r1,|L1.2108|
0007ba  6808              LDR      r0,[r1,#0]            ;648  ; sEETimeout
0007bc  1e41              SUBS     r1,r0,#1              ;648
0007be  4a1f              LDR      r2,|L1.2108|
0007c0  6011              STR      r1,[r2,#0]            ;648  ; sEETimeout
0007c2  b910              CBNZ     r0,|L1.1994|
0007c4  f7fffffe          BL       sEE_TIMEOUT_UserCallback
0007c8  e735              B        |L1.1590|
                  |L1.1994|
0007ca  4823              LDR      r0,|L1.2136|
0007cc  8800              LDRH     r0,[r0,#0]            ;646  ; sEEDataNum
0007ce  2800              CMP      r0,#0                 ;646
0007d0  dcf2              BGT      |L1.1976|
0007d2  f7fffffe          BL       sEE_WaitEepromStandbyState
0007d6  eb060004          ADD      r0,r6,r4              ;651
0007da  b286              UXTH     r6,r0                 ;651
0007dc  44a0              ADD      r8,r8,r4              ;652
                  |L1.2014|
0007de  e021              B        |L1.2084|
                  |L1.2016|
0007e0  f44f7080          MOV      r0,#0x100             ;658
0007e4  491c              LDR      r1,|L1.2136|
0007e6  8008              STRH     r0,[r1,#0]            ;658
0007e8  460a              MOV      r2,r1                 ;659
0007ea  4631              MOV      r1,r6                 ;659
0007ec  4640              MOV      r0,r8                 ;659
0007ee  f7fffffe          BL       sEE_WritePage
0007f2  f44f4020          MOV      r0,#0xa000            ;661
0007f6  4911              LDR      r1,|L1.2108|
0007f8  6008              STR      r0,[r1,#0]            ;661  ; sEETimeout
0007fa  e008              B        |L1.2062|
                  |L1.2044|
0007fc  490f              LDR      r1,|L1.2108|
0007fe  6808              LDR      r0,[r1,#0]            ;664  ; sEETimeout
000800  1e41              SUBS     r1,r0,#1              ;664
000802  4a0e              LDR      r2,|L1.2108|
000804  6011              STR      r1,[r2,#0]            ;664  ; sEETimeout
000806  b910              CBNZ     r0,|L1.2062|
000808  f7fffffe          BL       sEE_TIMEOUT_UserCallback
00080c  e713              B        |L1.1590|
                  |L1.2062|
00080e  4812              LDR      r0,|L1.2136|
000810  8800              LDRH     r0,[r0,#0]            ;662  ; sEEDataNum
000812  2800              CMP      r0,#0                 ;662
000814  dcf2              BGT      |L1.2044|
000816  f7fffffe          BL       sEE_WaitEepromStandbyState
00081a  f5067080          ADD      r0,r6,#0x100          ;667
00081e  b286              UXTH     r6,r0                 ;667
000820  f5087880          ADD      r8,r8,#0x100          ;668
                  |L1.2084|
000824  ea5f0009          MOVS     r0,r9                 ;655
000828  f1a90101          SUB      r1,r9,#1              ;655
00082c  f00109ff          AND      r9,r1,#0xff           ;655
000830  d1d6              BNE      |L1.2016|
000832  b35f              CBZ      r7,|L1.2188|
000834  4808              LDR      r0,|L1.2136|
000836  8007              STRH     r7,[r0,#0]            ;673
000838  4602              MOV      r2,r0                 ;674
00083a  e00f              B        |L1.2140|
                  |L1.2108|
                          DCD      sEETimeout
                  |L1.2112|
                          DCD      0x40005400
                  |L1.2116|
                          DCD      0x00030002
                  |L1.2120|
                          DCD      0x40026010
                  |L1.2124|
                          DCD      sEEDataWritePointer
                  |L1.2128|
                          DCD      sEEAddress
                  |L1.2132|
                          DCD      0x00070082
                  |L1.2136|
                          DCD      sEEDataNum
                  |L1.2140|
00085c  4631              MOV      r1,r6                 ;674
00085e  4640              MOV      r0,r8                 ;674
000860  f7fffffe          BL       sEE_WritePage
000864  f44f4020          MOV      r0,#0xa000            ;676
000868  4935              LDR      r1,|L1.2368|
00086a  6008              STR      r0,[r1,#0]            ;676  ; sEETimeout
00086c  e008              B        |L1.2176|
                  |L1.2158|
00086e  4934              LDR      r1,|L1.2368|
000870  6808              LDR      r0,[r1,#0]            ;679  ; sEETimeout
000872  1e41              SUBS     r1,r0,#1              ;679
000874  4a32              LDR      r2,|L1.2368|
000876  6011              STR      r1,[r2,#0]            ;679  ; sEETimeout
000878  b910              CBNZ     r0,|L1.2176|
00087a  f7fffffe          BL       sEE_TIMEOUT_UserCallback
00087e  e6da              B        |L1.1590|
                  |L1.2176|
000880  4830              LDR      r0,|L1.2372|
000882  8800              LDRH     r0,[r0,#0]            ;677  ; sEEDataNum
000884  2800              CMP      r0,#0                 ;677
000886  dcf2              BGT      |L1.2158|
000888  f7fffffe          BL       sEE_WaitEepromStandbyState
                  |L1.2188|
00088c  bf00              NOP      
00088e  e6d2              B        |L1.1590|
;;;686    
                          ENDP

                  BSP_WriteI2C1 PROC
;;;144    
;;;145    uint8_t BSP_WriteI2C1(uint8_t *buf, uint16_t WriteAddr, uint16_t NumByteToWrite)
000890  e92d41f0          PUSH     {r4-r8,lr}
;;;146    {	
000894  4604              MOV      r4,r0
000896  460d              MOV      r5,r1
000898  4616              MOV      r6,r2
;;;147    	uint8_t err;
;;;148    	
;;;149    	FLASH_WP_DISABLE;
00089a  f04f0004          MOV      r0,#4
00089e  492a              LDR      r1,|L1.2376|
0008a0  8348              STRH     r0,[r1,#0x1a]
;;;150    	sEE_WriteBuffer(buf, WriteAddr, NumByteToWrite);
0008a2  4632              MOV      r2,r6
0008a4  4629              MOV      r1,r5
0008a6  4620              MOV      r0,r4
0008a8  f7fffffe          BL       sEE_WriteBuffer
;;;151    	/* Wait for EEPROM standby state */
;;;152    	err = sEE_WaitEepromStandbyState();  
0008ac  f7fffffe          BL       sEE_WaitEepromStandbyState
0008b0  b2c7              UXTB     r7,r0
;;;153    	FLASH_WP_ENABLE;
0008b2  f04f0004          MOV      r0,#4
0008b6  4924              LDR      r1,|L1.2376|
0008b8  8308              STRH     r0,[r1,#0x18]
;;;154    	
;;;155    	if (err)
0008ba  b117              CBZ      r7,|L1.2242|
;;;156    		return 1;
0008bc  2001              MOVS     r0,#1
                  |L1.2238|
;;;157    	return 0;
;;;158    }
0008be  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2242|
0008c2  2000              MOVS     r0,#0                 ;157
0008c4  e7fb              B        |L1.2238|
;;;159    
                          ENDP

                  sEE_LowLevel_DeInit PROC
;;;817    
;;;818    void sEE_LowLevel_DeInit(void)
0008c6  b51c              PUSH     {r2-r4,lr}
;;;819    {
;;;820    	GPIO_InitTypeDef  GPIO_InitStructure; 
;;;821       
;;;822    	/* sEE_I2C Peripheral Disable */
;;;823    	I2C_Cmd(sEE_I2C, DISABLE);
0008c8  2100              MOVS     r1,#0
0008ca  4820              LDR      r0,|L1.2380|
0008cc  f7fffffe          BL       I2C_Cmd
;;;824     
;;;825    	/* sEE_I2C DeInit */
;;;826    	I2C_DeInit(sEE_I2C);
0008d0  481e              LDR      r0,|L1.2380|
0008d2  f7fffffe          BL       I2C_DeInit
;;;827    
;;;828    	/*!< sEE_I2C Periph clock disable */
;;;829    	RCC_APB1PeriphClockCmd(sEE_I2C_CLK, DISABLE);
0008d6  2100              MOVS     r1,#0
0008d8  f44f1000          MOV      r0,#0x200000
0008dc  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;830        
;;;831    	/*!< GPIO configuration */  
;;;832    	/*!< Configure sEE_I2C pins: SCL */
;;;833    	GPIO_InitStructure.GPIO_Pin = sEE_I2C_SCL_PIN;
0008e0  f04f0040          MOV      r0,#0x40
0008e4  9000              STR      r0,[sp,#0]
;;;834    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
0008e6  f04f0000          MOV      r0,#0
0008ea  f88d0004          STRB     r0,[sp,#4]
;;;835    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
0008ee  f88d0007          STRB     r0,[sp,#7]
;;;836    	GPIO_Init(sEE_I2C_SCL_GPIO_PORT, &GPIO_InitStructure);
0008f2  4669              MOV      r1,sp
0008f4  4816              LDR      r0,|L1.2384|
0008f6  f7fffffe          BL       GPIO_Init
;;;837    
;;;838    	/*!< Configure sEE_I2C pins: SDA */
;;;839    	GPIO_InitStructure.GPIO_Pin = sEE_I2C_SDA_PIN;
0008fa  f04f0080          MOV      r0,#0x80
0008fe  9000              STR      r0,[sp,#0]
;;;840    	GPIO_Init(sEE_I2C_SDA_GPIO_PORT, &GPIO_InitStructure);
000900  4669              MOV      r1,sp
000902  4813              LDR      r0,|L1.2384|
000904  f7fffffe          BL       GPIO_Init
;;;841    
;;;842    	/* Disable I2C DMA TX Stream interrupt */
;;;843    	BSP_IntDis(sEE_I2C_DMA_TX_IRQn);
000908  2011              MOVS     r0,#0x11
00090a  f7fffffe          BL       BSP_IntDis
;;;844    
;;;845    	/* Disable I2C DMA RX Stream interrupt */
;;;846    	BSP_IntDis(sEE_I2C_DMA_RX_IRQn);
00090e  200b              MOVS     r0,#0xb
000910  f7fffffe          BL       BSP_IntDis
;;;847      
;;;848    	/* Disable and Deinitialize the DMA Streams */
;;;849    	DMA_Cmd(sEE_I2C_DMA_STREAM_TX, DISABLE);
000914  2100              MOVS     r1,#0
000916  480f              LDR      r0,|L1.2388|
000918  f7fffffe          BL       DMA_Cmd
;;;850    	DMA_Cmd(sEE_I2C_DMA_STREAM_RX, DISABLE);
00091c  2100              MOVS     r1,#0
00091e  480d              LDR      r0,|L1.2388|
000920  3890              SUBS     r0,r0,#0x90
000922  f7fffffe          BL       DMA_Cmd
;;;851    	DMA_DeInit(sEE_I2C_DMA_STREAM_TX);
000926  480b              LDR      r0,|L1.2388|
000928  f7fffffe          BL       DMA_DeInit
;;;852    	DMA_DeInit(sEE_I2C_DMA_STREAM_RX);
00092c  4809              LDR      r0,|L1.2388|
00092e  3890              SUBS     r0,r0,#0x90
000930  f7fffffe          BL       DMA_DeInit
;;;853    }
000934  bd1c              POP      {r2-r4,pc}
;;;854    
                          ENDP

                  sEE_DeInit PROC
;;;177      */
;;;178    void sEE_DeInit(void)
000936  b510              PUSH     {r4,lr}
;;;179    {
;;;180    	sEE_LowLevel_DeInit(); 
000938  f7fffffe          BL       sEE_LowLevel_DeInit
;;;181    }
00093c  bd10              POP      {r4,pc}
;;;182    
                          ENDP

00093e  0000              DCW      0x0000
                  |L1.2368|
                          DCD      sEETimeout
                  |L1.2372|
                          DCD      sEEDataNum
                  |L1.2376|
                          DCD      0x40020000
                  |L1.2380|
                          DCD      0x40005400
                  |L1.2384|
                          DCD      0x40020400
                  |L1.2388|
                          DCD      0x400260a0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  sEEDMA_InitStructure
                          %        60

                          AREA ||.data||, DATA, ALIGN=2

                  cpu_sr
                          DCD      0x00000000
                  sEEAddress
000004  0000              DCW      0x0000
000006  0000              DCB      0x00,0x00
                  sEETimeout
                          DCD      0x0000a000
                  sEEDataReadPointer
                          DCD      0x00000000
                  sEEDataWritePointer
                          DCD      0x00000000
                  sEEDataNum
000014  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\BSP\\bsp_i2c.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_bsp_i2c_c_cpu_sr____REV16|
#line 112 "..\\BSP\\CMSIS\\core_cmInstr.h"
|__asm___9_bsp_i2c_c_cpu_sr____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_bsp_i2c_c_cpu_sr____REVSH|
#line 130
|__asm___9_bsp_i2c_c_cpu_sr____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
