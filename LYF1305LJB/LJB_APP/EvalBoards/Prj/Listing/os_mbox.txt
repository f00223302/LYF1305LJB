; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Output\os_mbox.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\Output\os_mbox.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\BSP -I..\BSP\UCOS-II -I..\BSP\STM32F2xx\inc -I..\BSP\CMSIS -I..\BSP\CMSIS\Device_Support -I..\BSP\UCOS-II -I..\..\uC-CPU -I..\..\uC-CPU\ARM-Cortex-M3 -I..\..\uC-LIB -I..\..\uC-LIB\Ports\ARM-Cortex-M3 -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3 -I..\App -I..\Prj -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DDEBUG -DLJB_CPU_MAIN -DUSE_CPU_F205RC --omf_browse=.\Output\os_mbox.crf ..\..\uCOS-II\Source\os_mbox.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  OSMboxAccept PROC
;;;48     #if OS_MBOX_ACCEPT_EN > 0u
;;;49     void  *OSMboxAccept (OS_EVENT *pevent)
000000  b570              PUSH     {r4-r6,lr}
;;;50     {
000002  4604              MOV      r4,r0
;;;51         void      *pmsg;
;;;52     #if OS_CRITICAL_METHOD == 3u                              /* Allocate storage for CPU status register  */
;;;53         OS_CPU_SR  cpu_sr = 0u;
000004  f04f0600          MOV      r6,#0
;;;54     #endif
;;;55     
;;;56     
;;;57     
;;;58     #if OS_ARG_CHK_EN > 0u
;;;59         if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
;;;60             return ((void *)0);
;;;61         }
;;;62     #endif
;;;63         if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
000008  7820              LDRB     r0,[r4,#0]
00000a  2801              CMP      r0,#1
00000c  d001              BEQ      |L1.18|
;;;64             return ((void *)0);
00000e  2000              MOVS     r0,#0
                  |L1.16|
;;;65         }
;;;66         OS_ENTER_CRITICAL();
;;;67         pmsg               = pevent->OSEventPtr;
;;;68         pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
;;;69         OS_EXIT_CRITICAL();
;;;70         return (pmsg);                                        /* Return the message received (or NULL)     */
;;;71     }
000010  bd70              POP      {r4-r6,pc}
                  |L1.18|
000012  f7fffffe          BL       OS_CPU_SR_Save
000016  4606              MOV      r6,r0                 ;66
000018  6865              LDR      r5,[r4,#4]            ;67
00001a  f04f0000          MOV      r0,#0                 ;68
00001e  6060              STR      r0,[r4,#4]            ;68
000020  4630              MOV      r0,r6                 ;69
000022  f7fffffe          BL       OS_CPU_SR_Restore
000026  4628              MOV      r0,r5                 ;70
000028  e7f2              B        |L1.16|
;;;72     #endif
                          ENDP

                  OSMboxCreate PROC
;;;89     
;;;90     OS_EVENT  *OSMboxCreate (void *pmsg)
00002a  b570              PUSH     {r4-r6,lr}
;;;91     {
00002c  4605              MOV      r5,r0
;;;92         OS_EVENT  *pevent;
;;;93     #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;94         OS_CPU_SR  cpu_sr = 0u;
00002e  f04f0600          MOV      r6,#0
;;;95     #endif
;;;96     
;;;97     
;;;98     
;;;99     #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;100        if (OSSafetyCriticalStartFlag == OS_TRUE) {
;;;101            OS_SAFETY_CRITICAL_EXCEPTION();
;;;102            return ((OS_EVENT *)0);
;;;103        }
;;;104    #endif
;;;105    
;;;106        if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
000032  48fd              LDR      r0,|L1.1064|
000034  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000036  b108              CBZ      r0,|L1.60|
;;;107            return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
000038  2000              MOVS     r0,#0
                  |L1.58|
;;;108        }
;;;109        OS_ENTER_CRITICAL();
;;;110        pevent = OSEventFreeList;                    /* Get next free event control block                  */
;;;111        if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
;;;112            OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
;;;113        }
;;;114        OS_EXIT_CRITICAL();
;;;115        if (pevent != (OS_EVENT *)0) {
;;;116            pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
;;;117            pevent->OSEventCnt     = 0u;
;;;118            pevent->OSEventPtr     = pmsg;           /* Deposit message in event control block             */
;;;119    #if OS_EVENT_NAME_EN > 0u
;;;120            pevent->OSEventName    = (INT8U *)(void *)"?";
;;;121    #endif
;;;122            OS_EventWaitListInit(pevent);
;;;123        }
;;;124        return (pevent);                             /* Return pointer to event control block              */
;;;125    }
00003a  bd70              POP      {r4-r6,pc}
                  |L1.60|
00003c  f7fffffe          BL       OS_CPU_SR_Save
000040  4606              MOV      r6,r0                 ;109
000042  48fa              LDR      r0,|L1.1068|
000044  6804              LDR      r4,[r0,#0]            ;110  ; OSEventFreeList
000046  6800              LDR      r0,[r0,#0]            ;111  ; OSEventFreeList
000048  b120              CBZ      r0,|L1.84|
00004a  48f8              LDR      r0,|L1.1068|
00004c  6800              LDR      r0,[r0,#0]            ;112  ; OSEventFreeList
00004e  6840              LDR      r0,[r0,#4]            ;112
000050  49f6              LDR      r1,|L1.1068|
000052  6008              STR      r0,[r1,#0]            ;112  ; OSEventFreeList
                  |L1.84|
000054  4630              MOV      r0,r6                 ;114
000056  f7fffffe          BL       OS_CPU_SR_Restore
00005a  b15c              CBZ      r4,|L1.116|
00005c  f04f0001          MOV      r0,#1                 ;116
000060  7020              STRB     r0,[r4,#0]            ;116
000062  f04f0000          MOV      r0,#0                 ;117
000066  8120              STRH     r0,[r4,#8]            ;117
000068  6065              STR      r5,[r4,#4]            ;118
00006a  a0f1              ADR      r0,|L1.1072|
00006c  6160              STR      r0,[r4,#0x14]         ;120
00006e  4620              MOV      r0,r4                 ;122
000070  f7fffffe          BL       OS_EventWaitListInit
                  |L1.116|
000074  4620              MOV      r0,r4                 ;124
000076  e7e0              B        |L1.58|
;;;126    /*$PAGE*/
                          ENDP

                  OSMboxDel PROC
;;;165    #if OS_MBOX_DEL_EN > 0u
;;;166    OS_EVENT  *OSMboxDel (OS_EVENT  *pevent,
000078  e92d47f0          PUSH     {r4-r10,lr}
;;;167                          INT8U      opt,
;;;168                          INT8U     *perr)
;;;169    {
00007c  4604              MOV      r4,r0
00007e  4688              MOV      r8,r1
000080  4615              MOV      r5,r2
;;;170        BOOLEAN    tasks_waiting;
;;;171        OS_EVENT  *pevent_return;
;;;172    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;173        OS_CPU_SR  cpu_sr = 0u;
000082  f04f0900          MOV      r9,#0
;;;174    #endif
;;;175    
;;;176    
;;;177    
;;;178    #ifdef OS_SAFETY_CRITICAL
;;;179        if (perr == (INT8U *)0) {
;;;180            OS_SAFETY_CRITICAL_EXCEPTION();
;;;181            return ((OS_EVENT *)0);
;;;182        }
;;;183    #endif
;;;184    
;;;185    #if OS_ARG_CHK_EN > 0u
;;;186        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;187            *perr = OS_ERR_PEVENT_NULL;
;;;188            return (pevent);
;;;189        }
;;;190    #endif
;;;191        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
000086  7820              LDRB     r0,[r4,#0]
000088  2801              CMP      r0,#1
00008a  d005              BEQ      |L1.152|
;;;192            *perr = OS_ERR_EVENT_TYPE;
00008c  f04f0001          MOV      r0,#1
000090  7028              STRB     r0,[r5,#0]
;;;193            return (pevent);
000092  4620              MOV      r0,r4
                  |L1.148|
;;;194        }
;;;195        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
;;;196            *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
;;;197            return (pevent);
;;;198        }
;;;199        OS_ENTER_CRITICAL();
;;;200        if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mailbox      */
;;;201            tasks_waiting = OS_TRUE;                           /* Yes                                      */
;;;202        } else {
;;;203            tasks_waiting = OS_FALSE;                          /* No                                       */
;;;204        }
;;;205        switch (opt) {
;;;206            case OS_DEL_NO_PEND:                               /* Delete mailbox only if no task waiting   */
;;;207                 if (tasks_waiting == OS_FALSE) {
;;;208    #if OS_EVENT_NAME_EN > 0u
;;;209                     pevent->OSEventName = (INT8U *)(void *)"?";
;;;210    #endif
;;;211                     pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
;;;212                     pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
;;;213                     pevent->OSEventCnt  = 0u;
;;;214                     OSEventFreeList     = pevent;             /* Get next free event control block        */
;;;215                     OS_EXIT_CRITICAL();
;;;216                     *perr               = OS_ERR_NONE;
;;;217                     pevent_return       = (OS_EVENT *)0;      /* Mailbox has been deleted                 */
;;;218                 } else {
;;;219                     OS_EXIT_CRITICAL();
;;;220                     *perr               = OS_ERR_TASK_WAITING;
;;;221                     pevent_return       = pevent;
;;;222                 }
;;;223                 break;
;;;224    
;;;225            case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
;;;226                 while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mailbox      */
;;;227                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
;;;228                 }
;;;229    #if OS_EVENT_NAME_EN > 0u
;;;230                 pevent->OSEventName    = (INT8U *)(void *)"?";
;;;231    #endif
;;;232                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;233                 pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
;;;234                 pevent->OSEventCnt     = 0u;
;;;235                 OSEventFreeList        = pevent;              /* Get next free event control block        */
;;;236                 OS_EXIT_CRITICAL();
;;;237                 if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
;;;238                     OS_Sched();                               /* Find highest priority task ready to run  */
;;;239                 }
;;;240                 *perr         = OS_ERR_NONE;
;;;241                 pevent_return = (OS_EVENT *)0;                /* Mailbox has been deleted                 */
;;;242                 break;
;;;243    
;;;244            default:
;;;245                 OS_EXIT_CRITICAL();
;;;246                 *perr         = OS_ERR_INVALID_OPT;
;;;247                 pevent_return = pevent;
;;;248                 break;
;;;249        }
;;;250        return (pevent_return);
;;;251    }
000094  e8bd87f0          POP      {r4-r10,pc}
                  |L1.152|
000098  48e3              LDR      r0,|L1.1064|
00009a  7800              LDRB     r0,[r0,#0]            ;195  ; OSIntNesting
00009c  b120              CBZ      r0,|L1.168|
00009e  f04f000f          MOV      r0,#0xf               ;196
0000a2  7028              STRB     r0,[r5,#0]            ;196
0000a4  4620              MOV      r0,r4                 ;197
0000a6  e7f5              B        |L1.148|
                  |L1.168|
0000a8  f7fffffe          BL       OS_CPU_SR_Save
0000ac  4681              MOV      r9,r0                 ;199
0000ae  7aa0              LDRB     r0,[r4,#0xa]          ;200
0000b0  b110              CBZ      r0,|L1.184|
0000b2  f04f0701          MOV      r7,#1                 ;201
0000b6  e001              B        |L1.188|
                  |L1.184|
0000b8  f04f0700          MOV      r7,#0                 ;203
                  |L1.188|
0000bc  f1b80f00          CMP      r8,#0                 ;205
0000c0  d003              BEQ      |L1.202|
0000c2  f1b80f01          CMP      r8,#1                 ;205
0000c6  d141              BNE      |L1.332|
0000c8  e01d              B        |L1.262|
                  |L1.202|
0000ca  b9a7              CBNZ     r7,|L1.246|
0000cc  a0d8              ADR      r0,|L1.1072|
0000ce  6160              STR      r0,[r4,#0x14]         ;209
0000d0  f04f0000          MOV      r0,#0                 ;211
0000d4  7020              STRB     r0,[r4,#0]            ;211
0000d6  48d5              LDR      r0,|L1.1068|
0000d8  6800              LDR      r0,[r0,#0]            ;212  ; OSEventFreeList
0000da  6060              STR      r0,[r4,#4]            ;212
0000dc  f04f0000          MOV      r0,#0                 ;213
0000e0  8120              STRH     r0,[r4,#8]            ;213
0000e2  48d2              LDR      r0,|L1.1068|
0000e4  6004              STR      r4,[r0,#0]            ;214  ; OSEventFreeList
0000e6  4648              MOV      r0,r9                 ;215
0000e8  f7fffffe          BL       OS_CPU_SR_Restore
0000ec  f04f0000          MOV      r0,#0                 ;216
0000f0  7028              STRB     r0,[r5,#0]            ;216
0000f2  4606              MOV      r6,r0                 ;217
0000f4  e006              B        |L1.260|
                  |L1.246|
0000f6  4648              MOV      r0,r9                 ;219
0000f8  f7fffffe          BL       OS_CPU_SR_Restore
0000fc  f04f0049          MOV      r0,#0x49              ;220
000100  7028              STRB     r0,[r5,#0]            ;220
000102  4626              MOV      r6,r4                 ;221
                  |L1.260|
000104  e02a              B        |L1.348|
                  |L1.262|
000106  e005              B        |L1.276|
                  |L1.264|
000108  2302              MOVS     r3,#2                 ;227
00010a  461a              MOV      r2,r3                 ;227
00010c  2100              MOVS     r1,#0                 ;227
00010e  4620              MOV      r0,r4                 ;227
000110  f7fffffe          BL       OS_EventTaskRdy
                  |L1.276|
000114  7aa0              LDRB     r0,[r4,#0xa]          ;226
000116  2800              CMP      r0,#0                 ;226
000118  d1f6              BNE      |L1.264|
00011a  a0c5              ADR      r0,|L1.1072|
00011c  6160              STR      r0,[r4,#0x14]         ;230
00011e  f04f0000          MOV      r0,#0                 ;232
000122  7020              STRB     r0,[r4,#0]            ;232
000124  48c1              LDR      r0,|L1.1068|
000126  6800              LDR      r0,[r0,#0]            ;233  ; OSEventFreeList
000128  6060              STR      r0,[r4,#4]            ;233
00012a  f04f0000          MOV      r0,#0                 ;234
00012e  8120              STRH     r0,[r4,#8]            ;234
000130  48be              LDR      r0,|L1.1068|
000132  6004              STR      r4,[r0,#0]            ;235  ; OSEventFreeList
000134  4648              MOV      r0,r9                 ;236
000136  f7fffffe          BL       OS_CPU_SR_Restore
00013a  2f01              CMP      r7,#1                 ;237
00013c  d101              BNE      |L1.322|
00013e  f7fffffe          BL       OS_Sched
                  |L1.322|
000142  f04f0000          MOV      r0,#0                 ;240
000146  7028              STRB     r0,[r5,#0]            ;240
000148  4606              MOV      r6,r0                 ;241
00014a  e007              B        |L1.348|
                  |L1.332|
00014c  4648              MOV      r0,r9                 ;245
00014e  f7fffffe          BL       OS_CPU_SR_Restore
000152  f04f0007          MOV      r0,#7                 ;246
000156  7028              STRB     r0,[r5,#0]            ;246
000158  4626              MOV      r6,r4                 ;247
00015a  bf00              NOP                            ;248
                  |L1.348|
00015c  bf00              NOP                            ;223
00015e  4630              MOV      r0,r6                 ;250
000160  e798              B        |L1.148|
;;;252    #endif
                          ENDP

                  OSMboxPend PROC
;;;287    /*$PAGE*/
;;;288    void  *OSMboxPend (OS_EVENT  *pevent,
000162  e92d41f0          PUSH     {r4-r8,lr}
;;;289                       INT32U     timeout,
;;;290                       INT8U     *perr)
;;;291    {
000166  4605              MOV      r5,r0
000168  460f              MOV      r7,r1
00016a  4614              MOV      r4,r2
;;;292        void      *pmsg;
;;;293    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;294        OS_CPU_SR  cpu_sr = 0u;
00016c  f04f0800          MOV      r8,#0
;;;295    #endif
;;;296    
;;;297    
;;;298    
;;;299    #ifdef OS_SAFETY_CRITICAL
;;;300        if (perr == (INT8U *)0) {
;;;301            OS_SAFETY_CRITICAL_EXCEPTION();
;;;302            return ((void *)0);
;;;303        }
;;;304    #endif
;;;305    
;;;306    #if OS_ARG_CHK_EN > 0u
;;;307        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;308            *perr = OS_ERR_PEVENT_NULL;
;;;309            return ((void *)0);
;;;310        }
;;;311    #endif
;;;312        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
000170  7828              LDRB     r0,[r5,#0]
000172  2801              CMP      r0,#1
000174  d006              BEQ      |L1.388|
;;;313            *perr = OS_ERR_EVENT_TYPE;
000176  f04f0001          MOV      r0,#1
00017a  7020              STRB     r0,[r4,#0]
;;;314            return ((void *)0);
00017c  f04f0000          MOV      r0,#0
                  |L1.384|
;;;315        }
;;;316        if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
;;;317            *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
;;;318            return ((void *)0);
;;;319        }
;;;320        if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
;;;321            *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
;;;322            return ((void *)0);
;;;323        }
;;;324        OS_ENTER_CRITICAL();
;;;325        pmsg = pevent->OSEventPtr;
;;;326        if (pmsg != (void *)0) {                          /* See if there is already a message             */
;;;327            pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
;;;328            OS_EXIT_CRITICAL();
;;;329            *perr = OS_ERR_NONE;
;;;330            return (pmsg);                                /* Return the message received (or NULL)         */
;;;331        }
;;;332        OSTCBCur->OSTCBStat     |= OS_STAT_MBOX;          /* Message not available, task will pend         */
;;;333        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;334        OSTCBCur->OSTCBDly       = timeout;               /* Load timeout in TCB                           */
;;;335        OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
;;;336        OS_EXIT_CRITICAL();
;;;337        OS_Sched();                                       /* Find next highest priority task ready to run  */
;;;338        OS_ENTER_CRITICAL();
;;;339        switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
;;;340            case OS_STAT_PEND_OK:
;;;341                 pmsg =  OSTCBCur->OSTCBMsg;
;;;342                *perr =  OS_ERR_NONE;
;;;343                 break;
;;;344    
;;;345            case OS_STAT_PEND_ABORT:
;;;346                 pmsg = (void *)0;
;;;347                *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
;;;348                 break;
;;;349    
;;;350            case OS_STAT_PEND_TO:
;;;351            default:
;;;352                 OS_EventTaskRemove(OSTCBCur, pevent);
;;;353                 pmsg = (void *)0;
;;;354                *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
;;;355                 break;
;;;356        }
;;;357        OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
;;;358        OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
;;;359        OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
;;;360    #if (OS_EVENT_MULTI_EN > 0u)
;;;361        OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
;;;362    #endif
;;;363        OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
;;;364        OS_EXIT_CRITICAL();
;;;365        return (pmsg);                                    /* Return received message                       */
;;;366    }
000180  e8bd81f0          POP      {r4-r8,pc}
                  |L1.388|
000184  48a8              LDR      r0,|L1.1064|
000186  7800              LDRB     r0,[r0,#0]            ;316  ; OSIntNesting
000188  b128              CBZ      r0,|L1.406|
00018a  f04f0002          MOV      r0,#2                 ;317
00018e  7020              STRB     r0,[r4,#0]            ;317
000190  f04f0000          MOV      r0,#0                 ;318
000194  e7f4              B        |L1.384|
                  |L1.406|
000196  48a7              LDR      r0,|L1.1076|
000198  7800              LDRB     r0,[r0,#0]            ;320  ; OSLockNesting
00019a  b128              CBZ      r0,|L1.424|
00019c  f04f000d          MOV      r0,#0xd               ;321
0001a0  7020              STRB     r0,[r4,#0]            ;321
0001a2  f04f0000          MOV      r0,#0                 ;322
0001a6  e7eb              B        |L1.384|
                  |L1.424|
0001a8  f7fffffe          BL       OS_CPU_SR_Save
0001ac  4680              MOV      r8,r0                 ;324
0001ae  686e              LDR      r6,[r5,#4]            ;325
0001b0  b156              CBZ      r6,|L1.456|
0001b2  f04f0000          MOV      r0,#0                 ;327
0001b6  6068              STR      r0,[r5,#4]            ;327
0001b8  4640              MOV      r0,r8                 ;328
0001ba  f7fffffe          BL       OS_CPU_SR_Restore
0001be  f04f0000          MOV      r0,#0                 ;329
0001c2  7020              STRB     r0,[r4,#0]            ;329
0001c4  4630              MOV      r0,r6                 ;330
0001c6  e7db              B        |L1.384|
                  |L1.456|
0001c8  489b              LDR      r0,|L1.1080|
0001ca  6800              LDR      r0,[r0,#0]            ;332  ; OSTCBCur
0001cc  f8900034          LDRB     r0,[r0,#0x34]         ;332
0001d0  f0400002          ORR      r0,r0,#2              ;332
0001d4  4998              LDR      r1,|L1.1080|
0001d6  6809              LDR      r1,[r1,#0]            ;332  ; OSTCBCur
0001d8  f8810034          STRB     r0,[r1,#0x34]         ;332
0001dc  f04f0000          MOV      r0,#0                 ;333
0001e0  4995              LDR      r1,|L1.1080|
0001e2  6809              LDR      r1,[r1,#0]            ;333  ; OSTCBCur
0001e4  f8810035          STRB     r0,[r1,#0x35]         ;333
0001e8  4893              LDR      r0,|L1.1080|
0001ea  6800              LDR      r0,[r0,#0]            ;334  ; OSTCBCur
0001ec  6307              STR      r7,[r0,#0x30]         ;334
0001ee  4628              MOV      r0,r5                 ;335
0001f0  f7fffffe          BL       OS_EventTaskWait
0001f4  4640              MOV      r0,r8                 ;336
0001f6  f7fffffe          BL       OS_CPU_SR_Restore
0001fa  f7fffffe          BL       OS_Sched
0001fe  f7fffffe          BL       OS_CPU_SR_Save
000202  4680              MOV      r8,r0                 ;338
000204  488c              LDR      r0,|L1.1080|
000206  6800              LDR      r0,[r0,#0]            ;339  ; OSTCBCur
000208  f8900035          LDRB     r0,[r0,#0x35]         ;339
00020c  b120              CBZ      r0,|L1.536|
00020e  2801              CMP      r0,#1                 ;339
000210  d010              BEQ      |L1.564|
000212  2802              CMP      r0,#2                 ;339
000214  d10d              BNE      |L1.562|
000216  e006              B        |L1.550|
                  |L1.536|
000218  4887              LDR      r0,|L1.1080|
00021a  6800              LDR      r0,[r0,#0]            ;341  ; OSTCBCur
00021c  6a46              LDR      r6,[r0,#0x24]         ;341
00021e  f04f0000          MOV      r0,#0                 ;342
000222  7020              STRB     r0,[r4,#0]            ;342
000224  e011              B        |L1.586|
                  |L1.550|
000226  f04f0600          MOV      r6,#0                 ;346
00022a  f04f000e          MOV      r0,#0xe               ;347
00022e  7020              STRB     r0,[r4,#0]            ;347
000230  e00b              B        |L1.586|
                  |L1.562|
000232  bf00              NOP                            ;350
                  |L1.564|
000234  4629              MOV      r1,r5                 ;352
000236  4880              LDR      r0,|L1.1080|
000238  6800              LDR      r0,[r0,#0]            ;352  ; OSTCBCur
00023a  f7fffffe          BL       OS_EventTaskRemove
00023e  f04f0600          MOV      r6,#0                 ;353
000242  f04f000a          MOV      r0,#0xa               ;354
000246  7020              STRB     r0,[r4,#0]            ;354
000248  bf00              NOP                            ;355
                  |L1.586|
00024a  bf00              NOP                            ;343
00024c  f04f0000          MOV      r0,#0                 ;357
000250  4979              LDR      r1,|L1.1080|
000252  6809              LDR      r1,[r1,#0]            ;357  ; OSTCBCur
000254  f8810034          STRB     r0,[r1,#0x34]         ;357
000258  4977              LDR      r1,|L1.1080|
00025a  6809              LDR      r1,[r1,#0]            ;358  ; OSTCBCur
00025c  f8810035          STRB     r0,[r1,#0x35]         ;358
000260  4975              LDR      r1,|L1.1080|
000262  6809              LDR      r1,[r1,#0]            ;359  ; OSTCBCur
000264  61c8              STR      r0,[r1,#0x1c]         ;359
000266  4974              LDR      r1,|L1.1080|
000268  6809              LDR      r1,[r1,#0]            ;361  ; OSTCBCur
00026a  6208              STR      r0,[r1,#0x20]         ;361
00026c  4972              LDR      r1,|L1.1080|
00026e  6809              LDR      r1,[r1,#0]            ;363  ; OSTCBCur
000270  6248              STR      r0,[r1,#0x24]         ;363
000272  4640              MOV      r0,r8                 ;364
000274  f7fffffe          BL       OS_CPU_SR_Restore
000278  4630              MOV      r0,r6                 ;365
00027a  e781              B        |L1.384|
;;;367    /*$PAGE*/
                          ENDP

                  OSMboxPendAbort PROC
;;;400    #if OS_MBOX_PEND_ABORT_EN > 0u
;;;401    INT8U  OSMboxPendAbort (OS_EVENT  *pevent,
00027c  e92d41f0          PUSH     {r4-r8,lr}
;;;402                            INT8U      opt,
;;;403                            INT8U     *perr)
;;;404    {
000280  4604              MOV      r4,r0
000282  460f              MOV      r7,r1
000284  4615              MOV      r5,r2
;;;405        INT8U      nbr_tasks;
;;;406    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;407        OS_CPU_SR  cpu_sr = 0u;
000286  f04f0800          MOV      r8,#0
;;;408    #endif
;;;409    
;;;410    
;;;411    
;;;412    #ifdef OS_SAFETY_CRITICAL
;;;413        if (perr == (INT8U *)0) {
;;;414            OS_SAFETY_CRITICAL_EXCEPTION();
;;;415            return (0u);
;;;416        }
;;;417    #endif
;;;418    
;;;419    #if OS_ARG_CHK_EN > 0u
;;;420        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;421            *perr = OS_ERR_PEVENT_NULL;
;;;422            return (0u);
;;;423        }
;;;424    #endif
;;;425        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00028a  7820              LDRB     r0,[r4,#0]
00028c  2801              CMP      r0,#1
00028e  d006              BEQ      |L1.670|
;;;426            *perr = OS_ERR_EVENT_TYPE;
000290  f04f0001          MOV      r0,#1
000294  7028              STRB     r0,[r5,#0]
;;;427            return (0u);
000296  f04f0000          MOV      r0,#0
                  |L1.666|
;;;428        }
;;;429        OS_ENTER_CRITICAL();
;;;430        if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on mailbox?      */
;;;431            nbr_tasks = 0u;
;;;432            switch (opt) {
;;;433                case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
;;;434                     while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on mailbox  */
;;;435                         (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
;;;436                         nbr_tasks++;
;;;437                     }
;;;438                     break;
;;;439    
;;;440                case OS_PEND_OPT_NONE:
;;;441                default:                                       /* No,  ready HPT       waiting on mailbox  */
;;;442                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
;;;443                     nbr_tasks++;
;;;444                     break;
;;;445            }
;;;446            OS_EXIT_CRITICAL();
;;;447            OS_Sched();                                        /* Find HPT ready to run                    */
;;;448            *perr = OS_ERR_PEND_ABORT;
;;;449            return (nbr_tasks);
;;;450        }
;;;451        OS_EXIT_CRITICAL();
;;;452        *perr = OS_ERR_NONE;
;;;453        return (0u);                                           /* No tasks waiting on mailbox              */
;;;454    }
00029a  e8bd81f0          POP      {r4-r8,pc}
                  |L1.670|
00029e  f7fffffe          BL       OS_CPU_SR_Save
0002a2  4680              MOV      r8,r0                 ;429
0002a4  7aa0              LDRB     r0,[r4,#0xa]          ;430
0002a6  b340              CBZ      r0,|L1.762|
0002a8  f04f0600          MOV      r6,#0                 ;431
0002ac  b187              CBZ      r7,|L1.720|
0002ae  2f01              CMP      r7,#1                 ;432
0002b0  d10d              BNE      |L1.718|
0002b2  e008              B        |L1.710|
                  |L1.692|
0002b4  2302              MOVS     r3,#2                 ;435
0002b6  461a              MOV      r2,r3                 ;435
0002b8  2100              MOVS     r1,#0                 ;435
0002ba  4620              MOV      r0,r4                 ;435
0002bc  f7fffffe          BL       OS_EventTaskRdy
0002c0  f1060001          ADD      r0,r6,#1              ;436
0002c4  b2c6              UXTB     r6,r0                 ;436
                  |L1.710|
0002c6  7aa0              LDRB     r0,[r4,#0xa]          ;434
0002c8  2800              CMP      r0,#0                 ;434
0002ca  d1f3              BNE      |L1.692|
0002cc  e00a              B        |L1.740|
                  |L1.718|
0002ce  bf00              NOP                            ;440
                  |L1.720|
0002d0  2302              MOVS     r3,#2                 ;442
0002d2  461a              MOV      r2,r3                 ;442
0002d4  2100              MOVS     r1,#0                 ;442
0002d6  4620              MOV      r0,r4                 ;442
0002d8  f7fffffe          BL       OS_EventTaskRdy
0002dc  f1060001          ADD      r0,r6,#1              ;443
0002e0  b2c6              UXTB     r6,r0                 ;443
0002e2  bf00              NOP                            ;444
                  |L1.740|
0002e4  bf00              NOP                            ;438
0002e6  4640              MOV      r0,r8                 ;446
0002e8  f7fffffe          BL       OS_CPU_SR_Restore
0002ec  f7fffffe          BL       OS_Sched
0002f0  f04f000e          MOV      r0,#0xe               ;448
0002f4  7028              STRB     r0,[r5,#0]            ;448
0002f6  4630              MOV      r0,r6                 ;449
0002f8  e7cf              B        |L1.666|
                  |L1.762|
0002fa  4640              MOV      r0,r8                 ;451
0002fc  f7fffffe          BL       OS_CPU_SR_Restore
000300  f04f0000          MOV      r0,#0                 ;452
000304  7028              STRB     r0,[r5,#0]            ;452
000306  bf00              NOP                            ;453
000308  e7c7              B        |L1.666|
;;;455    #endif
                          ENDP

                  OSMboxPost PROC
;;;480    #if OS_MBOX_POST_EN > 0u
;;;481    INT8U  OSMboxPost (OS_EVENT  *pevent,
00030a  b570              PUSH     {r4-r6,lr}
;;;482                       void      *pmsg)
;;;483    {
00030c  4604              MOV      r4,r0
00030e  460d              MOV      r5,r1
;;;484    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;485        OS_CPU_SR  cpu_sr = 0u;
000310  f04f0600          MOV      r6,#0
;;;486    #endif
;;;487    
;;;488    
;;;489    
;;;490    #if OS_ARG_CHK_EN > 0u
;;;491        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;492            return (OS_ERR_PEVENT_NULL);
;;;493        }
;;;494        if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
;;;495            return (OS_ERR_POST_NULL_PTR);
;;;496        }
;;;497    #endif
;;;498        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
000314  7820              LDRB     r0,[r4,#0]
000316  2801              CMP      r0,#1
000318  d001              BEQ      |L1.798|
;;;499            return (OS_ERR_EVENT_TYPE);
00031a  2001              MOVS     r0,#1
                  |L1.796|
;;;500        }
;;;501        OS_ENTER_CRITICAL();
;;;502        if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
;;;503                                                          /* Ready HPT waiting on event                    */
;;;504            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
;;;505            OS_EXIT_CRITICAL();
;;;506            OS_Sched();                                   /* Find highest priority task ready to run       */
;;;507            return (OS_ERR_NONE);
;;;508        }
;;;509        if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
;;;510            OS_EXIT_CRITICAL();
;;;511            return (OS_ERR_MBOX_FULL);
;;;512        }
;;;513        pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
;;;514        OS_EXIT_CRITICAL();
;;;515        return (OS_ERR_NONE);
;;;516    }
00031c  bd70              POP      {r4-r6,pc}
                  |L1.798|
00031e  f7fffffe          BL       OS_CPU_SR_Save
000322  4606              MOV      r6,r0                 ;501
000324  7aa0              LDRB     r0,[r4,#0xa]          ;502
000326  b160              CBZ      r0,|L1.834|
000328  2300              MOVS     r3,#0                 ;504
00032a  2202              MOVS     r2,#2                 ;504
00032c  4629              MOV      r1,r5                 ;504
00032e  4620              MOV      r0,r4                 ;504
000330  f7fffffe          BL       OS_EventTaskRdy
000334  4630              MOV      r0,r6                 ;505
000336  f7fffffe          BL       OS_CPU_SR_Restore
00033a  f7fffffe          BL       OS_Sched
00033e  2000              MOVS     r0,#0                 ;507
000340  e7ec              B        |L1.796|
                  |L1.834|
000342  6860              LDR      r0,[r4,#4]            ;509
000344  b120              CBZ      r0,|L1.848|
000346  4630              MOV      r0,r6                 ;510
000348  f7fffffe          BL       OS_CPU_SR_Restore
00034c  2014              MOVS     r0,#0x14              ;511
00034e  e7e5              B        |L1.796|
                  |L1.848|
000350  6065              STR      r5,[r4,#4]            ;513
000352  4630              MOV      r0,r6                 ;514
000354  f7fffffe          BL       OS_CPU_SR_Restore
000358  2000              MOVS     r0,#0                 ;515
00035a  e7df              B        |L1.796|
;;;517    #endif
                          ENDP

                  OSMboxPostOpt PROC
;;;552    #if OS_MBOX_POST_OPT_EN > 0u
;;;553    INT8U  OSMboxPostOpt (OS_EVENT  *pevent,
00035c  e92d41f0          PUSH     {r4-r8,lr}
;;;554                          void      *pmsg,
;;;555                          INT8U      opt)
;;;556    {
000360  4604              MOV      r4,r0
000362  460e              MOV      r6,r1
000364  4615              MOV      r5,r2
;;;557    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;558        OS_CPU_SR  cpu_sr = 0u;
000366  f04f0700          MOV      r7,#0
;;;559    #endif
;;;560    
;;;561    
;;;562    
;;;563    #if OS_ARG_CHK_EN > 0u
;;;564        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;565            return (OS_ERR_PEVENT_NULL);
;;;566        }
;;;567        if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
;;;568            return (OS_ERR_POST_NULL_PTR);
;;;569        }
;;;570    #endif
;;;571        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
00036a  7820              LDRB     r0,[r4,#0]
00036c  2801              CMP      r0,#1
00036e  d002              BEQ      |L1.886|
;;;572            return (OS_ERR_EVENT_TYPE);
000370  2001              MOVS     r0,#1
                  |L1.882|
;;;573        }
;;;574        OS_ENTER_CRITICAL();
;;;575        if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
;;;576            if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
;;;577                while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on mailbox     */
;;;578                    (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
;;;579                }
;;;580            } else {                                      /* No,  Post to HPT waiting on mbox              */
;;;581                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
;;;582            }
;;;583            OS_EXIT_CRITICAL();
;;;584            if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
;;;585                OS_Sched();                               /* Find HPT ready to run                         */
;;;586            }
;;;587            return (OS_ERR_NONE);
;;;588        }
;;;589        if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
;;;590            OS_EXIT_CRITICAL();
;;;591            return (OS_ERR_MBOX_FULL);
;;;592        }
;;;593        pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
;;;594        OS_EXIT_CRITICAL();
;;;595        return (OS_ERR_NONE);
;;;596    }
000372  e8bd81f0          POP      {r4-r8,pc}
                  |L1.886|
000376  f7fffffe          BL       OS_CPU_SR_Save
00037a  4607              MOV      r7,r0                 ;574
00037c  7aa0              LDRB     r0,[r4,#0xa]          ;575
00037e  b1e8              CBZ      r0,|L1.956|
000380  f0150f01          TST      r5,#1                 ;576
000384  d00a              BEQ      |L1.924|
000386  e005              B        |L1.916|
                  |L1.904|
000388  2300              MOVS     r3,#0                 ;578
00038a  2202              MOVS     r2,#2                 ;578
00038c  4631              MOV      r1,r6                 ;578
00038e  4620              MOV      r0,r4                 ;578
000390  f7fffffe          BL       OS_EventTaskRdy
                  |L1.916|
000394  7aa0              LDRB     r0,[r4,#0xa]          ;577
000396  2800              CMP      r0,#0                 ;577
000398  d1f6              BNE      |L1.904|
00039a  e005              B        |L1.936|
                  |L1.924|
00039c  2300              MOVS     r3,#0                 ;581
00039e  2202              MOVS     r2,#2                 ;581
0003a0  4631              MOV      r1,r6                 ;581
0003a2  4620              MOV      r0,r4                 ;581
0003a4  f7fffffe          BL       OS_EventTaskRdy
                  |L1.936|
0003a8  4638              MOV      r0,r7                 ;583
0003aa  f7fffffe          BL       OS_CPU_SR_Restore
0003ae  f0150f04          TST      r5,#4                 ;584
0003b2  d101              BNE      |L1.952|
0003b4  f7fffffe          BL       OS_Sched
                  |L1.952|
0003b8  2000              MOVS     r0,#0                 ;587
0003ba  e7da              B        |L1.882|
                  |L1.956|
0003bc  6860              LDR      r0,[r4,#4]            ;589
0003be  b120              CBZ      r0,|L1.970|
0003c0  4638              MOV      r0,r7                 ;590
0003c2  f7fffffe          BL       OS_CPU_SR_Restore
0003c6  2014              MOVS     r0,#0x14              ;591
0003c8  e7d3              B        |L1.882|
                  |L1.970|
0003ca  6066              STR      r6,[r4,#4]            ;593
0003cc  4638              MOV      r0,r7                 ;594
0003ce  f7fffffe          BL       OS_CPU_SR_Restore
0003d2  2000              MOVS     r0,#0                 ;595
0003d4  e7cd              B        |L1.882|
;;;597    #endif
                          ENDP

                  OSMboxQuery PROC
;;;618    #if OS_MBOX_QUERY_EN > 0u
;;;619    INT8U  OSMboxQuery (OS_EVENT      *pevent,
0003d6  e92d47f0          PUSH     {r4-r10,lr}
;;;620                        OS_MBOX_DATA  *p_mbox_data)
;;;621    {
0003da  4604              MOV      r4,r0
0003dc  460d              MOV      r5,r1
;;;622        INT8U       i;
;;;623        OS_PRIO    *psrc;
;;;624        OS_PRIO    *pdest;
;;;625    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;626        OS_CPU_SR   cpu_sr = 0u;
0003de  f04f0900          MOV      r9,#0
;;;627    #endif
;;;628    
;;;629    
;;;630    
;;;631    #if OS_ARG_CHK_EN > 0u
;;;632        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;633            return (OS_ERR_PEVENT_NULL);
;;;634        }
;;;635        if (p_mbox_data == (OS_MBOX_DATA *)0) {                /* Validate 'p_mbox_data'                   */
;;;636            return (OS_ERR_PDATA_NULL);
;;;637        }
;;;638    #endif
;;;639        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
0003e2  7820              LDRB     r0,[r4,#0]
0003e4  2801              CMP      r0,#1
0003e6  d002              BEQ      |L1.1006|
;;;640            return (OS_ERR_EVENT_TYPE);
0003e8  2001              MOVS     r0,#1
                  |L1.1002|
;;;641        }
;;;642        OS_ENTER_CRITICAL();
;;;643        p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
;;;644        psrc                    = &pevent->OSEventTbl[0];
;;;645        pdest                   = &p_mbox_data->OSEventTbl[0];
;;;646        for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
;;;647            *pdest++ = *psrc++;
;;;648        }
;;;649        p_mbox_data->OSMsg = pevent->OSEventPtr;               /* Get message from mailbox                 */
;;;650        OS_EXIT_CRITICAL();
;;;651        return (OS_ERR_NONE);
;;;652    }
0003ea  e8bd87f0          POP      {r4-r10,pc}
                  |L1.1006|
0003ee  f7fffffe          BL       OS_CPU_SR_Save
0003f2  4681              MOV      r9,r0                 ;642
0003f4  7aa0              LDRB     r0,[r4,#0xa]          ;643
0003f6  7328              STRB     r0,[r5,#0xc]          ;643
0003f8  f104070b          ADD      r7,r4,#0xb            ;644
0003fc  f1050804          ADD      r8,r5,#4              ;645
000400  f04f0600          MOV      r6,#0                 ;646
000404  e006              B        |L1.1044|
                  |L1.1030|
000406  f8170b01          LDRB     r0,[r7],#1            ;647
00040a  f8080b01          STRB     r0,[r8],#1            ;647
00040e  f1060001          ADD      r0,r6,#1              ;646
000412  b2c6              UXTB     r6,r0                 ;646
                  |L1.1044|
000414  2e08              CMP      r6,#8                 ;646
000416  d3f6              BCC      |L1.1030|
000418  6860              LDR      r0,[r4,#4]            ;649
00041a  6028              STR      r0,[r5,#0]            ;649
00041c  4648              MOV      r0,r9                 ;650
00041e  f7fffffe          BL       OS_CPU_SR_Restore
000422  2000              MOVS     r0,#0                 ;651
000424  e7e1              B        |L1.1002|
000426  0000              DCW      0x0000
                  |L1.1064|
                          DCD      OSIntNesting
                  |L1.1068|
                          DCD      OSEventFreeList
                  |L1.1072|
000430  3f00              DCB      "?",0
000432  00                DCB      0
000433  00                DCB      0
                  |L1.1076|
                          DCD      OSLockNesting
                  |L1.1080|
                          DCD      OSTCBCur
                          ENDP

