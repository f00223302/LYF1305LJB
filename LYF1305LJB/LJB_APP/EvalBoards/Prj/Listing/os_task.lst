L 1 "..\..\uCOS-II\Source\os_task.c"
N/*
N*********************************************************************************************************
N*                                                uC/OS-II
N*                                          The Real-Time Kernel
N*                                            TASK MANAGEMENT
N*
N*                              (c) Copyright 1992-2012, Micrium, Weston, FL
N*                                           All Rights Reserved
N*
N* File    : OS_TASK.C
N* By      : Jean J. Labrosse
N* Version : V2.92.07
N*
N* LICENSING TERMS:
N* ---------------
N*   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
N* If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
N* its use in your product. We provide ALL the source code for your convenience and to help you experience
N* uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
N* licensing fee.
N*********************************************************************************************************
N*/
N
N#define  MICRIUM_SOURCE
N
N#ifndef  OS_MASTER_FILE
N#include <ucos_ii.h>
L 1 "..\..\uCOS-II\Source\ucos_ii.h" 1
N/*
N*********************************************************************************************************
N*                                              uC/OS-II
N*                                        The Real-Time Kernel
N*
N*                            (c) Copyright 1992-2012, Micrium, Weston, FL
N*                                           All Rights Reserved
N*
N* File    : uCOS_II.H
N* By      : Jean J. Labrosse
N* Version : V2.92.07
N*
N* LICENSING TERMS:
N* ---------------
N*   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
N* If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
N* its use in your product. We provide ALL the source code for your convenience and to help you experience
N* uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
N* licensing fee.
N*********************************************************************************************************
N*/
N
N#ifndef   OS_uCOS_II_H
N#define   OS_uCOS_II_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*
N*********************************************************************************************************
N*                                       uC/OS-II VERSION NUMBER
N*********************************************************************************************************
N*/
N
N#define  OS_VERSION                 29207u              /* Version of uC/OS-II (Vx.yy mult. by 10000)  */
N
N/*
N*********************************************************************************************************
N*                                        INCLUDE HEADER FILES
N*********************************************************************************************************
N*/
N
N#include <app_cfg.h>
L 1 "..\App\app_cfg.h" 1
N/*
N	FileName : app_cfg.h
N	Description : 
N		CM3 系统硬件配置。不同应用可根据实际硬件设置功能单元。
N	
N	Created on 2012.10.18 by ZZP.
N	
N	Revision History:
N	
N*/
N
N
N#ifndef  __APP_CFG_H__
N#define  __APP_CFG_H__
N
N#include  <stdio.h>
L 1 "D:\Keil\ARM\RV31\INC\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 137287 $
N * Checkin $Date: 2008-08-27 13:36:52 +0100 (Wed, 27 Aug 2008) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;   /* see <stddef.h> */
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined)
X#if 0L || !0L || !0L
N/* always defined in C++ and non-strict C for consistency of debug info */
N  typedef struct __va_list __va_list;
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
L 17 "..\App\app_cfg.h" 2
N#include <cpu_core.h>
L 1 "..\..\uC-CPU\cpu_core.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/CPU
N*                                    CPU CONFIGURATION & PORT LAYER
N*
N*                          (c) Copyright 2004-2011; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/CPU is provided in source form to registered licensees ONLY.  It is 
N*               illegal to distribute this source code to any third party unless you receive 
N*               written permission by an authorized Micrium representative.  Knowledge of 
N*               the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest 
N*               software available.  Your honesty is greatly appreciated.
N*
N*               You can contact us at www.micrium.com.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                           CORE CPU MODULE
N*
N* Filename      : cpu_core.h
N* Version       : V1.29.01
N* Programmer(s) : SR
N*                 ITJ
N*********************************************************************************************************
N* Note(s)       : (1) Assumes the following versions (or more recent) of software modules are included in 
N*                     the project build :
N*
N*                     (a) uC/LIB V1.35.00
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*
N* Note(s) : (1) This core CPU header file is protected from multiple pre-processor inclusion through use of 
N*               the  core CPU module present pre-processor macro definition.
N*********************************************************************************************************
N*/
N
N#ifndef  CPU_CORE_MODULE_PRESENT                                /* See Note #1.                                         */
N#define  CPU_CORE_MODULE_PRESENT
N
N
N/*
N*********************************************************************************************************
N*                                               EXTERNS
N*********************************************************************************************************
N*/
N
N#ifdef   CPU_CORE_MODULE
S#define  CPU_CORE_EXT
N#else
N#define  CPU_CORE_EXT  extern
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            INCLUDE FILES
N*
N* Note(s) : (1) CPU-configuration software files are located in the following directories :
N*
N*               (a) \<Your Product Application>\cpu_cfg.h
N*
N*               (b) (1) \<CPU-Compiler Directory>\cpu_*.*
N*                   (2) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
N*
N*                       where
N*                               <Your Product Application>      directory path for Your Product's Application
N*                               <CPU-Compiler Directory>        directory path for common CPU-compiler software
N*                               <cpu>                           directory name for specific processor (CPU)
N*                               <compiler>                      directory name for specific compiler
N*
N*           (2) NO compiler-supplied standard library functions SHOULD be used.
N*
N*               (a) Standard library functions are implemented in the custom library module(s) :
N*
N*                       \<Custom Library Directory>\lib_*.*
N*
N*                           where
N*                                   <Custom Library Directory>      directory path for custom library software
N*
N*           (3) Compiler MUST be configured to include as additional include path directories :
N*
N*               (a) '\<Your Product Application>\' directory                            See Note #1a
N*
N*               (b) (1) '\<CPU-Compiler Directory>\'                  directory         See Note #1b1
N*                   (2) '\<CPU-Compiler Directory>\<cpu>\<compiler>\' directory         See Note #1b2
N*
N*               (c) '\<Custom Library Directory>\' directory                            See Note #2a
N*********************************************************************************************************
N*/
N
N#include  <cpu.h>
L 1 "..\..\uC-CPU\ARM-Cortex-M3\cpu.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/CPU
N*                                    CPU CONFIGURATION & PORT LAYER
N*
N*                          (c) Copyright 2004-2011; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/CPU is provided in source form to registered licensees ONLY.  It is 
N*               illegal to distribute this source code to any third party unless you receive 
N*               written permission by an authorized Micrium representative.  Knowledge of 
N*               the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest 
N*               software available.  Your honesty is greatly appreciated.
N*
N*               You can contact us at www.micrium.com.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                            CPU PORT FILE
N*
N*                                            ARM-Cortex-M3
N*                                      RealView Development Suite
N*                            RealView Microcontroller Development Kit (MDK)
N*                                       ARM Developer Suite (ADS)
N*                                            Keil uVision
N*
N* Filename      : cpu.h
N* Version       : V1.29.01.00
N* Programmer(s) : JJL
N*                 BAN
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*
N* Note(s) : (1) This CPU header file is protected from multiple pre-processor inclusion through use of 
N*               the  CPU module present pre-processor macro definition.
N*********************************************************************************************************
N*/
N
N#ifndef  CPU_MODULE_PRESENT                                     /* See Note #1.                                         */
N#define  CPU_MODULE_PRESENT
N
N
N/*
N*********************************************************************************************************
N*                                          CPU INCLUDE FILES
N*
N* Note(s) : (1) The following CPU files are located in the following directories :
N*
N*               (a) \<Your Product Application>\cpu_cfg.h
N*
N*               (b) (1) \<CPU-Compiler Directory>\cpu_def.h
N*                   (2) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
N*
N*                       where
N*                               <Your Product Application>      directory path for Your Product's Application
N*                               <CPU-Compiler Directory>        directory path for common   CPU-compiler software
N*                               <cpu>                           directory name for specific CPU
N*                               <compiler>                      directory name for specific compiler
N*
N*           (2) Compiler MUST be configured to include as additional include path directories :
N*
N*               (a) '\<Your Product Application>\' directory                            See Note #1a
N*
N*               (b) (1) '\<CPU-Compiler Directory>\'                  directory         See Note #1b1
N*                   (2) '\<CPU-Compiler Directory>\<cpu>\<compiler>\' directory         See Note #1b2
N*
N*           (3) Since NO custom library modules are included, 'cpu.h' may ONLY use configurations from
N*               CPU configuration file 'cpu_cfg.h' that do NOT reference any custom library definitions.
N*
N*               In other words, 'cpu.h' may use 'cpu_cfg.h' configurations that are #define'd to numeric
N*               constants or to NULL (i.e. NULL-valued #define's); but may NOT use configurations to
N*               custom library #define's (e.g. DEF_DISABLED or DEF_ENABLED).
N*********************************************************************************************************
N*/
N
N#include  <cpu_def.h>
L 1 "..\..\uC-CPU\cpu_def.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/CPU
N*                                    CPU CONFIGURATION & PORT LAYER
N*
N*                          (c) Copyright 2004-2011; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/CPU is provided in source form to registered licensees ONLY.  It is 
N*               illegal to distribute this source code to any third party unless you receive 
N*               written permission by an authorized Micrium representative.  Knowledge of 
N*               the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest 
N*               software available.  Your honesty is greatly appreciated.
N*
N*               You can contact us at www.micrium.com.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                      CPU CONFIGURATION DEFINES
N*
N* Filename      : cpu_def.h
N* Version       : V1.29.01
N* Programmer(s) : ITJ
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*
N* Note(s) : (1) This CPU definition header file is protected from multiple pre-processor inclusion 
N*               through use of the CPU definition module present pre-processor macro definition.
N*********************************************************************************************************
N*/
N
N#ifndef  CPU_DEF_MODULE_PRESENT
N#define  CPU_DEF_MODULE_PRESENT
N
N
N/*
N*********************************************************************************************************
N*                                   CORE CPU MODULE VERSION NUMBER
N*
N* Note(s) : (1) (a) The core CPU module software version is denoted as follows :
N*
N*                       Vx.yy.zz
N*
N*                           where
N*                                   V               denotes 'Version' label
N*                                   x               denotes     major software version revision number
N*                                   yy              denotes     minor software version revision number
N*                                   zz              denotes sub-minor software version revision number
N*
N*               (b) The software version label #define is formatted as follows :
N*
N*                       ver = x.yyzz * 100 * 100
N*
N*                           where
N*                                   ver             denotes software version number scaled as an integer value
N*                                   x.yyzz          denotes software version number, where the unscaled integer 
N*                                                       portion denotes the major version number & the unscaled 
N*                                                       fractional portion denotes the (concatenated) minor 
N*                                                       version numbers
N*********************************************************************************************************
N*/
N
N#define  CPU_CORE_VERSION                              12901u   /* See Note #1.                                         */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                       CPU WORD CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_ADDR_SIZE & CPU_CFG_DATA_SIZE in 'cpu.h' with CPU's word sizes :
N*
N*                   CPU_WORD_SIZE_08             8-bit word size
N*                   CPU_WORD_SIZE_16            16-bit word size
N*                   CPU_WORD_SIZE_32            32-bit word size
N*                   CPU_WORD_SIZE_64            64-bit word size
N*
N*           (2) Configure CPU_CFG_ENDIAN_TYPE in 'cpu.h' with CPU's data-word-memory order :
N*
N*               (a) CPU_ENDIAN_TYPE_BIG         Big-   endian word order (CPU words' most  significant
N*                                                                         octet @ lowest memory address)
N*               (b) CPU_ENDIAN_TYPE_LITTLE      Little-endian word order (CPU words' least significant
N*                                                                         octet @ lowest memory address)
N*********************************************************************************************************
N*/
N
N                                                        /* ---------------------- CPU WORD SIZE ----------------------- */
N#define  CPU_WORD_SIZE_08                          1    /*  8-bit word size (in octets).                                */
N#define  CPU_WORD_SIZE_16                          2    /* 16-bit word size (in octets).                                */
N#define  CPU_WORD_SIZE_32                          4    /* 32-bit word size (in octets).                                */
N#define  CPU_WORD_SIZE_64                          8    /* 64-bit word size (in octets).                                */
N
N
N                                                        /* ------------------ CPU WORD-ENDIAN ORDER ------------------- */
N#define  CPU_ENDIAN_TYPE_NONE                      0u
N#define  CPU_ENDIAN_TYPE_BIG                       1u   /* Big-   endian word order (see Note #1a).                     */
N#define  CPU_ENDIAN_TYPE_LITTLE                    2u   /* Little-endian word order (see Note #1b).                     */
N
N
N/*
N*********************************************************************************************************
N*                                       CPU STACK CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_STK_GROWTH in 'cpu.h' with CPU's stack growth order :
N*
N*               (a) CPU_STK_GROWTH_LO_TO_HI     CPU stack pointer increments to the next higher  stack 
N*                                                   memory address after data is pushed onto the stack
N*               (b) CPU_STK_GROWTH_HI_TO_LO     CPU stack pointer decrements to the next lower   stack 
N*                                                   memory address after data is pushed onto the stack
N*********************************************************************************************************
N*/
N
N                                                        /* ------------------ CPU STACK GROWTH ORDER ------------------ */
N#define  CPU_STK_GROWTH_NONE                       0u
N#define  CPU_STK_GROWTH_LO_TO_HI                   1u   /* CPU stk incs towards higher mem addrs (see Note #1a).        */
N#define  CPU_STK_GROWTH_HI_TO_LO                   2u   /* CPU stk decs towards lower  mem addrs (see Note #1b).        */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                   CRITICAL SECTION CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_CRITICAL_METHOD with CPU's/compiler's critical section method :
N*
N*                                                       Enter/Exit critical sections by ...
N*
N*                   CPU_CRITICAL_METHOD_INT_DIS_EN      Disable/Enable interrupts
N*                   CPU_CRITICAL_METHOD_STATUS_STK      Push/Pop       interrupt status onto stack
N*                   CPU_CRITICAL_METHOD_STATUS_LOCAL    Save/Restore   interrupt status to local variable
N*
N*               (a) CPU_CRITICAL_METHOD_INT_DIS_EN  is NOT a preferred method since it does NOT support
N*                   multiple levels of interrupts.  However, with some CPUs/compilers, this is the only
N*                   available method.
N*
N*               (b) CPU_CRITICAL_METHOD_STATUS_STK    is one preferred method since it supports multiple
N*                   levels of interrupts.  However, this method assumes that the compiler provides C-level
N*                   &/or assembly-level functionality for the following :
N*
N*                     ENTER CRITICAL SECTION :
N*                       (1) Push/save   interrupt status onto a local stack
N*                       (2) Disable     interrupts
N*
N*                     EXIT  CRITICAL SECTION :
N*                       (3) Pop/restore interrupt status from a local stack
N*
N*               (c) CPU_CRITICAL_METHOD_STATUS_LOCAL  is one preferred method since it supports multiple
N*                   levels of interrupts.  However, this method assumes that the compiler provides C-level
N*                   &/or assembly-level functionality for the following :
N*
N*                     ENTER CRITICAL SECTION :
N*                       (1) Save    interrupt status into a local variable
N*                       (2) Disable interrupts
N*
N*                     EXIT  CRITICAL SECTION :
N*                       (3) Restore interrupt status from a local variable
N*
N*           (2) Critical section macro's most likely require inline assembly.  If the compiler does NOT
N*               allow inline assembly in C source files, critical section macro's MUST call an assembly
N*               subroutine defined in a 'cpu_a.asm' file located in the following software directory :
N*
N*                   \<CPU-Compiler Directory>\<cpu>\<compiler>\
N*
X
N*                       where
N*                               <CPU-Compiler Directory>    directory path for common   CPU-compiler software
N*                               <cpu>                       directory name for specific CPU
N*                               <compiler>                  directory name for specific compiler
N*
N*           (3) (a) To save/restore interrupt status, a local variable 'cpu_sr' of type 'CPU_SR' MAY need 
N*                   to be declared (e.g. if 'CPU_CRITICAL_METHOD_STATUS_LOCAL' method is configured).
N*
N*                   (1) 'cpu_sr' local variable SHOULD be declared via the CPU_SR_ALLOC() macro which, 
N*                        if used, MUST be declared following ALL other local variables (see any 'cpu.h  
N*                        CRITICAL SECTION CONFIGURATION  Note #3a1').
N*
N*                        Example :
N*
N*                           void  Fnct (void)
N*                           {
N*                               CPU_INT08U  val_08;
N*                               CPU_INT16U  val_16;
N*                               CPU_INT32U  val_32;
N*                               CPU_SR_ALLOC();         MUST be declared after ALL other local variables
N*                                   :
N*                                   :
N*                           }
N*
N*               (b) Configure 'CPU_SR' data type with the appropriate-sized CPU data type large enough to 
N*                   completely store the CPU's/compiler's status word.
N*********************************************************************************************************
N*/
N
N                                                        /* --------------- CPU CRITICAL SECTION METHODS --------------- */
N#define  CPU_CRITICAL_METHOD_NONE                  0u   /*                                                              */
N#define  CPU_CRITICAL_METHOD_INT_DIS_EN            1u   /* DIS/EN       ints                    (see Note #1a).         */
N#define  CPU_CRITICAL_METHOD_STATUS_STK            2u   /* Push/Pop     int status onto stk     (see Note #1b).         */
N#define  CPU_CRITICAL_METHOD_STATUS_LOCAL          3u   /* Save/Restore int status to local var (see Note #1c).         */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*
N* Note(s) : (1) See 'cpu_def.h  MODULE'.
N*********************************************************************************************************
N*/
N
N#endif                                                  /* End of CPU def module include.                               */
N
L 88 "..\..\uC-CPU\ARM-Cortex-M3\cpu.h" 2
N#include  <cpu_cfg.h>                                           /* See Note #3.                                         */
L 1 "..\App\cpu_cfg.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/CPU
N*                                    CPU CONFIGURATION & PORT LAYER
N*
N*                          (c) Copyright 2004-2011; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/CPU is provided in source form to registered licensees ONLY.  It is 
N*               illegal to distribute this source code to any third party unless you receive 
N*               written permission by an authorized Micrium representative.  Knowledge of 
N*               the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest 
N*               software available.  Your honesty is greatly appreciated.
N*
N*               You can contact us at www.micrium.com.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                       CPU CONFIGURATION FILE
N*
N*                                              TEMPLATE
N*
N* Filename      : cpu_cfg.h
N* Version       : V1.29.01
N* Programmer(s) : SR
N*                 ITJ
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*********************************************************************************************************
N*/
N
N#ifndef  CPU_CFG_MODULE_PRESENT
N#define  CPU_CFG_MODULE_PRESENT
N
N
N/*
N*********************************************************************************************************
N*                                       CPU NAME CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_NAME_EN to enable/disable CPU host name feature :
N*
N*               (a) CPU host name storage
N*               (b) CPU host name API functions
N*
N*           (2) Configure CPU_CFG_NAME_SIZE with the desired ASCII string size of the CPU host name, 
N*               including the terminating NULL character.
N*
N*               See also 'cpu_core.h  GLOBAL VARIABLES  Note #1'.
N*********************************************************************************************************
N*/
N
N                                                                /* Configure CPU host name feature (see Note #1) :      */
N#define  CPU_CFG_NAME_EN                         DEF_ENABLED
N                                                                /*   DEF_DISABLED  CPU host name DISABLED               */
N                                                                /*   DEF_ENABLED   CPU host name ENABLED                */
N
N                                                                /* Configure CPU host name ASCII string size ...        */
N#define  CPU_CFG_NAME_SIZE                                16    /* ... (see Note #2).                                   */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                     CPU TIMESTAMP CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_TS_xx_EN to enable/disable CPU timestamp features :
N*
N*               (a) CPU_CFG_TS_32_EN   enable/disable 32-bit CPU timestamp feature
N*               (b) CPU_CFG_TS_64_EN   enable/disable 64-bit CPU timestamp feature
N*
N*           (2) (a) Configure CPU_CFG_TS_TMR_SIZE with the CPU timestamp timer's word size :
N*
N*                       CPU_WORD_SIZE_08         8-bit word size
N*                       CPU_WORD_SIZE_16        16-bit word size
N*                       CPU_WORD_SIZE_32        32-bit word size
N*                       CPU_WORD_SIZE_64        64-bit word size
N*
N*               (b) If the size of the CPU timestamp timer is not a binary multiple of 8-bit octets 
N*                   (e.g. 20-bits or even 24-bits), then the next lower, binary-multiple octet word 
N*                   size SHOULD be configured (e.g. to 16-bits).  However, the minimum supported word 
N*                   size for CPU timestamp timers is 8-bits.
N*
N*                   See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2a'.
N*********************************************************************************************************
N*/
N
N                                                                /* Configure CPU timestamp features (see Note #1) :     */
N#define  CPU_CFG_TS_32_EN                       DEF_ENABLED
N#define  CPU_CFG_TS_64_EN                       DEF_DISABLED
N                                                                /*   DEF_DISABLED  CPU timestamps DISABLED              */
N                                                                /*   DEF_ENABLED   CPU timestamps ENABLED               */
N
N                                                                /* Configure CPU timestamp timer word size ...          */
N                                                                /* ... (see Note #2) :                                  */
N#define  CPU_CFG_TS_TMR_SIZE                    CPU_WORD_SIZE_32
N
N
N/*
N*********************************************************************************************************
N*                        CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION
N*
N* Note(s) : (1) (a) Configure CPU_CFG_INT_DIS_MEAS_EN to enable/disable measuring CPU's interrupts 
N*                   disabled time :
N*
N*                   (a)  Enabled,       if CPU_CFG_INT_DIS_MEAS_EN      #define'd in 'cpu_cfg.h'
N*
N*                   (b) Disabled,       if CPU_CFG_INT_DIS_MEAS_EN  NOT #define'd in 'cpu_cfg.h'
N*
N*                   See also 'cpu_core.h  FUNCTION PROTOTYPES  Note #1'.
N*
N*               (b) Configure CPU_CFG_INT_DIS_MEAS_OVRHD_NBR with the number of times to measure & 
N*                   average the interrupts disabled time measurements overhead.
N*
N*                   Recommend a single (1) overhead time measurement, even for instruction-cache-enabled 
N*                   CPUs, since critical sections are NOT typically called within instruction-cached loops.
N*                   Thus a single non-cached/non-averaged time measurement is a more realistic overhead 
N*                   for the majority of non-cached interrupts disabled time measurements.
N*
N*                   See also 'cpu_core.c  CPU_IntDisMeasInit()  Note #3a'.
N*********************************************************************************************************
N*/
N
N#if 0                                                           /* Configure CPU interrupts disabled time ...           */
S#define  CPU_CFG_INT_DIS_MEAS_EN                                /* ... measurements feature (see Note #1a).             */
N#endif
N
N                                                                /* Configure number of interrupts disabled overhead ... */
N#define  CPU_CFG_INT_DIS_MEAS_OVRHD_NBR                    1u   /* ... time measurements (see Note #1b).                */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                    CPU COUNT ZEROS CONFIGURATION
N*
N* Note(s) : (1) (a) Configure CPU_CFG_LEAD_ZEROS_ASM_PRESENT  to define count leading  zeros bits 
N*                   function(s) in :
N*
N*                   (1) 'cpu_a.asm',  if CPU_CFG_LEAD_ZEROS_ASM_PRESENT       #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable assembly-optimized function(s)
N*
N*                   (2) 'cpu_core.c', if CPU_CFG_LEAD_ZEROS_ASM_PRESENT   NOT #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable C-source-optimized function(s) otherwise
N*
N*               (b) Configure CPU_CFG_TRAIL_ZEROS_ASM_PRESENT to define count trailing zeros bits 
N*                   function(s) in :
N*
N*                   (1) 'cpu_a.asm',  if CPU_CFG_TRAIL_ZEROS_ASM_PRESENT      #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable assembly-optimized function(s)
N*
N*                   (2) 'cpu_core.c', if CPU_CFG_TRAIL_ZEROS_ASM_PRESENT  NOT #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable C-source-optimized function(s) otherwise
N*********************************************************************************************************
N*/
N
N#if 1                                                           /* Configure CPU count leading  zeros bits ...          */
N#define  CPU_CFG_LEAD_ZEROS_ASM_PRESENT                         /* ... assembly-version (see Note #1a).                 */
N#endif
N
N#if 0                                                           /* Configure CPU count trailing zeros bits ...          */
S#define  CPU_CFG_TRAIL_ZEROS_ASM_PRESENT                        /* ... assembly-version (see Note #1b).                 */
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of CPU cfg module include.                       */
N
L 89 "..\..\uC-CPU\ARM-Cortex-M3\cpu.h" 2
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                    CONFIGURE STANDARD DATA TYPES
N*
N* Note(s) : (1) Configure standard data types according to CPU-/compiler-specifications.
N*
N*           (2) (a) (1) 'CPU_FNCT_VOID' data type defined to replace the commonly-used function pointer
N*                       data type of a pointer to a function which returns void & has no arguments.
N*
N*                   (2) Example function pointer usage :
N*
N*                           CPU_FNCT_VOID  FnctName;
N*
N*                           FnctName();
N*
N*               (b) (1) 'CPU_FNCT_PTR'  data type defined to replace the commonly-used function pointer
N*                       data type of a pointer to a function which returns void & has a single void
N*                       pointer argument.
N*
N*                   (2) Example function pointer usage :
N*
N*                           CPU_FNCT_PTR   FnctName;
N*                           void          *p_obj
N*
N*                           FnctName(p_obj);
N*********************************************************************************************************
N*/
N
Ntypedef            void        CPU_VOID;
Ntypedef            char        CPU_CHAR;                        /*  8-bit character                                     */
Ntypedef  unsigned  char        CPU_BOOLEAN;                     /*  8-bit boolean or logical                            */
Ntypedef  unsigned  char        CPU_INT08U;                      /*  8-bit unsigned integer                              */
Ntypedef    signed  char        CPU_INT08S;                      /*  8-bit   signed integer                              */
Ntypedef  unsigned  short       CPU_INT16U;                      /* 16-bit unsigned integer                              */
Ntypedef    signed  short       CPU_INT16S;                      /* 16-bit   signed integer                              */
Ntypedef  unsigned  int         CPU_INT32U;                      /* 32-bit unsigned integer                              */
Ntypedef    signed  int         CPU_INT32S;                      /* 32-bit   signed integer                              */
Ntypedef  unsigned  long  long  CPU_INT64U;                      /* 64-bit unsigned integer                              */
Ntypedef    signed  long  long  CPU_INT64S;                      /* 64-bit   signed integer                              */
N
Ntypedef            float       CPU_FP32;                        /* 32-bit floating point                                */
Ntypedef            double      CPU_FP64;                        /* 64-bit floating point                                */
N
N
Ntypedef  volatile  CPU_INT08U  CPU_REG08;                       /*  8-bit register                                      */
Ntypedef  volatile  CPU_INT16U  CPU_REG16;                       /* 16-bit register                                      */
Ntypedef  volatile  CPU_INT32U  CPU_REG32;                       /* 32-bit register                                      */
Ntypedef  volatile  CPU_INT64U  CPU_REG64;                       /* 64-bit register                                      */
N
N
Ntypedef            void      (*CPU_FNCT_VOID)(void);            /* See Note #2a.                                        */
Ntypedef            void      (*CPU_FNCT_PTR )(void *p_obj);     /* See Note #2b.                                        */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                       CPU WORD CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_ADDR_SIZE, CPU_CFG_DATA_SIZE, & CPU_CFG_DATA_SIZE_MAX with CPU's &/or 
N*               compiler's word sizes :
N*
N*                   CPU_WORD_SIZE_08             8-bit word size
N*                   CPU_WORD_SIZE_16            16-bit word size
N*                   CPU_WORD_SIZE_32            32-bit word size
N*                   CPU_WORD_SIZE_64            64-bit word size
N*
N*           (2) Configure CPU_CFG_ENDIAN_TYPE with CPU's data-word-memory order :
N*
N*               (a) CPU_ENDIAN_TYPE_BIG         Big-   endian word order (CPU words' most  significant
N*                                                                         octet @ lowest memory address)
N*               (b) CPU_ENDIAN_TYPE_LITTLE      Little-endian word order (CPU words' least significant
N*                                                                         octet @ lowest memory address)
N*********************************************************************************************************
N*/
N
N                                                                /* Define  CPU         word sizes (see Note #1) :       */
N#define  CPU_CFG_ADDR_SIZE              CPU_WORD_SIZE_32        /* Defines CPU address word size  (in octets).          */
N#define  CPU_CFG_DATA_SIZE              CPU_WORD_SIZE_32        /* Defines CPU data    word size  (in octets).          */
N#define  CPU_CFG_DATA_SIZE_MAX          CPU_WORD_SIZE_64        /* Defines CPU maximum word size  (in octets).          */
N
N#define  CPU_CFG_ENDIAN_TYPE            CPU_ENDIAN_TYPE_LITTLE  /* Defines CPU data    word-memory order (see Note #2). */
N
N
N/*
N*********************************************************************************************************
N*                                 CONFIGURE CPU ADDRESS & DATA TYPES
N*********************************************************************************************************
N*/
N
N                                                                /* CPU address type based on address bus size.          */
N#if     (CPU_CFG_ADDR_SIZE == CPU_WORD_SIZE_32)
X#if     (4 == 4)
Ntypedef  CPU_INT32U  CPU_ADDR;
N#elif   (CPU_CFG_ADDR_SIZE == CPU_WORD_SIZE_16)
Stypedef  CPU_INT16U  CPU_ADDR;
S#else
Stypedef  CPU_INT08U  CPU_ADDR;
N#endif
N
N                                                                /* CPU data    type based on data    bus size.          */
N#if     (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_32)
X#if     (4 == 4)
Ntypedef  CPU_INT32U  CPU_DATA;
N#elif   (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_16)
Stypedef  CPU_INT16U  CPU_DATA;
S#else
Stypedef  CPU_INT08U  CPU_DATA;
N#endif
N
N
Ntypedef  CPU_DATA    CPU_ALIGN;                                 /* Defines CPU data-word-alignment size.                */
Ntypedef  CPU_ADDR    CPU_SIZE_T;                                /* Defines CPU standard 'size_t'   size.                */
N
N
N/*
N*********************************************************************************************************
N*                                       CPU STACK CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_STK_GROWTH in 'cpu.h' with CPU's stack growth order :
N*
N*               (a) CPU_STK_GROWTH_LO_TO_HI     CPU stack pointer increments to the next higher  stack
N*                                                   memory address after data is pushed onto the stack
N*               (b) CPU_STK_GROWTH_HI_TO_LO     CPU stack pointer decrements to the next lower   stack
N*                                                   memory address after data is pushed onto the stack
N*********************************************************************************************************
N*/
N
N#define  CPU_CFG_STK_GROWTH     CPU_STK_GROWTH_HI_TO_LO         /* Defines CPU stack growth order (see Note #1).        */
N
Ntypedef  CPU_INT32U             CPU_STK;                        /* Defines CPU stack word size (in octets).             */
Ntypedef  CPU_ADDR               CPU_STK_SIZE;                   /* Defines CPU stack      size (in number of CPU_STKs). */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                   CRITICAL SECTION CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_CRITICAL_METHOD with CPU's/compiler's critical section method :
N*
N*                                                       Enter/Exit critical sections by ...
N*
N*                   CPU_CRITICAL_METHOD_INT_DIS_EN      Disable/Enable interrupts
N*                   CPU_CRITICAL_METHOD_STATUS_STK      Push/Pop       interrupt status onto stack
N*                   CPU_CRITICAL_METHOD_STATUS_LOCAL    Save/Restore   interrupt status to local variable
N*
N*               (a) CPU_CRITICAL_METHOD_INT_DIS_EN  is NOT a preferred method since it does NOT support
N*                   multiple levels of interrupts.  However, with some CPUs/compilers, this is the only
N*                   available method.
N*
N*               (b) CPU_CRITICAL_METHOD_STATUS_STK    is one preferred method since it supports multiple
N*                   levels of interrupts.  However, this method assumes that the compiler provides C-level
N*                   &/or assembly-level functionality for the following :
N*
N*                     ENTER CRITICAL SECTION :
N*                       (1) Push/save   interrupt status onto a local stack
N*                       (2) Disable     interrupts
N*
N*                     EXIT  CRITICAL SECTION :
N*                       (3) Pop/restore interrupt status from a local stack
N*
N*               (c) CPU_CRITICAL_METHOD_STATUS_LOCAL  is one preferred method since it supports multiple
N*                   levels of interrupts.  However, this method assumes that the compiler provides C-level
N*                   &/or assembly-level functionality for the following :
N*
N*                     ENTER CRITICAL SECTION :
N*                       (1) Save    interrupt status into a local variable
N*                       (2) Disable interrupts
N*
N*                     EXIT  CRITICAL SECTION :
N*                       (3) Restore interrupt status from a local variable
N*
N*           (2) Critical section macro's most likely require inline assembly.  If the compiler does NOT
N*               allow inline assembly in C source files, critical section macro's MUST call an assembly
N*               subroutine defined in a 'cpu_a.asm' file located in the following software directory :
N*
N*                   \<CPU-Compiler Directory>\<cpu>\<compiler>\
N*
X
N*                       where
N*                               <CPU-Compiler Directory>    directory path for common   CPU-compiler software
N*                               <cpu>                       directory name for specific CPU
N*                               <compiler>                  directory name for specific compiler
N*
N*           (3) (a) To save/restore interrupt status, a local variable 'cpu_sr' of type 'CPU_SR' MAY need
N*                   to be declared (e.g. if 'CPU_CRITICAL_METHOD_STATUS_LOCAL' method is configured).
N*
N*                   (1) 'cpu_sr' local variable SHOULD be declared via the CPU_SR_ALLOC() macro which, if 
N*                        used, MUST be declared following ALL other local variables.
N*
N*                        Example :
N*
N*                           void  Fnct (void)
N*                           {
N*                               CPU_INT08U  val_08;
N*                               CPU_INT16U  val_16;
N*                               CPU_INT32U  val_32;
N*                               CPU_SR_ALLOC();         MUST be declared after ALL other local variables
N*                                   :
N*                                   :
N*                           }
N*
N*               (b) Configure 'CPU_SR' data type with the appropriate-sized CPU data type large enough to
N*                   completely store the CPU's/compiler's status word.
N*********************************************************************************************************
N*/
N/*$PAGE*/
N                                                                /* Configure CPU critical method      (see Note #1) :   */
N#define  CPU_CFG_CRITICAL_METHOD    CPU_CRITICAL_METHOD_STATUS_LOCAL
N
Ntypedef  CPU_INT32U                 CPU_SR;                     /* Defines   CPU status register size (see Note #3b).   */
N
N                                                                /* Allocates CPU status register word (see Note #3a).   */
N#if     (CPU_CFG_CRITICAL_METHOD == CPU_CRITICAL_METHOD_STATUS_LOCAL)
X#if     (3u == 3u)
N#define  CPU_SR_ALLOC()             CPU_SR  cpu_sr = (CPU_SR)0
N#else
S#define  CPU_SR_ALLOC()
N#endif
N
N
N
N#define  CPU_INT_DIS()         do { cpu_sr = CPU_SR_Save(); } while (0) /* Save    CPU status word & disable interrupts.*/
N#define  CPU_INT_EN()          do { CPU_SR_Restore(cpu_sr); } while (0) /* Restore CPU status word.                     */
N
N
N#ifdef   CPU_CFG_INT_DIS_MEAS_EN
S                                                                        /* Disable interrupts, ...                      */
S                                                                        /* & start interrupts disabled time measurement.*/
S#define  CPU_CRITICAL_ENTER()  do { CPU_INT_DIS();         \
S                                    CPU_IntDisMeasStart(); }  while (0)
X#define  CPU_CRITICAL_ENTER()  do { CPU_INT_DIS();                                             CPU_IntDisMeasStart(); }  while (0)
S                                                                        /* Stop & measure   interrupts disabled time,   */
S                                                                        /* ...  & re-enable interrupts.                 */
S#define  CPU_CRITICAL_EXIT()   do { CPU_IntDisMeasStop();  \
S                                    CPU_INT_EN();          }  while (0)
X#define  CPU_CRITICAL_EXIT()   do { CPU_IntDisMeasStop();                                      CPU_INT_EN();          }  while (0)
S
N#else
N
N#define  CPU_CRITICAL_ENTER()  do { CPU_INT_DIS(); } while (0)          /* Disable   interrupts.                        */
N#define  CPU_CRITICAL_EXIT()   do { CPU_INT_EN();  } while (0)          /* Re-enable interrupts.                        */
N
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                    CPU COUNT ZEROS CONFIGURATION
N*
N* Note(s) : (1) (a) Configure CPU_CFG_LEAD_ZEROS_ASM_PRESENT  to define count leading  zeros bits 
N*                   function(s) in :
N*
N*                   (1) 'cpu_a.asm',  if CPU_CFG_LEAD_ZEROS_ASM_PRESENT       #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable assembly-optimized function(s)
N*
N*                   (2) 'cpu_core.c', if CPU_CFG_LEAD_ZEROS_ASM_PRESENT   NOT #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable C-source-optimized function(s) otherwise
N*
N*               (b) Configure CPU_CFG_TRAIL_ZEROS_ASM_PRESENT to define count trailing zeros bits 
N*                   function(s) in :
N*
N*                   (1) 'cpu_a.asm',  if CPU_CFG_TRAIL_ZEROS_ASM_PRESENT      #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable assembly-optimized function(s)
N*
N*                   (2) 'cpu_core.c', if CPU_CFG_TRAIL_ZEROS_ASM_PRESENT  NOT #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable C-source-optimized function(s) otherwise
N*********************************************************************************************************
N*/
N
N                                                                /* Configure CPU count leading  zeros bits ...          */
N#define  CPU_CFG_LEAD_ZEROS_ASM_PRESENT                         /* ... assembly-version (see Note #1a).                 */
N
N                                                                /* Configure CPU count trailing zeros bits ...          */
N#define  CPU_CFG_TRAIL_ZEROS_ASM_PRESENT                        /* ... assembly-version (see Note #1b).                 */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
Nvoid        CPU_IntDis       (void);
Nvoid        CPU_IntEn        (void);
N
Nvoid        CPU_IntSrcDis    (CPU_INT08U  pos);
Nvoid        CPU_IntSrcEn     (CPU_INT08U  pos);
Nvoid        CPU_IntSrcPendClr(CPU_INT08U  pos);
NCPU_INT16S  CPU_IntSrcPrioGet(CPU_INT08U  pos);
Nvoid        CPU_IntSrcPrioSet(CPU_INT08U  pos,
N                              CPU_INT08U  prio);
N
N
NCPU_SR      CPU_SR_Save      (void);
Nvoid        CPU_SR_Restore   (CPU_SR      cpu_sr);
N
N
Nvoid        CPU_WaitForInt   (void);
Nvoid        CPU_WaitForExcept(void);
N
N
NCPU_DATA    CPU_RevBits      (CPU_DATA    val);
N
Nvoid        CPU_BitBandClr   (CPU_ADDR    addr,
N                              CPU_INT08U  bit_nbr);
Nvoid        CPU_BitBandSet   (CPU_ADDR    addr,
N                              CPU_INT08U  bit_nbr);
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          INTERRUPT SOURCES
N*********************************************************************************************************
N*/
N
N#define  CPU_INT_STK_PTR                                   0u
N#define  CPU_INT_RESET                                     1u
N#define  CPU_INT_NMI                                       2u
N#define  CPU_INT_HFAULT                                    3u
N#define  CPU_INT_MEM                                       4u
N#define  CPU_INT_BUSFAULT                                  5u
N#define  CPU_INT_USAGEFAULT                                6u
N#define  CPU_INT_RSVD_07                                   7u
N#define  CPU_INT_RSVD_08                                   8u
N#define  CPU_INT_RSVD_09                                   9u
N#define  CPU_INT_RSVD_10                                  10u
N#define  CPU_INT_SVCALL                                   11u
N#define  CPU_INT_DBGMON                                   12u
N#define  CPU_INT_RSVD_13                                  13u
N#define  CPU_INT_PENDSV                                   14u
N#define  CPU_INT_SYSTICK                                  15u
N#define  CPU_INT_EXT0                                     16u
N
N
N/*
N*********************************************************************************************************
N*                                            CPU REGISTERS
N*********************************************************************************************************
N*/
N
N#define  CPU_REG_NVIC_NVIC           (*((CPU_REG32 *)(0xE000E004)))             /* Int Ctrl'er Type Reg.                */
N#define  CPU_REG_NVIC_ST_CTRL        (*((CPU_REG32 *)(0xE000E010)))             /* SysTick Ctrl & Status Reg.           */
N#define  CPU_REG_NVIC_ST_RELOAD      (*((CPU_REG32 *)(0xE000E014)))             /* SysTick Reload      Value Reg.       */
N#define  CPU_REG_NVIC_ST_CURRENT     (*((CPU_REG32 *)(0xE000E018)))             /* SysTick Current     Value Reg.       */
N#define  CPU_REG_NVIC_ST_CAL         (*((CPU_REG32 *)(0xE000E01C)))             /* SysTick Calibration Value Reg.       */
N
N#define  CPU_REG_NVIC_SETEN(n)       (*((CPU_REG32 *)(0xE000E100 + (n) * 4u)))  /* IRQ Set En Reg.                      */
N#define  CPU_REG_NVIC_CLREN(n)       (*((CPU_REG32 *)(0xE000E180 + (n) * 4u)))  /* IRQ Clr En Reg.                      */
N#define  CPU_REG_NVIC_SETPEND(n)     (*((CPU_REG32 *)(0xE000E200 + (n) * 4u)))  /* IRQ Set Pending Reg.                 */
N#define  CPU_REG_NVIC_CLRPEND(n)     (*((CPU_REG32 *)(0xE000E280 + (n) * 4u)))  /* IRQ Clr Pending Reg.                 */
N#define  CPU_REG_NVIC_ACTIVE(n)      (*((CPU_REG32 *)(0xE000E300 + (n) * 4u)))  /* IRQ Active Reg.                      */
N#define  CPU_REG_NVIC_PRIO(n)        (*((CPU_REG32 *)(0xE000E400 + (n) * 4u)))  /* IRQ Prio Reg.                        */
N
N#define  CPU_REG_NVIC_CPUID          (*((CPU_REG32 *)(0xE000ED00)))             /* CPUID Base Reg.                      */
N#define  CPU_REG_NVIC_ICSR           (*((CPU_REG32 *)(0xE000ED04)))             /* Int Ctrl State  Reg.                 */
N#define  CPU_REG_NVIC_VTOR           (*((CPU_REG32 *)(0xE000ED08)))             /* Vect Tbl Offset Reg.                 */
N#define  CPU_REG_NVIC_AIRCR          (*((CPU_REG32 *)(0xE000ED0C)))             /* App Int/Reset Ctrl Reg.              */
N#define  CPU_REG_NVIC_SCR            (*((CPU_REG32 *)(0xE000ED10)))             /* System Ctrl Reg.                     */
N#define  CPU_REG_NVIC_CCR            (*((CPU_REG32 *)(0xE000ED14)))             /* Cfg    Ctrl Reg.                     */
N#define  CPU_REG_NVIC_SHPRI1         (*((CPU_REG32 *)(0xE000ED18)))             /* System Handlers  4 to  7 Prio.       */
N#define  CPU_REG_NVIC_SHPRI2         (*((CPU_REG32 *)(0xE000ED1C)))             /* System Handlers  8 to 11 Prio.       */
N#define  CPU_REG_NVIC_SHPRI3         (*((CPU_REG32 *)(0xE000ED20)))             /* System Handlers 12 to 15 Prio.       */
N#define  CPU_REG_NVIC_SHCSR          (*((CPU_REG32 *)(0xE000ED24)))             /* System Handler Ctrl & State Reg.     */
N#define  CPU_REG_NVIC_CFSR           (*((CPU_REG32 *)(0xE000ED28)))             /* Configurable Fault Status Reg.       */
N#define  CPU_REG_NVIC_HFSR           (*((CPU_REG32 *)(0xE000ED2C)))             /* Hard  Fault Status Reg.              */
N#define  CPU_REG_NVIC_DFSR           (*((CPU_REG32 *)(0xE000ED30)))             /* Debug Fault Status Reg.              */
N#define  CPU_REG_NVIC_MMFAR          (*((CPU_REG32 *)(0xE000ED34)))             /* Mem Manage Addr Reg.                 */
N#define  CPU_REG_NVIC_BFAR           (*((CPU_REG32 *)(0xE000ED38)))             /* Bus Fault  Addr Reg.                 */
N#define  CPU_REG_NVIC_AFSR           (*((CPU_REG32 *)(0xE000ED3C)))             /* Aux Fault Status Reg.                */
N
N#define  CPU_REG_NVIC_PFR0           (*((CPU_REG32 *)(0xE000ED40)))             /* Processor Feature Reg 0.             */
N#define  CPU_REG_NVIC_PFR1           (*((CPU_REG32 *)(0xE000ED44)))             /* Processor Feature Reg 1.             */
N#define  CPU_REG_NVIC_DFR0           (*((CPU_REG32 *)(0xE000ED48)))             /* Debug     Feature Reg 0.             */
N#define  CPU_REG_NVIC_AFR0           (*((CPU_REG32 *)(0xE000ED4C)))             /* Aux       Feature Reg 0.             */
N#define  CPU_REG_NVIC_MMFR0          (*((CPU_REG32 *)(0xE000ED50)))             /* Memory Model Feature Reg 0.          */
N#define  CPU_REG_NVIC_MMFR1          (*((CPU_REG32 *)(0xE000ED54)))             /* Memory Model Feature Reg 1.          */
N#define  CPU_REG_NVIC_MMFR2          (*((CPU_REG32 *)(0xE000ED58)))             /* Memory Model Feature Reg 2.          */
N#define  CPU_REG_NVIC_MMFR3          (*((CPU_REG32 *)(0xE000ED5C)))             /* Memory Model Feature Reg 3.          */
N#define  CPU_REG_NVIC_ISAFR0         (*((CPU_REG32 *)(0xE000ED60)))             /* ISA Feature Reg 0.                   */
N#define  CPU_REG_NVIC_ISAFR1         (*((CPU_REG32 *)(0xE000ED64)))             /* ISA Feature Reg 1.                   */
N#define  CPU_REG_NVIC_ISAFR2         (*((CPU_REG32 *)(0xE000ED68)))             /* ISA Feature Reg 2.                   */
N#define  CPU_REG_NVIC_ISAFR3         (*((CPU_REG32 *)(0xE000ED6C)))             /* ISA Feature Reg 3.                   */
N#define  CPU_REG_NVIC_ISAFR4         (*((CPU_REG32 *)(0xE000ED70)))             /* ISA Feature Reg 4.                   */
N#define  CPU_REG_NVIC_SW_TRIG        (*((CPU_REG32 *)(0xE000EF00)))             /* Software Trigger Int Reg.            */
N
N#define  CPU_REG_MPU_TYPE            (*((CPU_REG32 *)(0xE000ED90)))             /* MPU Type Reg.                        */
N#define  CPU_REG_MPU_CTRL            (*((CPU_REG32 *)(0xE000ED94)))             /* MPU Ctrl Reg.                        */
N#define  CPU_REG_MPU_REG_NBR         (*((CPU_REG32 *)(0xE000ED98)))             /* MPU Region Nbr Reg.                  */
N#define  CPU_REG_MPU_REG_BASE        (*((CPU_REG32 *)(0xE000ED9C)))             /* MPU Region Base Addr Reg.            */
N#define  CPU_REG_MPU_REG_ATTR        (*((CPU_REG32 *)(0xE000EDA0)))             /* MPU Region Attrib & Size Reg.        */
N
N#define  CPU_REG_DBG_CTRL            (*((CPU_REG32 *)(0xE000EDF0)))             /* Debug Halting Ctrl & Status Reg.     */
N#define  CPU_REG_DBG_SELECT          (*((CPU_REG32 *)(0xE000EDF4)))             /* Debug Core Reg Selector Reg.         */
N#define  CPU_REG_DBG_DATA            (*((CPU_REG32 *)(0xE000EDF8)))             /* Debug Core Reg Data     Reg.         */
N#define  CPU_REG_DBG_INT             (*((CPU_REG32 *)(0xE000EDFC)))             /* Debug Except & Monitor Ctrl Reg.     */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          CPU REGISTER BITS
N*********************************************************************************************************
N*/
N
N                                                                /* ---------- SYSTICK CTRL & STATUS REG BITS ---------- */
N#define  CPU_REG_NVIC_ST_CTRL_COUNTFLAG           0x00010000
N#define  CPU_REG_NVIC_ST_CTRL_CLKSOURCE           0x00000004
N#define  CPU_REG_NVIC_ST_CTRL_TICKINT             0x00000002
N#define  CPU_REG_NVIC_ST_CTRL_ENABLE              0x00000001
N
N
N                                                                /* -------- SYSTICK CALIBRATION VALUE REG BITS -------- */
N#define  CPU_REG_NVIC_ST_CAL_NOREF                0x80000000
N#define  CPU_REG_NVIC_ST_CAL_SKEW                 0x40000000
N
N                                                                /* -------------- INT CTRL STATE REG BITS ------------- */
N#define  CPU_REG_NVIC_ICSR_NMIPENDSET             0x80000000
N#define  CPU_REG_NVIC_ICSR_PENDSVSET              0x10000000
N#define  CPU_REG_NVIC_ICSR_PENDSVCLR              0x08000000
N#define  CPU_REG_NVIC_ICSR_PENDSTSET              0x04000000
N#define  CPU_REG_NVIC_ICSR_PENDSTCLR              0x02000000
N#define  CPU_REG_NVIC_ICSR_ISRPREEMPT             0x00800000
N#define  CPU_REG_NVIC_ICSR_ISRPENDING             0x00400000
N#define  CPU_REG_NVIC_ICSR_RETTOBASE              0x00000800
N
N                                                                /* ------------- VECT TBL OFFSET REG BITS ------------- */
N#define  CPU_REG_NVIC_VTOR_TBLBASE                0x20000000
N
N                                                                /* ------------ APP INT/RESET CTRL REG BITS ----------- */
N#define  CPU_REG_NVIC_AIRCR_ENDIANNESS            0x00008000
N#define  CPU_REG_NVIC_AIRCR_SYSRESETREQ           0x00000004
N#define  CPU_REG_NVIC_AIRCR_VECTCLRACTIVE         0x00000002
N#define  CPU_REG_NVIC_AIRCR_VECTRESET             0x00000001
N
N                                                                /* --------------- SYSTEM CTRL REG BITS --------------- */
N#define  CPU_REG_NVIC_SCR_SEVONPEND               0x00000010
N#define  CPU_REG_NVIC_SCR_SLEEPDEEP               0x00000004
N#define  CPU_REG_NVIC_SCR_SLEEPONEXIT             0x00000002
N
N                                                                /* ----------------- CFG CTRL REG BITS ---------------- */
N#define  CPU_REG_NVIC_CCR_STKALIGN                0x00000200
N#define  CPU_REG_NVIC_CCR_BFHFNMIGN               0x00000100
N#define  CPU_REG_NVIC_CCR_DIV_0_TRP               0x00000010
N#define  CPU_REG_NVIC_CCR_UNALIGN_TRP             0x00000008
N#define  CPU_REG_NVIC_CCR_USERSETMPEND            0x00000002
N#define  CPU_REG_NVIC_CCR_NONBASETHRDENA          0x00000001
N
N                                                                /* ------- SYSTEM HANDLER CTRL & STATE REG BITS ------- */
N#define  CPU_REG_NVIC_SHCSR_USGFAULTENA           0x00040000
N#define  CPU_REG_NVIC_SHCSR_BUSFAULTENA           0x00020000
N#define  CPU_REG_NVIC_SHCSR_MEMFAULTENA           0x00010000
N#define  CPU_REG_NVIC_SHCSR_SVCALLPENDED          0x00008000
N#define  CPU_REG_NVIC_SHCSR_BUSFAULTPENDED        0x00004000
N#define  CPU_REG_NVIC_SHCSR_MEMFAULTPENDED        0x00002000
N#define  CPU_REG_NVIC_SHCSR_USGFAULTPENDED        0x00001000
N#define  CPU_REG_NVIC_SHCSR_SYSTICKACT            0x00000800
N#define  CPU_REG_NVIC_SHCSR_PENDSVACT             0x00000400
N#define  CPU_REG_NVIC_SHCSR_MONITORACT            0x00000100
N#define  CPU_REG_NVIC_SHCSR_SVCALLACT             0x00000080
N#define  CPU_REG_NVIC_SHCSR_USGFAULTACT           0x00000008
N#define  CPU_REG_NVIC_SHCSR_BUSFAULTACT           0x00000002
N#define  CPU_REG_NVIC_SHCSR_MEMFAULTACT           0x00000001
N
N/*$PAGE*/
N                                                                /* -------- CONFIGURABLE FAULT STATUS REG BITS -------- */
N#define  CPU_REG_NVIC_CFSR_DIVBYZERO              0x02000000
N#define  CPU_REG_NVIC_CFSR_UNALIGNED              0x01000000
N#define  CPU_REG_NVIC_CFSR_NOCP                   0x00080000
N#define  CPU_REG_NVIC_CFSR_INVPC                  0x00040000
N#define  CPU_REG_NVIC_CFSR_INVSTATE               0x00020000
N#define  CPU_REG_NVIC_CFSR_UNDEFINSTR             0x00010000
N#define  CPU_REG_NVIC_CFSR_BFARVALID              0x00008000
N#define  CPU_REG_NVIC_CFSR_STKERR                 0x00001000
N#define  CPU_REG_NVIC_CFSR_UNSTKERR               0x00000800
N#define  CPU_REG_NVIC_CFSR_IMPRECISERR            0x00000400
N#define  CPU_REG_NVIC_CFSR_PRECISERR              0x00000200
N#define  CPU_REG_NVIC_CFSR_IBUSERR                0x00000100
N#define  CPU_REG_NVIC_CFSR_MMARVALID              0x00000080
N#define  CPU_REG_NVIC_CFSR_MSTKERR                0x00000010
N#define  CPU_REG_NVIC_CFSR_MUNSTKERR              0x00000008
N#define  CPU_REG_NVIC_CFSR_DACCVIOL               0x00000002
N#define  CPU_REG_NVIC_CFSR_IACCVIOL               0x00000001
N
N                                                                /* ------------ HARD FAULT STATUS REG BITS ------------ */
N#define  CPU_REG_NVIC_HFSR_DEBUGEVT               0x80000000
N#define  CPU_REG_NVIC_HFSR_FORCED                 0x40000000
N#define  CPU_REG_NVIC_HFSR_VECTTBL                0x00000002
N
N                                                                /* ------------ DEBUG FAULT STATUS REG BITS ----------- */
N#define  CPU_REG_NVIC_DFSR_EXTERNAL               0x00000010
N#define  CPU_REG_NVIC_DFSR_VCATCH                 0x00000008
N#define  CPU_REG_NVIC_DFSR_DWTTRAP                0x00000004
N#define  CPU_REG_NVIC_DFSR_BKPT                   0x00000002
N#define  CPU_REG_NVIC_DFSR_HALTED                 0x00000001
N
N
N/*
N*********************************************************************************************************
N*                                          CPU REGISTER MASK
N*********************************************************************************************************
N*/
N
N#define  CPU_MSK_NVIC_ICSR_VECT_ACTIVE            0x000001FF
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N#ifndef  CPU_CFG_ADDR_SIZE
S#error  "CPU_CFG_ADDR_SIZE              not #define'd in 'cpu.h'               "
S#error  "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_64  64-bit alignment]"
S
S#elif  ((CPU_CFG_ADDR_SIZE != CPU_WORD_SIZE_08) && \
S        (CPU_CFG_ADDR_SIZE != CPU_WORD_SIZE_16) && \
S        (CPU_CFG_ADDR_SIZE != CPU_WORD_SIZE_32) && \
S        (CPU_CFG_ADDR_SIZE != CPU_WORD_SIZE_64))
X#elif  ((4 != 1) &&         (4 != 2) &&         (4 != 4) &&         (4 != 8))
S#error  "CPU_CFG_ADDR_SIZE        illegally #define'd in 'cpu.h'               "
S#error  "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_64  64-bit alignment]"
N#endif
N
N
N#ifndef  CPU_CFG_DATA_SIZE
S#error  "CPU_CFG_DATA_SIZE              not #define'd in 'cpu.h'               "
S#error  "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_64  64-bit alignment]"
S
S#elif  ((CPU_CFG_DATA_SIZE != CPU_WORD_SIZE_08) && \
S        (CPU_CFG_DATA_SIZE != CPU_WORD_SIZE_16) && \
S        (CPU_CFG_DATA_SIZE != CPU_WORD_SIZE_32) && \
S        (CPU_CFG_DATA_SIZE != CPU_WORD_SIZE_64))
X#elif  ((4 != 1) &&         (4 != 2) &&         (4 != 4) &&         (4 != 8))
S#error  "CPU_CFG_DATA_SIZE        illegally #define'd in 'cpu.h'               "
S#error  "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_64  64-bit alignment]"
N#endif
N
N
N#ifndef  CPU_CFG_DATA_SIZE_MAX
S#error  "CPU_CFG_DATA_SIZE_MAX          not #define'd in 'cpu.h'               "
S#error  "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_64  64-bit alignment]"
S
S#elif  ((CPU_CFG_DATA_SIZE_MAX != CPU_WORD_SIZE_08) && \
S        (CPU_CFG_DATA_SIZE_MAX != CPU_WORD_SIZE_16) && \
S        (CPU_CFG_DATA_SIZE_MAX != CPU_WORD_SIZE_32) && \
S        (CPU_CFG_DATA_SIZE_MAX != CPU_WORD_SIZE_64))
X#elif  ((8 != 1) &&         (8 != 2) &&         (8 != 4) &&         (8 != 8))
S#error  "CPU_CFG_DATA_SIZE_MAX    illegally #define'd in 'cpu.h'               "
S#error  "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_64  64-bit alignment]"
N#endif
N
N
N
N#if     (CPU_CFG_DATA_SIZE_MAX < CPU_CFG_DATA_SIZE)
X#if     (8 < 4)
S#error  "CPU_CFG_DATA_SIZE_MAX    illegally #define'd in 'cpu.h' "
S#error  "                         [MUST be  >= CPU_CFG_DATA_SIZE]"
N#endif
N
N
N
N
N/*$PAGE*/
N#ifndef  CPU_CFG_ENDIAN_TYPE
S#error  "CPU_CFG_ENDIAN_TYPE            not #define'd in 'cpu.h'   "
S#error  "                         [MUST be  CPU_ENDIAN_TYPE_BIG   ]"
S#error  "                         [     ||  CPU_ENDIAN_TYPE_LITTLE]"
S
S#elif  ((CPU_CFG_ENDIAN_TYPE != CPU_ENDIAN_TYPE_BIG   ) && \
S        (CPU_CFG_ENDIAN_TYPE != CPU_ENDIAN_TYPE_LITTLE))
X#elif  ((2u != 1u   ) &&         (2u != 2u))
S#error  "CPU_CFG_ENDIAN_TYPE      illegally #define'd in 'cpu.h'   "
S#error  "                         [MUST be  CPU_ENDIAN_TYPE_BIG   ]"
S#error  "                         [     ||  CPU_ENDIAN_TYPE_LITTLE]"
N#endif
N
N
N
N
N#ifndef  CPU_CFG_STK_GROWTH
S#error  "CPU_CFG_STK_GROWTH             not #define'd in 'cpu.h'    "
S#error  "                         [MUST be  CPU_STK_GROWTH_LO_TO_HI]"
S#error  "                         [     ||  CPU_STK_GROWTH_HI_TO_LO]"
S
S#elif  ((CPU_CFG_STK_GROWTH != CPU_STK_GROWTH_LO_TO_HI) && \
S        (CPU_CFG_STK_GROWTH != CPU_STK_GROWTH_HI_TO_LO))
X#elif  ((2u != 1u) &&         (2u != 2u))
S#error  "CPU_CFG_STK_GROWTH       illegally #define'd in 'cpu.h'    "
S#error  "                         [MUST be  CPU_STK_GROWTH_LO_TO_HI]"
S#error  "                         [     ||  CPU_STK_GROWTH_HI_TO_LO]"
N#endif
N
N
N
N
N#ifndef  CPU_CFG_CRITICAL_METHOD
S#error  "CPU_CFG_CRITICAL_METHOD        not #define'd in 'cpu.h'             "
S#error  "                         [MUST be  CPU_CRITICAL_METHOD_INT_DIS_EN  ]"
S#error  "                         [     ||  CPU_CRITICAL_METHOD_STATUS_STK  ]"
S#error  "                         [     ||  CPU_CRITICAL_METHOD_STATUS_LOCAL]"
S
S#elif  ((CPU_CFG_CRITICAL_METHOD != CPU_CRITICAL_METHOD_INT_DIS_EN  ) && \
S        (CPU_CFG_CRITICAL_METHOD != CPU_CRITICAL_METHOD_STATUS_STK  ) && \
S        (CPU_CFG_CRITICAL_METHOD != CPU_CRITICAL_METHOD_STATUS_LOCAL))
X#elif  ((3u != 1u  ) &&         (3u != 2u  ) &&         (3u != 3u))
S#error  "CPU_CFG_CRITICAL_METHOD  illegally #define'd in 'cpu.h'             "
S#error  "                         [MUST be  CPU_CRITICAL_METHOD_INT_DIS_EN  ]"
S#error  "                         [     ||  CPU_CRITICAL_METHOD_STATUS_STK  ]"
S#error  "                         [     ||  CPU_CRITICAL_METHOD_STATUS_LOCAL]"
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*
N* Note(s) : (1) See 'cpu.h  MODULE'.
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of CPU module include.                           */
N
L 105 "..\..\uC-CPU\cpu_core.h" 2
N#include  <lib_def.h>
L 1 "..\..\uC-LIB\lib_def.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/LIB
N*                                        CUSTOM LIBRARY MODULES
N*
N*                          (c) Copyright 2004-2012; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/LIB is provided in source form to registered licensees ONLY.  It is 
N*               illegal to distribute this source code to any third party unless you receive 
N*               written permission by an authorized Micrium representative.  Knowledge of 
N*               the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest 
N*               software available.  Your honesty is greatly appreciated.
N*
N*               You can contact us at www.micrium.com.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                     CORE CUSTOM LIBRARY MODULE
N*
N* Filename      : lib_def.h
N* Version       : V1.37.01
N* Programmer(s) : ITJ
N*                 FBJ
N*********************************************************************************************************
N* Note(s)       : (1) Assumes the following versions (or more recent) of software modules are included in 
N*                     the project build :
N*
N*                     (a) uC/CPU V1.29.00
N*
N*
N*                 (2) NO compiler-supplied standard library functions are used in library or product software.
N*
N*                     (a) ALL standard library functions are implemented in the custom library modules :
N*
N*                         (1) \<Custom Library Directory>\lib_*.*
N*
N*                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
N*
N*                               where
N*                                       <Custom Library Directory>      directory path for custom library software
N*                                       <cpu>                           directory name for specific processor (CPU)
N*                                       <compiler>                      directory name for specific compiler
N*
N*                     (b) Product-specific library functions are implemented in individual products.
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*
N* Note(s) : (1) This library definition header file is protected from multiple pre-processor inclusion 
N*               through use of the library definition module present pre-processor macro definition.
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_DEF_MODULE_PRESENT
N#define  LIB_DEF_MODULE_PRESENT
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                CUSTOM LIBRARY MODULE VERSION NUMBER
N*
N* Note(s) : (1) (a) The custom library module software version is denoted as follows :
N*
N*                       Vx.yy.zz
N*
N*                           where
N*                                   V               denotes 'Version' label
N*                                   x               denotes     major software version revision number
N*                                   yy              denotes     minor software version revision number
N*                                   zz              denotes sub-minor software version revision number
N*
N*               (b) The software version label #define is formatted as follows :
N*
N*                       ver = x.yyzz * 100 * 100
N*
N*                           where
N*                                   ver             denotes software version number scaled as an integer value
N*                                   x.yyzz          denotes software version number, where the unscaled integer 
N*                                                       portion denotes the major version number & the unscaled 
N*                                                       fractional portion denotes the (concatenated) minor 
N*                                                       version numbers
N*********************************************************************************************************
N*/
N
N#define  LIB_VERSION                                   13700u   /* See Note #1.                                         */
N
N
N/*
N*********************************************************************************************************
N*                                            INCLUDE FILES
N*
N* Note(s) : (1) The custom library software files are located in the following directories :
N*
N*               (a) \<Custom Library Directory>\lib_*.*
N*
N*                       where
N*                               <Custom Library Directory>      directory path for custom library software
N*
N*           (2) CPU-configuration  software files are located in the following directories :
N*
N*               (a) \<CPU-Compiler Directory>\cpu_*.*
N*               (b) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
N*
N*                       where
N*                               <CPU-Compiler Directory>        directory path for common CPU-compiler software
N*                               <cpu>                           directory name for specific processor (CPU)
N*                               <compiler>                      directory name for specific compiler
N*
N*           (3) Compiler MUST be configured to include as additional include path directories :
N*
N*               (a) '\<Custom Library Directory>\' directory                            See Note #1a
N*
N*               (b) (1) '\<CPU-Compiler Directory>\'                  directory         See Note #2a
N*                   (2) '\<CPU-Compiler Directory>\<cpu>\<compiler>\' directory         See Note #2b
N*********************************************************************************************************
N*/
N
N#include  <cpu_def.h>
N#include  <cpu.h>
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          STANDARD DEFINES
N*********************************************************************************************************
N*/
N
N#define  DEF_NULL                                 ((void *)0)
N
N
N                                                                /* ----------------- BOOLEAN DEFINES ------------------ */
N#define  DEF_FALSE                                         0u
N#define  DEF_TRUE                                          1u
N
N#define  DEF_NO                                            0u
N#define  DEF_YES                                           1u
N
N#define  DEF_DISABLED                                      0u
N#define  DEF_ENABLED                                       1u
N
N#define  DEF_INACTIVE                                      0u
N#define  DEF_ACTIVE                                        1u
N
N#define  DEF_INVALID                                       0u
N#define  DEF_VALID                                         1u
N
N#define  DEF_OFF                                           0u
N#define  DEF_ON                                            1u
N
N#define  DEF_CLR                                           0u
N#define  DEF_SET                                           1u
N
N#define  DEF_FAIL                                          0u
N#define  DEF_OK                                            1u
N
N
N                                                                /* ------------------- BIT DEFINES -------------------- */
N#define  DEF_BIT_NONE                                   0x00u
N
N#define  DEF_BIT_00                                     0x01u
N#define  DEF_BIT_01                                     0x02u
N#define  DEF_BIT_02                                     0x04u
N#define  DEF_BIT_03                                     0x08u
N#define  DEF_BIT_04                                     0x10u
N#define  DEF_BIT_05                                     0x20u
N#define  DEF_BIT_06                                     0x40u
N#define  DEF_BIT_07                                     0x80u
N
N#define  DEF_BIT_08                                   0x0100u
N#define  DEF_BIT_09                                   0x0200u
N#define  DEF_BIT_10                                   0x0400u
N#define  DEF_BIT_11                                   0x0800u
N#define  DEF_BIT_12                                   0x1000u
N#define  DEF_BIT_13                                   0x2000u
N#define  DEF_BIT_14                                   0x4000u
N#define  DEF_BIT_15                                   0x8000u
N
N#define  DEF_BIT_16                               0x00010000u
N#define  DEF_BIT_17                               0x00020000u
N#define  DEF_BIT_18                               0x00040000u
N#define  DEF_BIT_19                               0x00080000u
N#define  DEF_BIT_20                               0x00100000u
N#define  DEF_BIT_21                               0x00200000u
N#define  DEF_BIT_22                               0x00400000u
N#define  DEF_BIT_23                               0x00800000u
N
N#define  DEF_BIT_24                               0x01000000u
N#define  DEF_BIT_25                               0x02000000u
N#define  DEF_BIT_26                               0x04000000u
N#define  DEF_BIT_27                               0x08000000u
N#define  DEF_BIT_28                               0x10000000u
N#define  DEF_BIT_29                               0x20000000u
N#define  DEF_BIT_30                               0x40000000u
N#define  DEF_BIT_31                               0x80000000u
N/*$PAGE*/
N#define  DEF_BIT_32                       0x0000000100000000u
N#define  DEF_BIT_33                       0x0000000200000000u
N#define  DEF_BIT_34                       0x0000000400000000u
N#define  DEF_BIT_35                       0x0000000800000000u
N#define  DEF_BIT_36                       0x0000001000000000u
N#define  DEF_BIT_37                       0x0000002000000000u
N#define  DEF_BIT_38                       0x0000004000000000u
N#define  DEF_BIT_39                       0x0000008000000000u
N
N#define  DEF_BIT_40                       0x0000010000000000u
N#define  DEF_BIT_41                       0x0000020000000000u
N#define  DEF_BIT_42                       0x0000040000000000u
N#define  DEF_BIT_43                       0x0000080000000000u
N#define  DEF_BIT_44                       0x0000100000000000u
N#define  DEF_BIT_45                       0x0000200000000000u
N#define  DEF_BIT_46                       0x0000400000000000u
N#define  DEF_BIT_47                       0x0000800000000000u
N
N#define  DEF_BIT_48                       0x0001000000000000u
N#define  DEF_BIT_49                       0x0002000000000000u
N#define  DEF_BIT_50                       0x0004000000000000u
N#define  DEF_BIT_51                       0x0008000000000000u
N#define  DEF_BIT_52                       0x0010000000000000u
N#define  DEF_BIT_53                       0x0020000000000000u
N#define  DEF_BIT_54                       0x0040000000000000u
N#define  DEF_BIT_55                       0x0080000000000000u
N
N#define  DEF_BIT_56                       0x0100000000000000u
N#define  DEF_BIT_57                       0x0200000000000000u
N#define  DEF_BIT_58                       0x0400000000000000u
N#define  DEF_BIT_59                       0x0800000000000000u
N#define  DEF_BIT_60                       0x1000000000000000u
N#define  DEF_BIT_61                       0x2000000000000000u
N#define  DEF_BIT_62                       0x4000000000000000u
N#define  DEF_BIT_63                       0x8000000000000000u
N
N
N                                                                /* ------------------ ALIGN DEFINES ------------------- */
N#define  DEF_ALIGN_MAX_NBR_OCTETS                       4096u
N
N
N                                                                /* ------------------ OCTET DEFINES ------------------- */
N#define  DEF_OCTET_NBR_BITS                                8u
N#define  DEF_OCTET_MASK                                 0xFFu
N
N#define  DEF_OCTET_TO_BIT_NBR_BITS                         3u
N#define  DEF_OCTET_TO_BIT_SHIFT                          DEF_OCTET_TO_BIT_NBR_BITS
N#define  DEF_OCTET_TO_BIT_MASK                          0x07u
N
N
N#define  DEF_NIBBLE_NBR_BITS                               4u
N#define  DEF_NIBBLE_MASK                                0x0Fu
N
N
N                                                                /* --------------- NUMBER BASE DEFINES ---------------- */
N#define  DEF_NBR_BASE_BIN                                  2u
N#define  DEF_NBR_BASE_OCT                                  8u
N#define  DEF_NBR_BASE_DEC                                 10u
N#define  DEF_NBR_BASE_HEX                                 16u
N
N
N/*$PAGE*/
N                                                                /* ----------------- INTEGER DEFINES ------------------ */
N#define  DEF_INT_08_NBR_BITS                               8u
N#define  DEF_INT_08_MASK                                0xFFu
N
N#define  DEF_INT_08U_MIN_VAL                               0u
N#define  DEF_INT_08U_MAX_VAL                             255u
N
N#define  DEF_INT_08S_MIN_VAL_ONES_CPL                  (-127)
N#define  DEF_INT_08S_MAX_VAL_ONES_CPL                    127
N
N#define  DEF_INT_08S_MIN_VAL                            (DEF_INT_08S_MIN_VAL_ONES_CPL - 1)
N#define  DEF_INT_08S_MAX_VAL                             DEF_INT_08S_MAX_VAL_ONES_CPL
N
N#define  DEF_INT_08U_NBR_DIG_MIN                           1u
N#define  DEF_INT_08U_NBR_DIG_MAX                           3u
N
N#define  DEF_INT_08S_NBR_DIG_MIN                           3u
N#define  DEF_INT_08S_NBR_DIG_MAX                           3u
N
N
N
N#define  DEF_INT_16_NBR_BITS                              16u
N#define  DEF_INT_16_MASK                              0xFFFFu
N
N#define  DEF_INT_16U_MIN_VAL                               0u
N#define  DEF_INT_16U_MAX_VAL                           65535u
N
N#define  DEF_INT_16S_MIN_VAL_ONES_CPL                (-32767)
N#define  DEF_INT_16S_MAX_VAL_ONES_CPL                  32767
N
N#define  DEF_INT_16S_MIN_VAL                            (DEF_INT_16S_MIN_VAL_ONES_CPL - 1)
N#define  DEF_INT_16S_MAX_VAL                             DEF_INT_16S_MAX_VAL_ONES_CPL
N
N#define  DEF_INT_16U_NBR_DIG_MIN                           1u
N#define  DEF_INT_16U_NBR_DIG_MAX                           5u
N
N#define  DEF_INT_16S_NBR_DIG_MIN                           5u
N#define  DEF_INT_16S_NBR_DIG_MAX                           5u
N
N
N
N#define  DEF_INT_32_NBR_BITS                              32u
N#define  DEF_INT_32_MASK                          0xFFFFFFFFu
N
N#define  DEF_INT_32U_MIN_VAL                               0u
N#define  DEF_INT_32U_MAX_VAL                      4294967295u
N
N#define  DEF_INT_32S_MIN_VAL_ONES_CPL           (-2147483647)
N#define  DEF_INT_32S_MAX_VAL_ONES_CPL             2147483647
N
N#define  DEF_INT_32S_MIN_VAL                            (DEF_INT_32S_MIN_VAL_ONES_CPL - 1)
N#define  DEF_INT_32S_MAX_VAL                             DEF_INT_32S_MAX_VAL_ONES_CPL
N
N#define  DEF_INT_32U_NBR_DIG_MIN                           1u
N#define  DEF_INT_32U_NBR_DIG_MAX                          10u
N
N#define  DEF_INT_32S_NBR_DIG_MIN                          10u
N#define  DEF_INT_32S_NBR_DIG_MAX                          10u
N
N
N
N#define  DEF_INT_64_NBR_BITS                              64u
N#define  DEF_INT_64_MASK                  0xFFFFFFFFFFFFFFFFu
N
N#define  DEF_INT_64U_MIN_VAL                               0u
N#define  DEF_INT_64U_MAX_VAL            18446744073709551615u
N
N#define  DEF_INT_64S_MIN_VAL_ONES_CPL  (-9223372036854775807)
N#define  DEF_INT_64S_MAX_VAL_ONES_CPL    9223372036854775807
N
N#define  DEF_INT_64S_MIN_VAL                            (DEF_INT_64S_MIN_VAL_ONES_CPL - 1)
N#define  DEF_INT_64S_MAX_VAL                             DEF_INT_64S_MAX_VAL_ONES_CPL
N
N#define  DEF_INT_64U_NBR_DIG_MIN                           1u
N#define  DEF_INT_64U_NBR_DIG_MAX                          20u
N
N#define  DEF_INT_64S_NBR_DIG_MIN                          19u
N#define  DEF_INT_64S_NBR_DIG_MAX                          19u
N
N
N
N/*$PAGE*/
N                                                                /* --------------- CPU INTEGER DEFINES ---------------- */
N#define  DEF_INT_CPU_NBR_BITS                           (CPU_CFG_DATA_SIZE     * DEF_OCTET_NBR_BITS)
N#define  DEF_INT_CPU_NBR_BITS_MAX                       (CPU_CFG_DATA_SIZE_MAX * DEF_OCTET_NBR_BITS)
N
N
N
N#if     (DEF_INT_CPU_NBR_BITS == DEF_INT_08_NBR_BITS)
X#if     ((4 * 8u) == 8u)
S
S
S#define  DEF_INT_CPU_MASK                                DEF_INT_08_MASK
S
S#define  DEF_INT_CPU_U_MIN_VAL                           DEF_INT_08U_MIN_VAL
S#define  DEF_INT_CPU_U_MAX_VAL                           DEF_INT_08U_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL                           DEF_INT_08S_MIN_VAL
S#define  DEF_INT_CPU_S_MAX_VAL                           DEF_INT_08S_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL_ONES_CPL                  DEF_INT_08S_MIN_VAL_ONES_CPL
S#define  DEF_INT_CPU_S_MAX_VAL_ONES_CPL                  DEF_INT_08S_MAX_VAL_ONES_CPL
S
S
S
S#elif   (DEF_INT_CPU_NBR_BITS == DEF_INT_16_NBR_BITS)
X#elif   ((4 * 8u) == 16u)
S
S
S#define  DEF_INT_CPU_MASK                                DEF_INT_16_MASK
S
S#define  DEF_INT_CPU_U_MIN_VAL                           DEF_INT_16U_MIN_VAL
S#define  DEF_INT_CPU_U_MAX_VAL                           DEF_INT_16U_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL                           DEF_INT_16S_MIN_VAL
S#define  DEF_INT_CPU_S_MAX_VAL                           DEF_INT_16S_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL_ONES_CPL                  DEF_INT_16S_MIN_VAL_ONES_CPL
S#define  DEF_INT_CPU_S_MAX_VAL_ONES_CPL                  DEF_INT_16S_MAX_VAL_ONES_CPL
S
S
S
N#elif   (DEF_INT_CPU_NBR_BITS == DEF_INT_32_NBR_BITS)
X#elif   ((4 * 8u) == 32u)
N
N
N#define  DEF_INT_CPU_MASK                                DEF_INT_32_MASK
N
N#define  DEF_INT_CPU_U_MIN_VAL                           DEF_INT_32U_MIN_VAL
N#define  DEF_INT_CPU_U_MAX_VAL                           DEF_INT_32U_MAX_VAL
N
N#define  DEF_INT_CPU_S_MIN_VAL                           DEF_INT_32S_MIN_VAL
N#define  DEF_INT_CPU_S_MAX_VAL                           DEF_INT_32S_MAX_VAL
N
N#define  DEF_INT_CPU_S_MIN_VAL_ONES_CPL                  DEF_INT_32S_MIN_VAL_ONES_CPL
N#define  DEF_INT_CPU_S_MAX_VAL_ONES_CPL                  DEF_INT_32S_MAX_VAL_ONES_CPL
N
N
N
N#elif   (DEF_INT_CPU_NBR_BITS == DEF_INT_64_NBR_BITS)
S
S
S#define  DEF_INT_CPU_MASK                                DEF_INT_64_MASK
S
S#define  DEF_INT_CPU_U_MIN_VAL                           DEF_INT_64U_MIN_VAL
S#define  DEF_INT_CPU_U_MAX_VAL                           DEF_INT_64U_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL                           DEF_INT_64S_MIN_VAL
S#define  DEF_INT_CPU_S_MAX_VAL                           DEF_INT_64S_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL_ONES_CPL                  DEF_INT_64S_MIN_VAL_ONES_CPL
S#define  DEF_INT_CPU_S_MAX_VAL_ONES_CPL                  DEF_INT_64S_MAX_VAL_ONES_CPL
S
S
S
S#else
S
S#error  "CPU_CFG_DATA_SIZE  illegally #defined in 'cpu.h'      "
S#error  "                   [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N
N/*$PAGE*/
N                                                                /* ------------------- TIME DEFINES ------------------- */
N#define  DEF_TIME_NBR_DAY_PER_WK                           7u
N#define  DEF_TIME_NBR_DAY_PER_YR                         365u
N#define  DEF_TIME_NBR_DAY_PER_YR_LEAP                    366u
N
N#define  DEF_TIME_NBR_HR_PER_DAY                          24u
N#define  DEF_TIME_NBR_HR_PER_WK                         (DEF_TIME_NBR_HR_PER_DAY  * DEF_TIME_NBR_DAY_PER_WK     )
N#define  DEF_TIME_NBR_HR_PER_YR                         (DEF_TIME_NBR_HR_PER_DAY  * DEF_TIME_NBR_DAY_PER_YR     )
N#define  DEF_TIME_NBR_HR_PER_YR_LEAP                    (DEF_TIME_NBR_HR_PER_DAY  * DEF_TIME_NBR_DAY_PER_YR_LEAP)
N
N#define  DEF_TIME_NBR_MIN_PER_HR                          60u
N#define  DEF_TIME_NBR_MIN_PER_DAY                       (DEF_TIME_NBR_MIN_PER_HR  * DEF_TIME_NBR_HR_PER_DAY     )
N#define  DEF_TIME_NBR_MIN_PER_WK                        (DEF_TIME_NBR_MIN_PER_DAY * DEF_TIME_NBR_DAY_PER_WK     )
N#define  DEF_TIME_NBR_MIN_PER_YR                        (DEF_TIME_NBR_MIN_PER_DAY * DEF_TIME_NBR_DAY_PER_YR     )
N#define  DEF_TIME_NBR_MIN_PER_YR_LEAP                   (DEF_TIME_NBR_MIN_PER_DAY * DEF_TIME_NBR_DAY_PER_YR_LEAP)
N
N#define  DEF_TIME_NBR_SEC_PER_MIN                         60u
N#define  DEF_TIME_NBR_SEC_PER_HR                        (DEF_TIME_NBR_SEC_PER_MIN * DEF_TIME_NBR_MIN_PER_HR     )
N#define  DEF_TIME_NBR_SEC_PER_DAY                       (DEF_TIME_NBR_SEC_PER_HR  * DEF_TIME_NBR_HR_PER_DAY     )
N#define  DEF_TIME_NBR_SEC_PER_WK                        (DEF_TIME_NBR_SEC_PER_DAY * DEF_TIME_NBR_DAY_PER_WK     )
N#define  DEF_TIME_NBR_SEC_PER_YR                        (DEF_TIME_NBR_SEC_PER_DAY * DEF_TIME_NBR_DAY_PER_YR     )
N#define  DEF_TIME_NBR_SEC_PER_YR_LEAP                   (DEF_TIME_NBR_SEC_PER_DAY * DEF_TIME_NBR_DAY_PER_YR_LEAP)
N
N#define  DEF_TIME_NBR_mS_PER_SEC                        1000u
N#define  DEF_TIME_NBR_uS_PER_SEC                     1000000u
N#define  DEF_TIME_NBR_nS_PER_SEC                  1000000000u
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             ERROR CODES
N*
N* Note(s) : (1) All library error codes are #define'd in 'lib_def.h';
N*********************************************************************************************************
N*/
N
Ntypedef enum lib_err {
N
N    LIB_ERR_NONE                            =         0u,
N
N    LIB_MEM_ERR_NONE                        =     10000u,
N    LIB_MEM_ERR_NULL_PTR                    =     10001u,       /* Ptr arg(s) passed NULL ptr(s).                       */
N
N    LIB_MEM_ERR_INVALID_MEM_SIZE            =     10100u,       /* Invalid mem     size.                                */
N    LIB_MEM_ERR_INVALID_MEM_ALIGN           =     10101u,       /* Invalid mem     align.                               */
N    LIB_MEM_ERR_INVALID_SEG_SIZE            =     10110u,       /* Invalid mem seg size.                                */
N    LIB_MEM_ERR_INVALID_SEG_OVERLAP         =     10111u,       /* Invalid mem seg overlaps other mem seg(s).           */
N    LIB_MEM_ERR_INVALID_POOL                =     10120u,       /* Invalid mem pool.                                    */
N    LIB_MEM_ERR_INVALID_BLK_NBR             =     10130u,       /* Invalid mem pool blk nbr.                            */
N    LIB_MEM_ERR_INVALID_BLK_SIZE            =     10131u,       /* Invalid mem pool blk size.                           */
N    LIB_MEM_ERR_INVALID_BLK_ALIGN           =     10132u,       /* Invalid mem pool blk align.                          */
N    LIB_MEM_ERR_INVALID_BLK_IX              =     10133u,       /* Invalid mem pool ix.                                 */
N    LIB_MEM_ERR_INVALID_BLK_ADDR            =     10135u,       /* Invalid mem pool blk addr.                           */
N    LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL    =     10136u,       /* Mem pool blk addr already in mem pool.               */
N
N    LIB_MEM_ERR_SEG_EMPTY                   =     10200u,       /* Mem seg  empty; i.e. NO avail mem in seg.            */
N    LIB_MEM_ERR_SEG_OVF                     =     10201u,       /* Mem seg  ovf;   i.e. req'd mem ovfs rem mem in seg.  */
N    LIB_MEM_ERR_POOL_FULL                   =     10205u,       /* Mem pool full;  i.e. all mem blks avail in mem pool. */
N    LIB_MEM_ERR_POOL_EMPTY                  =     10206u,       /* Mem pool empty; i.e. NO  mem blks avail in mem pool. */
N
N    LIB_MEM_ERR_HEAP_EMPTY                  =     10210u,       /* Heap seg empty; i.e. NO avail mem in heap.           */
N    LIB_MEM_ERR_HEAP_OVF                    =     10211u,       /* Heap seg ovf;   i.e. req'd mem ovfs rem mem in heap. */
N    LIB_MEM_ERR_HEAP_NOT_FOUND              =     10215u        /* Heap seg NOT found.                                  */
N
N} LIB_ERR;
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             DATA TYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                          GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               TRACING
N*********************************************************************************************************
N*/
N
N                                                                /* Trace level, default to TRACE_LEVEL_OFF.             */
N#ifndef  TRACE_LEVEL_OFF
N#define  TRACE_LEVEL_OFF                                   0u
N#endif
N
N#ifndef  TRACE_LEVEL_INFO
N#define  TRACE_LEVEL_INFO                                  1u
N#endif
N
N#ifndef  TRACE_LEVEL_DBG
N#define  TRACE_LEVEL_DBG                                   2u
N#endif
N
N#ifndef  TRACE_LEVEL_LOG
N#define  TRACE_LEVEL_LOG                                   3u
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             BIT MACRO'S
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                              DEF_BIT()
N*
N* Description : Create bit mask with single, specified bit set.
N*
N* Argument(s) : bit         Bit number of bit to set.
N*
N* Return(s)   : Bit mask with single, specified bit set.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'bit' SHOULD be a non-negative integer.
N*
N*               (2) (a) 'bit' values that overflow the target CPU &/or compiler environment (e.g. negative 
N*                       or greater-than-CPU-data-size values) MAY generate compiler warnings &/or errors.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT(bit)                                                   (1u << (bit))
N
N
N/*
N*********************************************************************************************************
N*                                             DEF_BITxx()
N*
N* Description : Create bit mask of specified bit size with single, specified bit set.
N*
N* Argument(s) : bit         Bit number of bit to set.
N*
N* Return(s)   : Bit mask with single, specified bit set.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'bit' SHOULD be a non-negative integer.
N*
N*               (2) (a) 'bit' values that overflow the target CPU &/or compiler environment (e.g. negative 
N*                       or greater-than-CPU-data-size values) MAY generate compiler warnings &/or errors.
N*
N*                   (b) To avoid overflowing any target CPU &/or compiler's integer data type, unsigned 
N*                       bit constant '1' is cast to specified integer data type size.
N*
N*               (3) Ideally, DEF_BITxx() macro's should be named DEF_BIT_xx(); however, these names already 
N*                   previously-released for bit constant #define's (see 'STANDARD DEFINES  BIT DEFINES').
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT08(bit)                        ((CPU_INT08U)((CPU_INT08U)1u  << (bit)))
N
N#define  DEF_BIT16(bit)                        ((CPU_INT16U)((CPU_INT16U)1u  << (bit)))
N
N#define  DEF_BIT32(bit)                        ((CPU_INT32U)((CPU_INT32U)1u  << (bit)))
N
N#define  DEF_BIT64(bit)                        ((CPU_INT64U)((CPU_INT64U)1u  << (bit)))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                           DEF_BIT_MASK()
N*
N* Description : Shift a bit mask.
N*
N* Argument(s) : bit_mask    Bit mask to shift.
N*
N*               bit_shift   Number of bit positions to left-shift bit mask.
N*
N* Return(s)   : Shifted bit mask.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) 'bit_mask'  SHOULD be an unsigned    integer.
N*
N*                   (b) 'bit_shift' SHOULD be a non-negative integer.
N*
N*               (2) 'bit_shift' values that overflow the target CPU &/or compiler environment (e.g. negative
N*                   or greater-than-CPU-data-size values) MAY generate compiler warnings &/or errors.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_MASK(bit_mask, bit_shift)                                     ((bit_mask) << (bit_shift))
N
N
N/*
N*********************************************************************************************************
N*                                          DEF_BIT_MASK_xx()
N*
N* Description : Shift a bit mask of specified bit size.
N*
N* Argument(s) : bit_mask    Bit mask to shift.
N*
N*               bit_shift   Number of bit positions to left-shift bit mask.
N*
N* Return(s)   : Shifted bit mask.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) 'bit_mask'  SHOULD be an unsigned    integer.
N*
N*                   (b) 'bit_shift' SHOULD be a non-negative integer.
N*
N*               (2) 'bit_shift' values that overflow the target CPU &/or compiler environment (e.g. negative
N*                   or greater-than-CPU-data-size values) MAY generate compiler warnings &/or errors.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_MASK_08(bit_mask, bit_shift)         ((CPU_INT08U)((CPU_INT08U)(bit_mask) << (bit_shift)))
N
N#define  DEF_BIT_MASK_16(bit_mask, bit_shift)         ((CPU_INT16U)((CPU_INT16U)(bit_mask) << (bit_shift)))
N
N#define  DEF_BIT_MASK_32(bit_mask, bit_shift)         ((CPU_INT32U)((CPU_INT32U)(bit_mask) << (bit_shift)))
N
N#define  DEF_BIT_MASK_64(bit_mask, bit_shift)         ((CPU_INT64U)((CPU_INT64U)(bit_mask) << (bit_shift)))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                           DEF_BIT_FIELD()
N*
N* Description : Create & shift a contiguous bit field.
N*
N* Argument(s) : bit_field   Number of contiguous bits to set in the bit field.
N*
N*               bit_shift   Number of bit positions   to left-shift bit field.
N*
N* Return(s)   : Shifted bit field.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'bit_field' & 'bit_shift' SHOULD be non-negative integers.
N*
N*               (2) (a) 'bit_field'/'bit_shift' values that overflow the target CPU &/or compiler 
N*                       environment (e.g. negative or greater-than-CPU-data-size values) MAY generate 
N*                       compiler warnings &/or errors.
N*
N*                   (b) To avoid overflowing any target CPU &/or compiler's integer data type, unsigned 
N*                       bit constant '1' is suffixed with 'L'ong integer modifier.
N*
N*                       This may still be insufficient for CPUs &/or compilers that support 'long long' 
N*                       integer data types, in which case 'LL' integer modifier should be suffixed.  
N*                       However, since almost all 16- & 32-bit CPUs & compilers support 'long' integer 
N*                       data types but many may NOT support 'long long' integer data types, only 'long' 
N*                       integer data types & modifiers are supported.
N*
N*                       See also 'DEF_BIT_FIELD_xx()  Note #1b'.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_FIELD(bit_field, bit_shift)                                 ((((bit_field) >= DEF_INT_CPU_NBR_BITS) ? (DEF_INT_CPU_U_MAX_VAL)     \
N                                                                                                                     : (DEF_BIT(bit_field) - 1uL)) \
N                                                                                                                            << (bit_shift))
X#define  DEF_BIT_FIELD(bit_field, bit_shift)                                 ((((bit_field) >= DEF_INT_CPU_NBR_BITS) ? (DEF_INT_CPU_U_MAX_VAL)                                                                                                                          : (DEF_BIT(bit_field) - 1uL))                                                                                                                             << (bit_shift))
N
N/*
N*********************************************************************************************************
N*                                         DEF_BIT_FIELD_xx()
N*
N* Description : Create & shift a contiguous bit field of specified bit size.
N*
N* Argument(s) : bit_field   Number of contiguous bits to set in the bit field.
N*
N*               bit_shift   Number of bit positions   to left-shift bit field.
N*
N* Return(s)   : Shifted bit field.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'bit_field' & 'bit_shift' SHOULD be non-negative integers.
N*
N*               (2) (a) 'bit_field'/'bit_shift' values that overflow the target CPU &/or compiler 
N*                       environment (e.g. negative or greater-than-CPU-data-size values) MAY generate 
N*                       compiler warnings &/or errors.
N*
N*                   (b) To avoid overflowing any target CPU &/or compiler's integer data type, unsigned 
N*                       bit constant '1' is cast to specified integer data type size.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_FIELD_08(bit_field, bit_shift)     ((CPU_INT08U)((((CPU_INT08U)(bit_field) >= (CPU_INT08U)DEF_INT_08_NBR_BITS) ? (CPU_INT08U)(DEF_INT_08U_MAX_VAL)                    \
N                                                                                                                                : (CPU_INT08U)(DEF_BIT08(bit_field) - (CPU_INT08U)1u)) \
N                                                                                                                                                     << (bit_shift)))
X#define  DEF_BIT_FIELD_08(bit_field, bit_shift)     ((CPU_INT08U)((((CPU_INT08U)(bit_field) >= (CPU_INT08U)DEF_INT_08_NBR_BITS) ? (CPU_INT08U)(DEF_INT_08U_MAX_VAL)                                                                                                                                                    : (CPU_INT08U)(DEF_BIT08(bit_field) - (CPU_INT08U)1u))                                                                                                                                                      << (bit_shift)))
N
N#define  DEF_BIT_FIELD_16(bit_field, bit_shift)     ((CPU_INT16U)((((CPU_INT16U)(bit_field) >= (CPU_INT16U)DEF_INT_16_NBR_BITS) ? (CPU_INT16U)(DEF_INT_16U_MAX_VAL)                    \
N                                                                                                                                : (CPU_INT16U)(DEF_BIT16(bit_field) - (CPU_INT16U)1u)) \
N                                                                                                                                                     << (bit_shift)))
X#define  DEF_BIT_FIELD_16(bit_field, bit_shift)     ((CPU_INT16U)((((CPU_INT16U)(bit_field) >= (CPU_INT16U)DEF_INT_16_NBR_BITS) ? (CPU_INT16U)(DEF_INT_16U_MAX_VAL)                                                                                                                                                    : (CPU_INT16U)(DEF_BIT16(bit_field) - (CPU_INT16U)1u))                                                                                                                                                      << (bit_shift)))
N
N#define  DEF_BIT_FIELD_32(bit_field, bit_shift)     ((CPU_INT32U)((((CPU_INT32U)(bit_field) >= (CPU_INT32U)DEF_INT_32_NBR_BITS) ? (CPU_INT32U)(DEF_INT_32U_MAX_VAL)                    \
N                                                                                                                                : (CPU_INT32U)(DEF_BIT32(bit_field) - (CPU_INT32U)1u)) \
N                                                                                                                                                     << (bit_shift)))
X#define  DEF_BIT_FIELD_32(bit_field, bit_shift)     ((CPU_INT32U)((((CPU_INT32U)(bit_field) >= (CPU_INT32U)DEF_INT_32_NBR_BITS) ? (CPU_INT32U)(DEF_INT_32U_MAX_VAL)                                                                                                                                                    : (CPU_INT32U)(DEF_BIT32(bit_field) - (CPU_INT32U)1u))                                                                                                                                                      << (bit_shift)))
N
N#define  DEF_BIT_FIELD_64(bit_field, bit_shift)     ((CPU_INT64U)((((CPU_INT64U)(bit_field) >= (CPU_INT64U)DEF_INT_64_NBR_BITS) ? (CPU_INT64U)(DEF_INT_64U_MAX_VAL)                    \
N                                                                                                                                : (CPU_INT64U)(DEF_BIT64(bit_field) - (CPU_INT64U)1u)) \
N                                                                                                                                                     << (bit_shift)))
X#define  DEF_BIT_FIELD_64(bit_field, bit_shift)     ((CPU_INT64U)((((CPU_INT64U)(bit_field) >= (CPU_INT64U)DEF_INT_64_NBR_BITS) ? (CPU_INT64U)(DEF_INT_64U_MAX_VAL)                                                                                                                                                    : (CPU_INT64U)(DEF_BIT64(bit_field) - (CPU_INT64U)1u))                                                                                                                                                      << (bit_shift)))
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          DEF_BIT_SET_xx()
N*
N* Description : Set specified bit(s) in a value of specified bit size.
N*
N* Argument(s) : val         Value to modify by setting specified bit(s).
N*
N*               mask        Mask of bits to set.
N*
N* Return(s)   : Modified value with specified bit(s) set.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'val' & 'mask' SHOULD be unsigned integers.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_SET_08(val, mask)                     ((val) = (CPU_INT08U)(((CPU_INT08U)(val)) | ((CPU_INT08U) (mask))))
N
N#define  DEF_BIT_SET_16(val, mask)                     ((val) = (CPU_INT16U)(((CPU_INT16U)(val)) | ((CPU_INT16U) (mask))))
N
N#define  DEF_BIT_SET_32(val, mask)                     ((val) = (CPU_INT32U)(((CPU_INT32U)(val)) | ((CPU_INT32U) (mask))))
N
N#define  DEF_BIT_SET_64(val, mask)                     ((val) = (CPU_INT64U)(((CPU_INT64U)(val)) | ((CPU_INT64U) (mask))))
N
N
N/*
N*********************************************************************************************************
N*                                            DEF_BIT_SET()
N*
N* Description : Set specified bit(s) in a value.
N*
N* Argument(s) : val         Value to modify by setting specified bit(s).
N*
N*               mask        Mask of bits to set.
N*
N* Return(s)   : Modified value with specified bit(s) set.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'val' & 'mask' SHOULD be unsigned integers.
N*********************************************************************************************************
N*/
N
N#if     (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_08)
X#if     (8 == 1)
S
S#define  DEF_BIT_SET(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_SET_08(val, mask) : 0)
S
S
S#elif   (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_16)
X#elif   (8 == 2)
S
S#define  DEF_BIT_SET(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_SET_08(val, mask) :   \
S                                                ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_SET_16(val, mask) : 0))
X#define  DEF_BIT_SET(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_SET_08(val, mask) :                                                   ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_SET_16(val, mask) : 0))
S
S
S#elif   (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_32)
X#elif   (8 == 4)
S
S#define  DEF_BIT_SET(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_SET_08(val, mask) :    \
S                                                ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_SET_16(val, mask) :    \
S                                                ((sizeof(val) == CPU_WORD_SIZE_32) ? DEF_BIT_SET_32(val, mask) : 0)))
X#define  DEF_BIT_SET(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_SET_08(val, mask) :                                                    ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_SET_16(val, mask) :                                                    ((sizeof(val) == CPU_WORD_SIZE_32) ? DEF_BIT_SET_32(val, mask) : 0)))
S
S
N#elif   (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_64)
X#elif   (8 == 8)
N
N#define  DEF_BIT_SET(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_SET_08(val, mask) :     \
N                                                ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_SET_16(val, mask) :     \
N                                                ((sizeof(val) == CPU_WORD_SIZE_32) ? DEF_BIT_SET_32(val, mask) :     \
N                                                ((sizeof(val) == CPU_WORD_SIZE_64) ? DEF_BIT_SET_64(val, mask) : 0))))
X#define  DEF_BIT_SET(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_SET_08(val, mask) :                                                     ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_SET_16(val, mask) :                                                     ((sizeof(val) == CPU_WORD_SIZE_32) ? DEF_BIT_SET_32(val, mask) :                                                     ((sizeof(val) == CPU_WORD_SIZE_64) ? DEF_BIT_SET_64(val, mask) : 0))))
N
N#else
S
S#error  "CPU_CFG_DATA_SIZE_MAX  illegally #defined in 'cpu.h'      "
S#error  "                       [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          DEF_BIT_CLR_xx()
N*
N* Description : Clear specified bit(s) in a value of specified bit size.
N*
N* Argument(s) : val         Value to modify by clearing specified bit(s).
N*
N*               mask        Mask of bits to clear.
N*
N* Return(s)   : Modified value with specified bit(s) clear.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'val' & 'mask' SHOULD be unsigned integers.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_CLR_08(val, mask)                     ((val) = (CPU_INT08U)(((CPU_INT08U)(val)) & ((CPU_INT08U)~(mask))))
N
N#define  DEF_BIT_CLR_16(val, mask)                     ((val) = (CPU_INT16U)(((CPU_INT16U)(val)) & ((CPU_INT16U)~(mask))))
N
N#define  DEF_BIT_CLR_32(val, mask)                     ((val) = (CPU_INT32U)(((CPU_INT32U)(val)) & ((CPU_INT32U)~(mask))))
N
N#define  DEF_BIT_CLR_64(val, mask)                     ((val) = (CPU_INT64U)(((CPU_INT64U)(val)) & ((CPU_INT64U)~(mask))))
N
N
N/*
N*********************************************************************************************************
N*                                            DEF_BIT_CLR()
N*
N* Description : Clear specified bit(s) in a value.
N*
N* Argument(s) : val         Value to modify by clearing specified bit(s).
N*
N*               mask        Mask of bits to clear.
N*
N* Return(s)   : Modified value with specified bit(s) clear.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'val' & 'mask' SHOULD be unsigned integers.
N*********************************************************************************************************
N*/
N
N#if     (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_08)
X#if     (8 == 1)
S
S#define  DEF_BIT_CLR(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_CLR_08(val, mask) : 0)
S
S
S#elif   (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_16)
X#elif   (8 == 2)
S
S#define  DEF_BIT_CLR(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_CLR_08(val, mask) :   \
S                                                ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_CLR_16(val, mask) : 0))
X#define  DEF_BIT_CLR(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_CLR_08(val, mask) :                                                   ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_CLR_16(val, mask) : 0))
S
S
S#elif   (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_32)
X#elif   (8 == 4)
S
S#define  DEF_BIT_CLR(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_CLR_08(val, mask) :    \
S                                                ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_CLR_16(val, mask) :    \
S                                                ((sizeof(val) == CPU_WORD_SIZE_32) ? DEF_BIT_CLR_32(val, mask) : 0)))
X#define  DEF_BIT_CLR(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_CLR_08(val, mask) :                                                    ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_CLR_16(val, mask) :                                                    ((sizeof(val) == CPU_WORD_SIZE_32) ? DEF_BIT_CLR_32(val, mask) : 0)))
S
S
N#elif   (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_64)
X#elif   (8 == 8)
N
N#define  DEF_BIT_CLR(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_CLR_08(val, mask) :     \
N                                                ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_CLR_16(val, mask) :     \
N                                                ((sizeof(val) == CPU_WORD_SIZE_32) ? DEF_BIT_CLR_32(val, mask) :     \
N                                                ((sizeof(val) == CPU_WORD_SIZE_64) ? DEF_BIT_CLR_64(val, mask) : 0))))
X#define  DEF_BIT_CLR(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_CLR_08(val, mask) :                                                     ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_CLR_16(val, mask) :                                                     ((sizeof(val) == CPU_WORD_SIZE_32) ? DEF_BIT_CLR_32(val, mask) :                                                     ((sizeof(val) == CPU_WORD_SIZE_64) ? DEF_BIT_CLR_64(val, mask) : 0))))
N
N#else
S
S#error  "CPU_CFG_DATA_SIZE_MAX  illegally #defined in 'cpu.h'      "
S#error  "                       [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          DEF_BIT_IS_SET()
N*
N* Description : Determine if specified bit(s) in a value are set.
N*
N* Argument(s) : val         Value to check for specified bit(s) set.
N*
N*               mask        Mask of bits to check if set (see Note #2).
N*
N* Return(s)   : DEF_YES, if ALL specified bit(s) are     set in value.
N*
N*               DEF_NO,  if ALL specified bit(s) are NOT set in value.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'val' & 'mask' SHOULD be unsigned integers.
N*
N*               (2) NULL 'mask' allowed; returns 'DEF_NO' since NO mask bits specified.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_IS_SET(val, mask)                           ((((mask)  !=  0u)  && \
N                                                      (((val) & (mask)) == (mask))) ? (DEF_YES) : (DEF_NO ))
X#define  DEF_BIT_IS_SET(val, mask)                           ((((mask)  !=  0u)  &&                                                       (((val) & (mask)) == (mask))) ? (DEF_YES) : (DEF_NO ))
N
N
N/*
N*********************************************************************************************************
N*                                          DEF_BIT_IS_CLR()
N*
N* Description : Determine if specified bit(s) in a value are clear.
N*
N* Argument(s) : val         Value to check for specified bit(s) clear.
N*
N*               mask        Mask of bits to check if clear (see Note #2).
N*
N* Return(s)   : DEF_YES, if ALL specified bit(s) are     clear in value.
N*
N*               DEF_NO,  if ALL specified bit(s) are NOT clear in value.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'val' & 'mask' SHOULD be unsigned integers.
N*
N*               (2) NULL 'mask' allowed; returns 'DEF_NO' since NO mask bits specified.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_IS_CLR(val, mask)                           ((((mask)  !=  0u)  && \
N                                                      (((val) & (mask)) ==  0u))    ? (DEF_YES) : (DEF_NO ))
X#define  DEF_BIT_IS_CLR(val, mask)                           ((((mask)  !=  0u)  &&                                                       (((val) & (mask)) ==  0u))    ? (DEF_YES) : (DEF_NO ))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        DEF_BIT_IS_SET_ANY()
N*
N* Description : Determine if any specified bit(s) in a value are set.
N*
N* Argument(s) : val         Value to check for specified bit(s) set.
N*
N*               mask        Mask of bits to check if set (see Note #2).
N*
N* Return(s)   : DEF_YES, if ANY specified bit(s) are     set in value.
N*
N*               DEF_NO,  if ALL specified bit(s) are NOT set in value.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'val' & 'mask' SHOULD be unsigned integers.
N*
N*               (2) NULL 'mask' allowed; returns 'DEF_NO' since NO mask bits specified.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_IS_SET_ANY(val, mask)               ((((val) & (mask)) ==  0u)     ? (DEF_NO ) : (DEF_YES))
N
N
N/*
N*********************************************************************************************************
N*                                        DEF_BIT_IS_CLR_ANY()
N*
N* Description : Determine if any specified bit(s) in a value are clear.
N*
N* Argument(s) : val         Value to check for specified bit(s) clear.
N*
N*               mask        Mask of bits to check if clear (see Note #2).
N*
N* Return(s)   : DEF_YES, if ANY specified bit(s) are     clear in value.
N*
N*               DEF_NO,  if ALL specified bit(s) are NOT clear in value.
N*
N* Note(s)     : (1) 'val' & 'mask' SHOULD be unsigned integers.
N*
N*               (2) NULL 'mask' allowed; returns 'DEF_NO' since NO mask bits specified.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_IS_CLR_ANY(val, mask)               ((((val) & (mask)) == (mask))  ? (DEF_NO ) : (DEF_YES))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            VALUE MACRO'S
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                          DEF_CHK_VAL_MIN()
N*
N* Description : Validate a value as greater than or equal to a specified minimum value.
N*
N* Argument(s) : val        Value to validate.
N*
N*               val_min    Minimum value to test.
N*
N* Return(s)   : DEF_OK,    Value is greater than or equal to minimum value.
N*
N*               DEF_FAIL,  otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) DEF_CHK_VAL_MIN() avoids directly comparing any two values if only one of the values 
N*                   is negative since the negative value might be incorrectly promoted to an arbitrary 
N*                   unsigned value if the other value to compare is unsigned.
N*
N*               (2) Validation of values is limited to the range supported by the compiler &/or target 
N*                   environment.  All other values that underflow/overflow the supported range will 
N*                   modulo/wrap into the supported range as arbitrary signed or unsigned values.
N*
N*                   Therefore, any values that underflow the most negative signed value or overflow 
N*                   the most positive unsigned value supported by the compiler &/or target environment 
N*                   cannot be validated :
N*
N*                           (    N-1       N     ]
N*                           ( -(2   )  ,  2  - 1 ]
N*                           (                    ]
N*
N*                               where
N*                                       N       Number of data word bits supported by the compiler 
N*                                                   &/or target environment
N*
N*                   (a) Note that the most negative value, -2^(N-1), is NOT included in the supported 
N*                       range since many compilers do NOT always correctly handle this value.
N*
N*               (3) 'val' and 'val_min' are compared to 1 instead of 0 to avoid warning generated for
N*                   unsigned numbers.
N*********************************************************************************************************
N*/
N
N#define  DEF_CHK_VAL_MIN(val, val_min)            (((!(((val)     >= 1) && ((val_min) < 1))) && \
N                                                     ((((val_min) >= 1) && ((val)     < 1))  || \
N                                                       ((val) < (val_min)))) ? DEF_FAIL : DEF_OK)
X#define  DEF_CHK_VAL_MIN(val, val_min)            (((!(((val)     >= 1) && ((val_min) < 1))) &&                                                      ((((val_min) >= 1) && ((val)     < 1))  ||                                                        ((val) < (val_min)))) ? DEF_FAIL : DEF_OK)
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          DEF_CHK_VAL_MAX()
N*
N* Description : Validate a value as less than or equal to a specified maximum value.
N*
N* Argument(s) : val        Value to validate.
N*
N*               val_max    Maximum value to test.
N*
N* Return(s)   : DEF_OK,    Value is less than or equal to maximum value.
N*
N*               DEF_FAIL,  otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) DEF_CHK_VAL_MAX() avoids directly comparing any two values if only one of the values 
N*                   is negative since the negative value might be incorrectly promoted to an arbitrary 
N*                   unsigned value if the other value to compare is unsigned.
N*
N*               (2) Validation of values is limited to the range supported by the compiler &/or target 
N*                   environment.  All other values that underflow/overflow the supported range will 
N*                   modulo/wrap into the supported range as arbitrary signed or unsigned values.
N*
N*                   Therefore, any values that underflow the most negative signed value or overflow 
N*                   the most positive unsigned value supported by the compiler &/or target environment 
N*                   cannot be validated :
N*
N*                           (    N-1       N     ]
N*                           ( -(2   )  ,  2  - 1 ]
N*                           (                    ]
N*
N*                               where
N*                                       N       Number of data word bits supported by the compiler 
N*                                                   &/or target environment
N*
N*                   (a) Note that the most negative value, -2^(N-1), is NOT included in the supported 
N*                       range since many compilers do NOT always correctly handle this value.
N*
N*               (3) 'val' and 'val_max' are compared to 1 instead of 0 to avoid warning generated for
N*                   unsigned numbers.
N*********************************************************************************************************
N*/
N
N#define  DEF_CHK_VAL_MAX(val, val_max)            (((!(((val_max) >= 1) && ((val)     < 1))) && \
N                                                     ((((val)     >= 1) && ((val_max) < 1))  || \
N                                                       ((val) > (val_max)))) ? DEF_FAIL : DEF_OK)
X#define  DEF_CHK_VAL_MAX(val, val_max)            (((!(((val_max) >= 1) && ((val)     < 1))) &&                                                      ((((val)     >= 1) && ((val_max) < 1))  ||                                                        ((val) > (val_max)))) ? DEF_FAIL : DEF_OK)
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            DEF_CHK_VAL()
N*
N* Description : Validate a value as greater than or equal to a specified minimum value & less than or 
N*                   equal to a specified maximum value.
N*
N* Argument(s) : val        Value to validate.
N*
N*               val_min    Minimum value to test.
N*
N*               val_max    Maximum value to test.
N*
N* Return(s)   : DEF_OK,    Value is greater than or equal to minimum value AND 
N*                                   less    than or equal to maximum value.
N*
N*               DEF_FAIL,  otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) DEF_CHK_VAL() avoids directly comparing any two values if only one of the values 
N*                   is negative since the negative value might be incorrectly promoted to an arbitrary 
N*                   unsigned value if the other value to compare is unsigned.
N*
N*               (2) Validation of values is limited to the range supported by the compiler &/or target 
N*                   environment.  All other values that underflow/overflow the supported range will 
N*                   modulo/wrap into the supported range as arbitrary signed or unsigned values.
N*
N*                   Therefore, any values that underflow the most negative signed value or overflow 
N*                   the most positive unsigned value supported by the compiler &/or target environment 
N*                   cannot be validated :
N*
N*                           (    N-1       N     ]
N*                           ( -(2   )  ,  2  - 1 ]
N*                           (                    ]
N*
N*                               where
N*                                       N       Number of data word bits supported by the compiler 
N*                                                   &/or target environment
N*
N*                   (a) Note that the most negative value, -2^(N-1), is NOT included in the supported 
N*                       range since many compilers do NOT always correctly handle this value.
N*
N*               (3) DEF_CHK_VAL() does NOT validate that the maximum value ('val_max') is greater than 
N*                   or equal to the minimum value ('val_min').
N*********************************************************************************************************
N*/
N
N#define  DEF_CHK_VAL(val, val_min, val_max)          (((DEF_CHK_VAL_MIN(val, val_min) == DEF_FAIL) ||                  \
N                                                       (DEF_CHK_VAL_MAX(val, val_max) == DEF_FAIL)) ? DEF_FAIL : DEF_OK)
X#define  DEF_CHK_VAL(val, val_min, val_max)          (((DEF_CHK_VAL_MIN(val, val_min) == DEF_FAIL) ||                                                                         (DEF_CHK_VAL_MAX(val, val_max) == DEF_FAIL)) ? DEF_FAIL : DEF_OK)
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         DEF_GET_U_MAX_VAL()
N*
N* Description : Get the maximum unsigned value that can be represented in an unsigned integer variable 
N*                   of the same data type size as an object.
N*
N* Argument(s) : obj         Object or data type to return maximum unsigned value (see Note #1).
N*
N* Return(s)   : Maximum unsigned integer value that can be represented by the object, if NO error(s).
N*
N*               0,                                                                    otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'obj' SHOULD be an integer object or data type but COULD also be a character or 
N*                   pointer object or data type.
N*********************************************************************************************************
N*/
N
N#if     (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_08)
X#if     (8 == 1)
S
S#define  DEF_GET_U_MAX_VAL(obj)                 ((sizeof(obj) == CPU_WORD_SIZE_08) ? DEF_INT_08U_MAX_VAL : 0)
S
S
S#elif   (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_16)
X#elif   (8 == 2)
S
S#define  DEF_GET_U_MAX_VAL(obj)                 ((sizeof(obj) == CPU_WORD_SIZE_08) ? DEF_INT_08U_MAX_VAL :   \
S                                                ((sizeof(obj) == CPU_WORD_SIZE_16) ? DEF_INT_16U_MAX_VAL : 0))
X#define  DEF_GET_U_MAX_VAL(obj)                 ((sizeof(obj) == CPU_WORD_SIZE_08) ? DEF_INT_08U_MAX_VAL :                                                   ((sizeof(obj) == CPU_WORD_SIZE_16) ? DEF_INT_16U_MAX_VAL : 0))
S
S
S#elif   (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_32)
X#elif   (8 == 4)
S
S#define  DEF_GET_U_MAX_VAL(obj)                 ((sizeof(obj) == CPU_WORD_SIZE_08) ? DEF_INT_08U_MAX_VAL :    \
S                                                ((sizeof(obj) == CPU_WORD_SIZE_16) ? DEF_INT_16U_MAX_VAL :    \
S                                                ((sizeof(obj) == CPU_WORD_SIZE_32) ? DEF_INT_32U_MAX_VAL : 0)))
X#define  DEF_GET_U_MAX_VAL(obj)                 ((sizeof(obj) == CPU_WORD_SIZE_08) ? DEF_INT_08U_MAX_VAL :                                                    ((sizeof(obj) == CPU_WORD_SIZE_16) ? DEF_INT_16U_MAX_VAL :                                                    ((sizeof(obj) == CPU_WORD_SIZE_32) ? DEF_INT_32U_MAX_VAL : 0)))
S
S
N#elif   (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_64)
X#elif   (8 == 8)
N
N#define  DEF_GET_U_MAX_VAL(obj)                 ((sizeof(obj) == CPU_WORD_SIZE_08) ? DEF_INT_08U_MAX_VAL :     \
N                                                ((sizeof(obj) == CPU_WORD_SIZE_16) ? DEF_INT_16U_MAX_VAL :     \
N                                                ((sizeof(obj) == CPU_WORD_SIZE_32) ? DEF_INT_32U_MAX_VAL :     \
N                                                ((sizeof(obj) == CPU_WORD_SIZE_64) ? DEF_INT_64U_MAX_VAL : 0))))
X#define  DEF_GET_U_MAX_VAL(obj)                 ((sizeof(obj) == CPU_WORD_SIZE_08) ? DEF_INT_08U_MAX_VAL :                                                     ((sizeof(obj) == CPU_WORD_SIZE_16) ? DEF_INT_16U_MAX_VAL :                                                     ((sizeof(obj) == CPU_WORD_SIZE_32) ? DEF_INT_32U_MAX_VAL :                                                     ((sizeof(obj) == CPU_WORD_SIZE_64) ? DEF_INT_64U_MAX_VAL : 0))))
N
N#else
S
S#error  "CPU_CFG_DATA_SIZE_MAX  illegally #defined in 'cpu.h'      "
S#error  "                       [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            MATH MACRO'S
N*
N* Note(s) : (1) Ideally, ALL mathematical macro's & functions SHOULD be defined in the custom mathematics 
N*               library ('lib_math.*').  #### However, to maintain backwards compatibility with previously-
N*               released modules, mathematical macro & function definitions should only be moved to the 
N*               custom mathematics library once all previously-released modules are updated to include the 
N*               custom mathematics library.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                              DEF_MIN()
N*
N* Description : Determine the minimum of two values.
N*
N* Argument(s) : a           First  value.
N*
N*               b           Second value.
N*
N* Return(s)   : Minimum of the two values.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_MIN(a, b)                                  (((a) < (b)) ? (a) : (b))
N
N
N/*
N*********************************************************************************************************
N*                                              DEF_MAX()
N*
N* Description : Determine the maximum of two values.
N*
N* Argument(s) : a           First  value.
N*
N*               b           Second value.
N*
N* Return(s)   : Maximum of the two values.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_MAX(a, b)                                  (((a) > (b)) ? (a) : (b))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                              DEF_ABS()
N*
N* Description : Determine the absolute value of a value.
N*
N* Argument(s) : a           Value to calculate absolute value.
N*
N* Return(s)   : Absolute value of the value.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_ABS(a)                                     (((a) < 0) ? (-(a)) : (a))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                        CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                    LIBRARY CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N                                                                /* See 'lib_def.h  Note #1a'.                           */
N#if     (CPU_CORE_VERSION < 12900u)
X#if     (12901u < 12900u)
S#error  "CPU_CORE_VERSION  [SHOULD be >= V1.29.00]"
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*
N* Note(s) : (1) See 'lib_def.h  MODULE'.
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of lib def module include.                       */
N
L 106 "..\..\uC-CPU\cpu_core.h" 2
N#include  <cpu_cfg.h>
N
N#if (CPU_CFG_NAME_EN == DEF_ENABLED)
X#if (1u == 1u)
N#include  <lib_mem.h>
L 1 "..\..\uC-LIB\lib_mem.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/LIB
N*                                        CUSTOM LIBRARY MODULES
N*
N*                          (c) Copyright 2004-2012; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/LIB is provided in source form to registered licensees ONLY.  It is
N*               illegal to distribute this source code to any third party unless you receive
N*               written permission by an authorized Micrium representative.  Knowledge of
N*               the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest
N*               software available.  Your honesty is greatly appreciated.
N*
N*               You can contact us at www.micrium.com.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                     STANDARD MEMORY OPERATIONS
N*
N* Filename      : lib_mem.h
N* Version       : V1.37.01
N* Programmer(s) : ITJ
N*                 FBJ
N*********************************************************************************************************
N* Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
N*
N*                     (a) ALL standard library functions are implemented in the custom library modules :
N*
N*                         (1) \<Custom Library Directory>\lib_*.*
N*
N*                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
N*
N*                               where
N*                                       <Custom Library Directory>      directory path for custom library software
N*                                       <cpu>                           directory name for specific processor (CPU)
N*                                       <compiler>                      directory name for specific compiler
N*
N*                     (b) Product-specific library functions are implemented in individual products.
N*
N*                 (2) Assumes the following versions (or more recent) of software modules are included in
N*                     the project build :
N*
N*                     (a) uC/CPU V1.27
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*
N* Note(s) : (1) This memory library header file is protected from multiple pre-processor inclusion through
N*               use of the memory library module present pre-processor macro definition.
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_MEM_MODULE_PRESENT                                 /* See Note #1.                                         */
N#define  LIB_MEM_MODULE_PRESENT
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            INCLUDE FILES
N*
N* Note(s) : (1) The custom library software files are located in the following directories :
N*
N*               (a) \<Your Product Application>\lib_cfg.h
N*
N*               (b) \<Custom Library Directory>\lib_*.*
N*
N*                       where
N*                               <Your Product Application>      directory path for Your Product's Application
N*                               <Custom Library Directory>      directory path for custom library software
N*
N*           (2) CPU-configuration  software files are located in the following directories :
N*
N*               (a) \<CPU-Compiler Directory>\cpu_*.*
N*               (b) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
N*
N*                       where
N*                               <CPU-Compiler Directory>        directory path for common CPU-compiler software
N*                               <cpu>                           directory name for specific processor (CPU)
N*                               <compiler>                      directory name for specific compiler
N*
N*           (3) Compiler MUST be configured to include as additional include path directories :
N*
N*               (a) '\<Your Product Application>\' directory                            See Note #1a
N*
N*               (b) '\<Custom Library Directory>\' directory                            See Note #1b
N*
N*               (c) (1) '\<CPU-Compiler Directory>\'                  directory         See Note #2a
N*                   (2) '\<CPU-Compiler Directory>\<cpu>\<compiler>\' directory         See Note #2b
N*
N*           (4) NO compiler-supplied standard library functions SHOULD be used.
N*********************************************************************************************************
N*/
N
N#include  <cpu.h>
N#include  <cpu_core.h>
L 1 "..\..\uC-CPU\cpu_core.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/CPU
N*                                    CPU CONFIGURATION & PORT LAYER
N*
N*                          (c) Copyright 2004-2011; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/CPU is provided in source form to registered licensees ONLY.  It is 
N*               illegal to distribute this source code to any third party unless you receive 
N*               written permission by an authorized Micrium representative.  Knowledge of 
N*               the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest 
N*               software available.  Your honesty is greatly appreciated.
N*
N*               You can contact us at www.micrium.com.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                           CORE CPU MODULE
N*
N* Filename      : cpu_core.h
N* Version       : V1.29.01
N* Programmer(s) : SR
N*                 ITJ
N*********************************************************************************************************
N* Note(s)       : (1) Assumes the following versions (or more recent) of software modules are included in 
N*                     the project build :
N*
N*                     (a) uC/LIB V1.35.00
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*
N* Note(s) : (1) This core CPU header file is protected from multiple pre-processor inclusion through use of 
N*               the  core CPU module present pre-processor macro definition.
N*********************************************************************************************************
N*/
N
N#ifndef  CPU_CORE_MODULE_PRESENT                                /* See Note #1.                                         */
S#define  CPU_CORE_MODULE_PRESENT
S
S
S/*
S*********************************************************************************************************
S*                                               EXTERNS
S*********************************************************************************************************
S*/
S
S#ifdef   CPU_CORE_MODULE
S#define  CPU_CORE_EXT
S#else
S#define  CPU_CORE_EXT  extern
S#endif
S
S
S/*$PAGE*/
S/*
S*********************************************************************************************************
S*                                            INCLUDE FILES
S*
S* Note(s) : (1) CPU-configuration software files are located in the following directories :
S*
S*               (a) \<Your Product Application>\cpu_cfg.h
S*
S*               (b) (1) \<CPU-Compiler Directory>\cpu_*.*
S*                   (2) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
S*
S*                       where
S*                               <Your Product Application>      directory path for Your Product's Application
S*                               <CPU-Compiler Directory>        directory path for common CPU-compiler software
S*                               <cpu>                           directory name for specific processor (CPU)
S*                               <compiler>                      directory name for specific compiler
S*
S*           (2) NO compiler-supplied standard library functions SHOULD be used.
S*
S*               (a) Standard library functions are implemented in the custom library module(s) :
S*
S*                       \<Custom Library Directory>\lib_*.*
S*
S*                           where
S*                                   <Custom Library Directory>      directory path for custom library software
S*
S*           (3) Compiler MUST be configured to include as additional include path directories :
S*
S*               (a) '\<Your Product Application>\' directory                            See Note #1a
S*
S*               (b) (1) '\<CPU-Compiler Directory>\'                  directory         See Note #1b1
S*                   (2) '\<CPU-Compiler Directory>\<cpu>\<compiler>\' directory         See Note #1b2
S*
S*               (c) '\<Custom Library Directory>\' directory                            See Note #2a
S*********************************************************************************************************
S*/
S
S#include  <cpu.h>
S#include  <lib_def.h>
S#include  <cpu_cfg.h>
S
S#if (CPU_CFG_NAME_EN == DEF_ENABLED)
S#include  <lib_mem.h>
S#include  <lib_str.h>
S#endif
S
S
S/*$PAGE*/
S/*
S*********************************************************************************************************
S*                                          CPU CONFIGURATION
S*
S* Note(s) : (1) The following pre-processor directives correctly configure CPU parameters.  DO NOT MODIFY.
S*
S*           (2) CPU timestamp timer feature is required for :
S*
S*               (a) CPU timestamps
S*               (b) CPU interrupts disabled time measurement
S*
S*               See also 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
S*                      & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1'.
S*********************************************************************************************************
S*/
S
S#ifdef   CPU_CFG_TS_EN
S#undef   CPU_CFG_TS_EN
S#endif
S
S
S#if    ((CPU_CFG_TS_32_EN == DEF_ENABLED) || \
S        (CPU_CFG_TS_64_EN == DEF_ENABLED))
X#if    ((CPU_CFG_TS_32_EN == DEF_ENABLED) ||         (CPU_CFG_TS_64_EN == DEF_ENABLED))
S#define  CPU_CFG_TS_EN                          DEF_ENABLED
S#else
S#define  CPU_CFG_TS_EN                          DEF_DISABLED
S#endif
S
S#if    ((CPU_CFG_TS_EN == DEF_ENABLED) || \
S(defined(CPU_CFG_INT_DIS_MEAS_EN)))
X#if    ((CPU_CFG_TS_EN == DEF_ENABLED) || (defined(CPU_CFG_INT_DIS_MEAS_EN)))
S#define  CPU_CFG_TS_TMR_EN                      DEF_ENABLED
S#else
S#define  CPU_CFG_TS_TMR_EN                      DEF_DISABLED
S#endif
S
S
S/*
S*********************************************************************************************************
S*                                               DEFINES
S*********************************************************************************************************
S*/
S
S#define  CPU_TIME_MEAS_NBR_MIN                             1u
S#define  CPU_TIME_MEAS_NBR_MAX                           128u
S
S
S/*$PAGE*/
S/*
S*********************************************************************************************************
S*                                             DATA TYPES
S*********************************************************************************************************
S*/
S
S
S/*
S*********************************************************************************************************
S*                                           CPU ERROR CODES
S*********************************************************************************************************
S*/
S
Stypedef enum cpu_err {
S
S    CPU_ERR_NONE                            =         0u,
S    CPU_ERR_NULL_PTR                        =        10u,
S
S    CPU_ERR_NAME_SIZE                       =      1000u,
S
S    CPU_ERR_TS_FREQ_INVALID                 =      2000u
S
S} CPU_ERR;
S
S
S/*
S*********************************************************************************************************
S*                                      CPU TIMESTAMP DATA TYPES
S*
S* Note(s) : (1) CPU timestamp timer data type defined to the binary-multiple of 8-bit octets as configured 
S*               by 'CPU_CFG_TS_TMR_SIZE' (see 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #2').
S*********************************************************************************************************
S*/
S
Stypedef  CPU_INT32U  CPU_TS32;
Stypedef  CPU_INT64U  CPU_TS64;
S
Stypedef  CPU_TS32    CPU_TS;                                    /* Req'd for backwards-compatibility.                   */
S
S
S#if     (CPU_CFG_TS_TMR_EN   == DEF_ENABLED)                    /* CPU ts tmr defined to cfg'd word size (see Note #1). */
S#if     (CPU_CFG_TS_TMR_SIZE == CPU_WORD_SIZE_08)
Stypedef  CPU_INT08U  CPU_TS_TMR;
S#elif   (CPU_CFG_TS_TMR_SIZE == CPU_WORD_SIZE_16)
Stypedef  CPU_INT16U  CPU_TS_TMR;
S#elif   (CPU_CFG_TS_TMR_SIZE == CPU_WORD_SIZE_64)
Stypedef  CPU_INT64U  CPU_TS_TMR;
S#else                                                           /* CPU ts tmr dflt size = 32-bits.                      */
Stypedef  CPU_INT32U  CPU_TS_TMR;
S#endif
S#endif
S
S
S/*
S*********************************************************************************************************
S*                               CPU TIMESTAMP TIMER FREQUENCY DATA TYPE
S*********************************************************************************************************
S*/
S
Stypedef  CPU_INT32U  CPU_TS_TMR_FREQ;
S
S
S/*
S*********************************************************************************************************
S*                                          GLOBAL VARIABLES
S*********************************************************************************************************
S*/
S
S#if    (CPU_CFG_NAME_EN   == DEF_ENABLED)
SCPU_CORE_EXT  CPU_CHAR         CPU_Name[CPU_CFG_NAME_SIZE];     /* CPU host name.                                       */
S#endif
S
S
S#if ((CPU_CFG_TS_32_EN    == DEF_ENABLED)  && \
S     (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32))
X#if ((CPU_CFG_TS_32_EN    == DEF_ENABLED)  &&      (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32))
SCPU_CORE_EXT  CPU_TS32         CPU_TS_32_Accum;                 /* 32-bit accum'd ts  (in ts tmr cnts).                 */
SCPU_CORE_EXT  CPU_TS_TMR       CPU_TS_32_TmrPrev;               /* 32-bit ts prev tmr (in ts tmr cnts).                 */
S#endif
S
S#if ((CPU_CFG_TS_64_EN    == DEF_ENABLED)  && \
S     (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64))
X#if ((CPU_CFG_TS_64_EN    == DEF_ENABLED)  &&      (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64))
SCPU_CORE_EXT  CPU_TS64         CPU_TS_64_Accum;                 /* 64-bit accum'd ts  (in ts tmr cnts).                 */
SCPU_CORE_EXT  CPU_TS_TMR       CPU_TS_64_TmrPrev;               /* 64-bit ts prev tmr (in ts tmr cnts).                 */
S#endif
S
S#if  (CPU_CFG_TS_TMR_EN   == DEF_ENABLED)
SCPU_CORE_EXT  CPU_TS_TMR_FREQ  CPU_TS_TmrFreq_Hz;               /* CPU ts tmr freq (in Hz).                             */
S#endif
S
S
S#ifdef  CPU_CFG_INT_DIS_MEAS_EN
SCPU_CORE_EXT  CPU_INT16U       CPU_IntDisMeasCtr;               /* Nbr tot    ints dis'd ctr.                           */
SCPU_CORE_EXT  CPU_INT16U       CPU_IntDisNestCtr;               /* Nbr nested ints dis'd ctr.                           */
S                                                                /* Ints dis'd time (in ts tmr cnts) : ...               */
SCPU_CORE_EXT  CPU_TS_TMR       CPU_IntDisMeasStart_cnts;        /* ...  start time.                                     */
SCPU_CORE_EXT  CPU_TS_TMR       CPU_IntDisMeasStop_cnts;         /* ...  stop  time.                                     */
SCPU_CORE_EXT  CPU_TS_TMR       CPU_IntDisMeasOvrhd_cnts;        /* ...        time meas ovrhd.                          */
SCPU_CORE_EXT  CPU_TS_TMR       CPU_IntDisMeasMaxCur_cnts;       /* ...     resetable max time dis'd.                    */
SCPU_CORE_EXT  CPU_TS_TMR       CPU_IntDisMeasMax_cnts;          /* ... non-resetable max time dis'd.                    */
S#endif
S
S
S/*$PAGE*/
S/*
S*********************************************************************************************************
S*                                               MACRO'S
S*********************************************************************************************************
S*/
S
S/*
S*********************************************************************************************************
S*                                         CPU_SW_EXCEPTION()
S*
S* Description : Trap unrecoverable software exception.
S*
S* Argument(s) : err_rtn_val     Error type &/or value of the calling function to return (see Note #2b).
S*
S* Return(s)   : none.
S*
S* Caller(s)   : various.
S*
S* Note(s)     : (1) CPU_SW_EXCEPTION() deadlocks the current code execution -- whether multi-tasked/
S*                   -processed/-threaded or single-threaded -- when the current code execution cannot 
S*                   gracefully recover or report a fault or exception condition.
S*
S*                   Example CPU_SW_EXCEPTION() call :
S*
S*                       void  Fnct (CPU_ERR  *p_err)
S*                       {
S*                           :
S*
S*                           if (p_err == (CPU_ERR *)0) {        If 'p_err' NULL, cannot return error ...
S*                               CPU_SW_EXCEPTION(;);            ... so trap invalid argument exception.
S*                           }
S*
S*                           :
S*                       }
S*
S*                   See also 'cpu_core.c  CPU_SW_Exception()  Note #1'.
S*
S*               (2) (a) CPU_SW_EXCEPTION()  MAY be developer-implemented to output &/or handle any error or 
S*                       exception conditions; but since CPU_SW_EXCEPTION() is intended to trap unrecoverable 
S*                       software  conditions, it is recommended that developer-implemented versions prevent 
S*                       execution of any code following calls to CPU_SW_EXCEPTION() by deadlocking the code 
S*                       (see Note #1).
S*
S*                           Example CPU_SW_EXCEPTION() :
S*
S*                               #define  CPU_SW_EXCEPTION(err_rtn_val)      do {                         \
S*                                                                               Log(__FILE__, __LINE__); \
S*                                                                               CPU_SW_Exception();      \
S*                                                                           } while (0)
X
S*
S*                   (b) (1) However, if execution of code following calls to CPU_SW_EXCEPTION() is required 
S*                           (e.g. for automated testing); it is recommended that the last statement in 
S*                           developer-implemented versions be to return from the current function to prevent 
S*                           possible software exception(s) in the current function from triggering CPU &/or 
S*                           hardware exception(s).
S*
S*                           Example CPU_SW_EXCEPTION() :
S*
S*                               #define  CPU_SW_EXCEPTION(err_rtn_val)      do {                         \
S*                                                                               Log(__FILE__, __LINE__); \
S*                                                                               return  err_rtn_val;     \
S*                                                                           } while (0)
X
S*
S*                           (A) Note that 'err_rtn_val' in the return statement MUST NOT be enclosed in 
S*                               parentheses.  This allows CPU_SW_EXCEPTION() to return from functions that 
S*                               return 'void', i.e. NO return type or value (see also Note #2b2A).
S*$PAGE*
S*                       (2) In order for CPU_SW_EXCEPTION() to return from functions with various return 
S*                           types/values, each caller function MUST pass an appropriate error return type 
S*                           & value to CPU_SW_EXCEPTION().
S*
S*                           (A) Note that CPU_SW_EXCEPTION()  MUST NOT be passed any return type or value 
S*                               for functions that return 'void', i.e. NO return type or value; but SHOULD 
S*                               instead be passed a single semicolon.  This prevents possible compiler 
S*                               warnings that CPU_SW_EXCEPTION() is passed too few arguments.  However, 
S*                               the compiler may warn that CPU_SW_EXCEPTION() does NOT prevent creating 
S*                               null statements on lines with NO other code statements.
S*
S*                           Example CPU_SW_EXCEPTION() calls :
S*
S*                               void  Fnct (CPU_ERR  *p_err)
S*                               {
S*                                   :
S*
S*                                   if (p_err == (CPU_ERR *)0) {
S*                                       CPU_SW_EXCEPTION(;);            Exception macro returns NO value
S*                                   }                                       (see Note #2b2A)
S*
S*                                   :
S*                               }
S*
S*                               CPU_BOOLEAN  Fnct (CPU_ERR  *p_err)
S*                               {
S*                                   :
S*
S*                                   if (p_err == (CPU_ERR *)0) {
S*                                       CPU_SW_EXCEPTION(DEF_FAIL);     Exception macro returns 'DEF_FAIL'
S*                                   }
S*
S*                                   :
S*                               }
S*
S*                               OBJ  *Fnct (CPU_ERR  *p_err)
S*                               {
S*                                   :
S*
S*                                   if (p_err == (CPU_ERR *)0) {
S*                                       CPU_SW_EXCEPTION((OBJ *)0);     Exception macro returns NULL 'OBJ *'
S*                                   }
S*
S*                                   :
S*                               }
S*
S*********************************************************************************************************
S*/
S
S#ifndef  CPU_SW_EXCEPTION                                                       /* See Note #2.                         */
S#define  CPU_SW_EXCEPTION(err_rtn_val)              do {                    \
S                                                        CPU_SW_Exception(); \
S                                                    } while (0)
X#define  CPU_SW_EXCEPTION(err_rtn_val)              do {                                                                            CPU_SW_Exception();                                                     } while (0)
S#endif
S
S
S/*$PAGE*/
S/*
S*********************************************************************************************************
S*                                           CPU_VAL_UNUSED()
S*
S* Description : 
S*
S* Argument(s) : none.
S*
S* Return(s)   : none.
S*
S* Caller(s)   : #### various.
S*
S* Note(s)     : none.
S*********************************************************************************************************
S*/
S
S
S#define  CPU_VAL_UNUSED(val)        ((void)&(val));
S
S
S#define  CPU_VAL_IGNORED(val)       CPU_VAL_UNUSED(val)
S
S
S/*$PAGE*/
S/*
S*********************************************************************************************************
S*                                          CPU_TYPE_CREATE()
S*
S* Description : Creates a generic type value.
S*
S* Argument(s) : char_1      1st ASCII character to create generic type value.
S*
S*               char_2      2nd ASCII character to create generic type value.
S*
S*               char_3      3rd ASCII character to create generic type value.
S*
S*               char_4      4th ASCII character to create generic type value.
S*
S* Return(s)   : 32-bit generic type value.
S*
S* Caller(s)   : various.
S*
S* Note(s)     : (1) (a) Generic type values should be #define'd with large, non-trivial values to trap 
S*                       & discard invalid/corrupted objects based on type value.
S*
S*                       In other words, by assigning large, non-trivial values to valid objects' type 
S*                       fields; the likelihood that an object with an unassigned &/or corrupted type 
S*                       field will contain a value is highly improbable & therefore the object itself 
S*                       will be trapped as invalid.
S*
S*                   (b) (1) CPU_TYPE_CREATE()  creates a 32-bit type value from four values.
S*
S*                       (2) Ideally, generic type values SHOULD be created from 'CPU_CHAR' characters to 
S*                           represent ASCII string abbreviations of the specific object types.  Memory 
S*                           displays of object type values will display the specific object types with 
S*                           their chosen ASCII names.
S*
S*                           Examples :
S*
S*                               #define  FILE_TYPE  CPU_TYPE_CREATE('F', 'I', 'L', 'E')
S*                               #define  BUF_TYPE   CPU_TYPE_CREATE('B', 'U', 'F', ' ')
S*********************************************************************************************************
S*/
S
S#if     (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG)
S#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (3u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_2)) << (2u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_3)) << (1u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_4)) << (0u * DEF_OCTET_NBR_BITS)))
X#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (3u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_2)) << (2u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_3)) << (1u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_4)) << (0u * DEF_OCTET_NBR_BITS)))
S
S#else
S
S#if    ((CPU_CFG_DATA_SIZE   == CPU_WORD_SIZE_64) || \
S        (CPU_CFG_DATA_SIZE   == CPU_WORD_SIZE_32))
X#if    ((CPU_CFG_DATA_SIZE   == CPU_WORD_SIZE_64) ||         (CPU_CFG_DATA_SIZE   == CPU_WORD_SIZE_32))
S#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (0u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_2)) << (1u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_3)) << (2u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_4)) << (3u * DEF_OCTET_NBR_BITS)))
X#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (0u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_2)) << (1u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_3)) << (2u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_4)) << (3u * DEF_OCTET_NBR_BITS)))
S
S
S#elif   (CPU_CFG_DATA_SIZE   == CPU_WORD_SIZE_16)
S#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (2u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_2)) << (3u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_3)) << (0u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_4)) << (1u * DEF_OCTET_NBR_BITS)))
X#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (2u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_2)) << (3u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_3)) << (0u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_4)) << (1u * DEF_OCTET_NBR_BITS)))
S
S#else                                                           /* Dflt CPU_WORD_SIZE_08.                               */
S#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (3u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_2)) << (2u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_3)) << (1u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_4)) << (0u * DEF_OCTET_NBR_BITS)))
X#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (3u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_2)) << (2u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_3)) << (1u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_4)) << (0u * DEF_OCTET_NBR_BITS)))
S#endif
S#endif
S
S
S/*$PAGE*/
S/*
S*********************************************************************************************************
S*                                         FUNCTION PROTOTYPES
S*
S* Note(s) : (1) CPU interrupts disabled time measurement functions prototyped/defined only if 
S*               CPU_CFG_INT_DIS_MEAS_EN  #define'd in 'cpu_cfg.h'.
S*
S*           (2) (a) CPU_CntLeadZeros()  defined in :
S*
S*                   (1) 'cpu_a.asm',  if CPU_CFG_LEAD_ZEROS_ASM_PRESENT       #define'd in 'cpu.h'/
S*                                         'cpu_cfg.h' to enable assembly-optimized function(s)
S*
S*                   (2) 'cpu_core.c', if CPU_CFG_LEAD_ZEROS_ASM_PRESENT   NOT #define'd in 'cpu.h'/
S*                                         'cpu_cfg.h' to enable C-source-optimized function(s)
S*
S*               (b) CPU_CntTrailZeros() defined in :
S*
S*                   (1) 'cpu_a.asm',  if CPU_CFG_TRAIL_ZEROS_ASM_PRESENT      #define'd in 'cpu.h'/
S*                                         'cpu_cfg.h' to enable assembly-optimized function(s)
S*
S*                   (2) 'cpu_core.c', if CPU_CFG_TRAIL_ZEROS_ASM_PRESENT  NOT #define'd in 'cpu.h'/
S*                                         'cpu_cfg.h' to enable C-source-optimized function(s)
S*********************************************************************************************************
S*/
S
Svoid             CPU_Init                 (void);
S
Svoid             CPU_SW_Exception         (void);
S
S
S
S#if (CPU_CFG_NAME_EN == DEF_ENABLED)                                    /* -------------- CPU NAME FNCTS -------------- */
Svoid             CPU_NameClr              (void);
S
Svoid             CPU_NameGet              (       CPU_CHAR  *p_name,
S                                                  CPU_ERR   *p_err);
S
Svoid             CPU_NameSet              (const  CPU_CHAR  *p_name,
S                                                  CPU_ERR   *p_err);
S#endif
S
S
S
S                                                                        /* --------------- CPU TS FNCTS --------------- */
S#if (CPU_CFG_TS_32_EN == DEF_ENABLED)
SCPU_TS32         CPU_TS_Get32             (void);
S#endif
S
S#if (CPU_CFG_TS_64_EN == DEF_ENABLED)
SCPU_TS64         CPU_TS_Get64             (void);
S#endif
S
S#if (CPU_CFG_TS_EN    == DEF_ENABLED)
Svoid             CPU_TS_Update            (void);
S#endif
S
S
S#if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)                                  /* ------------- CPU TS TMR FNCTS ------------- */
SCPU_TS_TMR_FREQ  CPU_TS_TmrFreqGet        (CPU_ERR          *p_err);
S
Svoid             CPU_TS_TmrFreqSet        (CPU_TS_TMR_FREQ   freq_hz);
S#endif
S
S
S
S#ifdef  CPU_CFG_INT_DIS_MEAS_EN                                         /* -------- CPU INT DIS TIME MEAS FNCTS ------- */
S                                                                        /* See Note #1.                                 */
SCPU_TS_TMR       CPU_IntDisMeasMaxCurReset(void);
S
SCPU_TS_TMR       CPU_IntDisMeasMaxCurGet  (void);
S
SCPU_TS_TMR       CPU_IntDisMeasMaxGet     (void);
S
S
Svoid             CPU_IntDisMeasStart      (void);
S
Svoid             CPU_IntDisMeasStop       (void);
S#endif
S
S
S
S                                                                        /* ----------- CPU CNT ZEROS FNCTS ------------ */
SCPU_DATA         CPU_CntLeadZeros         (CPU_DATA    val);
S
S#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_08)
SCPU_DATA         CPU_CntLeadZeros08       (CPU_INT08U  val);
S#endif
S#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_16)
SCPU_DATA         CPU_CntLeadZeros16       (CPU_INT16U  val);
S#endif
S#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_32)
SCPU_DATA         CPU_CntLeadZeros32       (CPU_INT32U  val);
S#endif
S#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_64)
SCPU_DATA         CPU_CntLeadZeros64       (CPU_INT64U  val);
S#endif
S
S
SCPU_DATA         CPU_CntTrailZeros        (CPU_DATA    val);
S
S#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_08)
SCPU_DATA         CPU_CntTrailZeros08      (CPU_INT08U  val);
S#endif
S#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_16)
SCPU_DATA         CPU_CntTrailZeros16      (CPU_INT16U  val);
S#endif
S#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_32)
SCPU_DATA         CPU_CntTrailZeros32      (CPU_INT32U  val);
S#endif
S#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_64)
SCPU_DATA         CPU_CntTrailZeros64      (CPU_INT64U  val);
S#endif
S
S
S/*$PAGE*/
S/*
S*********************************************************************************************************
S*                                         FUNCTION PROTOTYPES
S*                                      DEFINED IN PRODUCT'S BSP
S*********************************************************************************************************
S*/
S
S/*
S*********************************************************************************************************
S*                                          CPU_TS_TmrInit()
S*
S* Description : Initialize & start CPU timestamp timer.
S*
S* Argument(s) : none.
S*
S* Return(s)   : none.
S*
S* Caller(s)   : CPU_TS_Init().
S*
S*               This function is an INTERNAL CPU module function & MUST be implemented by application/
S*               BSP function(s) [see Note #1] but MUST NOT be called by application function(s).
S*
S* Note(s)     : (1) CPU_TS_TmrInit() is an application/BSP function that MUST be defined by the developer 
S*                   if either of the following CPU features is enabled :
S*
S*                   (a) CPU timestamps
S*                   (b) CPU interrupts disabled time measurements
S*
S*                   See 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
S*                     & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1a'.
S*
S*               (2) (a) Timer count values MUST be returned via word-size-configurable 'CPU_TS_TMR' 
S*                       data type.
S*
S*                       (1) If timer has more bits, truncate timer values' higher-order bits greater 
S*                           than the configured 'CPU_TS_TMR' timestamp timer data type word size.
S*
S*                       (2) Since the timer MUST NOT have less bits than the configured 'CPU_TS_TMR' 
S*                           timestamp timer data type word size; 'CPU_CFG_TS_TMR_SIZE' MUST be 
S*                           configured so that ALL bits in 'CPU_TS_TMR' data type are significant.
S*
S*                           In other words, if timer size is not a binary-multiple of 8-bit octets 
S*                           (e.g. 20-bits or even 24-bits), then the next lower, binary-multiple 
S*                           octet word size SHOULD be configured (e.g. to 16-bits).  However, the 
S*                           minimum supported word size for CPU timestamp timers is 8-bits.
S*
S*                       See also 'cpu_cfg.h   CPU TIMESTAMP CONFIGURATION  Note #2'
S*                              & 'cpu_core.h  CPU TIMESTAMP DATA TYPES     Note #1'.
S*
S*                   (b) Timer SHOULD be an 'up'  counter whose values increase with each time count.
S*
S*                   (c) When applicable, timer period SHOULD be less than the typical measured time 
S*                       but MUST be less than the maximum measured time; otherwise, timer resolution 
S*                       inadequate to measure desired times.
S*
S*                   See also 'CPU_TS_TmrRd()  Note #2'.
S*********************************************************************************************************
S*/
S
S#if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
Svoid  CPU_TS_TmrInit(void);
S#endif
S
S
S/*$PAGE*/
S/*
S*********************************************************************************************************
S*                                           CPU_TS_TmrRd()
S*
S* Description : Get current CPU timestamp timer count value.
S*
S* Argument(s) : none.
S*
S* Return(s)   : Timestamp timer count (see Notes #2a & #2b).
S*
S* Caller(s)   : CPU_TS_Init(),
S*               CPU_TS_Get32(),
S*               CPU_TS_Get64(),
S*               CPU_IntDisMeasStart(),
S*               CPU_IntDisMeasStop().
S*
S*               This function is an INTERNAL CPU module function & MUST be implemented by application/
S*               BSP function(s) [see Note #1] but SHOULD NOT be called by application function(s).
S*
S* Note(s)     : (1) CPU_TS_TmrRd() is an application/BSP function that MUST be defined by the developer 
S*                   if either of the following CPU features is enabled :
S*
S*                   (a) CPU timestamps
S*                   (b) CPU interrupts disabled time measurements
S*
S*                   See 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
S*                     & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1a'.
S*
S*               (2) (a) Timer count values MUST be returned via word-size-configurable 'CPU_TS_TMR' 
S*                       data type.
S*
S*                       (1) If timer has more bits, truncate timer values' higher-order bits greater 
S*                           than the configured 'CPU_TS_TMR' timestamp timer data type word size.
S*
S*                       (2) Since the timer MUST NOT have less bits than the configured 'CPU_TS_TMR' 
S*                           timestamp timer data type word size; 'CPU_CFG_TS_TMR_SIZE' MUST be 
S*                           configured so that ALL bits in 'CPU_TS_TMR' data type are significant.
S*
S*                           In other words, if timer size is not a binary-multiple of 8-bit octets 
S*                           (e.g. 20-bits or even 24-bits), then the next lower, binary-multiple 
S*                           octet word size SHOULD be configured (e.g. to 16-bits).  However, the 
S*                           minimum supported word size for CPU timestamp timers is 8-bits.
S*
S*                       See also 'cpu_cfg.h   CPU TIMESTAMP CONFIGURATION  Note #2'
S*                              & 'cpu_core.h  CPU TIMESTAMP DATA TYPES     Note #1'.
S*
S*                   (b) Timer SHOULD be an 'up'  counter whose values increase with each time count.
S*
S*                       (1) If timer is a 'down' counter whose values decrease with each time count,
S*                           then the returned timer value MUST be ones-complemented.
S*
S*                   (c) (1) When applicable, the amount of time measured by CPU timestamps is 
S*                           calculated by either of the following equations :
S*
S*                           (A) Time measured  =  Number timer counts  *  Timer period
S*
S*                                   where
S*
S*                                       Number timer counts     Number of timer counts measured 
S*                                       Timer period            Timer's period in some units of 
S*                                                                   (fractional) seconds
S*                                       Time measured           Amount of time measured, in same 
S*                                                                   units of (fractional) seconds 
S*                                                                   as the Timer period
S*
S*                                                  Number timer counts
S*                           (B) Time measured  =  ---------------------
S*                                                    Timer frequency
S*
S*                                   where
S*
S*                                       Number timer counts     Number of timer counts measured
S*                                       Timer frequency         Timer's frequency in some units 
S*                                                                   of counts per second
S*                                       Time measured           Amount of time measured, in seconds
S*
S*                       (2) Timer period SHOULD be less than the typical measured time but MUST be less 
S*                           than the maximum measured time; otherwise, timer resolution inadequate to 
S*                           measure desired times.
S*********************************************************************************************************
S*/
S
S#if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
SCPU_TS_TMR  CPU_TS_TmrRd(void);
S#endif
S
S
S/*$PAGE*/
S/*
S*********************************************************************************************************
S*                                         CPU_TSxx_to_uSec()
S*
S* Description : Convert a 32-/64-bit CPU timestamp from timer counts to microseconds.
S*
S* Argument(s) : ts_cnts   CPU timestamp (in timestamp timer counts [see Note #2aA]).
S*
S* Return(s)   : Converted CPU timestamp (in microseconds           [see Note #2aD]).
S*
S* Caller(s)   : Application.
S*
S*               This function is an (optional) CPU module application programming interface (API) 
S*               function which MAY be implemented by application/BSP function(s) [see Note #1] & 
S*               MAY be called by application function(s).
S*
S* Note(s)     : (1) CPU_TS32_to_uSec()/CPU_TS64_to_uSec() are application/BSP functions that MAY be 
S*                   optionally defined by the developer when either of the following CPU features is 
S*                   enabled :
S*
S*                   (a) CPU timestamps
S*                   (b) CPU interrupts disabled time measurements
S*
S*                   See 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
S*                     & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1a'.
S*
S*               (2) (a) The amount of time measured by CPU timestamps is calculated by either of 
S*                       the following equations :
S*
S*                                                                        10^6 microseconds
S*                       (1) Time measured  =   Number timer counts   *  -------------------  *  Timer period
S*                                                                            1 second
S*
S*                                              Number timer counts       10^6 microseconds
S*                       (2) Time measured  =  ---------------------  *  -------------------
S*                                                Timer frequency             1 second
S*
S*                               where
S*
S*                                   (A) Number timer counts     Number of timer counts measured
S*                                   (B) Timer frequency         Timer's frequency in some units 
S*                                                                   of counts per second
S*                                   (C) Timer period            Timer's period in some units of 
S*                                                                   (fractional)  seconds
S*                                   (D) Time measured           Amount of time measured, 
S*                                                                   in microseconds
S*
S*                   (b) Timer period SHOULD be less than the typical measured time but MUST be less 
S*                       than the maximum measured time; otherwise, timer resolution inadequate to 
S*                       measure desired times.
S*
S*                   (c) Specific implementations may convert any number of CPU_TS32 or CPU_TS64 bits 
S*                       -- up to 32 or 64, respectively -- into microseconds.
S*********************************************************************************************************
S*/
S
S#if (CPU_CFG_TS_32_EN == DEF_ENABLED)
SCPU_INT64U  CPU_TS32_to_uSec(CPU_TS32  ts_cnts);
S#endif
S
S#if (CPU_CFG_TS_64_EN == DEF_ENABLED)
SCPU_INT64U  CPU_TS64_to_uSec(CPU_TS64  ts_cnts);
S#endif
S
S
S/*$PAGE*/
S/*
S*********************************************************************************************************
S*                                        CONFIGURATION ERRORS
S*********************************************************************************************************
S*/
S
S#ifndef  CPU_CFG_NAME_EN
S#error  "CPU_CFG_NAME_EN                       not #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  DEF_ENABLED ]           "
S#error  "                                [     ||  DEF_DISABLED]           "
S
S#elif  ((CPU_CFG_NAME_EN != DEF_ENABLED ) && \
S        (CPU_CFG_NAME_EN != DEF_DISABLED))
X#elif  ((CPU_CFG_NAME_EN != DEF_ENABLED ) &&         (CPU_CFG_NAME_EN != DEF_DISABLED))
S#error  "CPU_CFG_NAME_EN                 illegally #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  DEF_ENABLED ]           "
S#error  "                                [     ||  DEF_DISABLED]           "
S
S
S#elif   (CPU_CFG_NAME_EN == DEF_ENABLED)
S
S#ifndef  CPU_CFG_NAME_SIZE
S#error  "CPU_CFG_NAME_SIZE                     not #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  >=   1]                 "
S#error  "                                [     &&  <= 255]                 "
S
S#elif   (DEF_CHK_VAL(CPU_CFG_NAME_SIZE,            \
S                     1,                            \
S                     DEF_INT_08U_MAX_VAL) != DEF_OK)
X#elif   (DEF_CHK_VAL(CPU_CFG_NAME_SIZE,                                 1,                                                 DEF_INT_08U_MAX_VAL) != DEF_OK)
S#error  "CPU_CFG_NAME_SIZE               illegally #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  >=   1]                 "
S#error  "                                [     &&  <= 255]                 "
S#endif
S
S#endif
S
S
S
S
S#ifndef  CPU_CFG_TS_32_EN
S#error  "CPU_CFG_TS_32_EN                      not #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  DEF_DISABLED]           "
S#error  "                                [     ||  DEF_ENABLED ]           "
S
S#elif  ((CPU_CFG_TS_32_EN != DEF_DISABLED) && \
S        (CPU_CFG_TS_32_EN != DEF_ENABLED ))
X#elif  ((CPU_CFG_TS_32_EN != DEF_DISABLED) &&         (CPU_CFG_TS_32_EN != DEF_ENABLED ))
S#error  "CPU_CFG_TS_32_EN                illegally #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  DEF_DISABLED]           "
S#error  "                                [     ||  DEF_ENABLED ]           "
S
S#endif
S
S
S#ifndef  CPU_CFG_TS_64_EN
S#error  "CPU_CFG_TS_64_EN                      not #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  DEF_DISABLED]           "
S#error  "                                [     ||  DEF_ENABLED ]           "
S
S#elif  ((CPU_CFG_TS_64_EN != DEF_DISABLED) && \
S        (CPU_CFG_TS_64_EN != DEF_ENABLED ))
X#elif  ((CPU_CFG_TS_64_EN != DEF_DISABLED) &&         (CPU_CFG_TS_64_EN != DEF_ENABLED ))
S#error  "CPU_CFG_TS_64_EN                illegally #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  DEF_DISABLED]           "
S#error  "                                [     ||  DEF_ENABLED ]           "
S
S#endif
S
S                                                                /* Correctly configured in 'cpu_core.h'; DO NOT MODIFY. */
S#ifndef  CPU_CFG_TS_EN
S#error  "CPU_CFG_TS_EN                         not #define'd in 'cpu_core.h'"
S#error  "                                [MUST be  DEF_DISABLED]            "
S#error  "                                [     ||  DEF_ENABLED ]            "
S
S#elif  ((CPU_CFG_TS_EN != DEF_DISABLED) && \
S        (CPU_CFG_TS_EN != DEF_ENABLED ))
X#elif  ((CPU_CFG_TS_EN != DEF_DISABLED) &&         (CPU_CFG_TS_EN != DEF_ENABLED ))
S#error  "CPU_CFG_TS_EN                   illegally #define'd in 'cpu_core.h'"
S#error  "                                [MUST be  DEF_DISABLED]            "
S#error  "                                [     ||  DEF_ENABLED ]            "
S
S#endif
S
S
S/*$PAGE*/
S                                                                /* Correctly configured in 'cpu_core.h'; DO NOT MODIFY. */
S#ifndef  CPU_CFG_TS_TMR_EN
S#error  "CPU_CFG_TS_TMR_EN                     not #define'd in 'cpu_core.h'"
S#error  "                                [MUST be  DEF_DISABLED]            "
S#error  "                                [     ||  DEF_ENABLED ]            "
S
S#elif  ((CPU_CFG_TS_TMR_EN != DEF_DISABLED) && \
S        (CPU_CFG_TS_TMR_EN != DEF_ENABLED ))
X#elif  ((CPU_CFG_TS_TMR_EN != DEF_DISABLED) &&         (CPU_CFG_TS_TMR_EN != DEF_ENABLED ))
S#error  "CPU_CFG_TS_TMR_EN               illegally #define'd in 'cpu_core.h'"
S#error  "                                [MUST be  DEF_DISABLED]            "
S#error  "                                [     ||  DEF_ENABLED ]            "
S
S
S#elif   (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
S
S#ifndef  CPU_CFG_TS_TMR_SIZE
S#error  "CPU_CFG_TS_TMR_SIZE                   not #define'd in 'cpu_cfg.h'       "
S#error  "                                [MUST be  CPU_WORD_SIZE_08   8-bit timer]"
S#error  "                                [     ||  CPU_WORD_SIZE_16  16-bit timer]"
S#error  "                                [     ||  CPU_WORD_SIZE_32  32-bit timer]"
S#error  "                                [     ||  CPU_WORD_SIZE_64  64-bit timer]"
S
S#elif  ((CPU_CFG_TS_TMR_SIZE != CPU_WORD_SIZE_08) && \
S        (CPU_CFG_TS_TMR_SIZE != CPU_WORD_SIZE_16) && \
S        (CPU_CFG_TS_TMR_SIZE != CPU_WORD_SIZE_32) && \
S        (CPU_CFG_TS_TMR_SIZE != CPU_WORD_SIZE_64))
X#elif  ((CPU_CFG_TS_TMR_SIZE != CPU_WORD_SIZE_08) &&         (CPU_CFG_TS_TMR_SIZE != CPU_WORD_SIZE_16) &&         (CPU_CFG_TS_TMR_SIZE != CPU_WORD_SIZE_32) &&         (CPU_CFG_TS_TMR_SIZE != CPU_WORD_SIZE_64))
S#error  "CPU_CFG_TS_TMR_SIZE             illegally #define'd in 'cpu_cfg.h'       "
S#error  "                                [MUST be  CPU_WORD_SIZE_08   8-bit timer]"
S#error  "                                [     ||  CPU_WORD_SIZE_16  16-bit timer]"
S#error  "                                [     ||  CPU_WORD_SIZE_32  32-bit timer]"
S#error  "                                [     ||  CPU_WORD_SIZE_64  64-bit timer]"
S#endif
S
S#endif
S
S
S
S#ifndef  CPU_CFG_INT_DIS_MEAS_EN
S#if 0                                                           /* Optionally configured in 'cpu_cfg.h'; DO NOT MODIFY. */
S#error  "CPU_CFG_INT_DIS_MEAS_EN               not #define'd in 'cpu_cfg.h'"
S#endif
S
S#else
S
S#ifndef  CPU_CFG_INT_DIS_MEAS_OVRHD_NBR
S#error  "CPU_CFG_INT_DIS_MEAS_OVRHD_NBR        not #define'd in 'cpu_cfg.h' "
S#error  "                                [MUST be  >= CPU_TIME_MEAS_NBR_MIN]"
S#error  "                                [     ||  <= CPU_TIME_MEAS_NBR_MAX]"
S
S#elif   (DEF_CHK_VAL(CPU_CFG_INT_DIS_MEAS_OVRHD_NBR, \
S                     CPU_TIME_MEAS_NBR_MIN,          \
S                     CPU_TIME_MEAS_NBR_MAX) != DEF_OK)
X#elif   (DEF_CHK_VAL(CPU_CFG_INT_DIS_MEAS_OVRHD_NBR,                      CPU_TIME_MEAS_NBR_MIN,                               CPU_TIME_MEAS_NBR_MAX) != DEF_OK)
S#error  "CPU_CFG_INT_DIS_MEAS_OVRHD_NBR  illegally #define'd in 'cpu_cfg.h' "
S#error  "                                [MUST be  >= CPU_TIME_MEAS_NBR_MIN]"
S#error  "                                [     ||  <= CPU_TIME_MEAS_NBR_MAX]"
S
S#endif
S
S#endif
S
S
S
S
S#ifndef  CPU_CFG_LEAD_ZEROS_ASM_PRESENT
S#if 0                                                           /* Optionally configured in 'cpu_cfg.h'; DO NOT MODIFY. */
S#error  "CPU_CFG_LEAD_ZEROS_ASM_PRESENT        not #define'd in 'cpu.h'/'cpu_cfg.h'"
S#endif
S#endif
S
S
S#ifndef  CPU_CFG_TRAIL_ZEROS_ASM_PRESENT
S#if 0                                                           /* Optionally configured in 'cpu_cfg.h'; DO NOT MODIFY. */
S#error  "CPU_CFG_TRAIL_ZEROS_ASM_PRESENT       not #define'd in 'cpu.h'/'cpu_cfg.h'"
S#endif
S#endif
S
S
S/*$PAGE*/
S/*
S*********************************************************************************************************
S*                                    CPU PORT CONFIGURATION ERRORS
S*********************************************************************************************************
S*/
S
S#ifndef  CPU_CFG_ADDR_SIZE
S#error  "CPU_CFG_ADDR_SIZE      not #define'd in 'cpu.h'"
S#endif
S
S#ifndef  CPU_CFG_DATA_SIZE
S#error  "CPU_CFG_DATA_SIZE      not #define'd in 'cpu.h'"
S#endif
S
S#ifndef  CPU_CFG_DATA_SIZE_MAX
S#error  "CPU_CFG_DATA_SIZE_MAX  not #define'd in 'cpu.h'"
S#endif
S
S
S/*
S*********************************************************************************************************
S*                                    LIBRARY CONFIGURATION ERRORS
S*********************************************************************************************************
S*/
S
S                                                                /* See 'cpu_core.h  Note #1a'.                          */
S#if     (LIB_VERSION < 13500u)
S#error  "LIB_VERSION  [SHOULD be >= V1.35.00]"
S#endif
S
S
S/*
S*********************************************************************************************************
S*                                             MODULE END
S*
S* Note(s) : (1) See 'cpu_core.h  MODULE'.
S*********************************************************************************************************
S*/
S
N#endif                                                          /* End of CPU core module include.                      */
N
L 108 "..\..\uC-LIB\lib_mem.h" 2
N
N#include  <lib_def.h>
N#include  <lib_cfg.h>
L 1 "..\App\lib_cfg.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/LIB
N*                                        CUSTOM LIBRARY MODULES
N*
N*                          (c) Copyright 2004-2013; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/LIB is provided in source form to registered licensees ONLY.  It is 
N*               illegal to distribute this source code to any third party unless you receive 
N*               written permission by an authorized Micrium representative.  Knowledge of 
N*               the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest 
N*               software available.  Your honesty is greatly appreciated.
N*
N*               You can contact us at www.micrium.com.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                  CUSTOM LIBRARY CONFIGURATION FILE
N*
N*                                     ST Microelectronics STM32
N*                                              on the
N*
N*                                           STM3220G-EVAL
N*                                         Evaluation Board
N*
N* Filename      : lib_cfg.h
N* Version       : V1.35.00
N* Programmer(s) : DC
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_CFG_MODULE_PRESENT
N#define  LIB_CFG_MODULE_PRESENT
N
N
N/*
N*********************************************************************************************************
N*                                          uC/LIB CONFIGURATION
N*********************************************************************************************************
N*/
N
N#define  LIB_MEM_CFG_ARG_CHK_EXT_EN     DEF_ENABLED
N                                                        /*   DEF_DISABLED     Argument check DISABLED                   */
N                                                        /*   DEF_ENABLED      Argument check ENABLED                    */
N
N#define  LIB_MEM_CFG_OPTIMIZE_ASM_EN    DEF_ENABLED
N                                                        /*   DEF_DISABLED     Assembly-optimized function(s) DISABLED   */
N                                                        /*   DEF_ENABLED      Assembly-optimized function(s) ENABLED    */
N
N#define  LIB_MEM_CFG_ALLOC_EN           DEF_DISABLED/*DEF_ENABLED*/
N                                                        /*   DEF_DISABLED     Memory allocation DISABLED                */
N                                                        /*   DEF_ENABLED      Memory allocation ENABLED                 */
N
N
N#define  LIB_MEM_CFG_HEAP_SIZE           9u * 1024u     /* Configure Heap Memory Size                                   */
N
N
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*********************************************************************************************************
N*/
N
N#endif                                                  /* End of lib cfg module include.                               */
N
L 111 "..\..\uC-LIB\lib_mem.h" 2
N
N
N/*
N*********************************************************************************************************
N*                                               EXTERNS
N*********************************************************************************************************
N*/
N
N#ifdef   LIB_MEM_MODULE
S#define  LIB_MEM_EXT
N#else
N#define  LIB_MEM_EXT  extern
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        DEFAULT CONFIGURATION
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                             MEMORY LIBRARY ARGUMENT CHECK CONFIGURATION
N*
N* Note(s) : (1) Configure LIB_MEM_CFG_ARG_CHK_EXT_EN to enable/disable the memory library suite external
N*               argument check feature :
N*
N*               (a) When ENABLED,      arguments received from any port interface provided by the developer
N*                   or application are checked/validated.
N*
N*               (b) When DISABLED, NO  arguments received from any port interface provided by the developer
N*                   or application are checked/validated.
N*********************************************************************************************************
N*/
N
N                                                        /* Configure external argument check feature (see Note #1) :    */
N#ifndef  LIB_MEM_CFG_ARG_CHK_EXT_EN
S#define  LIB_MEM_CFG_ARG_CHK_EXT_EN     DEF_DISABLED
S                                                        /*   DEF_DISABLED     Argument check DISABLED                   */
S                                                        /*   DEF_ENABLED      Argument check ENABLED                    */
N#endif
N
N
N/*
N*********************************************************************************************************
N*                         MEMORY LIBRARY ASSEMBLY OPTIMIZATION CONFIGURATION
N*
N* Note(s) : (1) Configure LIB_MEM_CFG_OPTIMIZE_ASM_EN to enable/disable assembly-optimized memory functions.
N*********************************************************************************************************
N*/
N
N                                                        /* Configure assembly-optimized function(s) [see Note #1] :     */
N#ifndef  LIB_MEM_CFG_OPTIMIZE_ASM_EN
S#define  LIB_MEM_CFG_OPTIMIZE_ASM_EN    DEF_DISABLED
S                                                        /*   DEF_DISABLED     Assembly-optimized function(s) DISABLED   */
S                                                        /*   DEF_ENABLED      Assembly-optimized function(s) ENABLED    */
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                   MEMORY ALLOCATION CONFIGURATION
N*
N* Note(s) : (1) Configure LIB_MEM_CFG_ALLOC_EN to enable/disable memory allocation functions.
N*********************************************************************************************************
N*/
N
N                                                        /* Configure memory allocation feature (see Note #1) :          */
N#ifndef  LIB_MEM_CFG_ALLOC_EN
S#define  LIB_MEM_CFG_ALLOC_EN           DEF_DISABLED
S                                                        /*   DEF_DISABLED     Memory allocation DISABLED                */
S                                                        /*   DEF_ENABLED      Memory allocation ENABLED                 */
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                               DEFINES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                     MEMORY LIBRARY TYPE DEFINES
N*
N* Note(s) : (1) LIB_MEM_TYPE_&&& #define values specifically chosen as ASCII representations of the memory
N*               library types.  Memory displays of memory library objects will display the library TYPEs
N*               with their chosen ASCII names.
N*********************************************************************************************************
N*/
N
N#define  LIB_MEM_TYPE_NONE                        CPU_TYPE_CREATE('N', 'O', 'N', 'E')
N#define  LIB_MEM_TYPE_HEAP                        CPU_TYPE_CREATE('H', 'E', 'A', 'P')
N#define  LIB_MEM_TYPE_POOL                        CPU_TYPE_CREATE('P', 'O', 'O', 'L')
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             DATA TYPES
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                            LIB MEM TYPE
N*
N* Note(s) : (1) 'LIB_MEM_TYPE' declared as 'CPU_INT32U' & all 'LIB_MEM_TYPE's #define'd with large, non-trivial
N*               values to trap & discard invalid/corrupted library memory objects based on 'LIB_MEM_TYPE'.
N*********************************************************************************************************
N*/
N
Ntypedef  CPU_INT32U  LIB_MEM_TYPE;
N
N
N/*
N*********************************************************************************************************
N*                                MEMORY POOL BLOCK QUANTITY DATA TYPE
N*********************************************************************************************************
N*/
N
Ntypedef  CPU_SIZE_T  MEM_POOL_BLK_QTY;
N
N
N/*
N*********************************************************************************************************
N*                                      MEMORY POOL TABLE IX TYPE
N*********************************************************************************************************
N*/
N
Ntypedef  MEM_POOL_BLK_QTY  MEM_POOL_IX;
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        MEMORY POOL DATA TYPES
N*
N*                                                                      MEMORY SEGMENT
N*                                                                     ----------------
N*                                            MEMORY POOL'S            |              | <----
N*                                             POINTERS TO             |    MEMORY    |     |
N*                    MEM_POOL                MEMORY BLOCKS            |    BLOCKS    |     |
N*               |----------------|            |---------|             |   --------   |     |
N*               |        O------------------> |    O--------------------> |      |   |     |
N*               |----------------|            |---------|             |   |      |   |     |
N*               | Pool Addr Ptrs |            |    O-------------     |   --------   |     |
N*               | Pool Size      |            |---------|       |     |              |     |
N*               |----------------|            |         |       |     |   --------   |     |
N*               |    Blk Size    |            |         |       --------> |      |   |     |
N*               |    Blk Nbr     |            |         |             |   |      |   |     |
N*               |    Blk Ix      |            |    .    |             |   --------   |     |
N*               |----------------|            |    .    |             |              |     |
N*               |----------------|            |    .    |             |      .       |     |
N*               |        O-----------------   |         |             |      .       |     |
N*               |----------------|        |   |         |             |      .       |     |
N*               |        O------------    |   |         |             |              |     |
N*               |----------------|   |    |   |---------|             |   --------   |     |
N*               |  Seg Size Tot  |   |    |   |    O--------------------> |      |   |     |
N*               |  Seg Size Rem  |   |    |   |---------|             |   |      |   |     |
N*               |----------------|   |    |   |         |             |   --------   |     |
N*               | Seg List Ptrs  |   |    |   |---------|             |              |     |
N*               |----------------|   |    |                           | ------------ |     |
N*                                    |    |                           |              | <--------
N*                                    |    |                           |              |     |   |
N*                                    |    |                           |              |     |   |
N*                                    |    |                           |              |     |   |
N*                                    |    |                           |              |     |   |
N*                                    |    |                           |              |     |   |
N*                                    |    |                           ----------------     |   |
N*                                    |    |                                                |   |
N*                                    |    --------------------------------------------------   |
N*                                    |                                                         |
N*                                    -----------------------------------------------------------
N*
N*********************************************************************************************************
N*/
N
Ntypedef  struct  mem_pool  MEM_POOL;
N
N                                                                /* --------------------- MEM POOL --------------------- */
Nstruct  mem_pool {
N    LIB_MEM_TYPE        Type;                                   /* Pool type : LIB_TYPE_POOL or LIB_TYPE_HEAP.          */
N
N    MEM_POOL           *SegHeadPtr;                             /* Ptr to head mem seg.                                 */
N    MEM_POOL           *SegPrevPtr;                             /* Ptr to PREV mem seg.                                 */
N    MEM_POOL           *SegNextPtr;                             /* Ptr to NEXT mem seg.                                 */
N    MEM_POOL           *PoolPrevPtr;                            /* Ptr to PREV mem pool.                                */
N    MEM_POOL           *PoolNextPtr;                            /* Ptr to NEXT mem pool.                                */
N
N    void               *PoolAddrStart;                          /* Ptr   to start of mem seg for mem pool blks.         */
N    void               *PoolAddrEnd;                            /* Ptr   to end   of mem seg for mem pool blks.         */
N    void              **PoolPtrs;                               /* Ptr   to mem pool's array of blk ptrs.               */
N    MEM_POOL_IX         BlkIx;                                  /* Ix  into mem pool's array of blk ptrs.               */
N    CPU_SIZE_T          PoolSize;                               /* Size  of mem pool        (in octets).                */
N    MEM_POOL_BLK_QTY    BlkNbr;                                 /* Nbr   of mem pool   blks.                            */
N    CPU_SIZE_T          BlkSize;                                /* Size  of mem pool   blks (in octets).                */
N    CPU_SIZE_T          BlkAlign;                               /* Align of mem pool   blks (in octets).                */
N
N                                                                /* --------------------- MEM SEG ---------------------- */
N    void               *SegAddr;                                /* Ptr      to mem seg's base/start addr.               */
N    void               *SegAddrNextAvail;                       /* Ptr      to mem seg's next avail addr.               */
N    CPU_SIZE_T          SegSizeTot;                             /* Tot size of mem seg (in octets).                     */
N    CPU_SIZE_T          SegSizeRem;                             /* Rem size of mem seg (in octets).                     */
N};
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                              MACRO'S
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                      MEMORY DATA VALUE MACRO'S
N*
N* Note(s) : (1) (a) Some variables & variable buffers to pass & receive data values MUST start on appropriate
N*                   CPU word-aligned addresses.  This is required because most word-aligned processors are more
N*                   efficient & may even REQUIRE that multi-octet words start on CPU word-aligned addresses.
N*
N*                   (1) For 16-bit word-aligned processors, this means that
N*
N*                           all 16- & 32-bit words MUST start on addresses that are multiples of 2 octets
N*
N*                   (2) For 32-bit word-aligned processors, this means that
N*
N*                           all 16-bit       words MUST start on addresses that are multiples of 2 octets
N*                           all 32-bit       words MUST start on addresses that are multiples of 4 octets
N*
N*               (b) However, some data values macro's appropriately access data values from any CPU addresses,
N*                   word-aligned or not.  Thus for processors that require data word alignment, data words can
N*                   be accessed to/from any CPU address, word-aligned or not, without generating data-word-
N*                   alignment exceptions/faults.
N*********************************************************************************************************
N*/
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                      ENDIAN WORD ORDER MACRO'S
N*
N* Description : Convert data values to & from big-, little, or host-endian CPU word order.
N*
N* Argument(s) : val       Data value to convert (see Notes #1 & #2).
N*
N* Return(s)   : Converted data value (see Notes #1 & #2).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) Convert data values to the desired data-word order :
N*
N*                       MEM_VAL_BIG_TO_LITTLE_xx()      Convert big-        endian data values
N*                                                            to little-     endian data values
N*                       MEM_VAL_LITTLE_TO_BIG_xx()      Convert little-     endian data values
N*                                                            to big-        endian data values
N*                       MEM_VAL_xxx_TO_HOST_xx()        Convert big-/little-endian data values
N*                                                            to host-       endian data values
N*                       MEM_VAL_HOST_TO_xxx_xx()        Convert host-       endian data values
N*                                                            to big-/little-endian data values
N*
N*                   See also 'cpu.h  CPU WORD CONFIGURATION  Note #2'.
N*
N*               (2) 'val' data value to convert & any variable to receive the returned conversion MUST
N*                   start on appropriate CPU word-aligned addresses.
N*
N*                   See also 'MEMORY DATA VALUE MACRO'S  Note #1a'.
N*
N*               (3) MEM_VAL_COPY_xxx() macro's are more efficient than generic endian word order macro's &
N*                   are also independent of CPU data-word-alignment & SHOULD be used whenever possible.
N*
N*                   See also 'MEM_VAL_COPY_GET_xxx()  Note #4'
N*                          & 'MEM_VAL_COPY_SET_xxx()  Note #4'.
N*
N*               (4) Generic endian word order macro's are NOT atomic operations & MUST NOT be used on any
N*                   non-static (i.e. volatile) variables, registers, hardware, etc.; without the caller of
N*                   the macro's providing some form of additional protection (e.g. mutual exclusion).
N*
N*               (5) The 'CPU_CFG_ENDIAN_TYPE' pre-processor 'else'-conditional code SHOULD never be compiled/
N*                   linked since each 'cpu.h' SHOULD ensure that the CPU data-word-memory order configuration
N*                   constant (CPU_CFG_ENDIAN_TYPE) is configured with an appropriate data-word-memory order
N*                   value (see 'cpu.h  CPU WORD CONFIGURATION  Note #2').  The 'else'-conditional code is
N*                   included as an extra precaution in case 'cpu.h' is incorrectly configured.
N*********************************************************************************************************
N*/
N/*$PAGE*/
N
N#if    ((CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_64) || \
N        (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_32))
X#if    ((4 == 8) ||         (4 == 4))
N
N#define  MEM_VAL_BIG_TO_LITTLE_16(val)        ((CPU_INT16U)(((CPU_INT16U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0xFF00u) >> (1u * DEF_OCTET_NBR_BITS))) | \
N                                                            ((CPU_INT16U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0x00FFu) << (1u * DEF_OCTET_NBR_BITS)))))
X#define  MEM_VAL_BIG_TO_LITTLE_16(val)        ((CPU_INT16U)(((CPU_INT16U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0xFF00u) >> (1u * DEF_OCTET_NBR_BITS))) |                                                             ((CPU_INT16U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0x00FFu) << (1u * DEF_OCTET_NBR_BITS)))))
N
N#define  MEM_VAL_BIG_TO_LITTLE_32(val)        ((CPU_INT32U)(((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0xFF000000u) >> (3u * DEF_OCTET_NBR_BITS))) | \
N                                                            ((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x00FF0000u) >> (1u * DEF_OCTET_NBR_BITS))) | \
N                                                            ((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x0000FF00u) << (1u * DEF_OCTET_NBR_BITS))) | \
N                                                            ((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x000000FFu) << (3u * DEF_OCTET_NBR_BITS)))))
X#define  MEM_VAL_BIG_TO_LITTLE_32(val)        ((CPU_INT32U)(((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0xFF000000u) >> (3u * DEF_OCTET_NBR_BITS))) |                                                             ((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x00FF0000u) >> (1u * DEF_OCTET_NBR_BITS))) |                                                             ((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x0000FF00u) << (1u * DEF_OCTET_NBR_BITS))) |                                                             ((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x000000FFu) << (3u * DEF_OCTET_NBR_BITS)))))
N
N#elif   (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_16)
S
S#define  MEM_VAL_BIG_TO_LITTLE_16(val)        ((CPU_INT16U)(((CPU_INT16U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0xFF00u) >> (1u * DEF_OCTET_NBR_BITS))) | \
S                                                            ((CPU_INT16U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0x00FFu) << (1u * DEF_OCTET_NBR_BITS)))))
X#define  MEM_VAL_BIG_TO_LITTLE_16(val)        ((CPU_INT16U)(((CPU_INT16U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0xFF00u) >> (1u * DEF_OCTET_NBR_BITS))) |                                                             ((CPU_INT16U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0x00FFu) << (1u * DEF_OCTET_NBR_BITS)))))
S
S#define  MEM_VAL_BIG_TO_LITTLE_32(val)        ((CPU_INT32U)(((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0xFF000000u) >> (1u * DEF_OCTET_NBR_BITS))) | \
S                                                            ((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x00FF0000u) << (1u * DEF_OCTET_NBR_BITS))) | \
S                                                            ((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x0000FF00u) >> (1u * DEF_OCTET_NBR_BITS))) | \
S                                                            ((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x000000FFu) << (1u * DEF_OCTET_NBR_BITS)))))
X#define  MEM_VAL_BIG_TO_LITTLE_32(val)        ((CPU_INT32U)(((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0xFF000000u) >> (1u * DEF_OCTET_NBR_BITS))) |                                                             ((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x00FF0000u) << (1u * DEF_OCTET_NBR_BITS))) |                                                             ((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x0000FF00u) >> (1u * DEF_OCTET_NBR_BITS))) |                                                             ((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x000000FFu) << (1u * DEF_OCTET_NBR_BITS)))))
S
S#else
S
S#define  MEM_VAL_BIG_TO_LITTLE_16(val)                                                  (val)
S#define  MEM_VAL_BIG_TO_LITTLE_32(val)                                                  (val)
S
N#endif
N
N
N#define  MEM_VAL_LITTLE_TO_BIG_16(val)                          MEM_VAL_BIG_TO_LITTLE_16(val)
N#define  MEM_VAL_LITTLE_TO_BIG_32(val)                          MEM_VAL_BIG_TO_LITTLE_32(val)
N
N
N
N#if     (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG)
X#if     (2u == 1u)
S
S#define  MEM_VAL_BIG_TO_HOST_16(val)                                                    (val)
S#define  MEM_VAL_BIG_TO_HOST_32(val)                                                    (val)
S#define  MEM_VAL_LITTLE_TO_HOST_16(val)                         MEM_VAL_LITTLE_TO_BIG_16(val)
S#define  MEM_VAL_LITTLE_TO_HOST_32(val)                         MEM_VAL_LITTLE_TO_BIG_32(val)
S
N#elif   (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_LITTLE)
X#elif   (2u == 2u)
N
N#define  MEM_VAL_BIG_TO_HOST_16(val)                            MEM_VAL_BIG_TO_LITTLE_16(val)
N#define  MEM_VAL_BIG_TO_HOST_32(val)                            MEM_VAL_BIG_TO_LITTLE_32(val)
N#define  MEM_VAL_LITTLE_TO_HOST_16(val)                                                 (val)
N#define  MEM_VAL_LITTLE_TO_HOST_32(val)                                                 (val)
N
N#else                                                               /* See Note #5.                                     */
S
S#error  "CPU_CFG_ENDIAN_TYPE  illegally #defined in 'cpu.h'      "
S#error  "                     [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N#define  MEM_VAL_HOST_TO_BIG_16(val)                            MEM_VAL_BIG_TO_HOST_16(val)
N#define  MEM_VAL_HOST_TO_BIG_32(val)                            MEM_VAL_BIG_TO_HOST_32(val)
N#define  MEM_VAL_HOST_TO_LITTLE_16(val)                         MEM_VAL_LITTLE_TO_HOST_16(val)
N#define  MEM_VAL_HOST_TO_LITTLE_32(val)                         MEM_VAL_LITTLE_TO_HOST_32(val)
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          MEM_VAL_GET_xxx()
N*
N* Description : Decode data values from any CPU memory address.
N*
N* Argument(s) : addr        Lowest CPU memory address of data value to decode (see Notes #2 & #3a).
N*
N* Return(s)   : Decoded data value from CPU memory address (see Notes #1 & #3b).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) Decode data values based on the values' data-word order in CPU memory :
N*
N*                       MEM_VAL_GET_xxx_BIG()           Decode big-   endian data values -- data words' most
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_GET_xxx_LITTLE()        Decode little-endian data values -- data words' least
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_GET_xxx()               Decode data values using CPU's native or configured
N*                                                           data-word order
N*
N*                   See also 'cpu.h  CPU WORD CONFIGURATION  Note #2'.
N*
N*               (2) CPU memory addresses/pointers NOT checked for NULL.
N*
N*               (3) (a) MEM_VAL_GET_xxx() macro's decode data values without regard to CPU word-aligned addresses.
N*                       Thus for processors that require data word alignment, data words can be decoded from any
N*                       CPU address, word-aligned or not, without generating data-word-alignment exceptions/faults.
N*
N*                   (b) However, any variable to receive the returned data value MUST start on an appropriate CPU
N*                       word-aligned address.
N*
N*                   See also 'MEMORY DATA VALUE MACRO'S  Note #1'.
N*
N*               (4) MEM_VAL_COPY_GET_xxx() macro's are more efficient than MEM_VAL_GET_xxx() macro's & are
N*                   also independent of CPU data-word-alignment & SHOULD be used whenever possible.
N*
N*                   See also 'MEM_VAL_COPY_GET_xxx()  Note #4'.
N*
N*               (5) MEM_VAL_GET_xxx() macro's are NOT atomic operations & MUST NOT be used on any non-static
N*                   (i.e. volatile) variables, registers, hardware, etc.; without the caller of the macro's
N*                   providing some form of additional protection (e.g. mutual exclusion).
N*
N*               (6) The 'CPU_CFG_ENDIAN_TYPE' pre-processor 'else'-conditional code SHOULD never be compiled/
N*                   linked since each 'cpu.h' SHOULD ensure that the CPU data-word-memory order configuration
N*                   constant (CPU_CFG_ENDIAN_TYPE) is configured with an appropriate data-word-memory order
N*                   value (see 'cpu.h  CPU WORD CONFIGURATION  Note #2').  The 'else'-conditional code is
N*                   included as an extra precaution in case 'cpu.h' is incorrectly configured.
N*********************************************************************************************************
N*/
N/*$PAGE*/
N
N#define  MEM_VAL_GET_INT08U_BIG(addr)           ((CPU_INT08U) ((CPU_INT08U)(((CPU_INT08U)(*(((CPU_INT08U *)(addr)) + 0))) << (0u * DEF_OCTET_NBR_BITS))))
N
N#define  MEM_VAL_GET_INT16U_BIG(addr)           ((CPU_INT16U)(((CPU_INT16U)(((CPU_INT16U)(*(((CPU_INT08U *)(addr)) + 0))) << (1u * DEF_OCTET_NBR_BITS))) + \
N                                                              ((CPU_INT16U)(((CPU_INT16U)(*(((CPU_INT08U *)(addr)) + 1))) << (0u * DEF_OCTET_NBR_BITS)))))
X#define  MEM_VAL_GET_INT16U_BIG(addr)           ((CPU_INT16U)(((CPU_INT16U)(((CPU_INT16U)(*(((CPU_INT08U *)(addr)) + 0))) << (1u * DEF_OCTET_NBR_BITS))) +                                                               ((CPU_INT16U)(((CPU_INT16U)(*(((CPU_INT08U *)(addr)) + 1))) << (0u * DEF_OCTET_NBR_BITS)))))
N
N#define  MEM_VAL_GET_INT32U_BIG(addr)           ((CPU_INT32U)(((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 0))) << (3u * DEF_OCTET_NBR_BITS))) + \
N                                                              ((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 1))) << (2u * DEF_OCTET_NBR_BITS))) + \
N                                                              ((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 2))) << (1u * DEF_OCTET_NBR_BITS))) + \
N                                                              ((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 3))) << (0u * DEF_OCTET_NBR_BITS)))))
X#define  MEM_VAL_GET_INT32U_BIG(addr)           ((CPU_INT32U)(((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 0))) << (3u * DEF_OCTET_NBR_BITS))) +                                                               ((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 1))) << (2u * DEF_OCTET_NBR_BITS))) +                                                               ((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 2))) << (1u * DEF_OCTET_NBR_BITS))) +                                                               ((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 3))) << (0u * DEF_OCTET_NBR_BITS)))))
N
N
N
N#define  MEM_VAL_GET_INT08U_LITTLE(addr)        ((CPU_INT08U) ((CPU_INT08U)(((CPU_INT08U)(*(((CPU_INT08U *)(addr)) + 0))) << (0u * DEF_OCTET_NBR_BITS))))
N
N#define  MEM_VAL_GET_INT16U_LITTLE(addr)        ((CPU_INT16U)(((CPU_INT16U)(((CPU_INT16U)(*(((CPU_INT08U *)(addr)) + 0))) << (0u * DEF_OCTET_NBR_BITS))) + \
N                                                              ((CPU_INT16U)(((CPU_INT16U)(*(((CPU_INT08U *)(addr)) + 1))) << (1u * DEF_OCTET_NBR_BITS)))))
X#define  MEM_VAL_GET_INT16U_LITTLE(addr)        ((CPU_INT16U)(((CPU_INT16U)(((CPU_INT16U)(*(((CPU_INT08U *)(addr)) + 0))) << (0u * DEF_OCTET_NBR_BITS))) +                                                               ((CPU_INT16U)(((CPU_INT16U)(*(((CPU_INT08U *)(addr)) + 1))) << (1u * DEF_OCTET_NBR_BITS)))))
N
N#define  MEM_VAL_GET_INT32U_LITTLE(addr)        ((CPU_INT32U)(((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 0))) << (0u * DEF_OCTET_NBR_BITS))) + \
N                                                              ((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 1))) << (1u * DEF_OCTET_NBR_BITS))) + \
N                                                              ((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 2))) << (2u * DEF_OCTET_NBR_BITS))) + \
N                                                              ((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 3))) << (3u * DEF_OCTET_NBR_BITS)))))
X#define  MEM_VAL_GET_INT32U_LITTLE(addr)        ((CPU_INT32U)(((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 0))) << (0u * DEF_OCTET_NBR_BITS))) +                                                               ((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 1))) << (1u * DEF_OCTET_NBR_BITS))) +                                                               ((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 2))) << (2u * DEF_OCTET_NBR_BITS))) +                                                               ((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 3))) << (3u * DEF_OCTET_NBR_BITS)))))
N
N
N
N#if     (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG)
X#if     (2u == 1u)
S
S#define  MEM_VAL_GET_INT08U(addr)                               MEM_VAL_GET_INT08U_BIG(addr)
S#define  MEM_VAL_GET_INT16U(addr)                               MEM_VAL_GET_INT16U_BIG(addr)
S#define  MEM_VAL_GET_INT32U(addr)                               MEM_VAL_GET_INT32U_BIG(addr)
S
N#elif   (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_LITTLE)
X#elif   (2u == 2u)
N
N#define  MEM_VAL_GET_INT08U(addr)                               MEM_VAL_GET_INT08U_LITTLE(addr)
N#define  MEM_VAL_GET_INT16U(addr)                               MEM_VAL_GET_INT16U_LITTLE(addr)
N#define  MEM_VAL_GET_INT32U(addr)                               MEM_VAL_GET_INT32U_LITTLE(addr)
N
N#else                                                               /* See Note #6.                                     */
S
S#error  "CPU_CFG_ENDIAN_TYPE  illegally #defined in 'cpu.h'      "
S#error  "                     [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          MEM_VAL_SET_xxx()
N*
N* Description : Encode data values to any CPU memory address.
N*
N* Argument(s) : addr        Lowest CPU memory address to encode data value (see Notes #2 & #3a).
N*
N*               val         Data value to encode (see Notes #1 & #3b).
N*
N* Return(s)   : none.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) Encode data values into CPU memory based on the values' data-word order :
N*
N*                       MEM_VAL_SET_xxx_BIG()           Encode big-   endian data values -- data words' most
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_SET_xxx_LITTLE()        Encode little-endian data values -- data words' least
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_SET_xxx()               Encode data values using CPU's native or configured
N*                                                           data-word order
N*
N*                   See also 'cpu.h  CPU WORD CONFIGURATION  Note #2'.
N*
N*               (2) CPU memory addresses/pointers NOT checked for NULL.
N*
N*               (3) (a) MEM_VAL_SET_xxx() macro's encode data values without regard to CPU word-aligned addresses.
N*                       Thus for processors that require data word alignment, data words can be encoded to any
N*                       CPU address, word-aligned or not, without generating data-word-alignment exceptions/faults.
N*
N*                   (b) However, 'val' data value to encode MUST start on an appropriate CPU word-aligned address.
N*
N*                   See also 'MEMORY DATA VALUE MACRO'S  Note #1'.
N*
N*               (4) MEM_VAL_COPY_SET_xxx() macro's are more efficient than MEM_VAL_SET_xxx() macro's & are
N*                   also independent of CPU data-word-alignment & SHOULD be used whenever possible.
N*
N*                   See also 'MEM_VAL_COPY_SET_xxx()  Note #4'.
N*
N*               (5) MEM_VAL_SET_xxx() macro's are NOT atomic operations & MUST NOT be used on any non-static
N*                   (i.e. volatile) variables, registers, hardware, etc.; without the caller of the macro's
N*                   providing some form of additional protection (e.g. mutual exclusion).
N*
N*               (6) The 'CPU_CFG_ENDIAN_TYPE' pre-processor 'else'-conditional code SHOULD never be compiled/
N*                   linked since each 'cpu.h' SHOULD ensure that the CPU data-word-memory order configuration
N*                   constant (CPU_CFG_ENDIAN_TYPE) is configured with an appropriate data-word-memory order
N*                   value (see 'cpu.h  CPU WORD CONFIGURATION  Note #2').  The 'else'-conditional code is
N*                   included as an extra precaution in case 'cpu.h' is incorrectly configured.
N*********************************************************************************************************
N*/
N/*$PAGE*/
N
N#define  MEM_VAL_SET_INT08U_BIG(addr, val)                     do { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT08U)(val)) & (CPU_INT08U)      0xFFu) >> (0u * DEF_OCTET_NBR_BITS))); } while (0)
N
N#define  MEM_VAL_SET_INT16U_BIG(addr, val)                     do { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0xFF00u) >> (1u * DEF_OCTET_NBR_BITS))); \
N                                                                    (*(((CPU_INT08U *)(addr)) + 1)) = ((CPU_INT08U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0x00FFu) >> (0u * DEF_OCTET_NBR_BITS))); } while (0)
X#define  MEM_VAL_SET_INT16U_BIG(addr, val)                     do { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0xFF00u) >> (1u * DEF_OCTET_NBR_BITS)));                                                                     (*(((CPU_INT08U *)(addr)) + 1)) = ((CPU_INT08U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0x00FFu) >> (0u * DEF_OCTET_NBR_BITS))); } while (0)
N
N#define  MEM_VAL_SET_INT32U_BIG(addr, val)                     do { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0xFF000000u) >> (3u * DEF_OCTET_NBR_BITS))); \
N                                                                    (*(((CPU_INT08U *)(addr)) + 1)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x00FF0000u) >> (2u * DEF_OCTET_NBR_BITS))); \
N                                                                    (*(((CPU_INT08U *)(addr)) + 2)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x0000FF00u) >> (1u * DEF_OCTET_NBR_BITS))); \
N                                                                    (*(((CPU_INT08U *)(addr)) + 3)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x000000FFu) >> (0u * DEF_OCTET_NBR_BITS))); } while (0)
X#define  MEM_VAL_SET_INT32U_BIG(addr, val)                     do { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0xFF000000u) >> (3u * DEF_OCTET_NBR_BITS)));                                                                     (*(((CPU_INT08U *)(addr)) + 1)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x00FF0000u) >> (2u * DEF_OCTET_NBR_BITS)));                                                                     (*(((CPU_INT08U *)(addr)) + 2)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x0000FF00u) >> (1u * DEF_OCTET_NBR_BITS)));                                                                     (*(((CPU_INT08U *)(addr)) + 3)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x000000FFu) >> (0u * DEF_OCTET_NBR_BITS))); } while (0)
N
N
N
N#define  MEM_VAL_SET_INT08U_LITTLE(addr, val)                  do { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT08U)(val)) & (CPU_INT08U)      0xFFu) >> (0u * DEF_OCTET_NBR_BITS))); } while (0)
N
N#define  MEM_VAL_SET_INT16U_LITTLE(addr, val)                  do { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0x00FFu) >> (0u * DEF_OCTET_NBR_BITS))); \
N                                                                    (*(((CPU_INT08U *)(addr)) + 1)) = ((CPU_INT08U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0xFF00u) >> (1u * DEF_OCTET_NBR_BITS))); } while (0)
X#define  MEM_VAL_SET_INT16U_LITTLE(addr, val)                  do { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0x00FFu) >> (0u * DEF_OCTET_NBR_BITS)));                                                                     (*(((CPU_INT08U *)(addr)) + 1)) = ((CPU_INT08U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0xFF00u) >> (1u * DEF_OCTET_NBR_BITS))); } while (0)
N
N#define  MEM_VAL_SET_INT32U_LITTLE(addr, val)                  do { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x000000FFu) >> (0u * DEF_OCTET_NBR_BITS))); \
N                                                                    (*(((CPU_INT08U *)(addr)) + 1)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x0000FF00u) >> (1u * DEF_OCTET_NBR_BITS))); \
N                                                                    (*(((CPU_INT08U *)(addr)) + 2)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x00FF0000u) >> (2u * DEF_OCTET_NBR_BITS))); \
N                                                                    (*(((CPU_INT08U *)(addr)) + 3)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0xFF000000u) >> (3u * DEF_OCTET_NBR_BITS))); } while (0)
X#define  MEM_VAL_SET_INT32U_LITTLE(addr, val)                  do { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x000000FFu) >> (0u * DEF_OCTET_NBR_BITS)));                                                                     (*(((CPU_INT08U *)(addr)) + 1)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x0000FF00u) >> (1u * DEF_OCTET_NBR_BITS)));                                                                     (*(((CPU_INT08U *)(addr)) + 2)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x00FF0000u) >> (2u * DEF_OCTET_NBR_BITS)));                                                                     (*(((CPU_INT08U *)(addr)) + 3)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0xFF000000u) >> (3u * DEF_OCTET_NBR_BITS))); } while (0)
N
N
N
N#if     (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG)
X#if     (2u == 1u)
S
S#define  MEM_VAL_SET_INT08U(addr, val)                          MEM_VAL_SET_INT08U_BIG(addr, val)
S#define  MEM_VAL_SET_INT16U(addr, val)                          MEM_VAL_SET_INT16U_BIG(addr, val)
S#define  MEM_VAL_SET_INT32U(addr, val)                          MEM_VAL_SET_INT32U_BIG(addr, val)
S
N#elif   (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_LITTLE)
X#elif   (2u == 2u)
N
N#define  MEM_VAL_SET_INT08U(addr, val)                          MEM_VAL_SET_INT08U_LITTLE(addr, val)
N#define  MEM_VAL_SET_INT16U(addr, val)                          MEM_VAL_SET_INT16U_LITTLE(addr, val)
N#define  MEM_VAL_SET_INT32U(addr, val)                          MEM_VAL_SET_INT32U_LITTLE(addr, val)
N
N#else                                                               /* See Note #6.                                     */
S
S#error  "CPU_CFG_ENDIAN_TYPE  illegally #defined in 'cpu.h'      "
S#error  "                     [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                       MEM_VAL_COPY_GET_xxx()
N*
N* Description : Copy & decode data values from any CPU memory address to any CPU memory address.
N*
N* Argument(s) : addr_dest       Lowest CPU memory address to copy/decode source address's data value
N*                                   (see Notes #2 & #3).
N*
N*               addr_src        Lowest CPU memory address of data value to copy/decode
N*                                   (see Notes #2 & #3).
N*
N* Return(s)   : none.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) Copy/decode data values based on the values' data-word order :
N*
N*                       MEM_VAL_COPY_GET_xxx_BIG()      Decode big-   endian data values -- data words' most
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_COPY_GET_xxx_LITTLE()   Decode little-endian data values -- data words' least
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_COPY_GET_xxx()          Decode data values using CPU's native or configured
N*                                                           data-word order
N*
N*                   See also 'cpu.h  CPU WORD CONFIGURATION  Note #2'.
N*
N*               (2) (a) CPU memory addresses/pointers NOT checked for NULL.
N*
N*                   (b) CPU memory addresses/buffers  NOT checked for overlapping.
N*
N*                       (1) IEEE Std 1003.1, 2004 Edition, Section 'memcpy() : DESCRIPTION' states that
N*                           "copying ... between objects that overlap ... is undefined".
N*
N*               (3) MEM_VAL_COPY_GET_xxx() macro's copy/decode data values without regard to CPU word-aligned
N*                   addresses.  Thus for processors that require data word alignment, data words can be copied/
N*                   decoded to/from any CPU address, word-aligned or not, without generating data-word-alignment
N*                   exceptions/faults.
N*
N*               (4) MEM_VAL_COPY_GET_xxx() macro's are more efficient than MEM_VAL_GET_xxx() macro's & are
N*                   also independent of CPU data-word-alignment & SHOULD be used whenever possible.
N*
N*                   See also 'MEM_VAL_GET_xxx()  Note #4'.
N*
N*               (5) Since octet-order copy/conversion are inverse operations, MEM_VAL_COPY_GET_xxx() &
N*                   MEM_VAL_COPY_SET_xxx() macros are inverse, but identical, operations & are provided
N*                   in both forms for semantics & consistency.
N*
N*                   See also 'MEM_VAL_COPY_SET_xxx()  Note #5'.
N*
N*               (6) MEM_VAL_COPY_GET_xxx() macro's are NOT atomic operations & MUST NOT be used on any non-
N*                   static (i.e. volatile) variables, registers, hardware, etc.; without the caller of the
N*                   macro's providing some form of additional protection (e.g. mutual exclusion).
N*
N*               (7) The 'CPU_CFG_ENDIAN_TYPE' pre-processor 'else'-conditional code SHOULD never be compiled/
N*                   linked since each 'cpu.h' SHOULD ensure that the CPU data-word-memory order configuration
N*                   constant (CPU_CFG_ENDIAN_TYPE) is configured with an appropriate data-word-memory order
N*                   value (see 'cpu.h  CPU WORD CONFIGURATION  Note #2').  The 'else'-conditional code is
N*                   included as an extra precaution in case 'cpu.h' is incorrectly configured.
N*********************************************************************************************************
N*/
N/*$PAGE*/
N
N#if     (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG)
X#if     (2u == 1u)
S
S
S#define  MEM_VAL_COPY_GET_INT08U_BIG(addr_dest, addr_src)      do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
S
S#define  MEM_VAL_COPY_GET_INT16U_BIG(addr_dest, addr_src)      do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); \
S                                                                    (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); } while (0)
X#define  MEM_VAL_COPY_GET_INT16U_BIG(addr_dest, addr_src)      do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); } while (0)
S
S#define  MEM_VAL_COPY_GET_INT32U_BIG(addr_dest, addr_src)      do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); \
S                                                                    (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); \
S                                                                    (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 2)); \
S                                                                    (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 3)); } while (0)
X#define  MEM_VAL_COPY_GET_INT32U_BIG(addr_dest, addr_src)      do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 2));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 3)); } while (0)
S
S
S
S#define  MEM_VAL_COPY_GET_INT08U_LITTLE(addr_dest, addr_src)   do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
S
S#define  MEM_VAL_COPY_GET_INT16U_LITTLE(addr_dest, addr_src)   do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 1)); \
S                                                                    (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
X#define  MEM_VAL_COPY_GET_INT16U_LITTLE(addr_dest, addr_src)   do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 1));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
S
S#define  MEM_VAL_COPY_GET_INT32U_LITTLE(addr_dest, addr_src)   do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 3)); \
S                                                                    (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 2)); \
S                                                                    (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 1)); \
S                                                                    (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
X#define  MEM_VAL_COPY_GET_INT32U_LITTLE(addr_dest, addr_src)   do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 3));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 2));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 1));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
S
S
S
S#define  MEM_VAL_COPY_GET_INT08U(addr_dest, addr_src)               MEM_VAL_COPY_GET_INT08U_BIG(addr_dest, addr_src)
S#define  MEM_VAL_COPY_GET_INT16U(addr_dest, addr_src)               MEM_VAL_COPY_GET_INT16U_BIG(addr_dest, addr_src)
S#define  MEM_VAL_COPY_GET_INT32U(addr_dest, addr_src)               MEM_VAL_COPY_GET_INT32U_BIG(addr_dest, addr_src)
S
S
S
S
N#elif   (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_LITTLE)
X#elif   (2u == 2u)
N
N
N#define  MEM_VAL_COPY_GET_INT08U_BIG(addr_dest, addr_src)      do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
N
N#define  MEM_VAL_COPY_GET_INT16U_BIG(addr_dest, addr_src)      do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 1)); \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
X#define  MEM_VAL_COPY_GET_INT16U_BIG(addr_dest, addr_src)      do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 1));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
N
N#define  MEM_VAL_COPY_GET_INT32U_BIG(addr_dest, addr_src)      do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 3)); \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 2)); \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 1)); \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
X#define  MEM_VAL_COPY_GET_INT32U_BIG(addr_dest, addr_src)      do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 3));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 2));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 1));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
N
N
N
N#define  MEM_VAL_COPY_GET_INT08U_LITTLE(addr_dest, addr_src)   do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
N
N#define  MEM_VAL_COPY_GET_INT16U_LITTLE(addr_dest, addr_src)   do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); } while (0)
X#define  MEM_VAL_COPY_GET_INT16U_LITTLE(addr_dest, addr_src)   do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); } while (0)
N
N#define  MEM_VAL_COPY_GET_INT32U_LITTLE(addr_dest, addr_src)   do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 2)); \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 3)); } while (0)
X#define  MEM_VAL_COPY_GET_INT32U_LITTLE(addr_dest, addr_src)   do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 2));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 3)); } while (0)
N
N
N
N#define  MEM_VAL_COPY_GET_INT08U(addr_dest, addr_src)               MEM_VAL_COPY_GET_INT08U_LITTLE(addr_dest, addr_src)
N#define  MEM_VAL_COPY_GET_INT16U(addr_dest, addr_src)               MEM_VAL_COPY_GET_INT16U_LITTLE(addr_dest, addr_src)
N#define  MEM_VAL_COPY_GET_INT32U(addr_dest, addr_src)               MEM_VAL_COPY_GET_INT32U_LITTLE(addr_dest, addr_src)
N
N
N
N
N#else                                                               /* See Note #7.                                     */
S
S#error  "CPU_CFG_ENDIAN_TYPE  illegally #defined in 'cpu.h'      "
S#error  "                     [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                     MEM_VAL_COPY_GET_INTU_xxx()
N*
N* Description : Copy & decode data values from any CPU memory address to any CPU memory address for
N*                   any sized data values.
N*
N* Argument(s) : addr_dest       Lowest CPU memory address to copy/decode source address's data value
N*                                   (see Notes #2 & #3).
N*
N*               addr_src        Lowest CPU memory address of data value to copy/decode
N*                                   (see Notes #2 & #3).
N*
N*               val_size        Number of data value octets to copy/decode.
N*
N* Return(s)   : none.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) Copy/decode data values based on the values' data-word order :
N*
N*                       MEM_VAL_COPY_GET_INTU_BIG()     Decode big-   endian data values -- data words' most
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_COPY_GET_INTU_LITTLE()  Decode little-endian data values -- data words' least
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_COPY_GET_INTU()         Decode data values using CPU's native or configured
N*                                                           data-word order
N*
N*                   See also 'cpu.h  CPU WORD CONFIGURATION  Note #2'.
N*
N*               (2) (a) CPU memory addresses/pointers NOT checked for NULL.
N*
N*                   (b) CPU memory addresses/buffers  NOT checked for overlapping.
N*
N*                       (1) IEEE Std 1003.1, 2004 Edition, Section 'memcpy() : DESCRIPTION' states that
N*                           "copying ... between objects that overlap ... is undefined".
N*
N*               (3) MEM_VAL_COPY_GET_INTU_xxx() macro's copy/decode data values without regard to CPU word-
N*                   aligned addresses.  Thus for processors that require data word alignment, data words
N*                   can be copied/decoded to/from any CPU address, word-aligned or not, without generating
N*                   data-word-alignment exceptions/faults.
N*
N*               (4) MEM_VAL_COPY_GET_xxx() macro's are more efficient than MEM_VAL_COPY_GET_INTU_xxx()
N*                   macro's & SHOULD be used whenever possible.
N*
N*                   See also 'MEM_VAL_COPY_GET_xxx()  Note #4'.
N*
N*               (5) Since octet-order copy/conversion are inverse operations, MEM_VAL_COPY_GET_INTU_xxx() &
N*                   MEM_VAL_COPY_SET_INTU_xxx() macros are inverse, but identical, operations & are provided
N*                   in both forms for semantics & consistency.
N*
N*                   See also 'MEM_VAL_COPY_SET_INTU_xxx()  Note #5'.
N*
N*               (6) MEM_VAL_COPY_GET_INTU_xxx() macro's are NOT atomic operations & MUST NOT be used on any
N*                   non-static (i.e. volatile) variables, registers, hardware, etc.; without the caller of
N*                   the macro's providing some form of additional protection (e.g. mutual exclusion).
N*
N*               (7) MISRA-C 2004 Rule 5.2 states that "identifiers in an inner scope shall not use the same
N*                   name as an indentifier in an outer scope, and therefore hide that identifier".
N*
N*                   Therefore, to avoid possible redeclaration of commonly-used loop counter identifier names,
N*                   'i' & 'j', MEM_VAL_COPY_GET_INTU_xxx() loop counter identifier names are prefixed with a
N*                   single underscore.
N*
N*               (8) The 'CPU_CFG_ENDIAN_TYPE' pre-processor 'else'-conditional code SHOULD never be compiled/
N*                   linked since each 'cpu.h' SHOULD ensure that the CPU data-word-memory order configuration
N*                   constant (CPU_CFG_ENDIAN_TYPE) is configured with an appropriate data-word-memory order
N*                   value (see 'cpu.h  CPU WORD CONFIGURATION  Note #2').  The 'else'-conditional code is
N*                   included as an extra precaution in case 'cpu.h' is incorrectly configured.
N*********************************************************************************************************
N*/
N/*$PAGE*/
N
N#if     (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG)
X#if     (2u == 1u)
S
S
S#define  MEM_VAL_COPY_GET_INTU_BIG(addr_dest, addr_src, val_size)       do {                                                                                  \
S                                                                            CPU_SIZE_T  _i;                                                                   \
S                                                                                                                                                              \
S                                                                            for (_i = 0; _i < (val_size); _i++) {                                             \
S                                                                                (*(((CPU_INT08U *)(addr_dest)) + _i)) = (*(((CPU_INT08U *)(addr_src)) + _i)); \
S                                                                            }                                                                                 \
S                                                                        } while (0)
X#define  MEM_VAL_COPY_GET_INTU_BIG(addr_dest, addr_src, val_size)       do {                                                                                                                                                              CPU_SIZE_T  _i;                                                                                                                                                                                                                                                                                                             for (_i = 0; _i < (val_size); _i++) {                                                                                                                             (*(((CPU_INT08U *)(addr_dest)) + _i)) = (*(((CPU_INT08U *)(addr_src)) + _i));                                                                             }                                                                                                                                                         } while (0)
S
S
S#define  MEM_VAL_COPY_GET_INTU_LITTLE(addr_dest, addr_src, val_size)    do {                                                                                  \
S                                                                            CPU_SIZE_T  _i;                                                                   \
S                                                                            CPU_SIZE_T  _j;                                                                   \
S                                                                                                                                                              \
S                                                                                                                                                              \
S                                                                            _j = (val_size) - 1;                                                              \
S                                                                                                                                                              \
S                                                                            for (_i = 0; _i < (val_size); _i++) {                                             \
S                                                                                (*(((CPU_INT08U *)(addr_dest)) + _i)) = (*(((CPU_INT08U *)(addr_src)) + _j)); \
S                                                                                _j--;                                                                         \
S                                                                            }                                                                                 \
S                                                                        } while (0)
X#define  MEM_VAL_COPY_GET_INTU_LITTLE(addr_dest, addr_src, val_size)    do {                                                                                                                                                              CPU_SIZE_T  _i;                                                                                                                                               CPU_SIZE_T  _j;                                                                                                                                                                                                                                                                                                                                                                                                                                                                           _j = (val_size) - 1;                                                                                                                                                                                                                                                                                                        for (_i = 0; _i < (val_size); _i++) {                                                                                                                             (*(((CPU_INT08U *)(addr_dest)) + _i)) = (*(((CPU_INT08U *)(addr_src)) + _j));                                                                                 _j--;                                                                                                                                                     }                                                                                                                                                         } while (0)
S
S
S#define  MEM_VAL_COPY_GET_INTU(addr_dest, addr_src, val_size)           MEM_VAL_COPY_GET_INTU_BIG(addr_dest, addr_src, val_size)
S
S
S
S
N#elif   (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_LITTLE)
X#elif   (2u == 2u)
N
N
N#define  MEM_VAL_COPY_GET_INTU_BIG(addr_dest, addr_src, val_size)       do {                                                                                  \
N                                                                            CPU_SIZE_T  _i;                                                                   \
N                                                                            CPU_SIZE_T  _j;                                                                   \
N                                                                                                                                                              \
N                                                                                                                                                              \
N                                                                            _j = (val_size) - 1;                                                              \
N                                                                                                                                                              \
N                                                                            for (_i = 0; _i < (val_size); _i++) {                                             \
N                                                                                (*(((CPU_INT08U *)(addr_dest)) + _i)) = (*(((CPU_INT08U *)(addr_src)) + _j)); \
N                                                                                _j--;                                                                         \
N                                                                            }                                                                                 \
N                                                                        } while (0)
X#define  MEM_VAL_COPY_GET_INTU_BIG(addr_dest, addr_src, val_size)       do {                                                                                                                                                              CPU_SIZE_T  _i;                                                                                                                                               CPU_SIZE_T  _j;                                                                                                                                                                                                                                                                                                                                                                                                                                                                           _j = (val_size) - 1;                                                                                                                                                                                                                                                                                                        for (_i = 0; _i < (val_size); _i++) {                                                                                                                             (*(((CPU_INT08U *)(addr_dest)) + _i)) = (*(((CPU_INT08U *)(addr_src)) + _j));                                                                                 _j--;                                                                                                                                                     }                                                                                                                                                         } while (0)
N
N
N#define  MEM_VAL_COPY_GET_INTU_LITTLE(addr_dest, addr_src, val_size)    do {                                                                                  \
N                                                                            CPU_SIZE_T  _i;                                                                   \
N                                                                                                                                                              \
N                                                                            for (_i = 0; _i < (val_size); _i++) {                                             \
N                                                                                (*(((CPU_INT08U *)(addr_dest)) + _i)) = (*(((CPU_INT08U *)(addr_src)) + _i)); \
N                                                                            }                                                                                 \
N                                                                        } while (0)
X#define  MEM_VAL_COPY_GET_INTU_LITTLE(addr_dest, addr_src, val_size)    do {                                                                                                                                                              CPU_SIZE_T  _i;                                                                                                                                                                                                                                                                                                             for (_i = 0; _i < (val_size); _i++) {                                                                                                                             (*(((CPU_INT08U *)(addr_dest)) + _i)) = (*(((CPU_INT08U *)(addr_src)) + _i));                                                                             }                                                                                                                                                         } while (0)
N
N
N#define  MEM_VAL_COPY_GET_INTU(addr_dest, addr_src, val_size)           MEM_VAL_COPY_GET_INTU_LITTLE(addr_dest, addr_src, val_size)
N
N
N
N
N#else                                                                   /* See Note #8.                                 */
S
S#error  "CPU_CFG_ENDIAN_TYPE  illegally #defined in 'cpu.h'      "
S#error  "                     [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                       MEM_VAL_COPY_SET_xxx()
N*
N* Description : Copy & encode data values from any CPU memory address to any CPU memory address.
N*
N* Argument(s) : addr_dest       Lowest CPU memory address to copy/encode source address's data value
N*                                   (see Notes #2 & #3).
N*
N*               addr_src        Lowest CPU memory address of data value to copy/encode
N*                                   (see Notes #2 & #3).
N*
N* Return(s)   : none.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) Copy/encode data values based on the values' data-word order :
N*
N*                       MEM_VAL_COPY_SET_xxx_BIG()      Encode big-   endian data values -- data words' most
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_COPY_SET_xxx_LITTLE()   Encode little-endian data values -- data words' least
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_COPY_SET_xxx()          Encode data values using CPU's native or configured
N*                                                           data-word order
N*
N*                   See also 'cpu.h  CPU WORD CONFIGURATION  Note #2'.
N*
N*               (2) (a) CPU memory addresses/pointers NOT checked for NULL.
N*
N*                   (b) CPU memory addresses/buffers  NOT checked for overlapping.
N*
N*                       (1) IEEE Std 1003.1, 2004 Edition, Section 'memcpy() : DESCRIPTION' states that
N*                           "copying ... between objects that overlap ... is undefined".
N*
N*               (3) MEM_VAL_COPY_SET_xxx() macro's copy/encode data values without regard to CPU word-aligned
N*                   addresses.  Thus for processors that require data word alignment, data words can be copied/
N*                   encoded to/from any CPU address, word-aligned or not, without generating data-word-alignment
N*                   exceptions/faults.
N*
N*               (4) MEM_VAL_COPY_SET_xxx() macro's are more efficient than MEM_VAL_SET_xxx() macro's & are
N*                   also independent of CPU data-word-alignment & SHOULD be used whenever possible.
N*
N*                   See also 'MEM_VAL_SET_xxx()  Note #4'.
N*
N*               (5) Since octet-order copy/conversion are inverse operations, MEM_VAL_COPY_GET_xxx() &
N*                   MEM_VAL_COPY_SET_xxx() macros are inverse, but identical, operations & are provided
N*                   in both forms for semantics & consistency.
N*
N*                   See also 'MEM_VAL_COPY_GET_xxx()  Note #5'.
N*
N*               (6) MEM_VAL_COPY_SET_xxx() macro's are NOT atomic operations & MUST NOT be used on any
N*                   non-static (i.e. volatile) variables, registers, hardware, etc.; without the caller
N*                   of the  macro's providing some form of additional protection (e.g. mutual exclusion).
N*********************************************************************************************************
N*/
N
N                                                                        /* See Note #5.                                 */
N#define  MEM_VAL_COPY_SET_INT08U_BIG(addr_dest, addr_src)               MEM_VAL_COPY_GET_INT08U_BIG(addr_dest, addr_src)
N#define  MEM_VAL_COPY_SET_INT16U_BIG(addr_dest, addr_src)               MEM_VAL_COPY_GET_INT16U_BIG(addr_dest, addr_src)
N#define  MEM_VAL_COPY_SET_INT32U_BIG(addr_dest, addr_src)               MEM_VAL_COPY_GET_INT32U_BIG(addr_dest, addr_src)
N
N#define  MEM_VAL_COPY_SET_INT08U_LITTLE(addr_dest, addr_src)            MEM_VAL_COPY_GET_INT08U_LITTLE(addr_dest, addr_src)
N#define  MEM_VAL_COPY_SET_INT16U_LITTLE(addr_dest, addr_src)            MEM_VAL_COPY_GET_INT16U_LITTLE(addr_dest, addr_src)
N#define  MEM_VAL_COPY_SET_INT32U_LITTLE(addr_dest, addr_src)            MEM_VAL_COPY_GET_INT32U_LITTLE(addr_dest, addr_src)
N
N
N#define  MEM_VAL_COPY_SET_INT08U(addr_dest, addr_src)                   MEM_VAL_COPY_GET_INT08U(addr_dest, addr_src)
N#define  MEM_VAL_COPY_SET_INT16U(addr_dest, addr_src)                   MEM_VAL_COPY_GET_INT16U(addr_dest, addr_src)
N#define  MEM_VAL_COPY_SET_INT32U(addr_dest, addr_src)                   MEM_VAL_COPY_GET_INT32U(addr_dest, addr_src)
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                     MEM_VAL_COPY_SET_INTU_xxx()
N*
N* Description : Copy & encode data values from any CPU memory address to any CPU memory address for
N*                   any sized data values.
N*
N* Argument(s) : addr_dest       Lowest CPU memory address to copy/encode source address's data value
N*                                   (see Notes #2 & #3).
N*
N*               addr_src        Lowest CPU memory address of data value to copy/encode
N*                                   (see Notes #2 & #3).
N*
N*               val_size        Number of data value octets to copy/encode.
N*
N* Return(s)   : none.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) Copy/encode data values based on the values' data-word order :
N*
N*                       MEM_VAL_COPY_SET_INTU_BIG()     Encode big-   endian data values -- data words' most
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_COPY_SET_INTU_LITTLE()  Encode little-endian data values -- data words' least
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_COPY_SET_INTU()         Encode data values using CPU's native or configured
N*                                                           data-word order
N*
N*                   See also 'cpu.h  CPU WORD CONFIGURATION  Note #2'.
N*
N*               (2) (a) CPU memory addresses/pointers NOT checked for NULL.
N*
N*                   (b) CPU memory addresses/buffers  NOT checked for overlapping.
N*
N*                       (1) IEEE Std 1003.1, 2004 Edition, Section 'memcpy() : DESCRIPTION' states that
N*                           "copying ... between objects that overlap ... is undefined".
N*
N*               (3) MEM_VAL_COPY_SET_INTU_xxx() macro's copy/encode data values without regard to CPU word-
N*                   aligned addresses.  Thus for processors that require data word alignment, data words
N*                   can be copied/encoded to/from any CPU address, word-aligned or not, without generating
N*                   data-word-alignment exceptions/faults.
N*
N*               (4) MEM_VAL_COPY_SET_xxx() macro's are more efficient than MEM_VAL_COPY_SET_INTU_xxx()
N*                   macro's & SHOULD be used whenever possible.
N*
N*                   See also 'MEM_VAL_COPY_SET_xxx()  Note #4'.
N*
N*               (5) Since octet-order copy/conversion are inverse operations, MEM_VAL_COPY_GET_INTU_xxx() &
N*                   MEM_VAL_COPY_SET_INTU_xxx() macros are inverse, but identical, operations & are provided
N*                   in both forms for semantics & consistency.
N*
N*                   See also 'MEM_VAL_COPY_GET_INTU_xxx()  Note #5'.
N*
N*               (6) MEM_VAL_COPY_SET_INTU_xxx() macro's are NOT atomic operations & MUST NOT be used on any
N*                   non-static (i.e. volatile) variables, registers, hardware, etc.; without the caller of
N*                   the macro's providing some form of additional protection (e.g. mutual exclusion).
N*********************************************************************************************************
N*/
N
N                                                                        /* See Note #5.                                 */
N#define  MEM_VAL_COPY_SET_INTU_BIG(addr_dest, addr_src, val_size)       MEM_VAL_COPY_GET_INTU_BIG(addr_dest, addr_src, val_size)
N#define  MEM_VAL_COPY_SET_INTU_LITTLE(addr_dest, addr_src, val_size)    MEM_VAL_COPY_GET_INTU_LITTLE(addr_dest, addr_src, val_size)
N#define  MEM_VAL_COPY_SET_INTU(addr_dest, addr_src, val_size)           MEM_VAL_COPY_GET_INTU(addr_dest, addr_src, val_size)
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         MEM_VAL_COPY_xxx()
N*
N* Description : Copy data values from any CPU memory address to any CPU memory address.
N*
N* Argument(s) : addr_dest       Lowest CPU memory address to copy source address's data value
N*                                   (see Notes #2 & #3).
N*
N*               addr_src        Lowest CPU memory address of data value to copy
N*                                   (see Notes #2 & #3).
N*
N*               val_size        Number of data value octets to copy.
N*
N* Return(s)   : none.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) MEM_VAL_COPY_xxx() macro's copy data values based on CPU's native data-word order.
N*
N*                   See also 'cpu.h  CPU WORD CONFIGURATION  Note #2'.
N*
N*               (2) (a) CPU memory addresses/pointers NOT checked for NULL.
N*
N*                   (b) CPU memory addresses/buffers  NOT checked for overlapping.
N*
N*                       (1) IEEE Std 1003.1, 2004 Edition, Section 'memcpy() : DESCRIPTION' states that
N*                           "copying ... between objects that overlap ... is undefined".
N*
N*               (3) MEM_VAL_COPY_xxx() macro's copy data values without regard to CPU word-aligned addresses.
N*                   Thus for processors that require data word alignment, data words can be copied to/from any
N*                   CPU address, word-aligned or not, without generating data-word-alignment exceptions/faults.
N*
N*               (4) MEM_VAL_COPY_xxx() macro's are more efficient than MEM_VAL_COPY() macro & SHOULD be
N*                   used whenever possible.
N*
N*               (5) MEM_VAL_COPY_xxx() macro's are NOT atomic operations & MUST NOT be used on any non-static
N*                   (i.e. volatile) variables, registers, hardware, etc.; without the caller of the macro's
N*                   providing some form of additional protection (e.g. mutual exclusion).
N*
N*               (6) MISRA-C 2004 Rule 5.2 states that "identifiers in an inner scope shall not use the same
N*                   name as an indentifier in an outer scope, and therefore hide that identifier".
N*
N*                   Therefore, to avoid possible redeclaration of commonly-used loop counter identifier name,
N*                   'i', MEM_VAL_COPY() loop counter identifier name is prefixed with a single underscore.
N*********************************************************************************************************
N*/
N
N#define  MEM_VAL_COPY_08(addr_dest, addr_src)                  do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
N
N#define  MEM_VAL_COPY_16(addr_dest, addr_src)                  do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); } while (0)
X#define  MEM_VAL_COPY_16(addr_dest, addr_src)                  do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); } while (0)
N
N#define  MEM_VAL_COPY_32(addr_dest, addr_src)                  do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 2)); \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 3)); } while (0)
X#define  MEM_VAL_COPY_32(addr_dest, addr_src)                  do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 2));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 3)); } while (0)
N
N
N#define  MEM_VAL_COPY(addr_dest, addr_src, val_size)        do {                                                                                \
N                                                                CPU_SIZE_T  _i;                                                                 \
N                                                                                                                                                \
N                                                                for (_i = 0; _i < (val_size); _i++) {                                           \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) +_i)) = (*(((CPU_INT08U *)(addr_src)) +_i)); \
N                                                                }                                                                               \
N                                                            } while (0)
X#define  MEM_VAL_COPY(addr_dest, addr_src, val_size)        do {                                                                                                                                                CPU_SIZE_T  _i;                                                                                                                                                                                                                                                                                 for (_i = 0; _i < (val_size); _i++) {                                                                                                               (*(((CPU_INT08U *)(addr_dest)) +_i)) = (*(((CPU_INT08U *)(addr_src)) +_i));                                                                 }                                                                                                                                           } while (0)
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
Nvoid               Mem_Init              (       void);
N
N                                                                    /* ---------------- MEM API  FNCTS ---------------- */
Nvoid               Mem_Clr               (       void              *pmem,
N                                                 CPU_SIZE_T         size);
N
Nvoid               Mem_Set               (       void              *pmem,
N                                                 CPU_INT08U         data_val,
N                                                 CPU_SIZE_T         size);
N
Nvoid               Mem_Copy              (       void              *pdest,
N                                          const  void              *psrc,
N                                                 CPU_SIZE_T         size);
N
Nvoid               Mem_Move              (       void              *pdest,
N                                          const  void              *psrc,
N                                                 CPU_SIZE_T         size);
N
NCPU_BOOLEAN        Mem_Cmp               (const  void              *p1_mem,
N                                          const  void              *p2_mem,
N                                                 CPU_SIZE_T         size);
N
N
N
N#if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)                           /* ---------------- MEM POOL FNCTS ---------------- */
X#if (0u == 1u)                            
S
Svoid              *Mem_HeapAlloc         (       CPU_SIZE_T         size,
S                                                 CPU_SIZE_T         align,
S                                                 CPU_SIZE_T        *poctets_reqd,
S                                                 LIB_ERR           *perr);
S
SCPU_SIZE_T         Mem_HeapGetSizeRem    (       CPU_SIZE_T         align,
S                                                 LIB_ERR           *perr);
S
S
SCPU_SIZE_T         Mem_SegGetSizeRem     (       MEM_POOL          *pmem_pool,
S                                                 CPU_SIZE_T         align,
S                                                 LIB_ERR           *perr);
S
S
Svoid               Mem_PoolClr           (       MEM_POOL          *pmem_pool,
S                                                 LIB_ERR           *perr);
S
Svoid               Mem_PoolCreate        (       MEM_POOL          *pmem_pool,
S                                                 void              *pmem_base_addr,
S                                                 CPU_SIZE_T         mem_size,
S                                                 MEM_POOL_BLK_QTY   blk_nbr,
S                                                 CPU_SIZE_T         blk_size,
S                                                 CPU_SIZE_T         blk_align,
S                                                 CPU_SIZE_T        *poctets_reqd,
S                                                 LIB_ERR           *perr);
S
S
SMEM_POOL_BLK_QTY   Mem_PoolBlkGetNbrAvail(       MEM_POOL          *pmem_pool,
S                                                 LIB_ERR           *perr);
S
Svoid              *Mem_PoolBlkGet        (       MEM_POOL          *pmem_pool,
S                                                 CPU_SIZE_T         size,
S                                                 LIB_ERR           *perr);
S
Svoid              *Mem_PoolBlkGetUsedAtIx(       MEM_POOL          *pmem_pool,
S                                                 MEM_POOL_IX        used_ix,
S                                                 LIB_ERR           *perr);
S
Svoid               Mem_PoolBlkFree       (       MEM_POOL          *pmem_pool,
S                                                 void              *pmem_blk,
S                                                 LIB_ERR           *perr);
S
SMEM_POOL_IX        Mem_PoolBlkIxGet      (       MEM_POOL          *pmem_pool,
S                                                 void              *pmem_blk,
S                                                 LIB_ERR           *perr);
S
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_MEM_CFG_ARG_CHK_EXT_EN
S#error  "LIB_MEM_CFG_ARG_CHK_EXT_EN         not #define'd in 'lib_cfg.h'"
S#error  "                             [MUST be  DEF_DISABLED]           "
S#error  "                             [     ||  DEF_ENABLED ]           "
S
S#elif  ((LIB_MEM_CFG_ARG_CHK_EXT_EN != DEF_DISABLED) && \
S        (LIB_MEM_CFG_ARG_CHK_EXT_EN != DEF_ENABLED ))
X#elif  ((1u != 0u) &&         (1u != 1u ))
S#error  "LIB_MEM_CFG_ARG_CHK_EXT_EN   illegally #define'd in 'lib_cfg.h'"
S#error  "                             [MUST be  DEF_DISABLED]           "
S#error  "                             [     ||  DEF_ENABLED ]           "
N#endif
N
N
N
N#ifndef  LIB_MEM_CFG_OPTIMIZE_ASM_EN
S#error  "LIB_MEM_CFG_OPTIMIZE_ASM_EN        not #define'd in 'lib_cfg.h'"
S#error  "                             [MUST be  DEF_DISABLED]           "
S#error  "                             [     ||  DEF_ENABLED ]           "
S
S#elif  ((LIB_MEM_CFG_OPTIMIZE_ASM_EN != DEF_DISABLED) && \
S        (LIB_MEM_CFG_OPTIMIZE_ASM_EN != DEF_ENABLED ))
X#elif  ((1u != 0u) &&         (1u != 1u ))
S#error  "LIB_MEM_CFG_OPTIMIZE_ASM_EN  illegally #define'd in 'lib_cfg.h'"
S#error  "                             [MUST be  DEF_DISABLED]           "
S#error  "                             [     ||  DEF_ENABLED ]           "
N#endif
N
N
N
N
N#ifndef  LIB_MEM_CFG_ALLOC_EN
S#error  "LIB_MEM_CFG_ALLOC_EN               not #define'd in 'lib_cfg.h'"
S#error  "                             [MUST be  DEF_DISABLED]           "
S#error  "                             [     ||  DEF_ENABLED ]           "
S
S#elif  ((LIB_MEM_CFG_ALLOC_EN != DEF_DISABLED) && \
S        (LIB_MEM_CFG_ALLOC_EN != DEF_ENABLED ))
X#elif  ((0u != 0u) &&         (0u != 1u ))
S#error  "LIB_MEM_CFG_ALLOC_EN         illegally #define'd in 'lib_cfg.h'"
S#error  "                             [MUST be  DEF_DISABLED]           "
S#error  "                             [     ||  DEF_ENABLED ]           "
S
S
S#elif   (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
X#elif   (0u == 1u)
S
S
S#ifndef  LIB_MEM_CFG_HEAP_SIZE
S#error  "LIB_MEM_CFG_HEAP_SIZE              not #define'd in 'lib_cfg.h'"
S#error  "                             [MUST be  > 0]                    "
S
S#elif   (DEF_CHK_VAL_MIN(LIB_MEM_CFG_HEAP_SIZE, 1) != DEF_OK)
S#error  "LIB_MEM_CFG_HEAP_SIZE        illegally #define'd in 'lib_cfg.h'"
S#error  "                             [MUST be  > 0]                    "
S#endif
S
S
S#ifdef   LIB_MEM_CFG_HEAP_BASE_ADDR
S#if     (LIB_MEM_CFG_HEAP_BASE_ADDR == 0x0)
S#error  "LIB_MEM_CFG_HEAP_BASE_ADDR   illegally #define'd in 'lib_cfg.h'"
S#error  "                             [MUST be  > 0x0]                  "
S#endif
S#endif
S
S
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                    LIBRARY CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N                                                                /* See 'lib_mem.h  Note #2a'.                           */
N#if     (CPU_CORE_VERSION < 127u)
X#if     (12901u < 127u)
S#error  "CPU_CORE_VERSION  [SHOULD be >= V1.27]"
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*
N* Note(s) : (1) See 'lib_mem.h  MODULE'.
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of lib mem module include.                       */
N
L 110 "..\..\uC-CPU\cpu_core.h" 2
N#include  <lib_str.h>
L 1 "..\..\uC-LIB\lib_str.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/LIB
N*                                        CUSTOM LIBRARY MODULES
N*
N*                          (c) Copyright 2004-2012; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/LIB is provided in source form to registered licensees ONLY.  It is 
N*               illegal to distribute this source code to any third party unless you receive 
N*               written permission by an authorized Micrium representative.  Knowledge of 
N*               the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest 
N*               software available.  Your honesty is greatly appreciated.
N*
N*               You can contact us at www.micrium.com.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                       ASCII STRING MANAGEMENT
N*
N* Filename      : lib_str.h
N* Version       : V1.37.01
N* Programmer(s) : ITJ
N*                 JDH
N*********************************************************************************************************
N* Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
N*
N*                     (a) ALL standard library functions are implemented in the custom library modules :
N*
N*                         (1) \<Custom Library Directory>\lib_*.*
N*
N*                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
N*
N*                               where
N*                                       <Custom Library Directory>      directory path for custom library software
N*                                       <cpu>                           directory name for specific processor (CPU)
N*                                       <compiler>                      directory name for specific compiler
N*
N*                     (b) Product-specific library functions are implemented in individual products.
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*
N* Note(s) : (1) This string library header file is protected from multiple pre-processor inclusion through 
N*               use of the string library module present pre-processor macro definition.
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_STR_MODULE_PRESENT                                 /* See Note #1.                                         */
N#define  LIB_STR_MODULE_PRESENT
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                 ASCII STRING CONFIGURATION DEFINES
N*
N* Note(s) : (1) Some ASCII string configuration #define's MUST be available PRIOR to including any 
N*               application configuration (see 'INCLUDE FILES  Note #1a').
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                    STRING FLOATING POINT DEFINES
N*
N* Note(s) : (1) (a) (1) The maximum accuracy for 32-bit floating-point numbers :
N*
N*
N*                             Maximum Accuracy            log [Internal-Base ^ (Number-Internal-Base-Digits)]
N*                       32-bit Floating-point Number  =  -----------------------------------------------------
N*                                                                         log [External-Base]
N*
N*                                                         log [2 ^ 24]
N*                                                     =  --------------
N*                                                           log [10]
N*
N*                                                     <  7.225  Base-10 Digits
N*
N*                           where
N*                                   Internal-Base                   Internal number base of floating-
N*                                                                       point numbers (i.e.  2)
N*                                   External-Base                   External number base of floating-
N*                                                                       point numbers (i.e. 10)
N*                                   Number-Internal-Base-Digits     Number of internal number base
N*                                                                       significant digits (i.e. 24)
N*
N*                   (2) Also, since some 32-bit floating-point calculations are converted to 32-bit 
N*                       unsigned numbers, the maximum accuracy is limited to the maximum accuracy
N*                       for 32-bit unsigned numbers of 9 digits.
N*
N*               (b) Some CPUs' &/or compilers' floating-point implementations MAY further reduce the 
N*                   maximum accuracy.
N*********************************************************************************************************
N*/
N
N#define  LIB_STR_FP_MAX_NBR_DIG_SIG_MIN                    1u
N#define  LIB_STR_FP_MAX_NBR_DIG_SIG_MAX                    9u   /* See Note #1a2.                                       */
N#define  LIB_STR_FP_MAX_NBR_DIG_SIG_DFLT                   7u   /* See Note #1a1.                                       */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            INCLUDE FILES
N*
N* Note(s) : (1) The custom library software files are located in the following directories :
N*
N*               (a) \<Your Product Application>\lib_cfg.h
N*
N*               (b) \<Custom Library Directory>\lib_*.*
N*
N*                       where
N*                               <Your Product Application>      directory path for Your Product's Application
N*                               <Custom Library Directory>      directory path for custom library software
N*
N*           (2) CPU-configuration  software files are located in the following directories :
N*
N*               (a) \<CPU-Compiler Directory>\cpu_*.*
N*               (b) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
N*
N*                       where
N*                               <CPU-Compiler Directory>        directory path for common CPU-compiler software
N*                               <cpu>                           directory name for specific processor (CPU)
N*                               <compiler>                      directory name for specific compiler
N*
N*           (3) Compiler MUST be configured to include as additional include path directories :
N*
N*               (a) '\<Your Product Application>\' directory                            See Note #1a
N*
N*               (b) '\<Custom Library Directory>\' directory                            See Note #1b
N*
N*               (c) (1) '\<CPU-Compiler Directory>\'                  directory         See Note #2a
N*                   (2) '\<CPU-Compiler Directory>\<cpu>\<compiler>\' directory         See Note #2b
N*
N*           (4) NO compiler-supplied standard library functions SHOULD be used.
N*
N*               #### The reference to standard library header files SHOULD be removed once all custom
N*               library functions are implemented WITHOUT reference to ANY standard library function(s).
N*
N*               See also 'STANDARD LIBRARY MACRO'S  Note #1'.
N*********************************************************************************************************
N*/
N
N#include  <cpu.h>
N
N#include  <lib_def.h>
N#include  <lib_ascii.h>
L 1 "..\..\uC-LIB\lib_ascii.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/LIB
N*                                        CUSTOM LIBRARY MODULES
N*
N*                          (c) Copyright 2004-2012; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/LIB is provided in source form to registered licensees ONLY.  It is 
N*               illegal to distribute this source code to any third party unless you receive 
N*               written permission by an authorized Micrium representative.  Knowledge of 
N*               the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest 
N*               software available.  Your honesty is greatly appreciated.
N*
N*               You can contact us at www.micrium.com.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                     ASCII CHARACTER OPERATIONS
N*
N* Filename      : lib_ascii.h
N* Version       : V1.37.01
N* Programmer(s) : BAN
N*********************************************************************************************************
N* Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
N*
N*                     (a) ALL standard library functions are implemented in the custom library modules :
N*
N*                         (1) \<Custom Library Directory>\lib_*.*
N*
N*                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
N*
N*                               where
N*                                       <Custom Library Directory>      directory path for custom library software
N*                                       <cpu>                           directory name for specific processor (CPU)
N*                                       <compiler>                      directory name for specific compiler
N*
N*                     (b) Product-specific library functions are implemented in individual products.
N*
N*
N*                 (2) (a) ECMA-6 '7-Bit coded Character Set' (6th edition), which corresponds to the
N*                         3rd edition of ISO 646, specifies several versions of a 7-bit character set :
N*
N*                         (1) THE GENERAL VERSION, which allows characters at 0x23 and 0x24 to be given a
N*                             set alternate form and allows the characters 0x40, 0x5B, 0x5D, 0x60, 0x7B &
N*                             0x7D to be assigned a "unique graphic character" or to be declared as unused.
N*                             All other characters are explicitly specified.
N*
N*                         (2) THE INTERNATIONAL REFERENCE VERSION, which explicitly specifies all characters
N*                             in the 7-bit character set.
N*
N*                         (3) NATIONAL & APPLICATION-ORIENTED VERSIONS, which may be derived from the
N*                             standard in specified ways.
N*
N*                     (b) The character set represented in this file reproduces the Internation Reference
N*                         Version.  This is identical to the 7-bit character set which occupies Unicode
N*                         characters 0x0000 through 0x007F.  The character names are taken from v5.0 of the
N*                         Unicode specification, with certain abbreviations so that the resulting #define
N*                         names will not violate ANSI C naming restriction :
N*
N*                         (1) For the Latin capital & lowercase letters, the name components 'LETTER_CAPITAL'
N*                             & 'LETTER_SMALL' are replaced by 'UPPER' & 'LOWER', respectively.
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*
N* Note(s) : (1) This ASCII library header file is protected from multiple pre-processor inclusion through 
N*               use of the ASCII library module present pre-processor macro definition.
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_ASCII_MODULE_PRESENT                               /* See Note #1.                                         */
N#define  LIB_ASCII_MODULE_PRESENT
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            INCLUDE FILES
N*
N* Note(s) : (1) The custom library software files are located in the following directories :
N*
N*               (a) \<Custom Library Directory>\lib_*.*
N*
N*                       where
N*                               <Custom Library Directory>      directory path for custom library software
N*
N*           (2) CPU-configuration  software files are located in the following directories :
N*
N*               (a) \<CPU-Compiler Directory>\cpu_*.*
N*               (b) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
N*
N*                       where
N*                               <CPU-Compiler Directory>        directory path for common CPU-compiler software
N*                               <cpu>                           directory name for specific processor (CPU)
N*                               <compiler>                      directory name for specific compiler
N*
N*           (3) Compiler MUST be configured to include as additional include path directories :
N*
N*               (a) '\<Custom Library Directory>\' directory                            See Note #1a
N*
N*               (b) (1) '\<CPU-Compiler Directory>\'                  directory         See Note #2a
N*                   (2) '\<CPU-Compiler Directory>\<cpu>\<compiler>\' directory         See Note #2b
N*
N*           (4) NO compiler-supplied standard library functions SHOULD be used.
N*********************************************************************************************************
N*/
N
N#include  <cpu.h>
N#include  <lib_def.h>
N
N
N/*
N*********************************************************************************************************
N*                                               EXTERNS
N*********************************************************************************************************
N*/
N
N#ifdef   LIB_ASCII_MODULE
S#define  LIB_ASCII_EXT
N#else
N#define  LIB_ASCII_EXT  extern
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                               DEFINES
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                         ASCII CHARACTER DEFINES
N*********************************************************************************************************
N*/
N
N                                                                /* -------------------- C0 CONTROLS ------------------- */
N#define  ASCII_CHAR_NULL                                0x00    /* '\0'                                                 */
N#define  ASCII_CHAR_START_OF_HEADING                    0x01
N#define  ASCII_CHAR_START_OF_TEXT                       0x02
N#define  ASCII_CHAR_END_OF_TEXT                         0x03
N#define  ASCII_CHAR_END_OF_TRANSMISSION                 0x04
N#define  ASCII_CHAR_ENQUIRY                             0x05
N#define  ASCII_CHAR_ACKNOWLEDGE                         0x06
N#define  ASCII_CHAR_BELL                                0x07    /* '\a'                                                 */
N#define  ASCII_CHAR_BACKSPACE                           0x08    /* '\b'                                                 */
N#define  ASCII_CHAR_CHARACTER_TABULATION                0x09    /* '\t'                                                 */
N#define  ASCII_CHAR_LINE_FEED                           0x0A    /* '\n'                                                 */
N#define  ASCII_CHAR_LINE_TABULATION                     0x0B    /* '\v'                                                 */
N#define  ASCII_CHAR_FORM_FEED                           0x0C    /* '\f'                                                 */
N#define  ASCII_CHAR_CARRIAGE_RETURN                     0x0D    /* '\r'                                                 */
N#define  ASCII_CHAR_SHIFT_OUT                           0x0E
N#define  ASCII_CHAR_SHIFT_IN                            0x0F
N#define  ASCII_CHAR_DATA_LINK_ESCAPE                    0x10
N#define  ASCII_CHAR_DEVICE_CONTROL_ONE                  0x11
N#define  ASCII_CHAR_DEVICE_CONTROL_TWO                  0x12
N#define  ASCII_CHAR_DEVICE_CONTROL_THREE                0x13
N#define  ASCII_CHAR_DEVICE_CONTROL_FOUR                 0x14
N#define  ASCII_CHAR_NEGATIVE_ACKNOWLEDGE                0x15
N#define  ASCII_CHAR_SYNCHRONOUS_IDLE                    0x16
N#define  ASCII_CHAR_END_OF_TRANSMISSION_BLOCK           0x17
N#define  ASCII_CHAR_CANCEL                              0x18
N#define  ASCII_CHAR_END_OF_MEDIUM                       0x19
N#define  ASCII_CHAR_SUBSITUTE                           0x1A
N#define  ASCII_CHAR_ESCAPE                              0x1B
N#define  ASCII_CHAR_INFO_SEPARATOR_FOUR                 0x1C
N#define  ASCII_CHAR_INFO_SEPARATOR_THREE                0x1D
N#define  ASCII_CHAR_INFO_SEPARATOR_TWO                  0x1E
N#define  ASCII_CHAR_INFO_SEPARATOR_ONE                  0x1F
N
N#define  ASCII_CHAR_NUL                                 ASCII_CHAR_NULL
N#define  ASCII_CHAR_SOH                                 ASCII_CHAR_START_OF_HEADING
N#define  ASCII_CHAR_START_HEADING                       ASCII_CHAR_START_OF_HEADING
N#define  ASCII_CHAR_STX                                 ASCII_CHAR_START_OF_TEXT
N#define  ASCII_CHAR_START_TEXT                          ASCII_CHAR_START_OF_TEXT
N#define  ASCII_CHAR_ETX                                 ASCII_CHAR_END_OF_TEXT
N#define  ASCII_CHAR_END_TEXT                            ASCII_CHAR_END_OF_TEXT
N#define  ASCII_CHAR_EOT                                 ASCII_CHAR_END_OF_TRANSMISSION
N#define  ASCII_CHAR_END_TRANSMISSION                    ASCII_CHAR_END_OF_TRANSMISSION
N#define  ASCII_CHAR_ENQ                                 ASCII_CHAR_ENQUIRY
N#define  ASCII_CHAR_ACK                                 ASCII_CHAR_ACKNOWLEDGE
N#define  ASCII_CHAR_BEL                                 ASCII_CHAR_BELL
N#define  ASCII_CHAR_BS                                  ASCII_CHAR_BACKSPACE
N#define  ASCII_CHAR_HT                                  ASCII_CHAR_CHARACTER_TABULATION
N#define  ASCII_CHAR_TAB                                 ASCII_CHAR_CHARACTER_TABULATION
N#define  ASCII_CHAR_LF                                  ASCII_CHAR_LINE_FEED
N#define  ASCII_CHAR_VT                                  ASCII_CHAR_LINE_TABULATION
N#define  ASCII_CHAR_FF                                  ASCII_CHAR_FORM_FEED
N#define  ASCII_CHAR_CR                                  ASCII_CHAR_CARRIAGE_RETURN
N#define  ASCII_CHAR_SO                                  ASCII_CHAR_SHIFT_OUT
N#define  ASCII_CHAR_SI                                  ASCII_CHAR_SHIFT_IN
N#define  ASCII_CHAR_DLE                                 ASCII_CHAR_DATA_LINK_ESCAPE
N#define  ASCII_CHAR_DC1                                 ASCII_CHAR_DEVICE_CONTROL_ONE
N#define  ASCII_CHAR_DC2                                 ASCII_CHAR_DEVICE_CONTROL_TWO
N#define  ASCII_CHAR_DC3                                 ASCII_CHAR_DEVICE_CONTROL_THREE
N#define  ASCII_CHAR_DC4                                 ASCII_CHAR_DEVICE_CONTROL_FOUR
N#define  ASCII_CHAR_DEV_CTRL_ONE                        ASCII_CHAR_DEVICE_CONTROL_ONE
N#define  ASCII_CHAR_DEV_CTRL_TWO                        ASCII_CHAR_DEVICE_CONTROL_TWO
N#define  ASCII_CHAR_DEV_CTRL_THREE                      ASCII_CHAR_DEVICE_CONTROL_THREE
N#define  ASCII_CHAR_DEV_CTRL_FOUR                       ASCII_CHAR_DEVICE_CONTROL_FOUR
N#define  ASCII_CHAR_NAK                                 ASCII_CHAR_NEGATIVE_ACKNOWLEDGE
N#define  ASCII_CHAR_NEG_ACK                             ASCII_CHAR_NEGATIVE_ACKNOWLEDGE
N#define  ASCII_CHAR_SYN                                 ASCII_CHAR_SYNCHRONOUS_IDLE
N#define  ASCII_CHAR_SYNC_IDLE                           ASCII_CHAR_SYNCHRONOUS_IDLE
N#define  ASCII_CHAR_ETB                                 ASCII_CHAR_END_OF_TRANSMISSION_BLOCK
N#define  ASCII_CHAR_END_TRANSMISSION_BLK                ASCII_CHAR_END_OF_TRANSMISSION_BLOCK
N#define  ASCII_CHAR_CAN                                 ASCII_CHAR_CANCEL
N#define  ASCII_CHAR_EM                                  ASCII_CHAR_END_OF_MEDIUM
N#define  ASCII_CHAR_END_MEDIUM                          ASCII_CHAR_END_OF_MEDIUM
N#define  ASCII_CHAR_SUB                                 ASCII_CHAR_SUBSITUTE
N#define  ASCII_CHAR_ESC                                 ASCII_CHAR_ESCAPE
N#define  ASCII_CHAR_IS1                                 ASCII_CHAR_INFO_SEPARATOR_ONE
N#define  ASCII_CHAR_IS2                                 ASCII_CHAR_INFO_SEPARATOR_TWO
N#define  ASCII_CHAR_IS3                                 ASCII_CHAR_INFO_SEPARATOR_THREE
N#define  ASCII_CHAR_IS4                                 ASCII_CHAR_INFO_SEPARATOR_FOUR
N
N
N/*$PAGE*/
N                                                                /* ------------ ASCII PUNCTUATION & SYMBOLS ----------- */
N#define  ASCII_CHAR_SPACE                               0x20    /* ' '                                                  */
N#define  ASCII_CHAR_EXCLAMATION_MARK                    0x21    /* '!'                                                  */
N#define  ASCII_CHAR_QUOTATION_MARK                      0x22    /* '\"'                                                 */
N#define  ASCII_CHAR_NUMBER_SIGN                         0x23    /* '#'                                                  */
N#define  ASCII_CHAR_DOLLAR_SIGN                         0x24    /* '$'                                                  */
N#define  ASCII_CHAR_PERCENTAGE_SIGN                     0x25    /* '%'                                                  */
N#define  ASCII_CHAR_AMPERSAND                           0x26    /* '&'                                                  */
N#define  ASCII_CHAR_APOSTROPHE                          0x27    /* '\''                                                 */
N#define  ASCII_CHAR_LEFT_PARENTHESIS                    0x28    /* '('                                                  */
N#define  ASCII_CHAR_RIGHT_PARENTHESIS                   0x29    /* ')'                                                  */
N#define  ASCII_CHAR_ASTERISK                            0x2A    /* '*'                                                  */
N#define  ASCII_CHAR_PLUS_SIGN                           0x2B    /* '+'                                                  */
N#define  ASCII_CHAR_COMMA                               0x2C    /* ','                                                  */
N#define  ASCII_CHAR_HYPHEN_MINUS                        0x2D    /* '-'                                                  */
N#define  ASCII_CHAR_FULL_STOP                           0x2E    /* '.'                                                  */
N#define  ASCII_CHAR_SOLIDUS                             0x2F    /* '/'                                                  */
N
N#define  ASCII_CHAR_PAREN_LEFT                          ASCII_CHAR_LEFT_PARENTHESIS
N#define  ASCII_CHAR_PAREN_RIGHT                         ASCII_CHAR_RIGHT_PARENTHESIS
N
N
N                                                                /* ------------------- ASCII DIGITS ------------------- */
N#define  ASCII_CHAR_DIGIT_ZERO                          0x30    /* '0'                                                  */
N#define  ASCII_CHAR_DIGIT_ONE                           0x31    /* '1'                                                  */
N#define  ASCII_CHAR_DIGIT_TWO                           0x32    /* '2'                                                  */
N#define  ASCII_CHAR_DIGIT_THREE                         0x33    /* '3'                                                  */
N#define  ASCII_CHAR_DIGIT_FOUR                          0x34    /* '4'                                                  */
N#define  ASCII_CHAR_DIGIT_FIVE                          0x35    /* '5'                                                  */
N#define  ASCII_CHAR_DIGIT_SIX                           0x36    /* '6'                                                  */
N#define  ASCII_CHAR_DIGIT_SEVEN                         0x37    /* '7'                                                  */
N#define  ASCII_CHAR_DIGIT_EIGHT                         0x38    /* '8'                                                  */
N#define  ASCII_CHAR_DIGIT_NINE                          0x39    /* '9'                                                  */
N
N#define  ASCII_CHAR_DIG_ZERO                            ASCII_CHAR_DIGIT_ZERO
N#define  ASCII_CHAR_DIG_ONE                             ASCII_CHAR_DIGIT_ONE
N#define  ASCII_CHAR_DIG_TWO                             ASCII_CHAR_DIGIT_TWO
N#define  ASCII_CHAR_DIG_THREE                           ASCII_CHAR_DIGIT_THREE
N#define  ASCII_CHAR_DIG_FOUR                            ASCII_CHAR_DIGIT_FOUR
N#define  ASCII_CHAR_DIG_FIVE                            ASCII_CHAR_DIGIT_FIVE
N#define  ASCII_CHAR_DIG_SIX                             ASCII_CHAR_DIGIT_SIX
N#define  ASCII_CHAR_DIG_SEVEN                           ASCII_CHAR_DIGIT_SEVEN
N#define  ASCII_CHAR_DIG_EIGHT                           ASCII_CHAR_DIGIT_EIGHT
N#define  ASCII_CHAR_DIG_NINE                            ASCII_CHAR_DIGIT_NINE
N
N
N                                                                /* ------------ ASCII PUNCTUATION & SYMBOLS ----------- */
N#define  ASCII_CHAR_COLON                               0x3A    /* ':'                                                  */
N#define  ASCII_CHAR_SEMICOLON                           0x3B    /* ';'                                                  */
N#define  ASCII_CHAR_LESS_THAN_SIGN                      0x3C    /* '<'                                                  */
N#define  ASCII_CHAR_EQUALS_SIGN                         0x3D    /* '='                                                  */
N#define  ASCII_CHAR_GREATER_THAN_SIGN                   0x3E    /* '>'                                                  */
N#define  ASCII_CHAR_QUESTION_MARK                       0x3F    /* '\?'                                                 */
N#define  ASCII_CHAR_COMMERCIAL_AT                       0x40    /* '@'                                                  */
N
N#define  ASCII_CHAR_AT_SIGN                             ASCII_CHAR_COMMERCIAL_AT
N
N
N/*$PAGE*/
N                                                                /* ------------- UPPERCASE LATIN ALPHABET ------------- */
N#define  ASCII_CHAR_LATIN_UPPER_A                       0x41    /* 'A'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_B                       0x42    /* 'B'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_C                       0x43    /* 'C'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_D                       0x44    /* 'D'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_E                       0x45    /* 'E'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_F                       0x46    /* 'F'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_G                       0x47    /* 'G'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_H                       0x48    /* 'H'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_I                       0x49    /* 'I'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_J                       0x4A    /* 'J'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_K                       0x4B    /* 'K'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_L                       0x4C    /* 'L'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_M                       0x4D    /* 'M'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_N                       0x4E    /* 'N'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_O                       0x4F    /* 'O'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_P                       0x50    /* 'P'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_Q                       0x51    /* 'Q'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_R                       0x52    /* 'R'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_S                       0x53    /* 'S'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_T                       0x54    /* 'T'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_U                       0x55    /* 'U'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_V                       0x56    /* 'V'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_W                       0x57    /* 'W'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_X                       0x58    /* 'X'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_Y                       0x59    /* 'Y'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_Z                       0x5A    /* 'Z'                                                  */
N
N
N                                                                /* ------------ ASCII PUNCTUATION & SYMBOLS ----------- */
N#define  ASCII_CHAR_LEFT_SQUARE_BRACKET                 0x5B    /* '['                                                  */
N#define  ASCII_CHAR_REVERSE_SOLIDUS                     0x5C    /* '\\'                                                 */
N#define  ASCII_CHAR_RIGHT_SQUARE_BRACKET                0x5D    /* ']'                                                  */
N#define  ASCII_CHAR_CIRCUMFLEX_ACCENT                   0x5E    /* '^'                                                  */
N#define  ASCII_CHAR_LOW_LINE                            0x5F    /* '_'                                                  */
N#define  ASCII_CHAR_GRAVE_ACCENT                        0x60    /* '`'                                                  */
N
N#define  ASCII_CHAR_BRACKET_SQUARE_LEFT                 ASCII_CHAR_LEFT_SQUARE_BRACKET
N#define  ASCII_CHAR_BRACKET_SQUARE_RIGHT                ASCII_CHAR_RIGHT_SQUARE_BRACKET
N
N
N                                                                /* ------------- LOWERCASE LATIN ALPHABET ------------- */
N#define  ASCII_CHAR_LATIN_LOWER_A                       0x61    /* 'a'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_B                       0x62    /* 'b'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_C                       0x63    /* 'c'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_D                       0x64    /* 'd'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_E                       0x65    /* 'e'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_F                       0x66    /* 'f'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_G                       0x67    /* 'g'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_H                       0x68    /* 'h'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_I                       0x69    /* 'i'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_J                       0x6A    /* 'j'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_K                       0x6B    /* 'k'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_L                       0x6C    /* 'l'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_M                       0x6D    /* 'm'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_N                       0x6E    /* 'n'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_O                       0x6F    /* 'o'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_P                       0x70    /* 'p'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_Q                       0x71    /* 'q'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_R                       0x72    /* 'r'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_S                       0x73    /* 's'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_T                       0x74    /* 't'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_U                       0x75    /* 'u'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_V                       0x76    /* 'v'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_W                       0x77    /* 'w'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_X                       0x78    /* 'x'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_Y                       0x79    /* 'y'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_Z                       0x7A    /* 'z'                                                  */
N
N
N                                                                /* ------------ ASCII PUNCTUATION & SYMBOLS ----------- */
N#define  ASCII_CHAR_LEFT_CURLY_BRACKET                  0x7B    /* '{'                                                  */
N#define  ASCII_CHAR_VERTICAL_LINE                       0x7C    /* '|'                                                  */
N#define  ASCII_CHAR_RIGHT_CURLY_BRACKET                 0x7D    /* '}'                                                  */
N#define  ASCII_CHAR_TILDE                               0x7E    /* '~'                                                  */
N
N#define  ASCII_CHAR_BRACKET_CURLY_LEFT                  ASCII_CHAR_LEFT_CURLY_BRACKET
N#define  ASCII_CHAR_BRACKET_CURLY_RIGHT                 ASCII_CHAR_RIGHT_CURLY_BRACKET
N
N
N                                                                /* ---------------- CONTROL CHARACTERS ---------------- */
N#define  ASCII_CHAR_DELETE                              0x7F
N
N#define  ASCII_CHAR_DEL                                 ASCII_CHAR_DELETE
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             DATA TYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                          GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                              MACRO'S
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                               ASCII CHARACTER CLASSIFICATION MACRO's
N*
N* Note(s) : (1) ISO/IEC 9899:TC2, Section 7.4.1.(1) states that "character classification functions ...
N*               return nonzero (true) if and only if the value of the argument 'c' conforms to ... the
N*               description of the function."
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                           ASCII_IS_DIG()
N*
N* Description : Determine whether a character is a decimal-digit character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a decimal-digit character.
N*
N*               DEF_NO,	 if character is NOT a decimal-digit character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.5.(2)  states that "isdigit()  ... tests for any
N*                   decimal-digit character".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_DIG(c)               ((((c) >= ASCII_CHAR_DIG_ZERO) && ((c) <= ASCII_CHAR_DIG_NINE)) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                         ASCII_IS_DIG_OCT()
N*
N* Description : Determine whether a character is an octal-digit character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     an octal-digit character.
N*
N*               DEF_NO,	 if character is NOT an octal-digit character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_DIG_OCT(c)          ((((c) >= ASCII_CHAR_DIG_ZERO) && ((c) <= ASCII_CHAR_DIG_SEVEN)) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                         ASCII_IS_DIG_HEX()
N*
N* Description : Determine whether a character is a hexadecimal-digit character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a hexadecimal-digit character.
N*
N*               DEF_NO,	 if character is NOT a hexadecimal-digit character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.12.(2) states that "isxdigit() ... tests for any
N*                   hexadecimal-digit character".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_DIG_HEX(c)          (((((c) >= ASCII_CHAR_DIG_ZERO     ) && ((c) <= ASCII_CHAR_DIG_NINE     )) || \
N                                        (((c) >= ASCII_CHAR_LATIN_UPPER_A) && ((c) <= ASCII_CHAR_LATIN_UPPER_F)) || \
N                                        (((c) >= ASCII_CHAR_LATIN_LOWER_A) && ((c) <= ASCII_CHAR_LATIN_LOWER_F))) ? (DEF_YES) : (DEF_NO))
X#define  ASCII_IS_DIG_HEX(c)          (((((c) >= ASCII_CHAR_DIG_ZERO     ) && ((c) <= ASCII_CHAR_DIG_NINE     )) ||                                         (((c) >= ASCII_CHAR_LATIN_UPPER_A) && ((c) <= ASCII_CHAR_LATIN_UPPER_F)) ||                                         (((c) >= ASCII_CHAR_LATIN_LOWER_A) && ((c) <= ASCII_CHAR_LATIN_LOWER_F))) ? (DEF_YES) : (DEF_NO))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          ASCII_IS_LOWER()
N*
N* Description : Determine whether a character is a lowercase alphabetic character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a lowercase alphabetic character.
N*
N*               DEF_NO,	 if character is NOT a lowercase alphabetic character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.7.(2)  states that "islower() returns true only for
N*                   the lowercase letters".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_LOWER(c)             ((((c) >= ASCII_CHAR_LATIN_LOWER_A) && ((c) <= ASCII_CHAR_LATIN_LOWER_Z)) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                          ASCII_IS_UPPER()
N*
N* Description : Determine whether a character is an uppercase alphabetic character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     an uppercase alphabetic character.
N*
N*               DEF_NO,	 if character is NOT an uppercase alphabetic character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.11.(2) states that "isupper() returns true only for
N*                   the uppercase letters".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_UPPER(c)             ((((c) >= ASCII_CHAR_LATIN_UPPER_A) && ((c) <= ASCII_CHAR_LATIN_UPPER_Z)) ? (DEF_YES) : (DEF_NO))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          ASCII_IS_ALPHA()
N*
N* Description : Determine whether a character is an alphabetic character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     an alphabetic character.
N*
N*               DEF_NO,	 if character is NOT an alphabetic character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.2.(2) states that "isalpha() returns true only for the
N*                   characters for which isupper() or islower() is true".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_ALPHA(c)             ((((ASCII_IS_UPPER(c)) == DEF_YES) || \
N                                         ((ASCII_IS_LOWER(c)) == DEF_YES)) ? (DEF_YES) : (DEF_NO))
X#define  ASCII_IS_ALPHA(c)             ((((ASCII_IS_UPPER(c)) == DEF_YES) ||                                          ((ASCII_IS_LOWER(c)) == DEF_YES)) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                        ASCII_IS_ALPHA_NUM()
N*
N* Description : Determine whether a character is an alphanumeric character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     an alphanumeric character.
N*
N*               DEF_NO,	 if character is NOT an alphanumeric character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.1.(2) states that "isalnum() ... tests for any character
N*                   for which isalpha() or isdigit() is true".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_ALPHA_NUM(c)         ((((ASCII_IS_ALPHA(c)) == DEF_YES) || \
N                                         ((ASCII_IS_DIG  (c)) == DEF_YES)) ? (DEF_YES) : (DEF_NO))
X#define  ASCII_IS_ALPHA_NUM(c)         ((((ASCII_IS_ALPHA(c)) == DEF_YES) ||                                          ((ASCII_IS_DIG  (c)) == DEF_YES)) ? (DEF_YES) : (DEF_NO))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          ASCII_IS_BLANK()
N*
N* Description : Determine whether a character is a standard blank character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a standard blank character.
N*
N*               DEF_NO,	 if character is NOT a standard blank character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.3.(2) states that "isblank() returns true only for
N*                       the standard blank characters".
N*
N*                   (b) ISO/IEC 9899:TC2, Section 7.4.1.3.(2) defines "the standard blank characters" as
N*                       the "space (' '), and horizontal tab ('\t')".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_BLANK(c)             ((((c) == ASCII_CHAR_SPACE) || ((c) == ASCII_CHAR_HT)) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                          ASCII_IS_SPACE()
N*
N* Description : Determine whether a character is a white-space character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a white-space character.
N*
N*               DEF_NO,	 if character is NOT a white-space character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.10.(2) states that "isspace() returns true only
N*                       for the standard white-space characters".
N*
N*                   (b) ISO/IEC 9899:TC2, Section 7.4.1.10.(2) defines "the standard white-space characters"
N*                       as the "space (' '), form feed ('\f'), new-line ('\n'), carriage return ('\r'),
N*                       horizontal tab ('\t'), and vertical tab ('\v')".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_SPACE(c)             ((((c) == ASCII_CHAR_SPACE) || ((c) == ASCII_CHAR_CR) || \
N                                         ((c) == ASCII_CHAR_LF   ) || ((c) == ASCII_CHAR_FF) || \
N                                         ((c) == ASCII_CHAR_HT   ) || ((c) == ASCII_CHAR_VT)) ? (DEF_YES) : (DEF_NO))
X#define  ASCII_IS_SPACE(c)             ((((c) == ASCII_CHAR_SPACE) || ((c) == ASCII_CHAR_CR) ||                                          ((c) == ASCII_CHAR_LF   ) || ((c) == ASCII_CHAR_FF) ||                                          ((c) == ASCII_CHAR_HT   ) || ((c) == ASCII_CHAR_VT)) ? (DEF_YES) : (DEF_NO))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          ASCII_IS_PRINT()
N*
N* Description : Determine whether a character is a printing character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a printing character.
N*
N*               DEF_NO,	 if character is NOT a printing character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.8.(2) states that "isprint() ... tests for any
N*                       printing character including space (' ')".
N*
N*                   (b) ISO/IEC 9899:TC2, Section 7.4.(3), Note 169, states that in "the seven-bit US
N*                       ASCII character set, the printing characters are those whose values lie from
N*                       0x20 (space) through 0x7E (tilde)".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_PRINT(c)             ((((c) >= ASCII_CHAR_SPACE) && ((c) <= ASCII_CHAR_TILDE)) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                          ASCII_IS_GRAPH()
N*
N* Description : Determine whether a character is any printing character except a space character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a graphic character.
N*
N*               DEF_NO,	 if character is NOT a graphic character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.6.(2) states that "isgraph() ... tests for any
N*                       printing character except space (' ')".
N*
N*                   (b) ISO/IEC 9899:TC2, Section 7.4.(3), Note 169, states that in "the seven-bit US
N*                       ASCII character set, the printing characters are those whose values lie from
N*                       0x20 (space) through 0x7E (tilde)".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_GRAPH(c)             ((((c) >= ASCII_CHAR_EXCLAMATION_MARK) && ((c) <= ASCII_CHAR_TILDE)) ? (DEF_YES) : (DEF_NO))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          ASCII_IS_PUNCT()
N*
N* Description : Determine whether a character is a punctuation character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a punctuation character.
N*
N*               DEF_NO,	 if character is NOT a punctuation character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.9.(2) states that "ispunct() returns true for every
N*                   printing character for which neither isspace() nor isalnum() is true".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_PUNCT(c)             ((((ASCII_IS_PRINT(c)) == DEF_YES) && \
N                                         ((ASCII_IS_SPACE(c)) == DEF_NO ) && \
N                                         ((ASCII_IS_ALPHA_NUM(c)) == DEF_NO )) ? (DEF_YES) : (DEF_NO))
X#define  ASCII_IS_PUNCT(c)             ((((ASCII_IS_PRINT(c)) == DEF_YES) &&                                          ((ASCII_IS_SPACE(c)) == DEF_NO ) &&                                          ((ASCII_IS_ALPHA_NUM(c)) == DEF_NO )) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                           ASCII_IS_CTRL()
N*
N* Description : Determine whether a character is a control character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a control character.
N*
N*               DEF_NO,	 if character is NOT a control character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.4.(2) states that "iscntrl() ... tests for any
N*                       control character".
N*
N*                   (b) ISO/IEC 9899:TC2, Section 7.4.(3), Note 169, states that in "the seven-bit US
N*                       ASCII character set, ... the control characters are those whose values lie from
N*                       0 (NUL) through 0x1F (US), and the character 0x7F (DEL)".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_CTRL(c)             (((((CPU_INT08S)(c) >= ASCII_CHAR_NULL  ) && ((c) <= ASCII_CHAR_IS1)) || \
N                                                                                   ((c) == ASCII_CHAR_DEL))  ? (DEF_YES) : (DEF_NO))
X#define  ASCII_IS_CTRL(c)             (((((CPU_INT08S)(c) >= ASCII_CHAR_NULL  ) && ((c) <= ASCII_CHAR_IS1)) ||                                                                                    ((c) == ASCII_CHAR_DEL))  ? (DEF_YES) : (DEF_NO))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                ASCII CHARACTER CASE MAPPING MACRO's
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                          ASCII_TO_LOWER()
N*
N* Description : Convert uppercase alphabetic character to its corresponding lowercase alphabetic character.
N*
N* Argument(s) : c           Character to convert.
N*
N* Return(s)   : Lowercase equivalent of 'c', if character 'c' is an uppercase character (see Note #1b1).
N*
N*               Character 'c',               otherwise                                  (see Note #1b2).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.2.1.(2) states that "tolower() ... converts an
N*                       uppercase letter to a corresponding lowercase letter".
N*
N*                   (b) ISO/IEC 9899:TC2, Section 7.4.2.1.(3) states that :
N*
N*                       (1) (A) "if the argument is a character for which isupper() is true and there are
N*                                one or more corresponding characters ... for which islower() is true," ...
N*                           (B) "tolower() ... returns one of the corresponding characters;" ...
N*
N*                       (2) "otherwise, the argument is returned unchanged."
N*********************************************************************************************************
N*/
N
N#define  ASCII_TO_LOWER(c)              (((ASCII_IS_UPPER(c)) == DEF_YES) ? ((c) + (ASCII_CHAR_LATIN_LOWER_A - ASCII_CHAR_LATIN_UPPER_A)) : (c))
N
N
N/*
N*********************************************************************************************************
N*                                          ASCII_TO_UPPER()
N*
N* Description : Convert lowercase alphabetic character to its corresponding uppercase alphabetic character.
N*
N* Argument(s) : c           Character to convert.
N*
N* Return(s)   : Uppercase equivalent of 'c', if character 'c' is a lowercase character (see Note #1b1).
N*
N*               Character 'c',               otherwise                                 (see Note #1b2).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.2.2.(2) states that "toupper() ... converts a
N*                       lowercase letter to a corresponding uppercase letter".
N*
N*                   (b) ISO/IEC 9899:TC2, Section 7.4.2.2.(3) states that :
N*
N*                       (1) (A) "if the argument is a character for which islower() is true and there are
N*                                one or more corresponding characters ... for which isupper() is true," ...
N*                           (B) "toupper() ... returns one of the corresponding characters;" ...
N*
N*                       (2) "otherwise, the argument is returned unchanged."
N*********************************************************************************************************
N*/
N
N#define  ASCII_TO_UPPER(c)              (((ASCII_IS_LOWER(c)) == DEF_YES) ? ((c) - (ASCII_CHAR_LATIN_LOWER_A - ASCII_CHAR_LATIN_UPPER_A)) : (c))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
NCPU_BOOLEAN  ASCII_IsAlpha   (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsAlphaNum(CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsLower   (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsUpper   (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsDig     (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsDigOct  (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsDigHex  (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsBlank   (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsSpace   (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsPrint   (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsGraph   (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsPunct   (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsCtrl    (CPU_CHAR  c);
N
N
NCPU_CHAR     ASCII_ToLower   (CPU_CHAR  c);
N
NCPU_CHAR     ASCII_ToUpper   (CPU_CHAR  c);
N
N
NCPU_BOOLEAN  ASCII_Cmp       (CPU_CHAR  c1,
N                              CPU_CHAR  c2);
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*
N* Note(s) : (1) See 'lib_ascii.h  MODULE'.
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of lib ascii module include.                     */
N
L 159 "..\..\uC-LIB\lib_str.h" 2
N
N#include  <lib_cfg.h>
N
N#if 0                                                           /* See Note #4.                                         */
S#include  <stdio.h>
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                               EXTERNS
N*********************************************************************************************************
N*/
N
N#ifdef   LIB_STR_MODULE
S#define  LIB_STR_EXT
N#else
N#define  LIB_STR_EXT  extern
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        DEFAULT CONFIGURATION
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                 STRING FLOATING POINT CONFIGURATION
N*
N* Note(s) : (1) Configure LIB_STR_CFG_FP_EN to enable/disable floating point string function(s).
N*
N*           (2) Configure LIB_STR_CFG_FP_MAX_NBR_DIG_SIG to configure the maximum number of significant 
N*               digits to calculate &/or display for floating point string function(s).
N*
N*               See also 'STRING FLOATING POINT DEFINES  Note #1'.
N*********************************************************************************************************
N*/
N
N                                                                /* Configure floating point feature(s) [see Note #1] :  */
N#ifndef  LIB_STR_CFG_FP_EN
N#define  LIB_STR_CFG_FP_EN                      DEF_DISABLED
N                                                                /*   DEF_DISABLED     Floating point functions DISABLED */
N                                                                /*   DEF_ENABLED      Floating point functions ENABLED  */
N#endif
N
N                                                                /* Configure floating point feature(s)' number of ...   */
N                                                                /* ... significant digits (see Note #2).                */
N#ifndef  LIB_STR_CFG_FP_MAX_NBR_DIG_SIG
N#define  LIB_STR_CFG_FP_MAX_NBR_DIG_SIG         LIB_STR_FP_MAX_NBR_DIG_SIG_DFLT
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                               DEFINES
N*********************************************************************************************************
N*/
N
N#define  STR_CR_LF                     "\r\n"
N#define  STR_LF_CR                     "\n\r"
N#define  STR_NEW_LINE                   STR_CR_LF
N#define  STR_PARENT_PATH               ".."
N
N#define  STR_CR_LF_LEN                 (sizeof(STR_CR_LF)       - 1)
N#define  STR_LF_CR_LEN                 (sizeof(STR_LF_CR)       - 1)
N#define  STR_NEW_LINE_LEN              (sizeof(STR_NEW_LINE)    - 1)
N#define  STR_PARENT_PATH_LEN           (sizeof(STR_PARENT_PATH) - 1)
N
N
N/*
N*********************************************************************************************************
N*                                             DATA TYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                          GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                              MACRO'S
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                      STANDARD LIBRARY MACRO'S
N*
N* Note(s) : (1) NO compiler-supplied standard library functions SHOULD be used.
N*
N*               #### The reference to standard memory functions SHOULD be removed once all custom library
N*               functions are implemented WITHOUT reference to ANY standard library function(s).
N*
N*               See also 'INCLUDE FILES  Note #3'.
N*********************************************************************************************************
N*/
N
N                                                                /* See Note #1.                                         */
N#define  Str_FmtPrint                   snprintf
N#define  Str_FmtScan                    sscanf
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
N                                                                /* ------------------ STR LEN  FNCTS ------------------ */
NCPU_SIZE_T   Str_Len            (const  CPU_CHAR      *pstr);
N
NCPU_SIZE_T   Str_Len_N          (const  CPU_CHAR      *pstr,
N                                        CPU_SIZE_T     len_max);
N
N
N                                                                       /* ------------------ STR COPY FNCTS ------------------ */
NCPU_CHAR    *Str_Copy           (       CPU_CHAR      *pstr_dest,
N                                 const  CPU_CHAR      *pstr_src);
N
NCPU_CHAR    *Str_Copy_N         (       CPU_CHAR      *pstr_dest,
N                                 const  CPU_CHAR      *pstr_src,
N                                        CPU_SIZE_T     len_max);
N
N
NCPU_CHAR    *Str_Cat            (       CPU_CHAR      *pstr_dest,
N                                 const  CPU_CHAR      *pstr_cat);
N
NCPU_CHAR    *Str_Cat_N          (       CPU_CHAR      *pstr_dest,
N                                 const  CPU_CHAR      *pstr_cat,
N                                        CPU_SIZE_T     len_max);
N
N
N                                                                       /* ------------------ STR CMP  FNCTS ------------------ */
NCPU_INT16S   Str_Cmp            (const  CPU_CHAR      *p1_str,
N                                 const  CPU_CHAR      *p2_str);
N
NCPU_INT16S   Str_Cmp_N          (const  CPU_CHAR      *p1_str,
N                                 const  CPU_CHAR      *p2_str,
N                                        CPU_SIZE_T     len_max);
N
NCPU_INT16S   Str_CmpIgnoreCase  (const  CPU_CHAR      *p1_str,
N                                 const  CPU_CHAR      *p2_str);
N
NCPU_INT16S   Str_CmpIgnoreCase_N(const  CPU_CHAR      *p1_str,
N                                 const  CPU_CHAR      *p2_str,
N                                        CPU_SIZE_T     len_max);
N
N
N                                                                       /* ------------------ STR SRCH FNCTS ------------------ */
NCPU_CHAR    *Str_Char           (const  CPU_CHAR      *pstr,
N                                        CPU_CHAR       srch_char);
N
NCPU_CHAR    *Str_Char_N         (const  CPU_CHAR      *pstr,
N                                        CPU_SIZE_T     len_max,
N                                        CPU_CHAR       srch_char);
N
NCPU_CHAR    *Str_Char_Last      (const  CPU_CHAR      *pstr,
N                                        CPU_CHAR       srch_char);
N
NCPU_CHAR    *Str_Char_Last_N    (const  CPU_CHAR      *pstr,
N                                        CPU_SIZE_T     len_max,
N                                        CPU_CHAR       srch_char);
N
NCPU_CHAR    *Str_Char_Replace   (       CPU_CHAR      *pstr,
N                                        CPU_CHAR       char_srch,
N                                        CPU_CHAR       char_replace);
N
NCPU_CHAR    *Str_Char_Replace_N (       CPU_CHAR      *pstr,
N                                        CPU_CHAR       char_srch,
N                                        CPU_CHAR       char_replace,
N                                        CPU_SIZE_T     len_max);
N
NCPU_CHAR    *Str_Str            (const  CPU_CHAR      *pstr,
N                                 const  CPU_CHAR      *pstr_srch);
N
NCPU_CHAR    *Str_Str_N          (const  CPU_CHAR      *pstr,
N                                 const  CPU_CHAR      *pstr_srch,
N                                        CPU_SIZE_T     len_max);
N
N
N/*$PAGE*/
N                                                                       /* ------------------ STR FMT  FNCTS ------------------ */
NCPU_CHAR    *Str_FmtNbr_Int32U  (       CPU_INT32U     nbr,
N                                        CPU_INT08U     nbr_dig,
N                                        CPU_INT08U     nbr_base,
N                                        CPU_CHAR       lead_char,
N                                        CPU_BOOLEAN    lower_case,
N                                        CPU_BOOLEAN    nul,
N                                        CPU_CHAR      *pstr);
N
NCPU_CHAR    *Str_FmtNbr_Int32S  (       CPU_INT32S     nbr,
N                                        CPU_INT08U     nbr_dig,
N                                        CPU_INT08U     nbr_base,
N                                        CPU_CHAR       lead_char,
N                                        CPU_BOOLEAN    lower_case,
N                                        CPU_BOOLEAN    nul,
N                                        CPU_CHAR      *pstr);
N
N#if (LIB_STR_CFG_FP_EN == DEF_ENABLED)
X#if (0u == 1u)
SCPU_CHAR    *Str_FmtNbr_32      (       CPU_FP32       nbr,
S                                        CPU_INT08U     nbr_dig,
S                                        CPU_INT08U     nbr_dp,
S                                        CPU_CHAR       lead_char,
S                                        CPU_BOOLEAN    nul,
S                                        CPU_CHAR      *pstr);
N#endif
N
N
N                                                                       /* ----------------- STR PARSE FNCTS ------------------ */
NCPU_INT32U   Str_ParseNbr_Int32U(const  CPU_CHAR      *pstr,
N                                        CPU_CHAR     **pstr_next,
N                                        CPU_INT08U     nbr_base);
N
NCPU_INT32S   Str_ParseNbr_Int32S(const  CPU_CHAR      *pstr,
N                                        CPU_CHAR     **pstr_next,
N                                        CPU_INT08U     nbr_base);
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_STR_CFG_FP_EN
S#error  "LIB_STR_CFG_FP_EN                     not #define'd in 'lib_cfg.h'"
S#error  "                                [MUST be  DEF_DISABLED]           "
S#error  "                                [     ||  DEF_ENABLED ]           "
S
S#elif  ((LIB_STR_CFG_FP_EN != DEF_DISABLED) && \
S        (LIB_STR_CFG_FP_EN != DEF_ENABLED ))
X#elif  ((0u != 0u) &&         (0u != 1u ))
S#error  "LIB_STR_CFG_FP_EN               illegally #define'd in 'lib_cfg.h'"
S#error  "                                [MUST be  DEF_DISABLED]           "
S#error  "                                [     ||  DEF_ENABLED ]           "
S
S
S#elif   (LIB_STR_CFG_FP_EN == DEF_ENABLED)
X#elif   (0u == 1u)
S
S#ifndef  LIB_STR_CFG_FP_MAX_NBR_DIG_SIG
S#error  "LIB_STR_CFG_FP_MAX_NBR_DIG_SIG        not #define'd in 'lib_cfg.h'          "
S#error  "                                [MUST be  >= LIB_STR_FP_MAX_NBR_DIG_SIG_MIN]"
S#error  "                                [     &&  <= LIB_STR_FP_MAX_NBR_DIG_SIG_MAX]"
S
S#elif   (DEF_CHK_VAL(LIB_STR_CFG_FP_MAX_NBR_DIG_SIG,          \
S                     LIB_STR_FP_MAX_NBR_DIG_SIG_MIN,          \
S                     LIB_STR_FP_MAX_NBR_DIG_SIG_MAX) != DEF_OK)
X#elif   (DEF_CHK_VAL(LIB_STR_CFG_FP_MAX_NBR_DIG_SIG,                               LIB_STR_FP_MAX_NBR_DIG_SIG_MIN,                               LIB_STR_FP_MAX_NBR_DIG_SIG_MAX) != DEF_OK)
S#error  "LIB_STR_CFG_FP_MAX_NBR_DIG_SIG  illegally #define'd in 'lib_cfg.h'          "
S#error  "                                [MUST be  >= LIB_STR_FP_MAX_NBR_DIG_SIG_MIN]"
S#error  "                                [     &&  <= LIB_STR_FP_MAX_NBR_DIG_SIG_MAX]"
S#endif
S
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*
N* Note(s) : (1) See 'lib_str.h  MODULE'.
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of lib str module include.                       */
N
L 111 "..\..\uC-CPU\cpu_core.h" 2
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          CPU CONFIGURATION
N*
N* Note(s) : (1) The following pre-processor directives correctly configure CPU parameters.  DO NOT MODIFY.
N*
N*           (2) CPU timestamp timer feature is required for :
N*
N*               (a) CPU timestamps
N*               (b) CPU interrupts disabled time measurement
N*
N*               See also 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
N*                      & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1'.
N*********************************************************************************************************
N*/
N
N#ifdef   CPU_CFG_TS_EN
S#undef   CPU_CFG_TS_EN
N#endif
N
N
N#if    ((CPU_CFG_TS_32_EN == DEF_ENABLED) || \
N        (CPU_CFG_TS_64_EN == DEF_ENABLED))
X#if    ((1u == 1u) ||         (0u == 1u))
N#define  CPU_CFG_TS_EN                          DEF_ENABLED
N#else
S#define  CPU_CFG_TS_EN                          DEF_DISABLED
N#endif
N
N#if    ((CPU_CFG_TS_EN == DEF_ENABLED) || \
N(defined(CPU_CFG_INT_DIS_MEAS_EN)))
X#if    ((1u == 1u) || (0L))
N#define  CPU_CFG_TS_TMR_EN                      DEF_ENABLED
N#else
S#define  CPU_CFG_TS_TMR_EN                      DEF_DISABLED
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                               DEFINES
N*********************************************************************************************************
N*/
N
N#define  CPU_TIME_MEAS_NBR_MIN                             1u
N#define  CPU_TIME_MEAS_NBR_MAX                           128u
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             DATA TYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                           CPU ERROR CODES
N*********************************************************************************************************
N*/
N
Ntypedef enum cpu_err {
N
N    CPU_ERR_NONE                            =         0u,
N    CPU_ERR_NULL_PTR                        =        10u,
N
N    CPU_ERR_NAME_SIZE                       =      1000u,
N
N    CPU_ERR_TS_FREQ_INVALID                 =      2000u
N
N} CPU_ERR;
N
N
N/*
N*********************************************************************************************************
N*                                      CPU TIMESTAMP DATA TYPES
N*
N* Note(s) : (1) CPU timestamp timer data type defined to the binary-multiple of 8-bit octets as configured 
N*               by 'CPU_CFG_TS_TMR_SIZE' (see 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #2').
N*********************************************************************************************************
N*/
N
Ntypedef  CPU_INT32U  CPU_TS32;
Ntypedef  CPU_INT64U  CPU_TS64;
N
Ntypedef  CPU_TS32    CPU_TS;                                    /* Req'd for backwards-compatibility.                   */
N
N
N#if     (CPU_CFG_TS_TMR_EN   == DEF_ENABLED)                    /* CPU ts tmr defined to cfg'd word size (see Note #1). */
X#if     (1u   == 1u)                     
N#if     (CPU_CFG_TS_TMR_SIZE == CPU_WORD_SIZE_08)
X#if     (4 == 1)
Stypedef  CPU_INT08U  CPU_TS_TMR;
S#elif   (CPU_CFG_TS_TMR_SIZE == CPU_WORD_SIZE_16)
X#elif   (4 == 2)
Stypedef  CPU_INT16U  CPU_TS_TMR;
S#elif   (CPU_CFG_TS_TMR_SIZE == CPU_WORD_SIZE_64)
X#elif   (4 == 8)
Stypedef  CPU_INT64U  CPU_TS_TMR;
N#else                                                           /* CPU ts tmr dflt size = 32-bits.                      */
Ntypedef  CPU_INT32U  CPU_TS_TMR;
N#endif
N#endif
N
N
N/*
N*********************************************************************************************************
N*                               CPU TIMESTAMP TIMER FREQUENCY DATA TYPE
N*********************************************************************************************************
N*/
N
Ntypedef  CPU_INT32U  CPU_TS_TMR_FREQ;
N
N
N/*
N*********************************************************************************************************
N*                                          GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
N#if    (CPU_CFG_NAME_EN   == DEF_ENABLED)
X#if    (1u   == 1u)
NCPU_CORE_EXT  CPU_CHAR         CPU_Name[CPU_CFG_NAME_SIZE];     /* CPU host name.                                       */
Xextern  CPU_CHAR         CPU_Name[16];      
N#endif
N
N
N#if ((CPU_CFG_TS_32_EN    == DEF_ENABLED)  && \
N     (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32))
X#if ((1u    == 1u)  &&      (4 <  4))
SCPU_CORE_EXT  CPU_TS32         CPU_TS_32_Accum;                 /* 32-bit accum'd ts  (in ts tmr cnts).                 */
SCPU_CORE_EXT  CPU_TS_TMR       CPU_TS_32_TmrPrev;               /* 32-bit ts prev tmr (in ts tmr cnts).                 */
N#endif
N
N#if ((CPU_CFG_TS_64_EN    == DEF_ENABLED)  && \
N     (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64))
X#if ((0u    == 1u)  &&      (4 <  8))
SCPU_CORE_EXT  CPU_TS64         CPU_TS_64_Accum;                 /* 64-bit accum'd ts  (in ts tmr cnts).                 */
SCPU_CORE_EXT  CPU_TS_TMR       CPU_TS_64_TmrPrev;               /* 64-bit ts prev tmr (in ts tmr cnts).                 */
N#endif
N
N#if  (CPU_CFG_TS_TMR_EN   == DEF_ENABLED)
X#if  (1u   == 1u)
NCPU_CORE_EXT  CPU_TS_TMR_FREQ  CPU_TS_TmrFreq_Hz;               /* CPU ts tmr freq (in Hz).                             */
Xextern  CPU_TS_TMR_FREQ  CPU_TS_TmrFreq_Hz;                
N#endif
N
N
N#ifdef  CPU_CFG_INT_DIS_MEAS_EN
SCPU_CORE_EXT  CPU_INT16U       CPU_IntDisMeasCtr;               /* Nbr tot    ints dis'd ctr.                           */
SCPU_CORE_EXT  CPU_INT16U       CPU_IntDisNestCtr;               /* Nbr nested ints dis'd ctr.                           */
S                                                                /* Ints dis'd time (in ts tmr cnts) : ...               */
SCPU_CORE_EXT  CPU_TS_TMR       CPU_IntDisMeasStart_cnts;        /* ...  start time.                                     */
SCPU_CORE_EXT  CPU_TS_TMR       CPU_IntDisMeasStop_cnts;         /* ...  stop  time.                                     */
SCPU_CORE_EXT  CPU_TS_TMR       CPU_IntDisMeasOvrhd_cnts;        /* ...        time meas ovrhd.                          */
SCPU_CORE_EXT  CPU_TS_TMR       CPU_IntDisMeasMaxCur_cnts;       /* ...     resetable max time dis'd.                    */
SCPU_CORE_EXT  CPU_TS_TMR       CPU_IntDisMeasMax_cnts;          /* ... non-resetable max time dis'd.                    */
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                               MACRO'S
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                         CPU_SW_EXCEPTION()
N*
N* Description : Trap unrecoverable software exception.
N*
N* Argument(s) : err_rtn_val     Error type &/or value of the calling function to return (see Note #2b).
N*
N* Return(s)   : none.
N*
N* Caller(s)   : various.
N*
N* Note(s)     : (1) CPU_SW_EXCEPTION() deadlocks the current code execution -- whether multi-tasked/
N*                   -processed/-threaded or single-threaded -- when the current code execution cannot 
N*                   gracefully recover or report a fault or exception condition.
N*
N*                   Example CPU_SW_EXCEPTION() call :
N*
N*                       void  Fnct (CPU_ERR  *p_err)
N*                       {
N*                           :
N*
N*                           if (p_err == (CPU_ERR *)0) {        If 'p_err' NULL, cannot return error ...
N*                               CPU_SW_EXCEPTION(;);            ... so trap invalid argument exception.
N*                           }
N*
N*                           :
N*                       }
N*
N*                   See also 'cpu_core.c  CPU_SW_Exception()  Note #1'.
N*
N*               (2) (a) CPU_SW_EXCEPTION()  MAY be developer-implemented to output &/or handle any error or 
N*                       exception conditions; but since CPU_SW_EXCEPTION() is intended to trap unrecoverable 
N*                       software  conditions, it is recommended that developer-implemented versions prevent 
N*                       execution of any code following calls to CPU_SW_EXCEPTION() by deadlocking the code 
N*                       (see Note #1).
N*
N*                           Example CPU_SW_EXCEPTION() :
N*
N*                               #define  CPU_SW_EXCEPTION(err_rtn_val)      do {                         \
N*                                                                               Log(__FILE__, __LINE__); \
N*                                                                               CPU_SW_Exception();      \
N*                                                                           } while (0)
X
N*
N*                   (b) (1) However, if execution of code following calls to CPU_SW_EXCEPTION() is required 
N*                           (e.g. for automated testing); it is recommended that the last statement in 
N*                           developer-implemented versions be to return from the current function to prevent 
N*                           possible software exception(s) in the current function from triggering CPU &/or 
N*                           hardware exception(s).
N*
N*                           Example CPU_SW_EXCEPTION() :
N*
N*                               #define  CPU_SW_EXCEPTION(err_rtn_val)      do {                         \
N*                                                                               Log(__FILE__, __LINE__); \
N*                                                                               return  err_rtn_val;     \
N*                                                                           } while (0)
X
N*
N*                           (A) Note that 'err_rtn_val' in the return statement MUST NOT be enclosed in 
N*                               parentheses.  This allows CPU_SW_EXCEPTION() to return from functions that 
N*                               return 'void', i.e. NO return type or value (see also Note #2b2A).
N*$PAGE*
N*                       (2) In order for CPU_SW_EXCEPTION() to return from functions with various return 
N*                           types/values, each caller function MUST pass an appropriate error return type 
N*                           & value to CPU_SW_EXCEPTION().
N*
N*                           (A) Note that CPU_SW_EXCEPTION()  MUST NOT be passed any return type or value 
N*                               for functions that return 'void', i.e. NO return type or value; but SHOULD 
N*                               instead be passed a single semicolon.  This prevents possible compiler 
N*                               warnings that CPU_SW_EXCEPTION() is passed too few arguments.  However, 
N*                               the compiler may warn that CPU_SW_EXCEPTION() does NOT prevent creating 
N*                               null statements on lines with NO other code statements.
N*
N*                           Example CPU_SW_EXCEPTION() calls :
N*
N*                               void  Fnct (CPU_ERR  *p_err)
N*                               {
N*                                   :
N*
N*                                   if (p_err == (CPU_ERR *)0) {
N*                                       CPU_SW_EXCEPTION(;);            Exception macro returns NO value
N*                                   }                                       (see Note #2b2A)
N*
N*                                   :
N*                               }
N*
N*                               CPU_BOOLEAN  Fnct (CPU_ERR  *p_err)
N*                               {
N*                                   :
N*
N*                                   if (p_err == (CPU_ERR *)0) {
N*                                       CPU_SW_EXCEPTION(DEF_FAIL);     Exception macro returns 'DEF_FAIL'
N*                                   }
N*
N*                                   :
N*                               }
N*
N*                               OBJ  *Fnct (CPU_ERR  *p_err)
N*                               {
N*                                   :
N*
N*                                   if (p_err == (CPU_ERR *)0) {
N*                                       CPU_SW_EXCEPTION((OBJ *)0);     Exception macro returns NULL 'OBJ *'
N*                                   }
N*
N*                                   :
N*                               }
N*
N*********************************************************************************************************
N*/
N
N#ifndef  CPU_SW_EXCEPTION                                                       /* See Note #2.                         */
N#define  CPU_SW_EXCEPTION(err_rtn_val)              do {                    \
N                                                        CPU_SW_Exception(); \
N                                                    } while (0)
X#define  CPU_SW_EXCEPTION(err_rtn_val)              do {                                                                            CPU_SW_Exception();                                                     } while (0)
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                           CPU_VAL_UNUSED()
N*
N* Description : 
N*
N* Argument(s) : none.
N*
N* Return(s)   : none.
N*
N* Caller(s)   : #### various.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N
N#define  CPU_VAL_UNUSED(val)        ((void)&(val));
N
N
N#define  CPU_VAL_IGNORED(val)       CPU_VAL_UNUSED(val)
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          CPU_TYPE_CREATE()
N*
N* Description : Creates a generic type value.
N*
N* Argument(s) : char_1      1st ASCII character to create generic type value.
N*
N*               char_2      2nd ASCII character to create generic type value.
N*
N*               char_3      3rd ASCII character to create generic type value.
N*
N*               char_4      4th ASCII character to create generic type value.
N*
N* Return(s)   : 32-bit generic type value.
N*
N* Caller(s)   : various.
N*
N* Note(s)     : (1) (a) Generic type values should be #define'd with large, non-trivial values to trap 
N*                       & discard invalid/corrupted objects based on type value.
N*
N*                       In other words, by assigning large, non-trivial values to valid objects' type 
N*                       fields; the likelihood that an object with an unassigned &/or corrupted type 
N*                       field will contain a value is highly improbable & therefore the object itself 
N*                       will be trapped as invalid.
N*
N*                   (b) (1) CPU_TYPE_CREATE()  creates a 32-bit type value from four values.
N*
N*                       (2) Ideally, generic type values SHOULD be created from 'CPU_CHAR' characters to 
N*                           represent ASCII string abbreviations of the specific object types.  Memory 
N*                           displays of object type values will display the specific object types with 
N*                           their chosen ASCII names.
N*
N*                           Examples :
N*
N*                               #define  FILE_TYPE  CPU_TYPE_CREATE('F', 'I', 'L', 'E')
N*                               #define  BUF_TYPE   CPU_TYPE_CREATE('B', 'U', 'F', ' ')
N*********************************************************************************************************
N*/
N
N#if     (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG)
X#if     (2u == 1u)
S#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (3u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_2)) << (2u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_3)) << (1u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_4)) << (0u * DEF_OCTET_NBR_BITS)))
X#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (3u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_2)) << (2u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_3)) << (1u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_4)) << (0u * DEF_OCTET_NBR_BITS)))
S
N#else
N
N#if    ((CPU_CFG_DATA_SIZE   == CPU_WORD_SIZE_64) || \
N        (CPU_CFG_DATA_SIZE   == CPU_WORD_SIZE_32))
X#if    ((4   == 8) ||         (4   == 4))
N#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (0u * DEF_OCTET_NBR_BITS)) | \
N                                                                 ((CPU_INT32U)((CPU_INT08U)(char_2)) << (1u * DEF_OCTET_NBR_BITS)) | \
N                                                                 ((CPU_INT32U)((CPU_INT08U)(char_3)) << (2u * DEF_OCTET_NBR_BITS)) | \
N                                                                 ((CPU_INT32U)((CPU_INT08U)(char_4)) << (3u * DEF_OCTET_NBR_BITS)))
X#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (0u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_2)) << (1u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_3)) << (2u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_4)) << (3u * DEF_OCTET_NBR_BITS)))
N
N
N#elif   (CPU_CFG_DATA_SIZE   == CPU_WORD_SIZE_16)
S#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (2u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_2)) << (3u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_3)) << (0u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_4)) << (1u * DEF_OCTET_NBR_BITS)))
X#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (2u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_2)) << (3u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_3)) << (0u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_4)) << (1u * DEF_OCTET_NBR_BITS)))
S
S#else                                                           /* Dflt CPU_WORD_SIZE_08.                               */
S#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (3u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_2)) << (2u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_3)) << (1u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_4)) << (0u * DEF_OCTET_NBR_BITS)))
X#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (3u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_2)) << (2u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_3)) << (1u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_4)) << (0u * DEF_OCTET_NBR_BITS)))
N#endif
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*
N* Note(s) : (1) CPU interrupts disabled time measurement functions prototyped/defined only if 
N*               CPU_CFG_INT_DIS_MEAS_EN  #define'd in 'cpu_cfg.h'.
N*
N*           (2) (a) CPU_CntLeadZeros()  defined in :
N*
N*                   (1) 'cpu_a.asm',  if CPU_CFG_LEAD_ZEROS_ASM_PRESENT       #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable assembly-optimized function(s)
N*
N*                   (2) 'cpu_core.c', if CPU_CFG_LEAD_ZEROS_ASM_PRESENT   NOT #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable C-source-optimized function(s)
N*
N*               (b) CPU_CntTrailZeros() defined in :
N*
N*                   (1) 'cpu_a.asm',  if CPU_CFG_TRAIL_ZEROS_ASM_PRESENT      #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable assembly-optimized function(s)
N*
N*                   (2) 'cpu_core.c', if CPU_CFG_TRAIL_ZEROS_ASM_PRESENT  NOT #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable C-source-optimized function(s)
N*********************************************************************************************************
N*/
N
Nvoid             CPU_Init                 (void);
N
Nvoid             CPU_SW_Exception         (void);
N
N
N
N#if (CPU_CFG_NAME_EN == DEF_ENABLED)                                    /* -------------- CPU NAME FNCTS -------------- */
X#if (1u == 1u)                                     
Nvoid             CPU_NameClr              (void);
N
Nvoid             CPU_NameGet              (       CPU_CHAR  *p_name,
N                                                  CPU_ERR   *p_err);
N
Nvoid             CPU_NameSet              (const  CPU_CHAR  *p_name,
N                                                  CPU_ERR   *p_err);
N#endif
N
N
N
N                                                                        /* --------------- CPU TS FNCTS --------------- */
N#if (CPU_CFG_TS_32_EN == DEF_ENABLED)
X#if (1u == 1u)
NCPU_TS32         CPU_TS_Get32             (void);
N#endif
N
N#if (CPU_CFG_TS_64_EN == DEF_ENABLED)
X#if (0u == 1u)
SCPU_TS64         CPU_TS_Get64             (void);
N#endif
N
N#if (CPU_CFG_TS_EN    == DEF_ENABLED)
X#if (1u    == 1u)
Nvoid             CPU_TS_Update            (void);
N#endif
N
N
N#if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)                                  /* ------------- CPU TS TMR FNCTS ------------- */
X#if (1u == 1u)                                   
NCPU_TS_TMR_FREQ  CPU_TS_TmrFreqGet        (CPU_ERR          *p_err);
N
Nvoid             CPU_TS_TmrFreqSet        (CPU_TS_TMR_FREQ   freq_hz);
N#endif
N
N
N
N#ifdef  CPU_CFG_INT_DIS_MEAS_EN                                         /* -------- CPU INT DIS TIME MEAS FNCTS ------- */
S                                                                        /* See Note #1.                                 */
SCPU_TS_TMR       CPU_IntDisMeasMaxCurReset(void);
S
SCPU_TS_TMR       CPU_IntDisMeasMaxCurGet  (void);
S
SCPU_TS_TMR       CPU_IntDisMeasMaxGet     (void);
S
S
Svoid             CPU_IntDisMeasStart      (void);
S
Svoid             CPU_IntDisMeasStop       (void);
N#endif
N
N
N
N                                                                        /* ----------- CPU CNT ZEROS FNCTS ------------ */
NCPU_DATA         CPU_CntLeadZeros         (CPU_DATA    val);
N
N#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_08)
X#if     (8 >= 1)
NCPU_DATA         CPU_CntLeadZeros08       (CPU_INT08U  val);
N#endif
N#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_16)
X#if     (8 >= 2)
NCPU_DATA         CPU_CntLeadZeros16       (CPU_INT16U  val);
N#endif
N#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_32)
X#if     (8 >= 4)
NCPU_DATA         CPU_CntLeadZeros32       (CPU_INT32U  val);
N#endif
N#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_64)
X#if     (8 >= 8)
NCPU_DATA         CPU_CntLeadZeros64       (CPU_INT64U  val);
N#endif
N
N
NCPU_DATA         CPU_CntTrailZeros        (CPU_DATA    val);
N
N#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_08)
X#if     (8 >= 1)
NCPU_DATA         CPU_CntTrailZeros08      (CPU_INT08U  val);
N#endif
N#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_16)
X#if     (8 >= 2)
NCPU_DATA         CPU_CntTrailZeros16      (CPU_INT16U  val);
N#endif
N#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_32)
X#if     (8 >= 4)
NCPU_DATA         CPU_CntTrailZeros32      (CPU_INT32U  val);
N#endif
N#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_64)
X#if     (8 >= 8)
NCPU_DATA         CPU_CntTrailZeros64      (CPU_INT64U  val);
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*                                      DEFINED IN PRODUCT'S BSP
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                          CPU_TS_TmrInit()
N*
N* Description : Initialize & start CPU timestamp timer.
N*
N* Argument(s) : none.
N*
N* Return(s)   : none.
N*
N* Caller(s)   : CPU_TS_Init().
N*
N*               This function is an INTERNAL CPU module function & MUST be implemented by application/
N*               BSP function(s) [see Note #1] but MUST NOT be called by application function(s).
N*
N* Note(s)     : (1) CPU_TS_TmrInit() is an application/BSP function that MUST be defined by the developer 
N*                   if either of the following CPU features is enabled :
N*
N*                   (a) CPU timestamps
N*                   (b) CPU interrupts disabled time measurements
N*
N*                   See 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
N*                     & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1a'.
N*
N*               (2) (a) Timer count values MUST be returned via word-size-configurable 'CPU_TS_TMR' 
N*                       data type.
N*
N*                       (1) If timer has more bits, truncate timer values' higher-order bits greater 
N*                           than the configured 'CPU_TS_TMR' timestamp timer data type word size.
N*
N*                       (2) Since the timer MUST NOT have less bits than the configured 'CPU_TS_TMR' 
N*                           timestamp timer data type word size; 'CPU_CFG_TS_TMR_SIZE' MUST be 
N*                           configured so that ALL bits in 'CPU_TS_TMR' data type are significant.
N*
N*                           In other words, if timer size is not a binary-multiple of 8-bit octets 
N*                           (e.g. 20-bits or even 24-bits), then the next lower, binary-multiple 
N*                           octet word size SHOULD be configured (e.g. to 16-bits).  However, the 
N*                           minimum supported word size for CPU timestamp timers is 8-bits.
N*
N*                       See also 'cpu_cfg.h   CPU TIMESTAMP CONFIGURATION  Note #2'
N*                              & 'cpu_core.h  CPU TIMESTAMP DATA TYPES     Note #1'.
N*
N*                   (b) Timer SHOULD be an 'up'  counter whose values increase with each time count.
N*
N*                   (c) When applicable, timer period SHOULD be less than the typical measured time 
N*                       but MUST be less than the maximum measured time; otherwise, timer resolution 
N*                       inadequate to measure desired times.
N*
N*                   See also 'CPU_TS_TmrRd()  Note #2'.
N*********************************************************************************************************
N*/
N
N#if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
X#if (1u == 1u)
Nvoid  CPU_TS_TmrInit(void);
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                           CPU_TS_TmrRd()
N*
N* Description : Get current CPU timestamp timer count value.
N*
N* Argument(s) : none.
N*
N* Return(s)   : Timestamp timer count (see Notes #2a & #2b).
N*
N* Caller(s)   : CPU_TS_Init(),
N*               CPU_TS_Get32(),
N*               CPU_TS_Get64(),
N*               CPU_IntDisMeasStart(),
N*               CPU_IntDisMeasStop().
N*
N*               This function is an INTERNAL CPU module function & MUST be implemented by application/
N*               BSP function(s) [see Note #1] but SHOULD NOT be called by application function(s).
N*
N* Note(s)     : (1) CPU_TS_TmrRd() is an application/BSP function that MUST be defined by the developer 
N*                   if either of the following CPU features is enabled :
N*
N*                   (a) CPU timestamps
N*                   (b) CPU interrupts disabled time measurements
N*
N*                   See 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
N*                     & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1a'.
N*
N*               (2) (a) Timer count values MUST be returned via word-size-configurable 'CPU_TS_TMR' 
N*                       data type.
N*
N*                       (1) If timer has more bits, truncate timer values' higher-order bits greater 
N*                           than the configured 'CPU_TS_TMR' timestamp timer data type word size.
N*
N*                       (2) Since the timer MUST NOT have less bits than the configured 'CPU_TS_TMR' 
N*                           timestamp timer data type word size; 'CPU_CFG_TS_TMR_SIZE' MUST be 
N*                           configured so that ALL bits in 'CPU_TS_TMR' data type are significant.
N*
N*                           In other words, if timer size is not a binary-multiple of 8-bit octets 
N*                           (e.g. 20-bits or even 24-bits), then the next lower, binary-multiple 
N*                           octet word size SHOULD be configured (e.g. to 16-bits).  However, the 
N*                           minimum supported word size for CPU timestamp timers is 8-bits.
N*
N*                       See also 'cpu_cfg.h   CPU TIMESTAMP CONFIGURATION  Note #2'
N*                              & 'cpu_core.h  CPU TIMESTAMP DATA TYPES     Note #1'.
N*
N*                   (b) Timer SHOULD be an 'up'  counter whose values increase with each time count.
N*
N*                       (1) If timer is a 'down' counter whose values decrease with each time count,
N*                           then the returned timer value MUST be ones-complemented.
N*
N*                   (c) (1) When applicable, the amount of time measured by CPU timestamps is 
N*                           calculated by either of the following equations :
N*
N*                           (A) Time measured  =  Number timer counts  *  Timer period
N*
N*                                   where
N*
N*                                       Number timer counts     Number of timer counts measured 
N*                                       Timer period            Timer's period in some units of 
N*                                                                   (fractional) seconds
N*                                       Time measured           Amount of time measured, in same 
N*                                                                   units of (fractional) seconds 
N*                                                                   as the Timer period
N*
N*                                                  Number timer counts
N*                           (B) Time measured  =  ---------------------
N*                                                    Timer frequency
N*
N*                                   where
N*
N*                                       Number timer counts     Number of timer counts measured
N*                                       Timer frequency         Timer's frequency in some units 
N*                                                                   of counts per second
N*                                       Time measured           Amount of time measured, in seconds
N*
N*                       (2) Timer period SHOULD be less than the typical measured time but MUST be less 
N*                           than the maximum measured time; otherwise, timer resolution inadequate to 
N*                           measure desired times.
N*********************************************************************************************************
N*/
N
N#if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
X#if (1u == 1u)
NCPU_TS_TMR  CPU_TS_TmrRd(void);
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         CPU_TSxx_to_uSec()
N*
N* Description : Convert a 32-/64-bit CPU timestamp from timer counts to microseconds.
N*
N* Argument(s) : ts_cnts   CPU timestamp (in timestamp timer counts [see Note #2aA]).
N*
N* Return(s)   : Converted CPU timestamp (in microseconds           [see Note #2aD]).
N*
N* Caller(s)   : Application.
N*
N*               This function is an (optional) CPU module application programming interface (API) 
N*               function which MAY be implemented by application/BSP function(s) [see Note #1] & 
N*               MAY be called by application function(s).
N*
N* Note(s)     : (1) CPU_TS32_to_uSec()/CPU_TS64_to_uSec() are application/BSP functions that MAY be 
N*                   optionally defined by the developer when either of the following CPU features is 
N*                   enabled :
N*
N*                   (a) CPU timestamps
N*                   (b) CPU interrupts disabled time measurements
N*
N*                   See 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
N*                     & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1a'.
N*
N*               (2) (a) The amount of time measured by CPU timestamps is calculated by either of 
N*                       the following equations :
N*
N*                                                                        10^6 microseconds
N*                       (1) Time measured  =   Number timer counts   *  -------------------  *  Timer period
N*                                                                            1 second
N*
N*                                              Number timer counts       10^6 microseconds
N*                       (2) Time measured  =  ---------------------  *  -------------------
N*                                                Timer frequency             1 second
N*
N*                               where
N*
N*                                   (A) Number timer counts     Number of timer counts measured
N*                                   (B) Timer frequency         Timer's frequency in some units 
N*                                                                   of counts per second
N*                                   (C) Timer period            Timer's period in some units of 
N*                                                                   (fractional)  seconds
N*                                   (D) Time measured           Amount of time measured, 
N*                                                                   in microseconds
N*
N*                   (b) Timer period SHOULD be less than the typical measured time but MUST be less 
N*                       than the maximum measured time; otherwise, timer resolution inadequate to 
N*                       measure desired times.
N*
N*                   (c) Specific implementations may convert any number of CPU_TS32 or CPU_TS64 bits 
N*                       -- up to 32 or 64, respectively -- into microseconds.
N*********************************************************************************************************
N*/
N
N#if (CPU_CFG_TS_32_EN == DEF_ENABLED)
X#if (1u == 1u)
NCPU_INT64U  CPU_TS32_to_uSec(CPU_TS32  ts_cnts);
N#endif
N
N#if (CPU_CFG_TS_64_EN == DEF_ENABLED)
X#if (0u == 1u)
SCPU_INT64U  CPU_TS64_to_uSec(CPU_TS64  ts_cnts);
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N#ifndef  CPU_CFG_NAME_EN
S#error  "CPU_CFG_NAME_EN                       not #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  DEF_ENABLED ]           "
S#error  "                                [     ||  DEF_DISABLED]           "
S
S#elif  ((CPU_CFG_NAME_EN != DEF_ENABLED ) && \
S        (CPU_CFG_NAME_EN != DEF_DISABLED))
X#elif  ((1u != 1u ) &&         (1u != 0u))
S#error  "CPU_CFG_NAME_EN                 illegally #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  DEF_ENABLED ]           "
S#error  "                                [     ||  DEF_DISABLED]           "
S
S
N#elif   (CPU_CFG_NAME_EN == DEF_ENABLED)
X#elif   (1u == 1u)
N
N#ifndef  CPU_CFG_NAME_SIZE
S#error  "CPU_CFG_NAME_SIZE                     not #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  >=   1]                 "
S#error  "                                [     &&  <= 255]                 "
S
S#elif   (DEF_CHK_VAL(CPU_CFG_NAME_SIZE,            \
S                     1,                            \
S                     DEF_INT_08U_MAX_VAL) != DEF_OK)
X#elif   (((((((!(((16) >= 1) && ((1) < 1))) && ((((1) >= 1) && ((16) < 1)) || ((16) < (1)))) ? 0u : 1u) == 0u) || ((((!(((255u) >= 1) && ((16) < 1))) && ((((16) >= 1) && ((255u) < 1)) || ((16) > (255u)))) ? 0u : 1u) == 0u)) ? 0u : 1u) != 1u)
S#error  "CPU_CFG_NAME_SIZE               illegally #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  >=   1]                 "
S#error  "                                [     &&  <= 255]                 "
N#endif
N
N#endif
N
N
N
N
N#ifndef  CPU_CFG_TS_32_EN
S#error  "CPU_CFG_TS_32_EN                      not #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  DEF_DISABLED]           "
S#error  "                                [     ||  DEF_ENABLED ]           "
S
S#elif  ((CPU_CFG_TS_32_EN != DEF_DISABLED) && \
S        (CPU_CFG_TS_32_EN != DEF_ENABLED ))
X#elif  ((1u != 0u) &&         (1u != 1u ))
S#error  "CPU_CFG_TS_32_EN                illegally #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  DEF_DISABLED]           "
S#error  "                                [     ||  DEF_ENABLED ]           "
S
N#endif
N
N
N#ifndef  CPU_CFG_TS_64_EN
S#error  "CPU_CFG_TS_64_EN                      not #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  DEF_DISABLED]           "
S#error  "                                [     ||  DEF_ENABLED ]           "
S
S#elif  ((CPU_CFG_TS_64_EN != DEF_DISABLED) && \
S        (CPU_CFG_TS_64_EN != DEF_ENABLED ))
X#elif  ((0u != 0u) &&         (0u != 1u ))
S#error  "CPU_CFG_TS_64_EN                illegally #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  DEF_DISABLED]           "
S#error  "                                [     ||  DEF_ENABLED ]           "
S
N#endif
N
N                                                                /* Correctly configured in 'cpu_core.h'; DO NOT MODIFY. */
N#ifndef  CPU_CFG_TS_EN
S#error  "CPU_CFG_TS_EN                         not #define'd in 'cpu_core.h'"
S#error  "                                [MUST be  DEF_DISABLED]            "
S#error  "                                [     ||  DEF_ENABLED ]            "
S
S#elif  ((CPU_CFG_TS_EN != DEF_DISABLED) && \
S        (CPU_CFG_TS_EN != DEF_ENABLED ))
X#elif  ((1u != 0u) &&         (1u != 1u ))
S#error  "CPU_CFG_TS_EN                   illegally #define'd in 'cpu_core.h'"
S#error  "                                [MUST be  DEF_DISABLED]            "
S#error  "                                [     ||  DEF_ENABLED ]            "
S
N#endif
N
N
N/*$PAGE*/
N                                                                /* Correctly configured in 'cpu_core.h'; DO NOT MODIFY. */
N#ifndef  CPU_CFG_TS_TMR_EN
S#error  "CPU_CFG_TS_TMR_EN                     not #define'd in 'cpu_core.h'"
S#error  "                                [MUST be  DEF_DISABLED]            "
S#error  "                                [     ||  DEF_ENABLED ]            "
S
S#elif  ((CPU_CFG_TS_TMR_EN != DEF_DISABLED) && \
S        (CPU_CFG_TS_TMR_EN != DEF_ENABLED ))
X#elif  ((1u != 0u) &&         (1u != 1u ))
S#error  "CPU_CFG_TS_TMR_EN               illegally #define'd in 'cpu_core.h'"
S#error  "                                [MUST be  DEF_DISABLED]            "
S#error  "                                [     ||  DEF_ENABLED ]            "
S
S
N#elif   (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
X#elif   (1u == 1u)
N
N#ifndef  CPU_CFG_TS_TMR_SIZE
S#error  "CPU_CFG_TS_TMR_SIZE                   not #define'd in 'cpu_cfg.h'       "
S#error  "                                [MUST be  CPU_WORD_SIZE_08   8-bit timer]"
S#error  "                                [     ||  CPU_WORD_SIZE_16  16-bit timer]"
S#error  "                                [     ||  CPU_WORD_SIZE_32  32-bit timer]"
S#error  "                                [     ||  CPU_WORD_SIZE_64  64-bit timer]"
S
S#elif  ((CPU_CFG_TS_TMR_SIZE != CPU_WORD_SIZE_08) && \
S        (CPU_CFG_TS_TMR_SIZE != CPU_WORD_SIZE_16) && \
S        (CPU_CFG_TS_TMR_SIZE != CPU_WORD_SIZE_32) && \
S        (CPU_CFG_TS_TMR_SIZE != CPU_WORD_SIZE_64))
X#elif  ((4 != 1) &&         (4 != 2) &&         (4 != 4) &&         (4 != 8))
S#error  "CPU_CFG_TS_TMR_SIZE             illegally #define'd in 'cpu_cfg.h'       "
S#error  "                                [MUST be  CPU_WORD_SIZE_08   8-bit timer]"
S#error  "                                [     ||  CPU_WORD_SIZE_16  16-bit timer]"
S#error  "                                [     ||  CPU_WORD_SIZE_32  32-bit timer]"
S#error  "                                [     ||  CPU_WORD_SIZE_64  64-bit timer]"
N#endif
N
N#endif
N
N
N
N#ifndef  CPU_CFG_INT_DIS_MEAS_EN
N#if 0                                                           /* Optionally configured in 'cpu_cfg.h'; DO NOT MODIFY. */
S#error  "CPU_CFG_INT_DIS_MEAS_EN               not #define'd in 'cpu_cfg.h'"
N#endif
N
N#else
S
S#ifndef  CPU_CFG_INT_DIS_MEAS_OVRHD_NBR
S#error  "CPU_CFG_INT_DIS_MEAS_OVRHD_NBR        not #define'd in 'cpu_cfg.h' "
S#error  "                                [MUST be  >= CPU_TIME_MEAS_NBR_MIN]"
S#error  "                                [     ||  <= CPU_TIME_MEAS_NBR_MAX]"
S
S#elif   (DEF_CHK_VAL(CPU_CFG_INT_DIS_MEAS_OVRHD_NBR, \
S                     CPU_TIME_MEAS_NBR_MIN,          \
S                     CPU_TIME_MEAS_NBR_MAX) != DEF_OK)
X#elif   (DEF_CHK_VAL(CPU_CFG_INT_DIS_MEAS_OVRHD_NBR,                      CPU_TIME_MEAS_NBR_MIN,                               CPU_TIME_MEAS_NBR_MAX) != DEF_OK)
S#error  "CPU_CFG_INT_DIS_MEAS_OVRHD_NBR  illegally #define'd in 'cpu_cfg.h' "
S#error  "                                [MUST be  >= CPU_TIME_MEAS_NBR_MIN]"
S#error  "                                [     ||  <= CPU_TIME_MEAS_NBR_MAX]"
S
S#endif
S
N#endif
N
N
N
N
N#ifndef  CPU_CFG_LEAD_ZEROS_ASM_PRESENT
S#if 0                                                           /* Optionally configured in 'cpu_cfg.h'; DO NOT MODIFY. */
S#error  "CPU_CFG_LEAD_ZEROS_ASM_PRESENT        not #define'd in 'cpu.h'/'cpu_cfg.h'"
S#endif
N#endif
N
N
N#ifndef  CPU_CFG_TRAIL_ZEROS_ASM_PRESENT
S#if 0                                                           /* Optionally configured in 'cpu_cfg.h'; DO NOT MODIFY. */
S#error  "CPU_CFG_TRAIL_ZEROS_ASM_PRESENT       not #define'd in 'cpu.h'/'cpu_cfg.h'"
S#endif
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                    CPU PORT CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N#ifndef  CPU_CFG_ADDR_SIZE
S#error  "CPU_CFG_ADDR_SIZE      not #define'd in 'cpu.h'"
N#endif
N
N#ifndef  CPU_CFG_DATA_SIZE
S#error  "CPU_CFG_DATA_SIZE      not #define'd in 'cpu.h'"
N#endif
N
N#ifndef  CPU_CFG_DATA_SIZE_MAX
S#error  "CPU_CFG_DATA_SIZE_MAX  not #define'd in 'cpu.h'"
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                    LIBRARY CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N                                                                /* See 'cpu_core.h  Note #1a'.                          */
N#if     (LIB_VERSION < 13500u)
X#if     (13700u < 13500u)
S#error  "LIB_VERSION  [SHOULD be >= V1.35.00]"
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*
N* Note(s) : (1) See 'cpu_core.h  MODULE'.
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of CPU core module include.                      */
N
L 18 "..\App\app_cfg.h" 2
N
N/*
N*********************************************************************************************************
N*                                       MODULE ENABLE / DISABLE
N*********************************************************************************************************
N*/
N#define APP_CFG_SERIAL_EN  DEF_ENABLED
N///允许 Tick 调用App_TimeTickFunc()
N#define 	APP_CFG_TICK_FUNC			DEF_ENABLED
N
N
N
N
N//////////////////////////////////////////////////////////////////
N///						允许哪些 USART
N//////////////////////////////////////////////////////////////////
N
N#define 	APP_USART_1_ENABLE			DEF_ENABLED
N
N#define 	APP_USART_2_ENABLE			DEF_DISABLED
N
N#define 	APP_USART_3_ENABLE			DEF_DISABLED
N
N#define 	APP_USART_4_ENABLE			DEF_DISABLED
N
N#define 	APP_USART_5_ENABLE			DEF_DISABLED
N
N#define 	APP_USART_6_ENABLE			DEF_ENABLED
N
N
N//////////////////////////////////////////////////////////////////
N///							I2C
N//////////////////////////////////////////////////////////////////
N
N#define 	APP_I2C_1_ENABLE			DEF_ENABLED
N
N#define 	APP_I2C_2_ENABLE			DEF_DISABLED
N#define		APP_I2C_3_ENABLE			DEF_DISABLED
N
N//////////////////////////////////////////////////////////////////
N///							SPI
N//////////////////////////////////////////////////////////////////
N#define		APP_SPI_1_ENABLE			DEF_DISABLED
N#define 	APP_SPI_2_ENABLE			DEF_DISABLED
N#define		APP_SPI_3_ENABLE			DEF_DISABLED
N
N
N//////////////////////////////////////////////////////////////////
N///							CAN
N//////////////////////////////////////////////////////////////////
N#define		APP_CAN_1_ENABLE			DEF_DISABLED
N#define 	APP_CAN_2_ENABLE			DEF_DISABLED
N
N//////////////////////////////////////////////////////////////////
N///							ADC
N//////////////////////////////////////////////////////////////////
N#define 	APP_ADC_ENABLE				DEF_ENABLED
N
N//////////////////////////////////////////////////////////////////
N///							DAC
N//////////////////////////////////////////////////////////////////
N#define 	APP_DAC_ENABLE				DEF_DISABLED
N
N//////////////////////////////////////////////////////////////////
N///							RTC
N//////////////////////////////////////////////////////////////////
N#define 	APP_RTC_ENABLE				DEF_DISABLED
N
N//////////////////////////////////////////////////////////////////
N///							USB
N//////////////////////////////////////////////////////////////////
N#define 	APP_USB_HOST_ENABLE			DEF_DISABLED
N
N//////////////////////////////////////////////////////////////////
N///							SD
N//////////////////////////////////////////////////////////////////
N#define 	APP_SD_ENABLE				DEF_DISABLED
N
N
N//////////////////////////////////////////////////////////////////
N///							SRAM
N//////////////////////////////////////////////////////////////////
N#define 	APP_SRAM_ENABLE				DEF_DISABLED
N
N//////////////////////////////////////////////////////////////////
N///						FILE SYSTEM
N//////////////////////////////////////////////////////////////////
N#define		APP_FILE_SYSTEM_ENABLE		DEF_DISABLED
N
N//////////////////////////////////////////////////////////////////
N///						EXTI9_5
N//////////////////////////////////////////////////////////////////
N#define		APP_EXTI9_5_ENABLE			DEF_DISABLED
N
N
N/////////////////////////////////////////////////
N///			根据需要设置波特率
N/////////////////////////////////////////////////
N///COM1
N#define USART_1_BAUD_RATE				115200L
N///COM2
N#define USART_2_BAUD_RATE				115200L
N///COM3
N#define USART_3_BAUD_RATE				115200L
N///COM4
N#define USART_4_BAUD_RATE				115200L
N///COM5
N#define USART_5_BAUD_RATE				115200L
N///COM6
N#define USART_6_BAUD_RATE				115200L
N
N
N
N
N///是否多处理器通信方式：
N#if defined JLB_CPU_SAMPLE
X#if 0L
S
S#define USART_3_MULTI_COMMUNICATION
S#define USART_3_MULTI_COMMUNICATION_ADDRESS		0x39
S
S#define USART_4_MULTI_COMMUNICATION
S#define USART_4_MULTI_COMMUNICATION_ADDRESS		0x38
S
N#endif
N
N /* Maximum timeout value */
N///数据定时
N#define USART1_TIMEOUT_MAX              10000
N#define USART2_TIMEOUT_MAX              10000
N#define USART3_TIMEOUT_MAX              10000
N#define USART4_TIMEOUT_MAX              10000
N#define USART5_TIMEOUT_MAX              10000
N#define USART6_TIMEOUT_MAX              10000
N
N
N
N
N/////////////////////////////////////////////////
N///			CAN 采样速率
N/////////////////////////////////////////////////
N///CAN1
N#define CAN_1_BAUD_RATE					250000L
N///CAN2
N#define CAN_2_BAUD_RATE					250000L
N
N
N
N/////////////////////////////////////////////////
N///			ADC 采样速率
N/////////////////////////////////////////////////
N///TIM3 定时频率:HZ
N#if defined JLB_CPU_SAMPLE
X#if 0L
S	#define 	TIM3_FREQ	1000L
S#elif defined JLB_CPU_MAIN
X#elif 0L
S	#define 	TIM3_FREQ	12500L
N#else
N	#define 	TIM3_FREQ	12500L
N#endif
N
N
N/////////////////////////////////////////////////
N///			DAC 采样频率
N/////////////////////////////////////////////////
N#define 	TIM6_FREQ	12000L
N
N
N
N
N
N
N
N
N
N
N/*
N*********************************************************************************************************
N*                                            TASK PRIORITIES
N*********************************************************************************************************
N*/
N///起始任务
N#define  APP_TASK_START_PRIO							55u
N
N
N
N
N///ADC处理任务
N#define  APP_TASK_ADC_PRIO								11u
N
N///DAC 处理任务
N#define  APP_TASK_DAC_PRIO								12u
N
N///RTC 处理任务
N#define  APP_TASK_RTC_PRIO								13u
N
N///USB 处理任务
N#define  APP_TASK_USB_PRIO								14u
N
N
N///CAN 处理任务
N#define  APP_TASK_CAN_1_PRIO							15u
N#define  APP_TASK_CAN_2_PRIO							16u
N
N
N
N
N///串口收发任务
N#define	 APP_TASK_USART_1_PRIO							21u
N#define	 APP_TASK_USART_2_PRIO							22u
N#define	 APP_TASK_USART_3_PRIO							23u
N#define	 APP_TASK_USART_4_PRIO							24u
N#define	 APP_TASK_USART_5_PRIO							25u
N#define	 APP_TASK_USART_6_PRIO							26u
N
N
N///I2C 处理任务
N#define  APP_TASK_I2C_1_PRIO							27u
N#define  APP_TASK_I2C_2_PRIO							28u
N#define  APP_TASK_I2C_3_PRIO							29u
N
N///SPI 处理任务
N#define  APP_TASK_SPI_1_PRIO							30u
N#define  APP_TASK_SPI_2_PRIO							31u
N#define  APP_TASK_SPI_3_PRIO							32u
N
N
N
N
N///SD 处理任务
N#define  APP_TASK_SD_PRIO								33u
N
N
N///系统定时任务
N#define  OS_TASK_TMR_PRIO                       		(OS_LOWEST_PRIO - 2)
N
N
N/*
N*********************************************************************************************************
N*                                            TASK STACK SIZES
N*                             Size of the task stacks (# of OS_STK entries)
N*********************************************************************************************************
N*/
N///起始任务
N#define  APP_TASK_START_STK_SIZE                        256u
N
N///串口收发任务
N#define	APP_TASK_USART_1_STK_SIZE						1024u
N#define	APP_TASK_USART_2_STK_SIZE						512u
N#define	APP_TASK_USART_3_STK_SIZE						512u
N#define	APP_TASK_USART_4_STK_SIZE						512u
N#define	APP_TASK_USART_5_STK_SIZE						512u
N#define	APP_TASK_USART_6_STK_SIZE						512u
N
N///ADC处理任务
N#define APP_TASK_ADC_STK_SIZE							512u
N
N
N///I2C 处理任务
N#define APP_TASK_I2C_1_STK_SIZE							512u
N#define APP_TASK_I2C_2_STK_SIZE							512u
N#define APP_TASK_I2C_3_STK_SIZE							512u
N
N///SPI 处理任务
N#define APP_TASK_SPI_1_STK_SIZE							512u
N#define APP_TASK_SPI_2_STK_SIZE							512u
N#define APP_TASK_SPI_3_STK_SIZE							512u
N
N
N///CAN 处理任务
N#define  APP_TASK_CAN_1_STK_SIZE						512u
N#define  APP_TASK_CAN_2_STK_SIZE						512u
N
N
N///RTC 处理任务
N#define APP_TASK_RTC_STK_SIZE							512u
N
N///
N///DAC 处理任务
N#define APP_TASK_DAC_STK_SIZE							512u
N
N///USB 处理任务
N#define APP_TASK_USB_STK_SIZE							512u
N
N///SD 处理任务
N#define APP_TASK_SD_STK_SIZE							512u
N
N
N
N/*
N*********************************************************************************************************
N*                                            BSP CFG
N*********************************************************************************************************
N*/
N
N#define  BSP_CFG_SER_COMM_SEL                   BSP_SER_COMM_UART_01
N
N
N
N
N/*
N*********************************************************************************************************
N*                                     TRACE / DEBUG CONFIGURATION
N*********************************************************************************************************
N*/
N#if 0
S#define  TRACE_LEVEL_OFF                                0
S#define  TRACE_LEVEL_INFO                               1
S#define  TRACE_LEVEL_DBG                                2
N#endif
N
N#define  APP_TRACE_LEVEL                                TRACE_LEVEL_INFO
N
N#if (APP_CFG_SERIAL_EN == DEF_ENABLED)
X#if (1u == 1u)
N#define  APP_TRACE                                      BSP_Ser_Printf
N#else
S#define  APP_TRACE                                      printf
N#endif
N
N#define  APP_TRACE_INFO(x)               ((APP_TRACE_LEVEL >= TRACE_LEVEL_INFO)  ? (void)(APP_TRACE x) : (void)0)
N#define  APP_TRACE_DBG(x)                ((APP_TRACE_LEVEL >= TRACE_LEVEL_DBG)   ? (void)(APP_TRACE x) : (void)0)
N
N#endif
N
L 45 "..\..\uCOS-II\Source\ucos_ii.h" 2
N#include <os_cfg.h>
L 1 "..\App\os_cfg.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/OS-II
N*                                          The Real-Time Kernel
N*                                  uC/OS-II Configuration File for V2.9x
N*
N*                               (c) Copyright 2005-2010, Micrium, Weston, FL
N*                                          All Rights Reserved
N*
N*
N* File    : OS_CFG.H
N* By      : Jean J. Labrosse
N* Version : V2.92
N*
N* LICENSING TERMS:
N* ---------------
N*   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
N* If you plan on using  uC/OS-II  in a commercial product you need to contact Micrim to properly license
N* its use in your product. We provide ALL the source code for your convenience and to help you experience
N* uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
N* licensing fee.
N*********************************************************************************************************
N*/
N
N#ifndef OS_CFG_H
N#define OS_CFG_H
N
N
N                                       /* ---------------------- MISCELLANEOUS ----------------------- */
N#define OS_APP_HOOKS_EN           1u   /* Application-defined hooks are called from the uC/OS-II hooks */
N#define OS_ARG_CHK_EN             0u   /* Enable (1) or Disable (0) argument checking                  */
N#define OS_CPU_HOOKS_EN           1u   /* uC/OS-II hooks are found in the processor port files         */
N
N#define OS_DEBUG_EN               1u   /* Enable(1) debug variables                                    */
N
N#define OS_EVENT_MULTI_EN         1u   /* Include code for OSEventPendMulti()                          */
N#define OS_EVENT_NAME_EN          1u   /* Enable names for Sem, Mutex, Mbox and Q                      */
N
N#define OS_LOWEST_PRIO           63u   /* Defines the lowest priority that can be assigned ...         */
N                                       /* ... MUST NEVER be higher than 254!                           */
N
N#define OS_MAX_EVENTS            80u   /* Max. number of event control blocks in your application      */
N#define OS_MAX_FLAGS              5u   /* Max. number of Event Flag Groups    in your application      */
N#define OS_MAX_MEM_PART           5u   /* Max. number of memory partitions                             */
N#define OS_MAX_QS                 4u   /* Max. number of queue control blocks in your application      */
N#define OS_MAX_TASKS             20u   /* Max. number of tasks in your application, MUST be >= 2       */
N
N#define OS_SCHED_LOCK_EN          1u   /* Include code for OSSchedLock() and OSSchedUnlock()           */
N
N#define OS_TICK_STEP_EN           1u   /* Enable tick stepping feature for uC/OS-View                  */
N#define OS_TICKS_PER_SEC       1000u   /* Set the number of ticks in one second                        */
N
N
N                                       /* --------------------- TASK STACK SIZE ---------------------- */
N#define OS_TASK_TMR_STK_SIZE    128u   /* Timer      task stack size (# of OS_STK wide entries)        */
N#define OS_TASK_STAT_STK_SIZE   128u   /* Statistics task stack size (# of OS_STK wide entries)        */
N#define OS_TASK_IDLE_STK_SIZE   128u   /* Idle       task stack size (# of OS_STK wide entries)        */
N
N
N                                       /* --------------------- TASK MANAGEMENT ---------------------- */
N#define OS_TASK_CHANGE_PRIO_EN    1u   /*     Include code for OSTaskChangePrio()                      */
N#define OS_TASK_CREATE_EN         1u   /*     Include code for OSTaskCreate()                          */
N#define OS_TASK_CREATE_EXT_EN     1u   /*     Include code for OSTaskCreateExt()                       */
N#define OS_TASK_DEL_EN            1u   /*     Include code for OSTaskDel()                             */
N#define OS_TASK_NAME_EN           1u   /*     Enable task names                                        */
N#define OS_TASK_PROFILE_EN        1u   /*     Include variables in OS_TCB for profiling                */
N#define OS_TASK_QUERY_EN          1u   /*     Include code for OSTaskQuery()                           */
N#define OS_TASK_REG_TBL_SIZE      1u   /*     Size of task variables array (#of INT32U entries)        */
N#define OS_TASK_STAT_EN           1u   /*     Enable (1) or Disable(0) the statistics task             */
N#define OS_TASK_STAT_STK_CHK_EN   1u   /*     Check task stacks from statistic task                    */
N#define OS_TASK_SUSPEND_EN        1u   /*     Include code for OSTaskSuspend() and OSTaskResume()      */
N#define OS_TASK_SW_HOOK_EN        1u   /*     Include code for OSTaskSwHook()                          */
N
N
N                                       /* ----------------------- EVENT FLAGS ------------------------ */
N#define OS_FLAG_EN                1u   /* Enable (1) or Disable (0) code generation for EVENT FLAGS    */
N#define OS_FLAG_ACCEPT_EN         1u   /*     Include code for OSFlagAccept()                          */
N#define OS_FLAG_DEL_EN            1u   /*     Include code for OSFlagDel()                             */
N#define OS_FLAG_NAME_EN           1u   /*     Enable names for event flag group                        */
N#define OS_FLAG_QUERY_EN          1u   /*     Include code for OSFlagQuery()                           */
N#define OS_FLAG_WAIT_CLR_EN       1u   /* Include code for Wait on Clear EVENT FLAGS                   */
N#define OS_FLAGS_NBITS           16u   /* Size in #bits of OS_FLAGS data type (8, 16 or 32)            */
N
N
N                                       /* -------------------- MESSAGE MAILBOXES --------------------- */
N#define OS_MBOX_EN                1u   /* Enable (1) or Disable (0) code generation for MAILBOXES      */
N#define OS_MBOX_ACCEPT_EN         1u   /*     Include code for OSMboxAccept()                          */
N#define OS_MBOX_DEL_EN            1u   /*     Include code for OSMboxDel()                             */
N#define OS_MBOX_PEND_ABORT_EN     1u   /*     Include code for OSMboxPendAbort()                       */
N#define OS_MBOX_POST_EN           1u   /*     Include code for OSMboxPost()                            */
N#define OS_MBOX_POST_OPT_EN       1u   /*     Include code for OSMboxPostOpt()                         */
N#define OS_MBOX_QUERY_EN          1u   /*     Include code for OSMboxQuery()                           */
N
N
N                                       /* --------------------- MEMORY MANAGEMENT -------------------- */
N#define OS_MEM_EN                 1u   /* Enable (1) or Disable (0) code generation for MEMORY MANAGER */
N#define OS_MEM_NAME_EN            1u   /*     Enable memory partition names                            */
N#define OS_MEM_QUERY_EN           1u   /*     Include code for OSMemQuery()                            */
N
N
N                                       /* ---------------- MUTUAL EXCLUSION SEMAPHORES --------------- */
N#define OS_MUTEX_EN               1u   /* Enable (1) or Disable (0) code generation for MUTEX          */
N#define OS_MUTEX_ACCEPT_EN        1u   /*     Include code for OSMutexAccept()                         */
N#define OS_MUTEX_DEL_EN           1u   /*     Include code for OSMutexDel()                            */
N#define OS_MUTEX_QUERY_EN         1u   /*     Include code for OSMutexQuery()                          */
N
N
N                                       /* ---------------------- MESSAGE QUEUES ---------------------- */
N#define OS_Q_EN                   1u   /* Enable (1) or Disable (0) code generation for QUEUES         */
N#define OS_Q_ACCEPT_EN            1u   /*     Include code for OSQAccept()                             */
N#define OS_Q_DEL_EN               1u   /*     Include code for OSQDel()                                */
N#define OS_Q_FLUSH_EN             1u   /*     Include code for OSQFlush()                              */
N#define OS_Q_PEND_ABORT_EN        1u   /*     Include code for OSQPendAbort()                          */
N#define OS_Q_POST_EN              1u   /*     Include code for OSQPost()                               */
N#define OS_Q_POST_FRONT_EN        1u   /*     Include code for OSQPostFront()                          */
N#define OS_Q_POST_OPT_EN          1u   /*     Include code for OSQPostOpt()                            */
N#define OS_Q_QUERY_EN             1u   /*     Include code for OSQQuery()                              */
N
N
N                                       /* ------------------------ SEMAPHORES ------------------------ */
N#define OS_SEM_EN                 1u   /* Enable (1) or Disable (0) code generation for SEMAPHORES     */
N#define OS_SEM_ACCEPT_EN          1u   /*    Include code for OSSemAccept()                            */
N#define OS_SEM_DEL_EN             1u   /*    Include code for OSSemDel()                               */
N#define OS_SEM_PEND_ABORT_EN      1u   /*    Include code for OSSemPendAbort()                         */
N#define OS_SEM_QUERY_EN           1u   /*    Include code for OSSemQuery()                             */
N#define OS_SEM_SET_EN             1u   /*    Include code for OSSemSet()                               */
N
N
N                                       /* --------------------- TIME MANAGEMENT ---------------------- */
N#define OS_TIME_DLY_HMSM_EN       1u   /*     Include code for OSTimeDlyHMSM()                         */
N#define OS_TIME_DLY_RESUME_EN     1u   /*     Include code for OSTimeDlyResume()                       */
N#define OS_TIME_GET_SET_EN        1u   /*     Include code for OSTimeGet() and OSTimeSet()             */
N#define OS_TIME_TICK_HOOK_EN      1u   /*     Include code for OSTimeTickHook()                        */
N
N
N                                       /* --------------------- TIMER MANAGEMENT --------------------- */
N#define OS_TMR_EN                 1u   /* Enable (1) or Disable (0) code generation for TIMERS         */
N#define OS_TMR_CFG_MAX           16u   /*     Maximum number of timers                                 */
N#define OS_TMR_CFG_NAME_EN        1u   /*     Determine timer names                                    */
N#define OS_TMR_CFG_WHEEL_SIZE     8u   /*     Size of timer wheel (#Spokes)                            */
N#define OS_TMR_CFG_TICKS_PER_SEC 10u   /*     Rate at which timer management task runs (Hz)            */
N
N#endif
L 46 "..\..\uCOS-II\Source\ucos_ii.h" 2
N#include <os_cpu.h>
L 1 "..\..\uCOS-II\Ports\ARM-Cortex-M3\os_cpu.h" 1
N/*
N*********************************************************************************************************
N*                                               uC/OS-II
N*                                         The Real-Time Kernel
N*
N*
N*                                (c) Copyright 2006, Micrium, Weston, FL
N*                                          All Rights Reserved
N*
N*                                           ARM Cortex-M3 Port
N*
N* File      : OS_CPU.H
N* Version   : V2.89
N* By        : Jean J. Labrosse
N*             Brian Nagel
N*
N* For       : ARMv7M Cortex-M3
N* Mode      : Thumb2
N* Toolchain : RealView Development Suite
N*             RealView Microcontroller Development Kit (MDK)
N*             ARM Developer Suite (ADS)
N*             Keil uVision
N*********************************************************************************************************
N*/
N
N#ifndef  OS_CPU_H
N#define  OS_CPU_H
N
N
N#ifdef   OS_CPU_GLOBALS
S#define  OS_CPU_EXT
N#else
N#define  OS_CPU_EXT  extern
N#endif
N
N#ifndef  OS_CPU_EXCEPT_STK_SIZE
N#define  OS_CPU_EXCEPT_STK_SIZE    128u          /* Default exception stack size is 128 OS_STK entries */
N#endif
N
N/*
N*********************************************************************************************************
N*                                              DATA TYPES
N*                                         (Compiler Specific)
N*********************************************************************************************************
N*/
N
Ntypedef unsigned char  BOOLEAN;
Ntypedef unsigned char  INT8U;                    /* Unsigned  8 bit quantity                           */
Ntypedef signed   char  INT8S;                    /* Signed    8 bit quantity                           */
Ntypedef unsigned short INT16U;                   /* Unsigned 16 bit quantity                           */
Ntypedef signed   short INT16S;                   /* Signed   16 bit quantity                           */
Ntypedef unsigned int   INT32U;                   /* Unsigned 32 bit quantity                           */
Ntypedef signed   int   INT32S;                   /* Signed   32 bit quantity                           */
Ntypedef float          FP32;                     /* Single precision floating point                    */
Ntypedef double         FP64;                     /* Double precision floating point                    */
N
Ntypedef unsigned int   OS_STK;                   /* Each stack entry is 32-bit wide                    */
Ntypedef unsigned int   OS_CPU_SR;                /* Define size of CPU status register (PSR = 32 bits) */
N
N/*
N*********************************************************************************************************
N*                                              Cortex-M3
N*                                      Critical Section Management
N*
N* Method #1:  Disable/Enable interrupts using simple instructions.  After critical section, interrupts
N*             will be enabled even if they were disabled before entering the critical section.
N*             NOT IMPLEMENTED
N*
N* Method #2:  Disable/Enable interrupts by preserving the state of interrupts.  In other words, if
N*             interrupts were disabled before entering the critical section, they will be disabled when
N*             leaving the critical section.
N*             NOT IMPLEMENTED
N*
N* Method #3:  Disable/Enable interrupts by preserving the state of interrupts.  Generally speaking you
N*             would store the state of the interrupt disable flag in the local variable 'cpu_sr' and then
N*             disable interrupts.  'cpu_sr' is allocated in all of uC/OS-II's functions that need to
N*             disable interrupts.  You would restore the interrupt disable state by copying back 'cpu_sr'
N*             into the CPU's status register.
N*********************************************************************************************************
N*/
N
N#define  OS_CRITICAL_METHOD   3u
N
N#if OS_CRITICAL_METHOD == 3u
X#if 3u == 3u
N#define  OS_ENTER_CRITICAL()  {cpu_sr = OS_CPU_SR_Save();}
N#define  OS_EXIT_CRITICAL()   {OS_CPU_SR_Restore(cpu_sr);}
N#endif
N
N/*
N*********************************************************************************************************
N*                                        Cortex-M3 Miscellaneous
N*********************************************************************************************************
N*/
N
N#define  OS_STK_GROWTH        1u                  /* Stack grows from HIGH to LOW memory on ARM        */
N
N#define  OS_TASK_SW()         OSCtxSw()
N
N/*
N*********************************************************************************************************
N*                                            GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
NOS_CPU_EXT  OS_STK   OS_CPU_ExceptStk[OS_CPU_EXCEPT_STK_SIZE];
Xextern  OS_STK   OS_CPU_ExceptStk[128u];
NOS_CPU_EXT  OS_STK  *OS_CPU_ExceptStkBase;
Xextern  OS_STK  *OS_CPU_ExceptStkBase;
N
N/*
N*********************************************************************************************************
N*                                              PROTOTYPES
N*********************************************************************************************************
N*/
N
N#if OS_CRITICAL_METHOD == 3u                      /* See OS_CPU_A.ASM                                  */
X#if 3u == 3u                       
NOS_CPU_SR  OS_CPU_SR_Save(void);
Nvoid       OS_CPU_SR_Restore(OS_CPU_SR cpu_sr);
N#endif
N
Nvoid       OSCtxSw(void);
Nvoid       OSIntCtxSw(void);
Nvoid       OSStartHighRdy(void);
N
Nvoid       OS_CPU_PendSVHandler(void);
N
N                                                  /* See OS_CPU_C.C                                    */
Nvoid       OS_CPU_SysTickHandler(void);
Nvoid       OS_CPU_SysTickInit(INT32U  cnts);
N#endif
L 47 "..\..\uCOS-II\Source\ucos_ii.h" 2
N
N/*
N*********************************************************************************************************
N*                                            MISCELLANEOUS
N*********************************************************************************************************
N*/
N
N#ifdef   OS_GLOBALS
S#define  OS_EXT
N#else
N#define  OS_EXT  extern
N#endif
N
N#ifndef  OS_FALSE
N#define  OS_FALSE                       0u
N#endif
N
N#ifndef  OS_TRUE
N#define  OS_TRUE                        1u
N#endif
N
N#define  OS_ASCII_NUL            (INT8U)0
N
N#define  OS_PRIO_SELF                0xFFu              /* Indicate SELF priority                      */
N#define  OS_PRIO_MUTEX_CEIL_DIS      0xFFu              /* Disable mutex priority ceiling promotion    */
N
N#if OS_TASK_STAT_EN > 0u
X#if 1u > 0u
N#define  OS_N_SYS_TASKS                 2u              /* Number of system tasks                      */
N#else
S#define  OS_N_SYS_TASKS                 1u
N#endif
N
N#define  OS_TASK_STAT_PRIO  (OS_LOWEST_PRIO - 1u)       /* Statistic task priority                     */
N#define  OS_TASK_IDLE_PRIO  (OS_LOWEST_PRIO)            /* IDLE      task priority                     */
N
N#if OS_LOWEST_PRIO <= 63u
X#if 63u <= 63u
N#define  OS_EVENT_TBL_SIZE ((OS_LOWEST_PRIO) / 8u + 1u) /* Size of event table                         */
N#define  OS_RDY_TBL_SIZE   ((OS_LOWEST_PRIO) / 8u + 1u) /* Size of ready table                         */
N#else
S#define  OS_EVENT_TBL_SIZE ((OS_LOWEST_PRIO) / 16u + 1u)/* Size of event table                         */
S#define  OS_RDY_TBL_SIZE   ((OS_LOWEST_PRIO) / 16u + 1u)/* Size of ready table                         */
N#endif
N
N#define  OS_TASK_IDLE_ID            65535u              /* ID numbers for Idle, Stat and Timer tasks   */
N#define  OS_TASK_STAT_ID            65534u
N#define  OS_TASK_TMR_ID             65533u
N
N#define  OS_EVENT_EN           (((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u) || (OS_SEM_EN > 0u) || (OS_MUTEX_EN > 0u))
N
N#define  OS_TCB_RESERVED        ((OS_TCB *)1)
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                             TASK STATUS (Bit definition for OSTCBStat)
N*********************************************************************************************************
N*/
N#define  OS_STAT_RDY                 0x00u  /* Ready to run                                            */
N#define  OS_STAT_SEM                 0x01u  /* Pending on semaphore                                    */
N#define  OS_STAT_MBOX                0x02u  /* Pending on mailbox                                      */
N#define  OS_STAT_Q                   0x04u  /* Pending on queue                                        */
N#define  OS_STAT_SUSPEND             0x08u  /* Task is suspended                                       */
N#define  OS_STAT_MUTEX               0x10u  /* Pending on mutual exclusion semaphore                   */
N#define  OS_STAT_FLAG                0x20u  /* Pending on event flag group                             */
N#define  OS_STAT_MULTI               0x80u  /* Pending on multiple events                              */
N
N#define  OS_STAT_PEND_ANY         (OS_STAT_SEM | OS_STAT_MBOX | OS_STAT_Q | OS_STAT_MUTEX | OS_STAT_FLAG)
N
N/*
N*********************************************************************************************************
N*                          TASK PEND STATUS (Status codes for OSTCBStatPend)
N*********************************************************************************************************
N*/
N#define  OS_STAT_PEND_OK                0u  /* Pending status OK, not pending, or pending complete     */
N#define  OS_STAT_PEND_TO                1u  /* Pending timed out                                       */
N#define  OS_STAT_PEND_ABORT             2u  /* Pending aborted                                         */
N
N/*
N*********************************************************************************************************
N*                                           OS_EVENT types
N*********************************************************************************************************
N*/
N#define  OS_EVENT_TYPE_UNUSED           0u
N#define  OS_EVENT_TYPE_MBOX             1u
N#define  OS_EVENT_TYPE_Q                2u
N#define  OS_EVENT_TYPE_SEM              3u
N#define  OS_EVENT_TYPE_MUTEX            4u
N#define  OS_EVENT_TYPE_FLAG             5u
N
N#define  OS_TMR_TYPE                  100u  /* Used to identify Timers ...                             */
N                                            /* ... (Must be different value than OS_EVENT_TYPE_xxx)    */
N
N/*
N*********************************************************************************************************
N*                                             EVENT FLAGS
N*********************************************************************************************************
N*/
N#define  OS_FLAG_WAIT_CLR_ALL           0u  /* Wait for ALL    the bits specified to be CLR (i.e. 0)   */
N#define  OS_FLAG_WAIT_CLR_AND           0u
N
N#define  OS_FLAG_WAIT_CLR_ANY           1u  /* Wait for ANY of the bits specified to be CLR (i.e. 0)   */
N#define  OS_FLAG_WAIT_CLR_OR            1u
N
N#define  OS_FLAG_WAIT_SET_ALL           2u  /* Wait for ALL    the bits specified to be SET (i.e. 1)   */
N#define  OS_FLAG_WAIT_SET_AND           2u
N
N#define  OS_FLAG_WAIT_SET_ANY           3u  /* Wait for ANY of the bits specified to be SET (i.e. 1)   */
N#define  OS_FLAG_WAIT_SET_OR            3u
N
N
N#define  OS_FLAG_CONSUME             0x80u  /* Consume the flags if condition(s) satisfied             */
N
N
N#define  OS_FLAG_CLR                    0u
N#define  OS_FLAG_SET                    1u
N
N/*
N*********************************************************************************************************
N*                                     Values for OSTickStepState
N*
N* Note(s): This feature is used by uC/OS-View.
N*********************************************************************************************************
N*/
N
N#if OS_TICK_STEP_EN > 0u
X#if 1u > 0u
N#define  OS_TICK_STEP_DIS               0u  /* Stepping is disabled, tick runs as normal               */
N#define  OS_TICK_STEP_WAIT              1u  /* Waiting for uC/OS-View to set OSTickStepState to _ONCE  */
N#define  OS_TICK_STEP_ONCE              2u  /* Process tick once and wait for next cmd from uC/OS-View */
N#endif
N
N/*
N*********************************************************************************************************
N*      Possible values for 'opt' argument of OSSemDel(), OSMboxDel(), OSQDel() and OSMutexDel()
N*********************************************************************************************************
N*/
N#define  OS_DEL_NO_PEND                 0u
N#define  OS_DEL_ALWAYS                  1u
N
N/*
N*********************************************************************************************************
N*                                        OS???Pend() OPTIONS
N*
N* These #defines are used to establish the options for OS???PendAbort().
N*********************************************************************************************************
N*/
N#define  OS_PEND_OPT_NONE               0u  /* NO option selected                                      */
N#define  OS_PEND_OPT_BROADCAST          1u  /* Broadcast action to ALL tasks waiting                   */
N
N/*
N*********************************************************************************************************
N*                                     OS???PostOpt() OPTIONS
N*
N* These #defines are used to establish the options for OSMboxPostOpt() and OSQPostOpt().
N*********************************************************************************************************
N*/
N#define  OS_POST_OPT_NONE            0x00u  /* NO option selected                                      */
N#define  OS_POST_OPT_BROADCAST       0x01u  /* Broadcast message to ALL tasks waiting                  */
N#define  OS_POST_OPT_FRONT           0x02u  /* Post to highest priority task waiting                   */
N#define  OS_POST_OPT_NO_SCHED        0x04u  /* Do not call the scheduler if this option is selected    */
N
N/*
N*********************************************************************************************************
N*                                TASK OPTIONS (see OSTaskCreateExt())
N*********************************************************************************************************
N*/
N#define  OS_TASK_OPT_NONE          0x0000u  /* NO option selected                                      */
N#define  OS_TASK_OPT_STK_CHK       0x0001u  /* Enable stack checking for the task                      */
N#define  OS_TASK_OPT_STK_CLR       0x0002u  /* Clear the stack when the task is create                 */
N#define  OS_TASK_OPT_SAVE_FP       0x0004u  /* Save the contents of any floating-point registers       */
N
N/*
N*********************************************************************************************************
N*                          TIMER OPTIONS (see OSTmrStart() and OSTmrStop())
N*********************************************************************************************************
N*/
N#define  OS_TMR_OPT_NONE                0u  /* No option selected                                      */
N
N#define  OS_TMR_OPT_ONE_SHOT            1u  /* Timer will not automatically restart when it expires    */
N#define  OS_TMR_OPT_PERIODIC            2u  /* Timer will     automatically restart when it expires    */
N
N#define  OS_TMR_OPT_CALLBACK            3u  /* OSTmrStop() option to call 'callback' w/ timer arg.     */
N#define  OS_TMR_OPT_CALLBACK_ARG        4u  /* OSTmrStop() option to call 'callback' w/ new   arg.     */
N
N/*
N*********************************************************************************************************
N*                                            TIMER STATES
N*********************************************************************************************************
N*/
N#define  OS_TMR_STATE_UNUSED            0u
N#define  OS_TMR_STATE_STOPPED           1u
N#define  OS_TMR_STATE_COMPLETED         2u
N#define  OS_TMR_STATE_RUNNING           3u
N
N/*
N*********************************************************************************************************
N*                                             ERROR CODES
N*********************************************************************************************************
N*/
N#define OS_ERR_NONE                     0u
N
N#define OS_ERR_EVENT_TYPE               1u
N#define OS_ERR_PEND_ISR                 2u
N#define OS_ERR_POST_NULL_PTR            3u
N#define OS_ERR_PEVENT_NULL              4u
N#define OS_ERR_POST_ISR                 5u
N#define OS_ERR_QUERY_ISR                6u
N#define OS_ERR_INVALID_OPT              7u
N#define OS_ERR_ID_INVALID               8u
N#define OS_ERR_PDATA_NULL               9u
N
N#define OS_ERR_TIMEOUT                 10u
N#define OS_ERR_EVENT_NAME_TOO_LONG     11u
N#define OS_ERR_PNAME_NULL              12u
N#define OS_ERR_PEND_LOCKED             13u
N#define OS_ERR_PEND_ABORT              14u
N#define OS_ERR_DEL_ISR                 15u
N#define OS_ERR_CREATE_ISR              16u
N#define OS_ERR_NAME_GET_ISR            17u
N#define OS_ERR_NAME_SET_ISR            18u
N#define OS_ERR_ILLEGAL_CREATE_RUN_TIME 19u
N
N#define OS_ERR_MBOX_FULL               20u
N
N#define OS_ERR_Q_FULL                  30u
N#define OS_ERR_Q_EMPTY                 31u
N
N#define OS_ERR_PRIO_EXIST              40u
N#define OS_ERR_PRIO                    41u
N#define OS_ERR_PRIO_INVALID            42u
N
N#define OS_ERR_SCHED_LOCKED            50u
N#define OS_ERR_SEM_OVF                 51u
N
N#define OS_ERR_TASK_CREATE_ISR         60u
N#define OS_ERR_TASK_DEL                61u
N#define OS_ERR_TASK_DEL_IDLE           62u
N#define OS_ERR_TASK_DEL_REQ            63u
N#define OS_ERR_TASK_DEL_ISR            64u
N#define OS_ERR_TASK_NAME_TOO_LONG      65u
N#define OS_ERR_TASK_NO_MORE_TCB        66u
N#define OS_ERR_TASK_NOT_EXIST          67u
N#define OS_ERR_TASK_NOT_SUSPENDED      68u
N#define OS_ERR_TASK_OPT                69u
N#define OS_ERR_TASK_RESUME_PRIO        70u
N#define OS_ERR_TASK_SUSPEND_IDLE       71u
N#define OS_ERR_TASK_SUSPEND_PRIO       72u
N#define OS_ERR_TASK_WAITING            73u
N
N#define OS_ERR_TIME_NOT_DLY            80u
N#define OS_ERR_TIME_INVALID_MINUTES    81u
N#define OS_ERR_TIME_INVALID_SECONDS    82u
N#define OS_ERR_TIME_INVALID_MS         83u
N#define OS_ERR_TIME_ZERO_DLY           84u
N#define OS_ERR_TIME_DLY_ISR            85u
N
N#define OS_ERR_MEM_INVALID_PART        90u
N#define OS_ERR_MEM_INVALID_BLKS        91u
N#define OS_ERR_MEM_INVALID_SIZE        92u
N#define OS_ERR_MEM_NO_FREE_BLKS        93u
N#define OS_ERR_MEM_FULL                94u
N#define OS_ERR_MEM_INVALID_PBLK        95u
N#define OS_ERR_MEM_INVALID_PMEM        96u
N#define OS_ERR_MEM_INVALID_PDATA       97u
N#define OS_ERR_MEM_INVALID_ADDR        98u
N#define OS_ERR_MEM_NAME_TOO_LONG       99u
N
N#define OS_ERR_NOT_MUTEX_OWNER        100u
N
N#define OS_ERR_FLAG_INVALID_PGRP      110u
N#define OS_ERR_FLAG_WAIT_TYPE         111u
N#define OS_ERR_FLAG_NOT_RDY           112u
N#define OS_ERR_FLAG_INVALID_OPT       113u
N#define OS_ERR_FLAG_GRP_DEPLETED      114u
N#define OS_ERR_FLAG_NAME_TOO_LONG     115u
N
N#define OS_ERR_PCP_LOWER              120u
N
N#define OS_ERR_TMR_INVALID_DLY        130u
N#define OS_ERR_TMR_INVALID_PERIOD     131u
N#define OS_ERR_TMR_INVALID_OPT        132u
N#define OS_ERR_TMR_INVALID_NAME       133u
N#define OS_ERR_TMR_NON_AVAIL          134u
N#define OS_ERR_TMR_INACTIVE           135u
N#define OS_ERR_TMR_INVALID_DEST       136u
N#define OS_ERR_TMR_INVALID_TYPE       137u
N#define OS_ERR_TMR_INVALID            138u
N#define OS_ERR_TMR_ISR                139u
N#define OS_ERR_TMR_NAME_TOO_LONG      140u
N#define OS_ERR_TMR_INVALID_STATE      141u
N#define OS_ERR_TMR_STOPPED            142u
N#define OS_ERR_TMR_NO_CALLBACK        143u
N
N#define OS_ERR_NO_MORE_ID_AVAIL       150u
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         EVENT CONTROL BLOCK
N*********************************************************************************************************
N*/
N
N#if OS_LOWEST_PRIO <= 63u
X#if 63u <= 63u
Ntypedef  INT8U    OS_PRIO;
N#else
Stypedef  INT16U   OS_PRIO;
N#endif
N
N#if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
X#if ((((1u > 0u) && (4u > 0u)) || (1u > 0u) || (1u > 0u) || (1u > 0u))) && (80u > 0u)
Ntypedef struct os_event {
N    INT8U    OSEventType;                    /* Type of event control block (see OS_EVENT_TYPE_xxxx)    */
N    void    *OSEventPtr;                     /* Pointer to message or queue structure                   */
N    INT16U   OSEventCnt;                     /* Semaphore Count (not used if other EVENT type)          */
N    OS_PRIO  OSEventGrp;                     /* Group corresponding to tasks waiting for event to occur */
N    OS_PRIO  OSEventTbl[OS_EVENT_TBL_SIZE];  /* List of tasks waiting for event to occur                */
X    OS_PRIO  OSEventTbl[((63u) / 8u + 1u)];   
N
N#if OS_EVENT_NAME_EN > 0u
X#if 1u > 0u
N    INT8U   *OSEventName;
N#endif
N} OS_EVENT;
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                      EVENT FLAGS CONTROL BLOCK
N*********************************************************************************************************
N*/
N
N#if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
X#if (1u > 0u) && (5u > 0u)
N
N#if OS_FLAGS_NBITS == 8u                    /* Determine the size of OS_FLAGS (8, 16 or 32 bits)       */
X#if 16u == 8u                     
Stypedef  INT8U    OS_FLAGS;
N#endif
N
N#if OS_FLAGS_NBITS == 16u
X#if 16u == 16u
Ntypedef  INT16U   OS_FLAGS;
N#endif
N
N#if OS_FLAGS_NBITS == 32u
X#if 16u == 32u
Stypedef  INT32U   OS_FLAGS;
N#endif
N
N
Ntypedef struct os_flag_grp {                /* Event Flag Group                                        */
N    INT8U         OSFlagType;               /* Should be set to OS_EVENT_TYPE_FLAG                     */
N    void         *OSFlagWaitList;           /* Pointer to first NODE of task waiting on event flag     */
N    OS_FLAGS      OSFlagFlags;              /* 8, 16 or 32 bit flags                                   */
N#if OS_FLAG_NAME_EN > 0u
X#if 1u > 0u
N    INT8U        *OSFlagName;
N#endif
N} OS_FLAG_GRP;
N
N
N
Ntypedef struct os_flag_node {               /* Event Flag Wait List Node                               */
N    void         *OSFlagNodeNext;           /* Pointer to next     NODE in wait list                   */
N    void         *OSFlagNodePrev;           /* Pointer to previous NODE in wait list                   */
N    void         *OSFlagNodeTCB;            /* Pointer to TCB of waiting task                          */
N    void         *OSFlagNodeFlagGrp;        /* Pointer to Event Flag Group                             */
N    OS_FLAGS      OSFlagNodeFlags;          /* Event flag to wait on                                   */
N    INT8U         OSFlagNodeWaitType;       /* Type of wait:                                           */
N                                            /*      OS_FLAG_WAIT_AND                                   */
N                                            /*      OS_FLAG_WAIT_ALL                                   */
N                                            /*      OS_FLAG_WAIT_OR                                    */
N                                            /*      OS_FLAG_WAIT_ANY                                   */
N} OS_FLAG_NODE;
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        MESSAGE MAILBOX DATA
N*********************************************************************************************************
N*/
N
N#if OS_MBOX_EN > 0u
X#if 1u > 0u
Ntypedef struct os_mbox_data {
N    void   *OSMsg;                         /* Pointer to message in mailbox                            */
N    OS_PRIO OSEventTbl[OS_EVENT_TBL_SIZE]; /* List of tasks waiting for event to occur                 */
X    OS_PRIO OSEventTbl[((63u) / 8u + 1u)];  
N    OS_PRIO OSEventGrp;                    /* Group corresponding to tasks waiting for event to occur  */
N} OS_MBOX_DATA;
N#endif
N
N/*
N*********************************************************************************************************
N*                                  MEMORY PARTITION DATA STRUCTURES
N*********************************************************************************************************
N*/
N
N#if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
X#if (1u > 0u) && (5u > 0u)
Ntypedef struct os_mem {                   /* MEMORY CONTROL BLOCK                                      */
N    void   *OSMemAddr;                    /* Pointer to beginning of memory partition                  */
N    void   *OSMemFreeList;                /* Pointer to list of free memory blocks                     */
N    INT32U  OSMemBlkSize;                 /* Size (in bytes) of each block of memory                   */
N    INT32U  OSMemNBlks;                   /* Total number of blocks in this partition                  */
N    INT32U  OSMemNFree;                   /* Number of memory blocks remaining in this partition       */
N#if OS_MEM_NAME_EN > 0u
X#if 1u > 0u
N    INT8U  *OSMemName;                    /* Memory partition name                                     */
N#endif
N} OS_MEM;
N
N
Ntypedef struct os_mem_data {
N    void   *OSAddr;                    /* Pointer to the beginning address of the memory partition     */
N    void   *OSFreeList;                /* Pointer to the beginning of the free list of memory blocks   */
N    INT32U  OSBlkSize;                 /* Size (in bytes) of each memory block                         */
N    INT32U  OSNBlks;                   /* Total number of blocks in the partition                      */
N    INT32U  OSNFree;                   /* Number of memory blocks free                                 */
N    INT32U  OSNUsed;                   /* Number of memory blocks used                                 */
N} OS_MEM_DATA;
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                   MUTUAL EXCLUSION SEMAPHORE DATA
N*********************************************************************************************************
N*/
N
N#if OS_MUTEX_EN > 0u
X#if 1u > 0u
Ntypedef struct os_mutex_data {
N    OS_PRIO OSEventTbl[OS_EVENT_TBL_SIZE];  /* List of tasks waiting for event to occur                */
X    OS_PRIO OSEventTbl[((63u) / 8u + 1u)];   
N    OS_PRIO OSEventGrp;                     /* Group corresponding to tasks waiting for event to occur */
N    BOOLEAN OSValue;                        /* Mutex value (OS_FALSE = used, OS_TRUE = available)      */
N    INT8U   OSOwnerPrio;                    /* Mutex owner's task priority or 0xFF if no owner         */
N    INT8U   OSMutexPCP;                     /* Priority Ceiling Priority or 0xFF if PCP disabled       */
N} OS_MUTEX_DATA;
N#endif
N
N/*
N*********************************************************************************************************
N*                                         MESSAGE QUEUE DATA
N*********************************************************************************************************
N*/
N
N#if OS_Q_EN > 0u
X#if 1u > 0u
Ntypedef struct os_q {                   /* QUEUE CONTROL BLOCK                                         */
N    struct os_q   *OSQPtr;              /* Link to next queue control block in list of free blocks     */
N    void         **OSQStart;            /* Pointer to start of queue data                              */
N    void         **OSQEnd;              /* Pointer to end   of queue data                              */
N    void         **OSQIn;               /* Pointer to where next message will be inserted  in   the Q  */
N    void         **OSQOut;              /* Pointer to where next message will be extracted from the Q  */
N    INT16U         OSQSize;             /* Size of queue (maximum number of entries)                   */
N    INT16U         OSQEntries;          /* Current number of entries in the queue                      */
N} OS_Q;
N
N
Ntypedef struct os_q_data {
N    void          *OSMsg;               /* Pointer to next message to be extracted from queue          */
N    INT16U         OSNMsgs;             /* Number of messages in message queue                         */
N    INT16U         OSQSize;             /* Size of message queue                                       */
N    OS_PRIO        OSEventTbl[OS_EVENT_TBL_SIZE];  /* List of tasks waiting for event to occur         */
X    OS_PRIO        OSEventTbl[((63u) / 8u + 1u)];   
N    OS_PRIO        OSEventGrp;          /* Group corresponding to tasks waiting for event to occur     */
N} OS_Q_DATA;
N#endif
N
N/*
N*********************************************************************************************************
N*                                           SEMAPHORE DATA
N*********************************************************************************************************
N*/
N
N#if OS_SEM_EN > 0u
X#if 1u > 0u
Ntypedef struct os_sem_data {
N    INT16U  OSCnt;                          /* Semaphore count                                         */
N    OS_PRIO OSEventTbl[OS_EVENT_TBL_SIZE];  /* List of tasks waiting for event to occur                */
X    OS_PRIO OSEventTbl[((63u) / 8u + 1u)];   
N    OS_PRIO OSEventGrp;                     /* Group corresponding to tasks waiting for event to occur */
N} OS_SEM_DATA;
N#endif
N
N/*
N*********************************************************************************************************
N*                                           TASK STACK DATA
N*********************************************************************************************************
N*/
N
N#if OS_TASK_CREATE_EXT_EN > 0u
X#if 1u > 0u
Ntypedef struct os_stk_data {
N    INT32U  OSFree;                    /* Number of free entries on the stack                          */
N    INT32U  OSUsed;                    /* Number of entries used on the stack                          */
N} OS_STK_DATA;
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         TASK CONTROL BLOCK
N*********************************************************************************************************
N*/
N
Ntypedef struct os_tcb {
N    OS_STK          *OSTCBStkPtr;           /* Pointer to current top of stack                         */
N
N#if OS_TASK_CREATE_EXT_EN > 0u
X#if 1u > 0u
N    void            *OSTCBExtPtr;           /* Pointer to user definable data for TCB extension        */
N    OS_STK          *OSTCBStkBottom;        /* Pointer to bottom of stack                              */
N    INT32U           OSTCBStkSize;          /* Size of task stack (in number of stack elements)        */
N    INT16U           OSTCBOpt;              /* Task options as passed by OSTaskCreateExt()             */
N    INT16U           OSTCBId;               /* Task ID (0..65535)                                      */
N#endif
N
N    struct os_tcb   *OSTCBNext;             /* Pointer to next     TCB in the TCB list                 */
N    struct os_tcb   *OSTCBPrev;             /* Pointer to previous TCB in the TCB list                 */
N
N#if (OS_EVENT_EN)
X#if ((((1u > 0u) && (4u > 0u)) || (1u > 0u) || (1u > 0u) || (1u > 0u)))
N    OS_EVENT        *OSTCBEventPtr;         /* Pointer to          event control block                 */
N#endif
N
N#if (OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u)
X#if ((((1u > 0u) && (4u > 0u)) || (1u > 0u) || (1u > 0u) || (1u > 0u))) && (1u > 0u)
N    OS_EVENT       **OSTCBEventMultiPtr;    /* Pointer to multiple event control blocks                */
N#endif
N
N#if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
X#if ((1u > 0u) && (4u > 0u)) || (1u > 0u)
N    void            *OSTCBMsg;              /* Message received from OSMboxPost() or OSQPost()         */
N#endif
N
N#if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
X#if (1u > 0u) && (5u > 0u)
N#if OS_TASK_DEL_EN > 0u
X#if 1u > 0u
N    OS_FLAG_NODE    *OSTCBFlagNode;         /* Pointer to event flag node                              */
N#endif
N    OS_FLAGS         OSTCBFlagsRdy;         /* Event flags that made task ready to run                 */
N#endif
N
N    INT32U           OSTCBDly;              /* Nbr ticks to delay task or, timeout waiting for event   */
N    INT8U            OSTCBStat;             /* Task      status                                        */
N    INT8U            OSTCBStatPend;         /* Task PEND status                                        */
N    INT8U            OSTCBPrio;             /* Task priority (0 == highest)                            */
N
N    INT8U            OSTCBX;                /* Bit position in group  corresponding to task priority   */
N    INT8U            OSTCBY;                /* Index into ready table corresponding to task priority   */
N    OS_PRIO          OSTCBBitX;             /* Bit mask to access bit position in ready table          */
N    OS_PRIO          OSTCBBitY;             /* Bit mask to access bit position in ready group          */
N
N#if OS_TASK_DEL_EN > 0u
X#if 1u > 0u
N    INT8U            OSTCBDelReq;           /* Indicates whether a task needs to delete itself         */
N#endif
N
N#if OS_TASK_PROFILE_EN > 0u
X#if 1u > 0u
N    INT32U           OSTCBCtxSwCtr;         /* Number of time the task was switched in                 */
N    INT32U           OSTCBCyclesTot;        /* Total number of clock cycles the task has been running  */
N    INT32U           OSTCBCyclesStart;      /* Snapshot of cycle counter at start of task resumption   */
N    OS_STK          *OSTCBStkBase;          /* Pointer to the beginning of the task stack              */
N    INT32U           OSTCBStkUsed;          /* Number of bytes used from the stack                     */
N#endif
N
N#if OS_TASK_NAME_EN > 0u
X#if 1u > 0u
N    INT8U           *OSTCBTaskName;
N#endif
N
N#if OS_TASK_REG_TBL_SIZE > 0u
X#if 1u > 0u
N    INT32U           OSTCBRegTbl[OS_TASK_REG_TBL_SIZE];
X    INT32U           OSTCBRegTbl[1u];
N#endif
N} OS_TCB;
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          TIMER DATA TYPES
N*********************************************************************************************************
N*/
N
N#if OS_TMR_EN > 0u
X#if 1u > 0u
Ntypedef  void (*OS_TMR_CALLBACK)(void *ptmr, void *parg);
N
N
N
Ntypedef  struct  os_tmr {
N    INT8U            OSTmrType;                       /* Should be set to OS_TMR_TYPE                                  */
N    OS_TMR_CALLBACK  OSTmrCallback;                   /* Function to call when timer expires                           */
N    void            *OSTmrCallbackArg;                /* Argument to pass to function when timer expires               */
N    void            *OSTmrNext;                       /* Double link list pointers                                     */
N    void            *OSTmrPrev;
N    INT32U           OSTmrMatch;                      /* Timer expires when OSTmrTime == OSTmrMatch                    */
N    INT32U           OSTmrDly;                        /* Delay time before periodic update starts                      */
N    INT32U           OSTmrPeriod;                     /* Period to repeat timer                                        */
N#if OS_TMR_CFG_NAME_EN > 0u
X#if 1u > 0u
N    INT8U           *OSTmrName;                       /* Name to give the timer                                        */
N#endif
N    INT8U            OSTmrOpt;                        /* Options (see OS_TMR_OPT_xxx)                                  */
N    INT8U            OSTmrState;                      /* Indicates the state of the timer:                             */
N                                                      /*     OS_TMR_STATE_UNUSED                                       */
N                                                      /*     OS_TMR_STATE_RUNNING                                      */
N                                                      /*     OS_TMR_STATE_STOPPED                                      */
N} OS_TMR;
N
N
N
Ntypedef  struct  os_tmr_wheel {
N    OS_TMR          *OSTmrFirst;                      /* Pointer to first timer in linked list                         */
N    INT16U           OSTmrEntries;
N} OS_TMR_WHEEL;
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
NOS_EXT  INT32U            OSCtxSwCtr;               /* Counter of number of context switches           */
Xextern  INT32U            OSCtxSwCtr;                
N
N#if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
X#if ((((1u > 0u) && (4u > 0u)) || (1u > 0u) || (1u > 0u) || (1u > 0u))) && (80u > 0u)
NOS_EXT  OS_EVENT         *OSEventFreeList;          /* Pointer to list of free EVENT control blocks    */
Xextern  OS_EVENT         *OSEventFreeList;           
NOS_EXT  OS_EVENT          OSEventTbl[OS_MAX_EVENTS];/* Table of EVENT control blocks                   */
Xextern  OS_EVENT          OSEventTbl[80u]; 
N#endif
N
N#if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
X#if (1u > 0u) && (5u > 0u)
NOS_EXT  OS_FLAG_GRP       OSFlagTbl[OS_MAX_FLAGS];  /* Table containing event flag groups              */
Xextern  OS_FLAG_GRP       OSFlagTbl[5u];   
NOS_EXT  OS_FLAG_GRP      *OSFlagFreeList;           /* Pointer to free list of event flag groups       */
Xextern  OS_FLAG_GRP      *OSFlagFreeList;            
N#endif
N
N#if OS_TASK_STAT_EN > 0u
X#if 1u > 0u
NOS_EXT  INT8U             OSCPUUsage;               /* Percentage of CPU used                          */
Xextern  INT8U             OSCPUUsage;                
NOS_EXT  INT32U            OSIdleCtrMax;             /* Max. value that idle ctr can take in 1 sec.     */
Xextern  INT32U            OSIdleCtrMax;              
NOS_EXT  INT32U            OSIdleCtrRun;             /* Val. reached by idle ctr at run time in 1 sec.  */
Xextern  INT32U            OSIdleCtrRun;              
NOS_EXT  BOOLEAN           OSStatRdy;                /* Flag indicating that the statistic task is rdy  */
Xextern  BOOLEAN           OSStatRdy;                 
NOS_EXT  OS_STK            OSTaskStatStk[OS_TASK_STAT_STK_SIZE];      /* Statistics task stack          */
Xextern  OS_STK            OSTaskStatStk[128u];       
N#endif
N
NOS_EXT  INT8U             OSIntNesting;             /* Interrupt nesting level                         */
Xextern  INT8U             OSIntNesting;              
N
NOS_EXT  INT8U             OSLockNesting;            /* Multitasking lock nesting level                 */
Xextern  INT8U             OSLockNesting;             
N
NOS_EXT  INT8U             OSPrioCur;                /* Priority of current task                        */
Xextern  INT8U             OSPrioCur;                 
NOS_EXT  INT8U             OSPrioHighRdy;            /* Priority of highest priority task               */
Xextern  INT8U             OSPrioHighRdy;             
N
NOS_EXT  OS_PRIO           OSRdyGrp;                        /* Ready list group                         */
Xextern  OS_PRIO           OSRdyGrp;                         
NOS_EXT  OS_PRIO           OSRdyTbl[OS_RDY_TBL_SIZE];       /* Table of tasks which are ready to run    */
Xextern  OS_PRIO           OSRdyTbl[((63u) / 8u + 1u)];        
N
NOS_EXT  BOOLEAN           OSRunning;                       /* Flag indicating that kernel is running   */
Xextern  BOOLEAN           OSRunning;                        
N
NOS_EXT  INT8U             OSTaskCtr;                       /* Number of tasks created                  */
Xextern  INT8U             OSTaskCtr;                        
N
NOS_EXT  volatile  INT32U  OSIdleCtr;                                 /* Idle counter                   */
Xextern  volatile  INT32U  OSIdleCtr;                                  
N
N#ifdef OS_SAFETY_CRITICAL_IEC61508
SOS_EXT  BOOLEAN           OSSafetyCriticalStartFlag;
N#endif
N
NOS_EXT  OS_STK            OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE];      /* Idle task stack                */
Xextern  OS_STK            OSTaskIdleStk[128u];       
N
N
NOS_EXT  OS_TCB           *OSTCBCur;                        /* Pointer to currently running TCB         */
Xextern  OS_TCB           *OSTCBCur;                         
NOS_EXT  OS_TCB           *OSTCBFreeList;                   /* Pointer to list of free TCBs             */
Xextern  OS_TCB           *OSTCBFreeList;                    
NOS_EXT  OS_TCB           *OSTCBHighRdy;                    /* Pointer to highest priority TCB R-to-R   */
Xextern  OS_TCB           *OSTCBHighRdy;                     
NOS_EXT  OS_TCB           *OSTCBList;                       /* Pointer to doubly linked list of TCBs    */
Xextern  OS_TCB           *OSTCBList;                        
NOS_EXT  OS_TCB           *OSTCBPrioTbl[OS_LOWEST_PRIO + 1u];    /* Table of pointers to created TCBs   */
Xextern  OS_TCB           *OSTCBPrioTbl[63u + 1u];     
NOS_EXT  OS_TCB            OSTCBTbl[OS_MAX_TASKS + OS_N_SYS_TASKS];   /* Table of TCBs                  */
Xextern  OS_TCB            OSTCBTbl[20u + 2u];    
N
N#if OS_TICK_STEP_EN > 0u
X#if 1u > 0u
NOS_EXT  INT8U             OSTickStepState;          /* Indicates the state of the tick step feature    */
Xextern  INT8U             OSTickStepState;           
N#endif
N
N#if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
X#if (1u > 0u) && (5u > 0u)
NOS_EXT  OS_MEM           *OSMemFreeList;            /* Pointer to free list of memory partitions       */
Xextern  OS_MEM           *OSMemFreeList;             
NOS_EXT  OS_MEM            OSMemTbl[OS_MAX_MEM_PART];/* Storage for memory partition manager            */
Xextern  OS_MEM            OSMemTbl[5u]; 
N#endif
N
N#if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
X#if (1u > 0u) && (4u > 0u)
NOS_EXT  OS_Q             *OSQFreeList;              /* Pointer to list of free QUEUE control blocks    */
Xextern  OS_Q             *OSQFreeList;               
NOS_EXT  OS_Q              OSQTbl[OS_MAX_QS];        /* Table of QUEUE control blocks                   */
Xextern  OS_Q              OSQTbl[4u];         
N#endif
N
N#if OS_TASK_REG_TBL_SIZE > 0u
X#if 1u > 0u
NOS_EXT  INT8U             OSTaskRegNextAvailID;     /* Next available Task register ID                 */
Xextern  INT8U             OSTaskRegNextAvailID;      
N#endif
N
N#if OS_TIME_GET_SET_EN > 0u
X#if 1u > 0u
NOS_EXT  volatile  INT32U  OSTime;                   /* Current value of system time (in ticks)         */
Xextern  volatile  INT32U  OSTime;                    
N#endif
N
N#if OS_TMR_EN > 0u
X#if 1u > 0u
NOS_EXT  INT16U            OSTmrFree;                /* Number of free entries in the timer pool        */
Xextern  INT16U            OSTmrFree;                 
NOS_EXT  INT16U            OSTmrUsed;                /* Number of timers used                           */
Xextern  INT16U            OSTmrUsed;                 
NOS_EXT  INT32U            OSTmrTime;                /* Current timer time                              */
Xextern  INT32U            OSTmrTime;                 
N
NOS_EXT  OS_EVENT         *OSTmrSem;                 /* Sem. used to gain exclusive access to timers    */
Xextern  OS_EVENT         *OSTmrSem;                  
NOS_EXT  OS_EVENT         *OSTmrSemSignal;           /* Sem. used to signal the update of timers        */
Xextern  OS_EVENT         *OSTmrSemSignal;            
N
NOS_EXT  OS_TMR            OSTmrTbl[OS_TMR_CFG_MAX]; /* Table containing pool of timers                 */
Xextern  OS_TMR            OSTmrTbl[16u];  
NOS_EXT  OS_TMR           *OSTmrFreeList;            /* Pointer to free list of timers                  */
Xextern  OS_TMR           *OSTmrFreeList;             
NOS_EXT  OS_STK            OSTmrTaskStk[OS_TASK_TMR_STK_SIZE];
Xextern  OS_STK            OSTmrTaskStk[128u];
N
NOS_EXT  OS_TMR_WHEEL      OSTmrWheelTbl[OS_TMR_CFG_WHEEL_SIZE];
Xextern  OS_TMR_WHEEL      OSTmrWheelTbl[8u];
N#endif
N
Nextern  INT8U   const     OSUnMapTbl[256];          /* Priority->Index    lookup table                 */
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          FUNCTION PROTOTYPES
N*                                     (Target Independent Functions)
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                            MISCELLANEOUS
N*********************************************************************************************************
N*/
N
N#if (OS_EVENT_EN)
X#if ((((1u > 0u) && (4u > 0u)) || (1u > 0u) || (1u > 0u) || (1u > 0u)))
N
N#if (OS_EVENT_NAME_EN > 0u)
X#if (1u > 0u)
NINT8U         OSEventNameGet          (OS_EVENT        *pevent,
N                                       INT8U          **pname,
N                                       INT8U           *perr);
N
Nvoid          OSEventNameSet          (OS_EVENT        *pevent,
N                                       INT8U           *pname,
N                                       INT8U           *perr);
N#endif
N
N#if (OS_EVENT_MULTI_EN > 0u)
X#if (1u > 0u)
NINT16U        OSEventPendMulti        (OS_EVENT       **pevents_pend,
N                                       OS_EVENT       **pevents_rdy,
N                                       void           **pmsgs_rdy,
N                                       INT32U           timeout,
N                                       INT8U           *perr);
N#endif
N
N#endif
N
N/*
N*********************************************************************************************************
N*                                       EVENT FLAGS MANAGEMENT
N*********************************************************************************************************
N*/
N
N#if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
X#if (1u > 0u) && (5u > 0u)
N
N#if OS_FLAG_ACCEPT_EN > 0u
X#if 1u > 0u
NOS_FLAGS      OSFlagAccept            (OS_FLAG_GRP     *pgrp,
N                                       OS_FLAGS         flags,
N                                       INT8U            wait_type,
N                                       INT8U           *perr);
N#endif
N
NOS_FLAG_GRP  *OSFlagCreate            (OS_FLAGS         flags,
N                                       INT8U           *perr);
N
N#if OS_FLAG_DEL_EN > 0u
X#if 1u > 0u
NOS_FLAG_GRP  *OSFlagDel               (OS_FLAG_GRP     *pgrp,
N                                       INT8U            opt,
N                                       INT8U           *perr);
N#endif
N
N#if (OS_FLAG_EN > 0u) && (OS_FLAG_NAME_EN > 0u)
X#if (1u > 0u) && (1u > 0u)
NINT8U         OSFlagNameGet           (OS_FLAG_GRP     *pgrp,
N                                       INT8U          **pname,
N                                       INT8U           *perr);
N
Nvoid          OSFlagNameSet           (OS_FLAG_GRP     *pgrp,
N                                       INT8U           *pname,
N                                       INT8U           *perr);
N#endif
N
NOS_FLAGS      OSFlagPend              (OS_FLAG_GRP     *pgrp,
N                                       OS_FLAGS         flags,
N                                       INT8U            wait_type,
N                                       INT32U           timeout,
N                                       INT8U           *perr);
N
NOS_FLAGS      OSFlagPendGetFlagsRdy   (void);
NOS_FLAGS      OSFlagPost              (OS_FLAG_GRP     *pgrp,
N                                       OS_FLAGS         flags,
N                                       INT8U            opt,
N                                       INT8U           *perr);
N
N#if OS_FLAG_QUERY_EN > 0u
X#if 1u > 0u
NOS_FLAGS      OSFlagQuery             (OS_FLAG_GRP     *pgrp,
N                                       INT8U           *perr);
N#endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                     MESSAGE MAILBOX MANAGEMENT
N*********************************************************************************************************
N*/
N
N#if OS_MBOX_EN > 0u
X#if 1u > 0u
N
N#if OS_MBOX_ACCEPT_EN > 0u
X#if 1u > 0u
Nvoid         *OSMboxAccept            (OS_EVENT        *pevent);
N#endif
N
NOS_EVENT     *OSMboxCreate            (void            *pmsg);
N
N#if OS_MBOX_DEL_EN > 0u
X#if 1u > 0u
NOS_EVENT     *OSMboxDel               (OS_EVENT        *pevent,
N                                       INT8U            opt,
N                                       INT8U           *perr);
N#endif
N
Nvoid         *OSMboxPend              (OS_EVENT        *pevent,
N                                       INT32U           timeout,
N                                       INT8U           *perr);
N
N#if OS_MBOX_PEND_ABORT_EN > 0u
X#if 1u > 0u
NINT8U         OSMboxPendAbort         (OS_EVENT        *pevent,
N                                       INT8U            opt,
N                                       INT8U           *perr);
N#endif
N
N#if OS_MBOX_POST_EN > 0u
X#if 1u > 0u
NINT8U         OSMboxPost              (OS_EVENT        *pevent,
N                                       void            *pmsg);
N#endif
N
N#if OS_MBOX_POST_OPT_EN > 0u
X#if 1u > 0u
NINT8U         OSMboxPostOpt           (OS_EVENT        *pevent,
N                                       void            *pmsg,
N                                       INT8U            opt);
N#endif
N
N#if OS_MBOX_QUERY_EN > 0u
X#if 1u > 0u
NINT8U         OSMboxQuery             (OS_EVENT        *pevent,
N                                       OS_MBOX_DATA    *p_mbox_data);
N#endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                          MEMORY MANAGEMENT
N*********************************************************************************************************
N*/
N
N#if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
X#if (1u > 0u) && (5u > 0u)
N
NOS_MEM       *OSMemCreate             (void            *addr,
N                                       INT32U           nblks,
N                                       INT32U           blksize,
N                                       INT8U           *perr);
N
Nvoid         *OSMemGet                (OS_MEM          *pmem,
N                                       INT8U           *perr);
N#if OS_MEM_NAME_EN > 0u
X#if 1u > 0u
NINT8U         OSMemNameGet            (OS_MEM          *pmem,
N                                       INT8U          **pname,
N                                       INT8U           *perr);
N
Nvoid          OSMemNameSet            (OS_MEM          *pmem,
N                                       INT8U           *pname,
N                                       INT8U           *perr);
N#endif
NINT8U         OSMemPut                (OS_MEM          *pmem,
N                                       void            *pblk);
N
N#if OS_MEM_QUERY_EN > 0u
X#if 1u > 0u
NINT8U         OSMemQuery              (OS_MEM          *pmem,
N                                       OS_MEM_DATA     *p_mem_data);
N#endif
N
N#endif
N
N/*
N*********************************************************************************************************
N*                                MUTUAL EXCLUSION SEMAPHORE MANAGEMENT
N*********************************************************************************************************
N*/
N
N#if OS_MUTEX_EN > 0u
X#if 1u > 0u
N
N#if OS_MUTEX_ACCEPT_EN > 0u
X#if 1u > 0u
NBOOLEAN       OSMutexAccept           (OS_EVENT        *pevent,
N                                       INT8U           *perr);
N#endif
N
NOS_EVENT     *OSMutexCreate           (INT8U            prio,
N                                       INT8U           *perr);
N
N#if OS_MUTEX_DEL_EN > 0u
X#if 1u > 0u
NOS_EVENT     *OSMutexDel              (OS_EVENT        *pevent,
N                                       INT8U            opt,
N                                       INT8U           *perr);
N#endif
N
Nvoid          OSMutexPend             (OS_EVENT        *pevent,
N                                       INT32U           timeout,
N                                       INT8U           *perr);
N
NINT8U         OSMutexPost             (OS_EVENT        *pevent);
N
N#if OS_MUTEX_QUERY_EN > 0u
X#if 1u > 0u
NINT8U         OSMutexQuery            (OS_EVENT        *pevent,
N                                       OS_MUTEX_DATA   *p_mutex_data);
N#endif
N
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                      MESSAGE QUEUE MANAGEMENT
N*********************************************************************************************************
N*/
N
N#if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
X#if (1u > 0u) && (4u > 0u)
N
N#if OS_Q_ACCEPT_EN > 0u
X#if 1u > 0u
Nvoid         *OSQAccept               (OS_EVENT        *pevent,
N                                       INT8U           *perr);
N#endif
N
NOS_EVENT     *OSQCreate               (void           **start,
N                                       INT16U           size);
N
N#if OS_Q_DEL_EN > 0u
X#if 1u > 0u
NOS_EVENT     *OSQDel                  (OS_EVENT        *pevent,
N                                       INT8U            opt,
N                                       INT8U           *perr);
N#endif
N
N#if OS_Q_FLUSH_EN > 0u
X#if 1u > 0u
NINT8U         OSQFlush                (OS_EVENT        *pevent);
N#endif
N
Nvoid         *OSQPend                 (OS_EVENT        *pevent,
N                                       INT32U           timeout,
N                                       INT8U           *perr);
N
N#if OS_Q_PEND_ABORT_EN > 0u
X#if 1u > 0u
NINT8U         OSQPendAbort            (OS_EVENT        *pevent,
N                                       INT8U            opt,
N                                       INT8U           *perr);
N#endif
N
N#if OS_Q_POST_EN > 0u
X#if 1u > 0u
NINT8U         OSQPost                 (OS_EVENT        *pevent,
N                                       void            *pmsg);
N#endif
N
N#if OS_Q_POST_FRONT_EN > 0u
X#if 1u > 0u
NINT8U         OSQPostFront            (OS_EVENT        *pevent,
N                                       void            *pmsg);
N#endif
N
N#if OS_Q_POST_OPT_EN > 0u
X#if 1u > 0u
NINT8U         OSQPostOpt              (OS_EVENT        *pevent,
N                                       void            *pmsg,
N                                       INT8U            opt);
N#endif
N
N#if OS_Q_QUERY_EN > 0u
X#if 1u > 0u
NINT8U         OSQQuery                (OS_EVENT        *pevent,
N                                       OS_Q_DATA       *p_q_data);
N#endif
N
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        SEMAPHORE MANAGEMENT
N*********************************************************************************************************
N*/
N#if OS_SEM_EN > 0u
X#if 1u > 0u
N
N#if OS_SEM_ACCEPT_EN > 0u
X#if 1u > 0u
NINT16U        OSSemAccept             (OS_EVENT        *pevent);
N#endif
N
NOS_EVENT     *OSSemCreate             (INT16U           cnt);
N
N#if OS_SEM_DEL_EN > 0u
X#if 1u > 0u
NOS_EVENT     *OSSemDel                (OS_EVENT        *pevent,
N                                       INT8U            opt,
N                                       INT8U           *perr);
N#endif
N
Nvoid          OSSemPend               (OS_EVENT        *pevent,
N                                       INT32U           timeout,
N                                       INT8U           *perr);
N
N#if OS_SEM_PEND_ABORT_EN > 0u
X#if 1u > 0u
NINT8U         OSSemPendAbort          (OS_EVENT        *pevent,
N                                       INT8U            opt,
N                                       INT8U           *perr);
N#endif
N
NINT8U         OSSemPost               (OS_EVENT        *pevent);
N
N#if OS_SEM_QUERY_EN > 0u
X#if 1u > 0u
NINT8U         OSSemQuery              (OS_EVENT        *pevent,
N                                       OS_SEM_DATA     *p_sem_data);
N#endif
N
N#if OS_SEM_SET_EN > 0u
X#if 1u > 0u
Nvoid          OSSemSet                (OS_EVENT        *pevent,
N                                       INT16U           cnt,
N                                       INT8U           *perr);
N#endif
N
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                           TASK MANAGEMENT
N*********************************************************************************************************
N*/
N#if OS_TASK_CHANGE_PRIO_EN > 0u
X#if 1u > 0u
NINT8U         OSTaskChangePrio        (INT8U            oldprio,
N                                       INT8U            newprio);
N#endif
N
N#if OS_TASK_CREATE_EN > 0u
X#if 1u > 0u
NINT8U         OSTaskCreate            (void           (*task)(void *p_arg),
N                                       void            *p_arg,
N                                       OS_STK          *ptos,
N                                       INT8U            prio);
N#endif
N
N#if OS_TASK_CREATE_EXT_EN > 0u
X#if 1u > 0u
NINT8U         OSTaskCreateExt         (void           (*task)(void *p_arg),
N                                       void            *p_arg,
N                                       OS_STK          *ptos,
N                                       INT8U            prio,
N                                       INT16U           id,
N                                       OS_STK          *pbos,
N                                       INT32U           stk_size,
N                                       void            *pext,
N                                       INT16U           opt);
N#endif
N
N#if OS_TASK_DEL_EN > 0u
X#if 1u > 0u
NINT8U         OSTaskDel               (INT8U            prio);
NINT8U         OSTaskDelReq            (INT8U            prio);
N#endif
N
N#if OS_TASK_NAME_EN > 0u
X#if 1u > 0u
NINT8U         OSTaskNameGet           (INT8U            prio,
N                                       INT8U          **pname,
N                                       INT8U           *perr);
N
Nvoid          OSTaskNameSet           (INT8U            prio,
N                                       INT8U           *pname,
N                                       INT8U           *perr);
N#endif
N
N#if OS_TASK_SUSPEND_EN > 0u
X#if 1u > 0u
NINT8U         OSTaskResume            (INT8U            prio);
NINT8U         OSTaskSuspend           (INT8U            prio);
N#endif
N
N#if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
X#if (1u > 0u) && (1u > 0u)
NINT8U         OSTaskStkChk            (INT8U            prio,
N                                       OS_STK_DATA     *p_stk_data);
N#endif
N
N#if OS_TASK_QUERY_EN > 0u
X#if 1u > 0u
NINT8U         OSTaskQuery             (INT8U            prio,
N                                       OS_TCB          *p_task_data);
N#endif
N
N
N
N#if OS_TASK_REG_TBL_SIZE > 0u
X#if 1u > 0u
NINT32U        OSTaskRegGet            (INT8U            prio,
N                                       INT8U            id,
N                                       INT8U           *perr);
N
NINT8U         OSTaskRegGetID          (INT8U           *perr);
N
Nvoid          OSTaskRegSet            (INT8U            prio,
N                                       INT8U            id,
N                                       INT32U           value,
N                                       INT8U           *perr);
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                           TIME MANAGEMENT
N*********************************************************************************************************
N*/
N
Nvoid          OSTimeDly               (INT32U           ticks);
N
N#if OS_TIME_DLY_HMSM_EN > 0u
X#if 1u > 0u
NINT8U         OSTimeDlyHMSM           (INT8U            hours,
N                                       INT8U            minutes,
N                                       INT8U            seconds,
N                                       INT16U           ms);
N#endif
N
N#if OS_TIME_DLY_RESUME_EN > 0u
X#if 1u > 0u
NINT8U         OSTimeDlyResume         (INT8U            prio);
N#endif
N
N#if OS_TIME_GET_SET_EN > 0u
X#if 1u > 0u
NINT32U        OSTimeGet               (void);
Nvoid          OSTimeSet               (INT32U           ticks);
N#endif
N
Nvoid          OSTimeTick              (void);
N
N/*
N*********************************************************************************************************
N*                                          TIMER MANAGEMENT
N*********************************************************************************************************
N*/
N
N#if OS_TMR_EN > 0u
X#if 1u > 0u
NOS_TMR      *OSTmrCreate              (INT32U           dly,
N                                       INT32U           period,
N                                       INT8U            opt,
N                                       OS_TMR_CALLBACK  callback,
N                                       void            *callback_arg,
N                                       INT8U           *pname,
N                                       INT8U           *perr);
N
NBOOLEAN      OSTmrDel                 (OS_TMR          *ptmr,
N                                       INT8U           *perr);
N
N#if OS_TMR_CFG_NAME_EN > 0u
X#if 1u > 0u
NINT8U        OSTmrNameGet             (OS_TMR          *ptmr,
N                                       INT8U          **pdest,
N                                       INT8U           *perr);
N#endif
NINT32U       OSTmrRemainGet           (OS_TMR          *ptmr,
N                                       INT8U           *perr);
N
NINT8U        OSTmrStateGet            (OS_TMR          *ptmr,
N                                       INT8U           *perr);
N
NBOOLEAN      OSTmrStart               (OS_TMR          *ptmr,
N                                       INT8U           *perr);
N
NBOOLEAN      OSTmrStop                (OS_TMR          *ptmr,
N                                       INT8U            opt,
N                                       void            *callback_arg,
N                                       INT8U           *perr);
N
NINT8U        OSTmrSignal              (void);
N#endif
N
N/*
N*********************************************************************************************************
N*                                            MISCELLANEOUS
N*********************************************************************************************************
N*/
N
Nvoid          OSInit                  (void);
N
Nvoid          OSIntEnter              (void);
Nvoid          OSIntExit               (void);
N
N#ifdef OS_SAFETY_CRITICAL_IEC61508
Svoid          OSSafetyCriticalStart   (void);
N#endif
N
N#if OS_SCHED_LOCK_EN > 0u
X#if 1u > 0u
Nvoid          OSSchedLock             (void);
Nvoid          OSSchedUnlock           (void);
N#endif
N
Nvoid          OSStart                 (void);
N
Nvoid          OSStatInit              (void);
N
NINT16U        OSVersion               (void);
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                      INTERNAL FUNCTION PROTOTYPES
N*                            (Your application MUST NOT call these functions)
N*********************************************************************************************************
N*/
N
N#if OS_TASK_DEL_EN > 0u
X#if 1u > 0u
Nvoid          OS_Dummy                (void);
N#endif
N
N#if (OS_EVENT_EN)
X#if ((((1u > 0u) && (4u > 0u)) || (1u > 0u) || (1u > 0u) || (1u > 0u)))
NINT8U         OS_EventTaskRdy         (OS_EVENT        *pevent,
N                                       void            *pmsg,
N                                       INT8U            msk,
N                                       INT8U            pend_stat);
N
Nvoid          OS_EventTaskWait        (OS_EVENT        *pevent);
N
Nvoid          OS_EventTaskRemove      (OS_TCB          *ptcb,
N                                       OS_EVENT        *pevent);
N
N#if (OS_EVENT_MULTI_EN > 0u)
X#if (1u > 0u)
Nvoid          OS_EventTaskWaitMulti   (OS_EVENT       **pevents_wait);
N
Nvoid          OS_EventTaskRemoveMulti (OS_TCB          *ptcb,
N                                       OS_EVENT       **pevents_multi);
N#endif
N
Nvoid          OS_EventWaitListInit    (OS_EVENT        *pevent);
N#endif
N
N#if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
X#if (1u > 0u) && (5u > 0u)
Nvoid          OS_FlagInit             (void);
Nvoid          OS_FlagUnlink           (OS_FLAG_NODE    *pnode);
N#endif
N
Nvoid          OS_MemClr               (INT8U           *pdest,
N                                       INT16U           size);
N
Nvoid          OS_MemCopy              (INT8U           *pdest,
N                                       INT8U           *psrc,
N                                       INT16U           size);
N
N#if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
X#if (1u > 0u) && (5u > 0u)
Nvoid          OS_MemInit              (void);
N#endif
N
N#if OS_Q_EN > 0u
X#if 1u > 0u
Nvoid          OS_QInit                (void);
N#endif
N
Nvoid          OS_Sched                (void);
N
N#if (OS_EVENT_NAME_EN > 0u) || (OS_FLAG_NAME_EN > 0u) || (OS_MEM_NAME_EN > 0u) || (OS_TASK_NAME_EN > 0u)
X#if (1u > 0u) || (1u > 0u) || (1u > 0u) || (1u > 0u)
NINT8U         OS_StrLen               (INT8U           *psrc);
N#endif
N
Nvoid          OS_TaskIdle             (void            *p_arg);
N
Nvoid          OS_TaskReturn           (void);
N
N#if OS_TASK_STAT_EN > 0u
X#if 1u > 0u
Nvoid          OS_TaskStat             (void            *p_arg);
N#endif
N
N#if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
X#if (1u > 0u) && (1u > 0u)
Nvoid          OS_TaskStkClr           (OS_STK          *pbos,
N                                       INT32U           size,
N                                       INT16U           opt);
N#endif
N
N#if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
X#if (1u > 0u) && (1u > 0u)
Nvoid          OS_TaskStatStkChk       (void);
N#endif
N
NINT8U         OS_TCBInit              (INT8U            prio,
N                                       OS_STK          *ptos,
N                                       OS_STK          *pbos,
N                                       INT16U           id,
N                                       INT32U           stk_size,
N                                       void            *pext,
N                                       INT16U           opt);
N
N#if OS_TMR_EN > 0u
X#if 1u > 0u
Nvoid          OSTmr_Init              (void);
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          FUNCTION PROTOTYPES
N*                                      (Target Specific Functions)
N*********************************************************************************************************
N*/
N
N#if OS_DEBUG_EN > 0u
X#if 1u > 0u
Nvoid          OSDebugInit             (void);
N#endif
N
Nvoid          OSInitHookBegin         (void);
Nvoid          OSInitHookEnd           (void);
N
Nvoid          OSTaskCreateHook        (OS_TCB          *ptcb);
Nvoid          OSTaskDelHook           (OS_TCB          *ptcb);
N
Nvoid          OSTaskIdleHook          (void);
N
Nvoid          OSTaskReturnHook        (OS_TCB          *ptcb);
N
Nvoid          OSTaskStatHook          (void);
NOS_STK       *OSTaskStkInit           (void           (*task)(void *p_arg),
N                                       void            *p_arg,
N                                       OS_STK          *ptos,
N                                       INT16U           opt);
N
N#if OS_TASK_SW_HOOK_EN > 0u
X#if 1u > 0u
Nvoid          OSTaskSwHook            (void);
N#endif
N
Nvoid          OSTCBInitHook           (OS_TCB          *ptcb);
N
N#if OS_TIME_TICK_HOOK_EN > 0u
X#if 1u > 0u
Nvoid          OSTimeTickHook          (void);
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          FUNCTION PROTOTYPES
N*                                   (Application Specific Functions)
N*********************************************************************************************************
N*/
N
N#if OS_APP_HOOKS_EN > 0u
X#if 1u > 0u
Nvoid          App_TaskCreateHook      (OS_TCB          *ptcb);
Nvoid          App_TaskDelHook         (OS_TCB          *ptcb);
Nvoid          App_TaskIdleHook        (void);
N
Nvoid          App_TaskReturnHook      (OS_TCB          *ptcb);
N
Nvoid          App_TaskStatHook        (void);
N
N#if OS_TASK_SW_HOOK_EN > 0u
X#if 1u > 0u
Nvoid          App_TaskSwHook          (void);
N#endif
N
Nvoid          App_TCBInitHook         (OS_TCB          *ptcb);
N
N#if OS_TIME_TICK_HOOK_EN > 0u
X#if 1u > 0u
Nvoid          App_TimeTickHook        (void);
N#endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                          FUNCTION PROTOTYPES
N*
N* IMPORTANT: These prototypes MUST be placed in OS_CPU.H
N*********************************************************************************************************
N*/
N
N#if 0
Svoid          OSStartHighRdy          (void);
Svoid          OSIntCtxSw              (void);
Svoid          OSCtxSw                 (void);
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                   LOOK FOR MISSING #define CONSTANTS
N*
N* This section is used to generate ERROR messages at compile time if certain #define constants are
N* MISSING in OS_CFG.H.  This allows you to quickly determine the source of the error.
N*
N* You SHOULD NOT change this section UNLESS you would like to add more comments as to the source of the
N* compile time error.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                             EVENT FLAGS
N*********************************************************************************************************
N*/
N
N#ifndef OS_FLAG_EN
S#error  "OS_CFG.H, Missing OS_FLAG_EN: Enable (1) or Disable (0) code generation for Event Flags"
N#else
N    #ifndef OS_MAX_FLAGS
S    #error  "OS_CFG.H, Missing OS_MAX_FLAGS: Max. number of Event Flag Groups in your application"
N    #else
N        #if     OS_MAX_FLAGS > 65500u
X        #if     5u > 65500u
S        #error  "OS_CFG.H, OS_MAX_FLAGS must be <= 65500"
N        #endif
N    #endif
N
N    #ifndef OS_FLAGS_NBITS
S    #error  "OS_CFG.H, Missing OS_FLAGS_NBITS: Determine #bits used for event flags, MUST be either 8, 16 or 32"
N    #endif
N
N    #ifndef OS_FLAG_WAIT_CLR_EN
S    #error  "OS_CFG.H, Missing OS_FLAG_WAIT_CLR_EN: Include code for Wait on Clear EVENT FLAGS"
N    #endif
N
N    #ifndef OS_FLAG_ACCEPT_EN
S    #error  "OS_CFG.H, Missing OS_FLAG_ACCEPT_EN: Include code for OSFlagAccept()"
N    #endif
N
N    #ifndef OS_FLAG_DEL_EN
S    #error  "OS_CFG.H, Missing OS_FLAG_DEL_EN: Include code for OSFlagDel()"
N    #endif
N
N    #ifndef OS_FLAG_NAME_EN
S    #error  "OS_CFG.H, Missing OS_FLAG_NAME_EN: Enable flag group names"
N    #endif
N
N    #ifndef OS_FLAG_QUERY_EN
S    #error  "OS_CFG.H, Missing OS_FLAG_QUERY_EN: Include code for OSFlagQuery()"
N    #endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                          MESSAGE MAILBOXES
N*********************************************************************************************************
N*/
N
N#ifndef OS_MBOX_EN
S#error  "OS_CFG.H, Missing OS_MBOX_EN: Enable (1) or Disable (0) code generation for MAILBOXES"
N#else
N    #ifndef OS_MBOX_ACCEPT_EN
S    #error  "OS_CFG.H, Missing OS_MBOX_ACCEPT_EN: Include code for OSMboxAccept()"
N    #endif
N
N    #ifndef OS_MBOX_DEL_EN
S    #error  "OS_CFG.H, Missing OS_MBOX_DEL_EN: Include code for OSMboxDel()"
N    #endif
N
N    #ifndef OS_MBOX_PEND_ABORT_EN
S    #error  "OS_CFG.H, Missing OS_MBOX_PEND_ABORT_EN: Include code for OSMboxPendAbort()"
N    #endif
N
N    #ifndef OS_MBOX_POST_EN
S    #error  "OS_CFG.H, Missing OS_MBOX_POST_EN: Include code for OSMboxPost()"
N    #endif
N
N    #ifndef OS_MBOX_POST_OPT_EN
S    #error  "OS_CFG.H, Missing OS_MBOX_POST_OPT_EN: Include code for OSMboxPostOpt()"
N    #endif
N
N    #ifndef OS_MBOX_QUERY_EN
S    #error  "OS_CFG.H, Missing OS_MBOX_QUERY_EN: Include code for OSMboxQuery()"
N    #endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                          MEMORY MANAGEMENT
N*********************************************************************************************************
N*/
N
N#ifndef OS_MEM_EN
S#error  "OS_CFG.H, Missing OS_MEM_EN: Enable (1) or Disable (0) code generation for MEMORY MANAGER"
N#else
N    #ifndef OS_MAX_MEM_PART
S    #error  "OS_CFG.H, Missing OS_MAX_MEM_PART: Max. number of memory partitions"
N    #else
N        #if     OS_MAX_MEM_PART > 65500u
X        #if     5u > 65500u
S        #error  "OS_CFG.H, OS_MAX_MEM_PART must be <= 65500"
N        #endif
N    #endif
N
N    #ifndef OS_MEM_NAME_EN
S    #error  "OS_CFG.H, Missing OS_MEM_NAME_EN: Enable memory partition names"
N    #endif
N
N    #ifndef OS_MEM_QUERY_EN
S    #error  "OS_CFG.H, Missing OS_MEM_QUERY_EN: Include code for OSMemQuery()"
N    #endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                     MUTUAL EXCLUSION SEMAPHORES
N*********************************************************************************************************
N*/
N
N#ifndef OS_MUTEX_EN
S#error  "OS_CFG.H, Missing OS_MUTEX_EN: Enable (1) or Disable (0) code generation for MUTEX"
N#else
N    #ifndef OS_MUTEX_ACCEPT_EN
S    #error  "OS_CFG.H, Missing OS_MUTEX_ACCEPT_EN: Include code for OSMutexAccept()"
N    #endif
N
N    #ifndef OS_MUTEX_DEL_EN
S    #error  "OS_CFG.H, Missing OS_MUTEX_DEL_EN: Include code for OSMutexDel()"
N    #endif
N
N    #ifndef OS_MUTEX_QUERY_EN
S    #error  "OS_CFG.H, Missing OS_MUTEX_QUERY_EN: Include code for OSMutexQuery()"
N    #endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                           MESSAGE QUEUES
N*********************************************************************************************************
N*/
N
N#ifndef OS_Q_EN
S#error  "OS_CFG.H, Missing OS_Q_EN: Enable (1) or Disable (0) code generation for QUEUES"
N#else
N    #ifndef OS_MAX_QS
S    #error  "OS_CFG.H, Missing OS_MAX_QS: Max. number of queue control blocks"
N    #else
N        #if     OS_MAX_QS > 65500u
X        #if     4u > 65500u
S        #error  "OS_CFG.H, OS_MAX_QS must be <= 65500"
N        #endif
N    #endif
N
N    #ifndef OS_Q_ACCEPT_EN
S    #error  "OS_CFG.H, Missing OS_Q_ACCEPT_EN: Include code for OSQAccept()"
N    #endif
N
N    #ifndef OS_Q_DEL_EN
S    #error  "OS_CFG.H, Missing OS_Q_DEL_EN: Include code for OSQDel()"
N    #endif
N
N    #ifndef OS_Q_FLUSH_EN
S    #error  "OS_CFG.H, Missing OS_Q_FLUSH_EN: Include code for OSQFlush()"
N    #endif
N
N    #ifndef OS_Q_PEND_ABORT_EN
S    #error  "OS_CFG.H, Missing OS_Q_PEND_ABORT_EN: Include code for OSQPendAbort()"
N    #endif
N
N    #ifndef OS_Q_POST_EN
S    #error  "OS_CFG.H, Missing OS_Q_POST_EN: Include code for OSQPost()"
N    #endif
N
N    #ifndef OS_Q_POST_FRONT_EN
S    #error  "OS_CFG.H, Missing OS_Q_POST_FRONT_EN: Include code for OSQPostFront()"
N    #endif
N
N    #ifndef OS_Q_POST_OPT_EN
S    #error  "OS_CFG.H, Missing OS_Q_POST_OPT_EN: Include code for OSQPostOpt()"
N    #endif
N
N    #ifndef OS_Q_QUERY_EN
S    #error  "OS_CFG.H, Missing OS_Q_QUERY_EN: Include code for OSQQuery()"
N    #endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                             SEMAPHORES
N*********************************************************************************************************
N*/
N
N#ifndef OS_SEM_EN
S#error  "OS_CFG.H, Missing OS_SEM_EN: Enable (1) or Disable (0) code generation for SEMAPHORES"
N#else
N    #ifndef OS_SEM_ACCEPT_EN
S    #error  "OS_CFG.H, Missing OS_SEM_ACCEPT_EN: Include code for OSSemAccept()"
N    #endif
N
N    #ifndef OS_SEM_DEL_EN
S    #error  "OS_CFG.H, Missing OS_SEM_DEL_EN: Include code for OSSemDel()"
N    #endif
N
N    #ifndef OS_SEM_PEND_ABORT_EN
S    #error  "OS_CFG.H, Missing OS_SEM_PEND_ABORT_EN: Include code for OSSemPendAbort()"
N    #endif
N
N    #ifndef OS_SEM_QUERY_EN
S    #error  "OS_CFG.H, Missing OS_SEM_QUERY_EN: Include code for OSSemQuery()"
N    #endif
N
N    #ifndef OS_SEM_SET_EN
S    #error  "OS_CFG.H, Missing OS_SEM_SET_EN: Include code for OSSemSet()"
N    #endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                           TASK MANAGEMENT
N*********************************************************************************************************
N*/
N
N#ifndef OS_MAX_TASKS
S#error  "OS_CFG.H, Missing OS_MAX_TASKS: Max. number of tasks in your application"
N#else
N    #if     OS_MAX_TASKS < 2u
X    #if     20u < 2u
S    #error  "OS_CFG.H,         OS_MAX_TASKS must be >= 2"
N    #endif
N
N    #if     OS_MAX_TASKS >  ((OS_LOWEST_PRIO - OS_N_SYS_TASKS) + 1u)
X    #if     20u >  ((63u - 2u) + 1u)
S    #error  "OS_CFG.H,         OS_MAX_TASKS must be <= OS_LOWEST_PRIO - OS_N_SYS_TASKS + 1"
N    #endif
N
N#endif
N
N#if     OS_LOWEST_PRIO >  254u
X#if     63u >  254u
S#error  "OS_CFG.H,         OS_LOWEST_PRIO must be <= 254 in V2.8x and higher"
N#endif
N
N#ifndef OS_TASK_IDLE_STK_SIZE
S#error  "OS_CFG.H, Missing OS_TASK_IDLE_STK_SIZE: Idle task stack size"
N#endif
N
N#ifndef OS_TASK_STAT_EN
S#error  "OS_CFG.H, Missing OS_TASK_STAT_EN: Enable (1) or Disable(0) the statistics task"
N#endif
N
N#ifndef OS_TASK_STAT_STK_SIZE
S#error  "OS_CFG.H, Missing OS_TASK_STAT_STK_SIZE: Statistics task stack size"
N#endif
N
N#ifndef OS_TASK_STAT_STK_CHK_EN
S#error  "OS_CFG.H, Missing OS_TASK_STAT_STK_CHK_EN: Check task stacks from statistics task"
N#endif
N
N#ifndef OS_TASK_CHANGE_PRIO_EN
S#error  "OS_CFG.H, Missing OS_TASK_CHANGE_PRIO_EN: Include code for OSTaskChangePrio()"
N#endif
N
N#ifndef OS_TASK_CREATE_EN
S#error  "OS_CFG.H, Missing OS_TASK_CREATE_EN: Include code for OSTaskCreate()"
N#endif
N
N#ifndef OS_TASK_CREATE_EXT_EN
S#error  "OS_CFG.H, Missing OS_TASK_CREATE_EXT_EN: Include code for OSTaskCreateExt()"
N#else
N    #if (OS_TASK_CREATE_EXT_EN == 0u) && (OS_TASK_CREATE_EN == 0u)
X    #if (1u == 0u) && (1u == 0u)
S    #error  "OS_CFG.H,         OS_TASK_CREATE_EXT_EN or OS_TASK_CREATE_EN must be Enable (1)"
N    #endif
N#endif
N
N#ifndef OS_TASK_DEL_EN
S#error  "OS_CFG.H, Missing OS_TASK_DEL_EN: Include code for OSTaskDel()"
N#endif
N
N#ifndef OS_TASK_NAME_EN
S#error  "OS_CFG.H, Missing OS_TASK_NAME_EN: Enable task names"
N#endif
N
N#ifndef OS_TASK_SUSPEND_EN
S#error  "OS_CFG.H, Missing OS_TASK_SUSPEND_EN: Include code for OSTaskSuspend() and OSTaskResume()"
N#endif
N
N#ifndef OS_TASK_QUERY_EN
S#error  "OS_CFG.H, Missing OS_TASK_QUERY_EN: Include code for OSTaskQuery()"
N#endif
N
N#ifndef OS_TASK_REG_TBL_SIZE
S#error  "OS_CFG.H, Missing OS_TASK_REG_TBL_SIZE: Include code for task specific registers"
N#else
N    #if     OS_TASK_REG_TBL_SIZE > 255u
X    #if     1u > 255u
S    #error  "OS_CFG.H,         OS_TASK_REG_TBL_SIZE must be <= 255"
N    #endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                           TIME MANAGEMENT
N*********************************************************************************************************
N*/
N
N#ifndef OS_TICKS_PER_SEC
S#error  "OS_CFG.H, Missing OS_TICKS_PER_SEC: Sets the number of ticks in one second"
N#endif
N
N#ifndef OS_TIME_DLY_HMSM_EN
S#error  "OS_CFG.H, Missing OS_TIME_DLY_HMSM_EN: Include code for OSTimeDlyHMSM()"
N#endif
N
N#ifndef OS_TIME_DLY_RESUME_EN
S#error  "OS_CFG.H, Missing OS_TIME_DLY_RESUME_EN: Include code for OSTimeDlyResume()"
N#endif
N
N#ifndef OS_TIME_GET_SET_EN
S#error  "OS_CFG.H, Missing OS_TIME_GET_SET_EN: Include code for OSTimeGet() and OSTimeSet()"
N#endif
N
N/*
N*********************************************************************************************************
N*                                          TIMER MANAGEMENT
N*********************************************************************************************************
N*/
N
N#ifndef OS_TMR_EN
S#error  "OS_CFG.H, Missing OS_TMR_EN: When (1) enables code generation for Timer Management"
N#elif   OS_TMR_EN > 0u
X#elif   1u > 0u
N    #if     OS_SEM_EN == 0u
X    #if     1u == 0u
S    #error  "OS_CFG.H, Semaphore management is required (set OS_SEM_EN to 1) when enabling Timer Management."
S    #error  "          Timer management require TWO semaphores."
N    #endif
N
N    #ifndef OS_TMR_CFG_MAX
S    #error  "OS_CFG.H, Missing OS_TMR_CFG_MAX: Determines the total number of timers in an application (2 .. 65500)"
N    #else
N        #if OS_TMR_CFG_MAX < 2u
X        #if 16u < 2u
S        #error  "OS_CFG.H, OS_TMR_CFG_MAX should be between 2 and 65500"
N        #endif
N
N        #if OS_TMR_CFG_MAX > 65500u
X        #if 16u > 65500u
S        #error  "OS_CFG.H, OS_TMR_CFG_MAX should be between 2 and 65500"
N        #endif
N    #endif
N
N    #ifndef OS_TMR_CFG_WHEEL_SIZE
S    #error  "OS_CFG.H, Missing OS_TMR_CFG_WHEEL_SIZE: Sets the size of the timer wheel (1 .. 1023)"
N    #else
N        #if OS_TMR_CFG_WHEEL_SIZE < 2u
X        #if 8u < 2u
S        #error  "OS_CFG.H, OS_TMR_CFG_WHEEL_SIZE should be between 2 and 1024"
N        #endif
N
N        #if OS_TMR_CFG_WHEEL_SIZE > 1024u
X        #if 8u > 1024u
S        #error  "OS_CFG.H, OS_TMR_CFG_WHEEL_SIZE should be between 2 and 1024"
N        #endif
N    #endif
N
N    #ifndef OS_TMR_CFG_NAME_EN
S    #error  "OS_CFG.H, Missing OS_TMR_CFG_NAME_EN: Enable Timer names"
N    #endif
N
N    #ifndef OS_TMR_CFG_TICKS_PER_SEC
S    #error  "OS_CFG.H, Missing OS_TMR_CFG_TICKS_PER_SEC: Determines the rate at which the timer management task will run (Hz)"
N    #endif
N
N    #ifndef OS_TASK_TMR_STK_SIZE
S    #error  "OS_CFG.H, Missing OS_TASK_TMR_STK_SIZE: Determines the size of the Timer Task's stack"
N    #endif
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                            MISCELLANEOUS
N*********************************************************************************************************
N*/
N
N#ifndef OS_ARG_CHK_EN
S#error  "OS_CFG.H, Missing OS_ARG_CHK_EN: Enable (1) or Disable (0) argument checking"
N#endif
N
N
N#ifndef OS_CPU_HOOKS_EN
S#error  "OS_CFG.H, Missing OS_CPU_HOOKS_EN: uC/OS-II hooks are found in the processor port files when 1"
N#endif
N
N
N#ifndef OS_APP_HOOKS_EN
S#error  "OS_CFG.H, Missing OS_APP_HOOKS_EN: Application-defined hooks are called from the uC/OS-II hooks"
N#endif
N
N
N#ifndef OS_DEBUG_EN
S#error  "OS_CFG.H, Missing OS_DEBUG_EN: Allows you to include variables for debugging or not"
N#endif
N
N
N#ifndef OS_LOWEST_PRIO
S#error  "OS_CFG.H, Missing OS_LOWEST_PRIO: Defines the lowest priority that can be assigned"
N#endif
N
N
N#ifndef OS_MAX_EVENTS
S#error  "OS_CFG.H, Missing OS_MAX_EVENTS: Max. number of event control blocks in your application"
N#else
N    #if     OS_MAX_EVENTS > 65500u
X    #if     80u > 65500u
S    #error  "OS_CFG.H, OS_MAX_EVENTS must be <= 65500"
N    #endif
N#endif
N
N
N#ifndef OS_SCHED_LOCK_EN
S#error  "OS_CFG.H, Missing OS_SCHED_LOCK_EN: Include code for OSSchedLock() and OSSchedUnlock()"
N#endif
N
N
N#ifndef OS_EVENT_MULTI_EN
S#error  "OS_CFG.H, Missing OS_EVENT_MULTI_EN: Include code for OSEventPendMulti()"
N#endif
N
N
N#ifndef OS_TASK_PROFILE_EN
S#error  "OS_CFG.H, Missing OS_TASK_PROFILE_EN: Include data structure for run-time task profiling"
N#endif
N
N
N#ifndef OS_TASK_SW_HOOK_EN
S#error  "OS_CFG.H, Missing OS_TASK_SW_HOOK_EN: Allows you to include the code for OSTaskSwHook() or not"
N#endif
N
N
N#ifndef OS_TICK_STEP_EN
S#error  "OS_CFG.H, Missing OS_TICK_STEP_EN: Allows to 'step' one tick at a time with uC/OS-View"
N#endif
N
N
N#ifndef OS_TIME_TICK_HOOK_EN
S#error  "OS_CFG.H, Missing OS_TIME_TICK_HOOK_EN: Allows you to include the code for OSTimeTickHook() or not"
N#endif
N
N/*
N*********************************************************************************************************
N*                                         SAFETY CRITICAL USE
N*********************************************************************************************************
N*/
N
N#ifdef SAFETY_CRITICAL_RELEASE
S
S#if    OS_ARG_CHK_EN < 1u
S#error "OS_CFG.H, OS_ARG_CHK_EN must be enabled for safety-critical release code"
S#endif
S
S#if    OS_APP_HOOKS_EN > 0u
S#error "OS_CFG.H, OS_APP_HOOKS_EN must be disabled for safety-critical release code"
S#endif
S
S#if    OS_DEBUG_EN > 0u
S#error "OS_CFG.H, OS_DEBUG_EN must be disabled for safety-critical release code"
S#endif
S
S#ifdef CANTATA
S#error "OS_CFG.H, CANTATA must be disabled for safety-critical release code"
S#endif
S
S#ifdef OS_SCHED_LOCK_EN
S#error "OS_CFG.H, OS_SCHED_LOCK_EN must be disabled for safety-critical release code"
S#endif
S
S#ifdef VSC_VALIDATION_MODE
S#error "OS_CFG.H, VSC_VALIDATION_MODE must be disabled for safety-critical release code"
S#endif
S
S#if    OS_TASK_STAT_EN > 0u
S#error "OS_CFG.H, OS_TASK_STAT_EN must be disabled for safety-critical release code"
S#endif
S
S#if    OS_TICK_STEP_EN > 0u
S#error "OS_CFG.H, OS_TICK_STEP_EN must be disabled for safety-critical release code"
S#endif
S
S#if    OS_FLAG_EN > 0u
S    #if    OS_FLAG_DEL_EN > 0
S    #error "OS_CFG.H, OS_FLAG_DEL_EN must be disabled for safety-critical release code"
S    #endif
S#endif
S
S#if    OS_MBOX_EN > 0u
S    #if    OS_MBOX_DEL_EN > 0u
S    #error "OS_CFG.H, OS_MBOX_DEL_EN must be disabled for safety-critical release code"
S    #endif
S#endif
S
S#if    OS_MUTEX_EN > 0u
S    #if    OS_MUTEX_DEL_EN > 0u
S    #error "OS_CFG.H, OS_MUTEX_DEL_EN must be disabled for safety-critical release code"
S    #endif
S#endif
S
S#if    OS_Q_EN > 0u
S    #if    OS_Q_DEL_EN > 0u
S    #error "OS_CFG.H, OS_Q_DEL_EN must be disabled for safety-critical release code"
S    #endif
S#endif
S
S#if    OS_SEM_EN > 0u
S    #if    OS_SEM_DEL_EN > 0u
S    #error "OS_CFG.H, OS_SEM_DEL_EN must be disabled for safety-critical release code"
S    #endif
S#endif
S
S#if    OS_TASK_DEL_EN > 0u
S#error "OS_CFG.H, OS_TASK_DEL_EN must be disabled for safety-critical release code"
S#endif
S
S#if    OS_CRITICAL_METHOD != 3u
S#error "OS_CPU.H, OS_CRITICAL_METHOD must be type 3 for safety-critical release code"
S#endif
S
N#endif  /* ------------------------ SAFETY_CRITICAL_RELEASE ------------------------ */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 28 "..\..\uCOS-II\Source\os_task.c" 2
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                      CHANGE PRIORITY OF A TASK
N*
N* Description: This function allows you to change the priority of a task dynamically.  Note that the new
N*              priority MUST be available.
N*
N* Arguments  : oldp     is the old priority
N*
N*              newp     is the new priority
N*
N* Returns    : OS_ERR_NONE            is the call was successful
N*              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
N*                                     (i.e. >= OS_LOWEST_PRIO)
N*              OS_ERR_PRIO_EXIST      if the new priority already exist.
N*              OS_ERR_PRIO            there is no task with the specified OLD priority (i.e. the OLD task does
N*                                     not exist.
N*              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP.
N*********************************************************************************************************
N*/
N
N#if OS_TASK_CHANGE_PRIO_EN > 0u
X#if 1u > 0u
NINT8U  OSTaskChangePrio (INT8U  oldprio,
N                         INT8U  newprio)
N{
N#if (OS_EVENT_EN)
X#if ((((1u > 0u) && (4u > 0u)) || (1u > 0u) || (1u > 0u) || (1u > 0u)))
N    OS_EVENT  *pevent;
N#if (OS_EVENT_MULTI_EN > 0u)
X#if (1u > 0u)
N    OS_EVENT **pevents;
N#endif
N#endif
N    OS_TCB    *ptcb;
N    INT8U      y_new;
N    INT8U      x_new;
N    INT8U      y_old;
N    OS_PRIO    bity_new;
N    OS_PRIO    bitx_new;
N    OS_PRIO    bity_old;
N    OS_PRIO    bitx_old;
N#if OS_CRITICAL_METHOD == 3u
X#if 3u == 3u
N    OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
N#endif
N
N
N/*$PAGE*/
N#if OS_ARG_CHK_EN > 0u
X#if 0u > 0u
S    if (oldprio >= OS_LOWEST_PRIO) {
S        if (oldprio != OS_PRIO_SELF) {
S            return (OS_ERR_PRIO_INVALID);
S        }
S    }
S    if (newprio >= OS_LOWEST_PRIO) {
S        return (OS_ERR_PRIO_INVALID);
S    }
N#endif
N    OS_ENTER_CRITICAL();
X    {cpu_sr = OS_CPU_SR_Save();};
N    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
N        OS_EXIT_CRITICAL();
X        {OS_CPU_SR_Restore(cpu_sr);};
N        return (OS_ERR_PRIO_EXIST);
X        return (40u);
N    }
N    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
X    if (oldprio == 0xFFu) {                           
N        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
N    }
N    ptcb = OSTCBPrioTbl[oldprio];
N    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
N        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
X        {OS_CPU_SR_Restore(cpu_sr);};                                  
N        return (OS_ERR_PRIO);
X        return (41u);
N    }
N    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
X    if (ptcb == ((OS_TCB *)1)) {                           
N        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
X        {OS_CPU_SR_Restore(cpu_sr);};                                  
N        return (OS_ERR_TASK_NOT_EXIST);
X        return (67u);
N    }
N#if OS_LOWEST_PRIO <= 63u
X#if 63u <= 63u
N    y_new                 = (INT8U)(newprio >> 3u);         /* Yes, compute new TCB fields             */
N    x_new                 = (INT8U)(newprio & 0x07u);
N#else
S    y_new                 = (INT8U)((INT8U)(newprio >> 4u) & 0x0Fu);
S    x_new                 = (INT8U)(newprio & 0x0Fu);
N#endif
N    bity_new              = (OS_PRIO)(1uL << y_new);
N    bitx_new              = (OS_PRIO)(1uL << x_new);
N
N    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
N    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
N    y_old                 =  ptcb->OSTCBY;
N    bity_old              =  ptcb->OSTCBBitY;
N    bitx_old              =  ptcb->OSTCBBitX;
N    if ((OSRdyTbl[y_old] &   bitx_old) != 0u) {             /* If task is ready make it not            */
N         OSRdyTbl[y_old] &= (OS_PRIO)~bitx_old;
N         if (OSRdyTbl[y_old] == 0u) {
N             OSRdyGrp &= (OS_PRIO)~bity_old;
N         }
N         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
N         OSRdyTbl[y_new] |= bitx_new;
N    }
N
N#if (OS_EVENT_EN)
X#if ((((1u > 0u) && (4u > 0u)) || (1u > 0u) || (1u > 0u) || (1u > 0u)))
N    pevent = ptcb->OSTCBEventPtr;
N    if (pevent != (OS_EVENT *)0) {
N        pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;    /* Remove old task prio from wait list     */
N        if (pevent->OSEventTbl[y_old] == 0u) {
N            pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
N        }
N        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
N        pevent->OSEventTbl[y_new] |= bitx_new;
N    }
N#if (OS_EVENT_MULTI_EN > 0u)
X#if (1u > 0u)
N    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
N        pevents =  ptcb->OSTCBEventMultiPtr;
N        pevent  = *pevents;
N        while (pevent != (OS_EVENT *)0) {
N            pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;   /* Remove old task prio from wait lists */
N            if (pevent->OSEventTbl[y_old] == 0u) {
N                pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
N            }
N            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
N            pevent->OSEventTbl[y_new] |= bitx_new;
N            pevents++;
N            pevent                     = *pevents;
N        }
N    }
N#endif
N#endif
N
N    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
N    ptcb->OSTCBY    = y_new;
N    ptcb->OSTCBX    = x_new;
N    ptcb->OSTCBBitY = bity_new;
N    ptcb->OSTCBBitX = bitx_new;
N    OS_EXIT_CRITICAL();
X    {OS_CPU_SR_Restore(cpu_sr);};
N    if (OSRunning == OS_TRUE) {
X    if (OSRunning == 1u) {
N        OS_Sched();                                         /* Find new highest priority task          */
N    }
N    return (OS_ERR_NONE);
X    return (0u);
N}
N#endif
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            CREATE A TASK
N*
N* Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
N*              be created prior to the start of multitasking or by a running task.  A task cannot be
N*              created by an ISR.
N*
N* Arguments  : task     is a pointer to the task's code
N*
N*              p_arg    is a pointer to an optional data area which can be used to pass parameters to
N*                       the task when the task first executes.  Where the task is concerned it thinks
N*                       it was invoked and passed the argument 'p_arg' as follows:
N*
N*                           void Task (void *p_arg)
N*                           {
N*                               for (;;) {
N*                                   Task code;
N*                               }
N*                           }
N*
N*              ptos     is a pointer to the task's top of stack.  If the configuration constant
N*                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
N*                       memory to low memory).  'pstk' will thus point to the highest (valid) memory
N*                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pstk' will point to the
N*                       lowest memory location of the stack and the stack will grow with increasing
N*                       memory locations.
N*
N*              prio     is the task's priority.  A unique priority MUST be assigned to each task and the
N*                       lower the number, the higher the priority.
N*
N* Returns    : OS_ERR_NONE                      if the function was successful.
N*              OS_ERR_PRIO_EXIST                if the task priority already exist
N*                                               (each task MUST have a unique priority).
N*              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
N*                                               allowed (i.e. >= OS_LOWEST_PRIO)
N*              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
N*              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
N*                                               operation started.
N*********************************************************************************************************
N*/
N
N#if OS_TASK_CREATE_EN > 0u
X#if 1u > 0u
NINT8U  OSTaskCreate (void   (*task)(void *p_arg),
N                     void    *p_arg,
N                     OS_STK  *ptos,
N                     INT8U    prio)
N{
N    OS_STK     *psp;
N    INT8U       err;
N#if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
X#if 3u == 3u                  
N    OS_CPU_SR   cpu_sr = 0u;
N#endif
N
N
N
N#ifdef OS_SAFETY_CRITICAL_IEC61508
S    if (OSSafetyCriticalStartFlag == OS_TRUE) {
S        OS_SAFETY_CRITICAL_EXCEPTION();
S        return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
S    }
N#endif
N
N#if OS_ARG_CHK_EN > 0u
X#if 0u > 0u
S    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
S        return (OS_ERR_PRIO_INVALID);
S    }
N#endif
N    OS_ENTER_CRITICAL();
X    {cpu_sr = OS_CPU_SR_Save();};
N    if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
N        OS_EXIT_CRITICAL();
X        {OS_CPU_SR_Restore(cpu_sr);};
N        return (OS_ERR_TASK_CREATE_ISR);
X        return (60u);
N    }
N    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
N        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
X        OSTCBPrioTbl[prio] = ((OS_TCB *)1); 
N                                             /* ... the same thing until task is created.              */
N        OS_EXIT_CRITICAL();
X        {OS_CPU_SR_Restore(cpu_sr);};
N        psp = OSTaskStkInit(task, p_arg, ptos, 0u);             /* Initialize the task's stack         */
N        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0u, 0u, (void *)0, 0u);
N        if (err == OS_ERR_NONE) {
X        if (err == 0u) {
N            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
X            if (OSRunning == 1u) {       
N                OS_Sched();
N            }
N        } else {
N            OS_ENTER_CRITICAL();
X            {cpu_sr = OS_CPU_SR_Save();};
N            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
N            OS_EXIT_CRITICAL();
X            {OS_CPU_SR_Restore(cpu_sr);};
N        }
N        return (err);
N    }
N    OS_EXIT_CRITICAL();
X    {OS_CPU_SR_Restore(cpu_sr);};
N    return (OS_ERR_PRIO_EXIST);
X    return (40u);
N}
N#endif
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                  CREATE A TASK (Extended Version)
N*
N* Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
N*              be created prior to the start of multitasking or by a running task.  A task cannot be
N*              created by an ISR.  This function is similar to OSTaskCreate() except that it allows
N*              additional information about a task to be specified.
N*
N* Arguments  : task      is a pointer to the task's code
N*
N*              p_arg     is a pointer to an optional data area which can be used to pass parameters to
N*                        the task when the task first executes.  Where the task is concerned it thinks
N*                        it was invoked and passed the argument 'p_arg' as follows:
N*
N*                            void Task (void *p_arg)
N*                            {
N*                                for (;;) {
N*                                    Task code;
N*                                }
N*                            }
N*
N*              ptos      is a pointer to the task's top of stack.  If the configuration constant
N*                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
N*                        memory to low memory).  'ptos' will thus point to the highest (valid) memory
N*                        location of the stack.  If OS_STK_GROWTH is set to 0, 'ptos' will point to the
N*                        lowest memory location of the stack and the stack will grow with increasing
N*                        memory locations.  'ptos' MUST point to a valid 'free' data item.
N*
N*              prio      is the task's priority.  A unique priority MUST be assigned to each task and the
N*                        lower the number, the higher the priority.
N*
N*              id        is the task's ID (0..65535)
N*
N*              pbos      is a pointer to the task's bottom of stack.  If the configuration constant
N*                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
N*                        memory to low memory).  'pbos' will thus point to the LOWEST (valid) memory
N*                        location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
N*                        HIGHEST memory location of the stack and the stack will grow with increasing
N*                        memory locations.  'pbos' MUST point to a valid 'free' data item.
N*
N*              stk_size  is the size of the stack in number of elements.  If OS_STK is set to INT8U,
N*                        'stk_size' corresponds to the number of bytes available.  If OS_STK is set to
N*                        INT16U, 'stk_size' contains the number of 16-bit entries available.  Finally, if
N*                        OS_STK is set to INT32U, 'stk_size' contains the number of 32-bit entries
N*                        available on the stack.
N*
N*              pext      is a pointer to a user supplied memory location which is used as a TCB extension.
N*                        For example, this user memory can hold the contents of floating-point registers
N*                        during a context switch, the time each task takes to execute, the number of times
N*                        the task has been switched-in, etc.
N*
N*              opt       contains additional information (or options) about the behavior of the task.  The
N*                        LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
N*                        specific.  See OS_TASK_OPT_??? in uCOS-II.H.  Current choices are:
N*
N*                        OS_TASK_OPT_STK_CHK      Stack checking to be allowed for the task
N*                        OS_TASK_OPT_STK_CLR      Clear the stack when the task is created
N*                        OS_TASK_OPT_SAVE_FP      If the CPU has floating-point registers, save them
N*                                                 during a context switch.
N*
N* Returns    : OS_ERR_NONE                      if the function was successful.
N*              OS_ERR_PRIO_EXIST                if the task priority already exist
N*                                               (each task MUST have a unique priority).
N*              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
N*                                               allowed (i.e. > OS_LOWEST_PRIO)
N*              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
N*              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
N*                                               operation started.
N*********************************************************************************************************
N*/
N/*$PAGE*/
N#if OS_TASK_CREATE_EXT_EN > 0u
X#if 1u > 0u
NINT8U  OSTaskCreateExt (void   (*task)(void *p_arg),
N                        void    *p_arg,
N                        OS_STK  *ptos,
N                        INT8U    prio,
N                        INT16U   id,
N                        OS_STK  *pbos,
N                        INT32U   stk_size,
N                        void    *pext,
N                        INT16U   opt)
N{
N    OS_STK     *psp;
N    INT8U       err;
N#if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
X#if 3u == 3u                  
N    OS_CPU_SR   cpu_sr = 0u;
N#endif
N
N
N
N#ifdef OS_SAFETY_CRITICAL_IEC61508
S    if (OSSafetyCriticalStartFlag == OS_TRUE) {
S        OS_SAFETY_CRITICAL_EXCEPTION();
S        return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
S    }
N#endif
N
N#if OS_ARG_CHK_EN > 0u
X#if 0u > 0u
S    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
S        return (OS_ERR_PRIO_INVALID);
S    }
N#endif
N    OS_ENTER_CRITICAL();
X    {cpu_sr = OS_CPU_SR_Save();};
N    if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
N        OS_EXIT_CRITICAL();
X        {OS_CPU_SR_Restore(cpu_sr);};
N        return (OS_ERR_TASK_CREATE_ISR);
X        return (60u);
N    }
N    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
N        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
X        OSTCBPrioTbl[prio] = ((OS_TCB *)1); 
N                                             /* ... the same thing until task is created.              */
N        OS_EXIT_CRITICAL();
X        {OS_CPU_SR_Restore(cpu_sr);};
N
N#if (OS_TASK_STAT_STK_CHK_EN > 0u)
X#if (1u > 0u)
N        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
N#endif
N
N        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
N        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
N        if (err == OS_ERR_NONE) {
X        if (err == 0u) {
N            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
X            if (OSRunning == 1u) {                         
N                OS_Sched();
N            }
N        } else {
N            OS_ENTER_CRITICAL();
X            {cpu_sr = OS_CPU_SR_Save();};
N            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
N            OS_EXIT_CRITICAL();
X            {OS_CPU_SR_Restore(cpu_sr);};
N        }
N        return (err);
N    }
N    OS_EXIT_CRITICAL();
X    {OS_CPU_SR_Restore(cpu_sr);};
N    return (OS_ERR_PRIO_EXIST);
X    return (40u);
N}
N#endif
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            DELETE A TASK
N*
N* Description: This function allows you to delete a task.  The calling task can delete itself by
N*              its own priority number.  The deleted task is returned to the dormant state and can be
N*              re-activated by creating the deleted task again.
N*
N* Arguments  : prio    is the priority of the task to delete.  Note that you can explicitly delete
N*                      the current task without knowing its priority level by setting 'prio' to
N*                      OS_PRIO_SELF.
N*
N* Returns    : OS_ERR_NONE             if the call is successful
N*              OS_ERR_TASK_DEL_IDLE    if you attempted to delete uC/OS-II's idle task
N*              OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
N*                                      (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
N*              OS_ERR_TASK_DEL         if the task is assigned to a Mutex PIP.
N*              OS_ERR_TASK_NOT_EXIST   if the task you want to delete does not exist.
N*              OS_ERR_TASK_DEL_ISR     if you tried to delete a task from an ISR
N*
N* Notes      : 1) To reduce interrupt latency, OSTaskDel() 'disables' the task:
N*                    a) by making it not ready
N*                    b) by removing it from any wait lists
N*                    c) by preventing OSTimeTick() from making the task ready to run.
N*                 The task can then be 'unlinked' from the miscellaneous structures in uC/OS-II.
N*              2) The function OS_Dummy() is called after OS_EXIT_CRITICAL() because, on most processors,
N*                 the next instruction following the enable interrupt instruction is ignored.
N*              3) An ISR cannot delete a task.
N*              4) The lock nesting counter is incremented because, for a brief instant, if the current
N*                 task is being deleted, the current task would not be able to be rescheduled because it
N*                 is removed from the ready list.  Incrementing the nesting counter prevents another task
N*                 from being schedule.  This means that an ISR would return to the current task which is
N*                 being deleted.  The rest of the deletion would thus be able to be completed.
N*********************************************************************************************************
N*/
N
N#if OS_TASK_DEL_EN > 0u
X#if 1u > 0u
NINT8U  OSTaskDel (INT8U prio)
N{
N#if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
X#if (1u > 0u) && (5u > 0u)
N    OS_FLAG_NODE *pnode;
N#endif
N    OS_TCB       *ptcb;
N#if OS_CRITICAL_METHOD == 3u                            /* Allocate storage for CPU status register    */
X#if 3u == 3u                             
N    OS_CPU_SR     cpu_sr = 0u;
N#endif
N
N
N
N    if (OSIntNesting > 0u) {                            /* See if trying to delete from ISR            */
N        return (OS_ERR_TASK_DEL_ISR);
X        return (64u);
N    }
N    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
X    if (prio == (63u)) {                     
N        return (OS_ERR_TASK_DEL_IDLE);
X        return (62u);
N    }
N#if OS_ARG_CHK_EN > 0u
X#if 0u > 0u
S    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
S        if (prio != OS_PRIO_SELF) {
S            return (OS_ERR_PRIO_INVALID);
S        }
S    }
N#endif
N
N/*$PAGE*/
N    OS_ENTER_CRITICAL();
X    {cpu_sr = OS_CPU_SR_Save();};
N    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
X    if (prio == 0xFFu) {                          
N        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
N    }
N    ptcb = OSTCBPrioTbl[prio];
N    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
N        OS_EXIT_CRITICAL();
X        {OS_CPU_SR_Restore(cpu_sr);};
N        return (OS_ERR_TASK_NOT_EXIST);
X        return (67u);
N    }
N    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
X    if (ptcb == ((OS_TCB *)1)) {                       
N        OS_EXIT_CRITICAL();
X        {OS_CPU_SR_Restore(cpu_sr);};
N        return (OS_ERR_TASK_DEL);
X        return (61u);
N    }
N
N    OSRdyTbl[ptcb->OSTCBY] &= (OS_PRIO)~ptcb->OSTCBBitX;
N    if (OSRdyTbl[ptcb->OSTCBY] == 0u) {                 /* Make task not ready                         */
N        OSRdyGrp           &= (OS_PRIO)~ptcb->OSTCBBitY;
N    }
N
N#if (OS_EVENT_EN)
X#if ((((1u > 0u) && (4u > 0u)) || (1u > 0u) || (1u > 0u) || (1u > 0u)))
N    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
N        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
N    }
N#if (OS_EVENT_MULTI_EN > 0u)
X#if (1u > 0u)
N    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
N        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
N    }
N#endif
N#endif
N
N#if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
X#if (1u > 0u) && (5u > 0u)
N    pnode = ptcb->OSTCBFlagNode;
N    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
N        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
N    }
N#endif
N
N    ptcb->OSTCBDly      = 0u;                           /* Prevent OSTimeTick() from updating          */
N    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
X    ptcb->OSTCBStat     = 0x00u;                   
N    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
X    ptcb->OSTCBStatPend = 0u;
N    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
N        OSLockNesting++;
N    }
N    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
X    {OS_CPU_SR_Restore(cpu_sr);};                                  
N    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
N    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
X    {cpu_sr = OS_CPU_SR_Save();};                                 
N    if (OSLockNesting > 0u) {                           /* Remove context switch lock                  */
N        OSLockNesting--;
N    }
N    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
N    OSTaskCtr--;                                        /* One less task being managed                 */
N    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
N    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
N        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
N        OSTCBList                  = ptcb->OSTCBNext;
N    } else {
N        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
N        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
N    }
N    ptcb->OSTCBNext     = OSTCBFreeList;                /* Return TCB to free TCB list                 */
N    OSTCBFreeList       = ptcb;
N#if OS_TASK_NAME_EN > 0u
X#if 1u > 0u
N    ptcb->OSTCBTaskName = (INT8U *)(void *)"?";
N#endif
N    OS_EXIT_CRITICAL();
X    {OS_CPU_SR_Restore(cpu_sr);};
N    if (OSRunning == OS_TRUE) {
X    if (OSRunning == 1u) {
N        OS_Sched();                                     /* Find new highest priority task              */
N    }
N    return (OS_ERR_NONE);
X    return (0u);
N}
N#endif
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                  REQUEST THAT A TASK DELETE ITSELF
N*
N* Description: This function is used to:
N*                   a) notify a task to delete itself.
N*                   b) to see if a task requested that the current task delete itself.
N*              This function is a little tricky to understand.  Basically, you have a task that needs
N*              to be deleted however, this task has resources that it has allocated (memory buffers,
N*              semaphores, mailboxes, queues etc.).  The task cannot be deleted otherwise these
N*              resources would not be freed.  The requesting task calls OSTaskDelReq() to indicate that
N*              the task needs to be deleted.  Deleting of the task is however, deferred to the task to
N*              be deleted.  For example, suppose that task #10 needs to be deleted.  The requesting task
N*              example, task #5, would call OSTaskDelReq(10).  When task #10 gets to execute, it calls
N*              this function by specifying OS_PRIO_SELF and monitors the returned value.  If the return
N*              value is OS_ERR_TASK_DEL_REQ, another task requested a task delete.  Task #10 would look like
N*              this:
N*
N*                   void Task(void *p_arg)
N*                   {
N*                       .
N*                       .
N*                       while (1) {
N*                           OSTimeDly(1);
N*                           if (OSTaskDelReq(OS_PRIO_SELF) == OS_ERR_TASK_DEL_REQ) {
N*                               Release any owned resources;
N*                               De-allocate any dynamic memory;
N*                               OSTaskDel(OS_PRIO_SELF);
N*                           }
N*                       }
N*                   }
N*
N* Arguments  : prio    is the priority of the task to request the delete from
N*
N* Returns    : OS_ERR_NONE            if the task exist and the request has been registered
N*              OS_ERR_TASK_NOT_EXIST  if the task has been deleted.  This allows the caller to know whether
N*                                     the request has been executed.
N*              OS_ERR_TASK_DEL        if the task is assigned to a Mutex.
N*              OS_ERR_TASK_DEL_IDLE   if you requested to delete uC/OS-II's idle task
N*              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
N*                                     (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
N*              OS_ERR_TASK_DEL_REQ    if a task (possibly another task) requested that the running task be
N*                                     deleted.
N*********************************************************************************************************
N*/
N/*$PAGE*/
N#if OS_TASK_DEL_EN > 0u
X#if 1u > 0u
NINT8U  OSTaskDelReq (INT8U prio)
N{
N    INT8U      stat;
N    OS_TCB    *ptcb;
N#if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
X#if 3u == 3u                      
N    OS_CPU_SR  cpu_sr = 0u;
N#endif
N
N
N
N    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
X    if (prio == (63u)) {                             
N        return (OS_ERR_TASK_DEL_IDLE);
X        return (62u);
N    }
N#if OS_ARG_CHK_EN > 0u
X#if 0u > 0u
S    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
S        if (prio != OS_PRIO_SELF) {
S            return (OS_ERR_PRIO_INVALID);
S        }
S    }
N#endif
N    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
X    if (prio == 0xFFu) {                                  
N        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
X        {cpu_sr = OS_CPU_SR_Save();};                                     
N        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
N        OS_EXIT_CRITICAL();
X        {OS_CPU_SR_Restore(cpu_sr);};
N        return (stat);
N    }
N    OS_ENTER_CRITICAL();
X    {cpu_sr = OS_CPU_SR_Save();};
N    ptcb = OSTCBPrioTbl[prio];
N    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
N        OS_EXIT_CRITICAL();
X        {OS_CPU_SR_Restore(cpu_sr);};
N        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
X        return (67u);                          
N    }
N    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
X    if (ptcb == ((OS_TCB *)1)) {                               
N        OS_EXIT_CRITICAL();
X        {OS_CPU_SR_Restore(cpu_sr);};
N        return (OS_ERR_TASK_DEL);
X        return (61u);
N    }
N    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
X    ptcb->OSTCBDelReq = 63u;                     
N    OS_EXIT_CRITICAL();
X    {OS_CPU_SR_Restore(cpu_sr);};
N    return (OS_ERR_NONE);
X    return (0u);
N}
N#endif
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                       GET THE NAME OF A TASK
N*
N* Description: This function is called to obtain the name of a task.
N*
N* Arguments  : prio      is the priority of the task that you want to obtain the name from.
N*
N*              pname     is a pointer to a pointer to an ASCII string that will receive the name of the task.
N*
N*              perr      is a pointer to an error code that can contain one of the following values:
N*
N*                        OS_ERR_NONE                if the requested task is resumed
N*                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
N*                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
N*                                                   A higher value than the idle task or not OS_PRIO_SELF.
N*                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
N*                        OS_ERR_NAME_GET_ISR        You called this function from an ISR
N*
N*
N* Returns    : The length of the string or 0 if the task does not exist.
N*********************************************************************************************************
N*/
N
N#if OS_TASK_NAME_EN > 0u
X#if 1u > 0u
NINT8U  OSTaskNameGet (INT8U    prio,
N                      INT8U  **pname,
N                      INT8U   *perr)
N{
N    OS_TCB    *ptcb;
N    INT8U      len;
N#if OS_CRITICAL_METHOD == 3u                             /* Allocate storage for CPU status register   */
X#if 3u == 3u                              
N    OS_CPU_SR  cpu_sr = 0u;
N#endif
N
N
N
N#ifdef OS_SAFETY_CRITICAL
S    if (perr == (INT8U *)0) {
S        OS_SAFETY_CRITICAL_EXCEPTION();
S        return (0u);
S    }
N#endif
N
N#if OS_ARG_CHK_EN > 0u
X#if 0u > 0u
S    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
S        if (prio != OS_PRIO_SELF) {
S            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
S            return (0u);
S        }
S    }
S    if (pname == (INT8U **)0) {                          /* Is 'pname' a NULL pointer?                 */
S        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
S        return (0u);
S    }
N#endif
N    if (OSIntNesting > 0u) {                              /* See if trying to call from an ISR          */
N        *perr = OS_ERR_NAME_GET_ISR;
X        *perr = 17u;
N        return (0u);
N    }
N    OS_ENTER_CRITICAL();
X    {cpu_sr = OS_CPU_SR_Save();};
N    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
X    if (prio == 0xFFu) {                           
N        prio = OSTCBCur->OSTCBPrio;
N    }
N    ptcb = OSTCBPrioTbl[prio];
N    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
N        OS_EXIT_CRITICAL();                              /* No                                         */
X        {OS_CPU_SR_Restore(cpu_sr);};                               
N        *perr = OS_ERR_TASK_NOT_EXIST;
X        *perr = 67u;
N        return (0u);
N    }
N    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
X    if (ptcb == ((OS_TCB *)1)) {                        
N        OS_EXIT_CRITICAL();                              /* Yes                                        */
X        {OS_CPU_SR_Restore(cpu_sr);};                               
N        *perr = OS_ERR_TASK_NOT_EXIST;
X        *perr = 67u;
N        return (0u);
N    }
N    *pname = ptcb->OSTCBTaskName;
N    len    = OS_StrLen(*pname);
N    OS_EXIT_CRITICAL();
X    {OS_CPU_SR_Restore(cpu_sr);};
N    *perr  = OS_ERR_NONE;
X    *perr  = 0u;
N    return (len);
N}
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                       ASSIGN A NAME TO A TASK
N*
N* Description: This function is used to set the name of a task.
N*
N* Arguments  : prio      is the priority of the task that you want the assign a name to.
N*
N*              pname     is a pointer to an ASCII string that contains the name of the task.
N*
N*              perr       is a pointer to an error code that can contain one of the following values:
N*
N*                        OS_ERR_NONE                if the requested task is resumed
N*                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
N*                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
N*                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
N*                                                   A higher value than the idle task or not OS_PRIO_SELF.
N*                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
N*
N* Returns    : None
N*********************************************************************************************************
N*/
N#if OS_TASK_NAME_EN > 0u
X#if 1u > 0u
Nvoid  OSTaskNameSet (INT8U   prio,
N                     INT8U  *pname,
N                     INT8U  *perr)
N{
N    OS_TCB    *ptcb;
N#if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
X#if 3u == 3u                          
N    OS_CPU_SR  cpu_sr = 0u;
N#endif
N
N
N
N#ifdef OS_SAFETY_CRITICAL
S    if (perr == (INT8U *)0) {
S        OS_SAFETY_CRITICAL_EXCEPTION();
S        return;
S    }
N#endif
N
N#if OS_ARG_CHK_EN > 0u
X#if 0u > 0u
S    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
S        if (prio != OS_PRIO_SELF) {
S            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
S            return;
S        }
S    }
S    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
S        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
S        return;
S    }
N#endif
N    if (OSIntNesting > 0u) {                         /* See if trying to call from an ISR              */
N        *perr = OS_ERR_NAME_SET_ISR;
X        *perr = 18u;
N        return;
N    }
N    OS_ENTER_CRITICAL();
X    {cpu_sr = OS_CPU_SR_Save();};
N    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
X    if (prio == 0xFFu) {                       
N        prio = OSTCBCur->OSTCBPrio;
N    }
N    ptcb = OSTCBPrioTbl[prio];
N    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
N        OS_EXIT_CRITICAL();                          /* No                                             */
X        {OS_CPU_SR_Restore(cpu_sr);};                           
N        *perr = OS_ERR_TASK_NOT_EXIST;
X        *perr = 67u;
N        return;
N    }
N    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
X    if (ptcb == ((OS_TCB *)1)) {                    
N        OS_EXIT_CRITICAL();                          /* Yes                                            */
X        {OS_CPU_SR_Restore(cpu_sr);};                           
N        *perr = OS_ERR_TASK_NOT_EXIST;
X        *perr = 67u;
N        return;
N    }
N    ptcb->OSTCBTaskName = pname;
N    OS_EXIT_CRITICAL();
X    {OS_CPU_SR_Restore(cpu_sr);};
N    *perr               = OS_ERR_NONE;
X    *perr               = 0u;
N}
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                       RESUME A SUSPENDED TASK
N*
N* Description: This function is called to resume a previously suspended task.  This is the only call that
N*              will remove an explicit task suspension.
N*
N* Arguments  : prio     is the priority of the task to resume.
N*
N* Returns    : OS_ERR_NONE                if the requested task is resumed
N*              OS_ERR_PRIO_INVALID        if the priority you specify is higher that the maximum allowed
N*                                         (i.e. >= OS_LOWEST_PRIO)
N*              OS_ERR_TASK_RESUME_PRIO    if the task to resume does not exist
N*              OS_ERR_TASK_NOT_EXIST      if the task is assigned to a Mutex PIP
N*              OS_ERR_TASK_NOT_SUSPENDED  if the task to resume has not been suspended
N*********************************************************************************************************
N*/
N
N#if OS_TASK_SUSPEND_EN > 0u
X#if 1u > 0u
NINT8U  OSTaskResume (INT8U prio)
N{
N    OS_TCB    *ptcb;
N#if OS_CRITICAL_METHOD == 3u                                  /* Storage for CPU status register       */
X#if 3u == 3u                                   
N    OS_CPU_SR  cpu_sr = 0u;
N#endif
N
N
N
N#if OS_ARG_CHK_EN > 0u
X#if 0u > 0u
S    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
S        return (OS_ERR_PRIO_INVALID);
S    }
N#endif
N    OS_ENTER_CRITICAL();
X    {cpu_sr = OS_CPU_SR_Save();};
N    ptcb = OSTCBPrioTbl[prio];
N    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
N        OS_EXIT_CRITICAL();
X        {OS_CPU_SR_Restore(cpu_sr);};
N        return (OS_ERR_TASK_RESUME_PRIO);
X        return (70u);
N    }
N    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
X    if (ptcb == ((OS_TCB *)1)) {                             
N        OS_EXIT_CRITICAL();
X        {OS_CPU_SR_Restore(cpu_sr);};
N        return (OS_ERR_TASK_NOT_EXIST);
X        return (67u);
N    }
N    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
X    if ((ptcb->OSTCBStat & 0x08u) != 0x00u) {  
N        ptcb->OSTCBStat &= (INT8U)~(INT8U)OS_STAT_SUSPEND;    /* Remove suspension                     */
X        ptcb->OSTCBStat &= (INT8U)~(INT8U)0x08u;     
N        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
X        if (ptcb->OSTCBStat == 0x00u) {                  
N            if (ptcb->OSTCBDly == 0u) {
N                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
N                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
N                OS_EXIT_CRITICAL();
X                {OS_CPU_SR_Restore(cpu_sr);};
N                if (OSRunning == OS_TRUE) {
X                if (OSRunning == 1u) {
N                    OS_Sched();                               /* Find new highest priority task        */
N                }
N            } else {
N                OS_EXIT_CRITICAL();
X                {OS_CPU_SR_Restore(cpu_sr);};
N            }
N        } else {                                              /* Must be pending on event              */
N            OS_EXIT_CRITICAL();
X            {OS_CPU_SR_Restore(cpu_sr);};
N        }
N        return (OS_ERR_NONE);
X        return (0u);
N    }
N    OS_EXIT_CRITICAL();
X    {OS_CPU_SR_Restore(cpu_sr);};
N    return (OS_ERR_TASK_NOT_SUSPENDED);
X    return (68u);
N}
N#endif
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                           STACK CHECKING
N*
N* Description: This function is called to check the amount of free memory left on the specified task's
N*              stack.
N*
N* Arguments  : prio          is the task priority
N*
N*              p_stk_data    is a pointer to a data structure of type OS_STK_DATA.
N*
N* Returns    : OS_ERR_NONE            upon success
N*              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
N*                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
N*              OS_ERR_TASK_NOT_EXIST  if the desired task has not been created or is assigned to a Mutex PIP
N*              OS_ERR_TASK_OPT        if you did NOT specified OS_TASK_OPT_STK_CHK when the task was created
N*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
N*********************************************************************************************************
N*/
N#if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
X#if (1u > 0u) && (1u > 0u)
NINT8U  OSTaskStkChk (INT8U         prio,
N                     OS_STK_DATA  *p_stk_data)
N{
N    OS_TCB    *ptcb;
N    OS_STK    *pchk;
N    INT32U     nfree;
N    INT32U     size;
N#if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
X#if 3u == 3u                            
N    OS_CPU_SR  cpu_sr = 0u;
N#endif
N
N
N
N#if OS_ARG_CHK_EN > 0u
X#if 0u > 0u
S    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
S        if (prio != OS_PRIO_SELF) {
S            return (OS_ERR_PRIO_INVALID);
S        }
S    }
S    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
S        return (OS_ERR_PDATA_NULL);
S    }
N#endif
N    p_stk_data->OSFree = 0u;                           /* Assume failure, set to 0 size                */
N    p_stk_data->OSUsed = 0u;
N    OS_ENTER_CRITICAL();
X    {cpu_sr = OS_CPU_SR_Save();};
N    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
X    if (prio == 0xFFu) {                         
N        prio = OSTCBCur->OSTCBPrio;
N    }
N    ptcb = OSTCBPrioTbl[prio];
N    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
N        OS_EXIT_CRITICAL();
X        {OS_CPU_SR_Restore(cpu_sr);};
N        return (OS_ERR_TASK_NOT_EXIST);
X        return (67u);
N    }
N    if (ptcb == OS_TCB_RESERVED) {
X    if (ptcb == ((OS_TCB *)1)) {
N        OS_EXIT_CRITICAL();
X        {OS_CPU_SR_Restore(cpu_sr);};
N        return (OS_ERR_TASK_NOT_EXIST);
X        return (67u);
N    }
N    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0u) { /* Make sure stack checking option is set      */
X    if ((ptcb->OSTCBOpt & 0x0001u) == 0u) {  
N        OS_EXIT_CRITICAL();
X        {OS_CPU_SR_Restore(cpu_sr);};
N        return (OS_ERR_TASK_OPT);
X        return (69u);
N    }
N    nfree = 0u;
N    size  = ptcb->OSTCBStkSize;
N    pchk  = ptcb->OSTCBStkBottom;
N    OS_EXIT_CRITICAL();
X    {OS_CPU_SR_Restore(cpu_sr);};
N#if OS_STK_GROWTH == 1u
X#if 1u == 1u
N    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
N        nfree++;
N    }
N#else
S    while (*pchk-- == (OS_STK)0) {
S        nfree++;
S    }
N#endif
N    p_stk_data->OSFree = nfree;                       /* Store   number of free entries on the stk     */
N    p_stk_data->OSUsed = size - nfree;                /* Compute number of entries used on the stk     */
N    return (OS_ERR_NONE);
X    return (0u);
N}
N#endif
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                           SUSPEND A TASK
N*
N* Description: This function is called to suspend a task.  The task can be the calling task if the
N*              priority passed to OSTaskSuspend() is the priority of the calling task or OS_PRIO_SELF.
N*
N* Arguments  : prio     is the priority of the task to suspend.  If you specify OS_PRIO_SELF, the
N*                       calling task will suspend itself and rescheduling will occur.
N*
N* Returns    : OS_ERR_NONE               if the requested task is suspended
N*              OS_ERR_TASK_SUSPEND_IDLE  if you attempted to suspend the idle task which is not allowed.
N*              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
N*                                        (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
N*              OS_ERR_TASK_SUSPEND_PRIO  if the task to suspend does not exist
N*              OS_ERR_TASK_NOT_EXITS     if the task is assigned to a Mutex PIP
N*
N* Note       : You should use this function with great care.  If you suspend a task that is waiting for
N*              an event (i.e. a message, a semaphore, a queue ...) you will prevent this task from
N*              running when the event arrives.
N*********************************************************************************************************
N*/
N
N#if OS_TASK_SUSPEND_EN > 0u
X#if 1u > 0u
NINT8U  OSTaskSuspend (INT8U prio)
N{
N    BOOLEAN    self;
N    OS_TCB    *ptcb;
N    INT8U      y;
N#if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
X#if 3u == 3u                      
N    OS_CPU_SR  cpu_sr = 0u;
N#endif
N
N
N
N#if OS_ARG_CHK_EN > 0u
X#if 0u > 0u
S    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
S        return (OS_ERR_TASK_SUSPEND_IDLE);
S    }
S    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
S        if (prio != OS_PRIO_SELF) {
S            return (OS_ERR_PRIO_INVALID);
S        }
S    }
N#endif
N    OS_ENTER_CRITICAL();
X    {cpu_sr = OS_CPU_SR_Save();};
N    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
X    if (prio == 0xFFu) {                                  
N        prio = OSTCBCur->OSTCBPrio;
N        self = OS_TRUE;
X        self = 1u;
N    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
N        self = OS_TRUE;
X        self = 1u;
N    } else {
N        self = OS_FALSE;                                        /* No suspending another task          */
X        self = 0u;                                         
N    }
N    ptcb = OSTCBPrioTbl[prio];
N    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
N        OS_EXIT_CRITICAL();
X        {OS_CPU_SR_Restore(cpu_sr);};
N        return (OS_ERR_TASK_SUSPEND_PRIO);
X        return (72u);
N    }
N    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
X    if (ptcb == ((OS_TCB *)1)) {                               
N        OS_EXIT_CRITICAL();
X        {OS_CPU_SR_Restore(cpu_sr);};
N        return (OS_ERR_TASK_NOT_EXIST);
X        return (67u);
N    }
N    y            = ptcb->OSTCBY;
N    OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;                   /* Make task not ready                 */
N    if (OSRdyTbl[y] == 0u) {
N        OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
N    }
N    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
X    ptcb->OSTCBStat |= 0x08u;                          
N    OS_EXIT_CRITICAL();
X    {OS_CPU_SR_Restore(cpu_sr);};
N    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
X    if (self == 1u) {                                       
N        OS_Sched();                                             /* Find new highest priority task      */
N    }
N    return (OS_ERR_NONE);
X    return (0u);
N}
N#endif
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            QUERY A TASK
N*
N* Description: This function is called to obtain a copy of the desired task's TCB.
N*
N* Arguments  : prio         is the priority of the task to obtain information from.
N*
N*              p_task_data  is a pointer to where the desired task's OS_TCB will be stored.
N*
N* Returns    : OS_ERR_NONE            if the requested task is suspended
N*              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
N*                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
N*              OS_ERR_PRIO            if the desired task has not been created
N*              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP
N*              OS_ERR_PDATA_NULL      if 'p_task_data' is a NULL pointer
N*********************************************************************************************************
N*/
N
N#if OS_TASK_QUERY_EN > 0u
X#if 1u > 0u
NINT8U  OSTaskQuery (INT8U    prio,
N                    OS_TCB  *p_task_data)
N{
N    OS_TCB    *ptcb;
N#if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
X#if 3u == 3u                      
N    OS_CPU_SR  cpu_sr = 0u;
N#endif
N
N
N
N#if OS_ARG_CHK_EN > 0u
X#if 0u > 0u
S    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
S        if (prio != OS_PRIO_SELF) {
S            return (OS_ERR_PRIO_INVALID);
S        }
S    }
S    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
S        return (OS_ERR_PDATA_NULL);
S    }
N#endif
N    OS_ENTER_CRITICAL();
X    {cpu_sr = OS_CPU_SR_Save();};
N    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
X    if (prio == 0xFFu) {                   
N        prio = OSTCBCur->OSTCBPrio;
N    }
N    ptcb = OSTCBPrioTbl[prio];
N    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
N        OS_EXIT_CRITICAL();
X        {OS_CPU_SR_Restore(cpu_sr);};
N        return (OS_ERR_PRIO);
X        return (41u);
N    }
N    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
X    if (ptcb == ((OS_TCB *)1)) {                
N        OS_EXIT_CRITICAL();
X        {OS_CPU_SR_Restore(cpu_sr);};
N        return (OS_ERR_TASK_NOT_EXIST);
X        return (67u);
N    }
N                                                 /* Copy TCB into user storage area                    */
N    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
N    OS_EXIT_CRITICAL();
X    {OS_CPU_SR_Restore(cpu_sr);};
N    return (OS_ERR_NONE);
X    return (0u);
N}
N#endif
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                              GET THE CURRENT VALUE OF A TASK REGISTER
N*
N* Description: This function is called to obtain the current value of a task register.  Task registers
N*              are application specific and can be used to store task specific values such as 'error
N*              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
N*
N* Arguments  : prio      is the priority of the task you want to get the task register from.  If you
N*                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
N*
N*              id        is the 'id' of the desired task register.  Note that the 'id' must be less
N*                        than OS_TASK_REG_TBL_SIZE
N*
N*              perr      is a pointer to a variable that will hold an error code related to this call.
N*
N*                        OS_ERR_NONE            if the call was successful
N*                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
N*                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
N*
N* Returns    : The current value of the task's register or 0 if an error is detected.
N*
N* Note(s)    : The maximum number of task variables is 254
N*********************************************************************************************************
N*/
N
N#if OS_TASK_REG_TBL_SIZE > 0u
X#if 1u > 0u
NINT32U  OSTaskRegGet (INT8U   prio,
N                      INT8U   id,
N                      INT8U  *perr)
N{
N#if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
X#if 3u == 3u                      
N    OS_CPU_SR  cpu_sr = 0u;
N#endif
N    INT32U     value;
N    OS_TCB    *ptcb;
N
N
N
N#ifdef OS_SAFETY_CRITICAL
S    if (perr == (INT8U *)0) {
S        OS_SAFETY_CRITICAL_EXCEPTION();
S        return (0u);
S    }
N#endif
N
N#if OS_ARG_CHK_EN > 0u
X#if 0u > 0u
S    if (prio >= OS_LOWEST_PRIO) {
S        if (prio != OS_PRIO_SELF) {
S            *perr = OS_ERR_PRIO_INVALID;
S            return (0u);
S        }
S    }
S    if (id >= OS_TASK_REG_TBL_SIZE) {
S        *perr = OS_ERR_ID_INVALID;
S        return (0u);
S    }
N#endif
N    OS_ENTER_CRITICAL();
X    {cpu_sr = OS_CPU_SR_Save();};
N    if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
X    if (prio == 0xFFu) {                   
N        ptcb = OSTCBCur;
N    } else {
N        ptcb = OSTCBPrioTbl[prio];
N    }
N    value = ptcb->OSTCBRegTbl[id];
N    OS_EXIT_CRITICAL();
X    {OS_CPU_SR_Restore(cpu_sr);};
N    *perr = OS_ERR_NONE;
X    *perr = 0u;
N    return (value);
N}
N#endif
N
N/*$PAGE*/
N/*
N************************************************************************************************************************
N*                                    ALLOCATE THE NEXT AVAILABLE TASK REGISTER ID
N*
N* Description: This function is called to obtain a task register ID.  This function thus allows task registers IDs to be
N*              allocated dynamically instead of statically.
N*
N* Arguments  : p_err       is a pointer to a variable that will hold an error code related to this call.
N*
N*                            OS_ERR_NONE               if the call was successful
N*                            OS_ERR_NO_MORE_ID_AVAIL   if you are attempting to assign more task register IDs than you 
N*                                                           have available through OS_TASK_REG_TBL_SIZE.
N*
N* Returns    : The next available task register 'id' or OS_TASK_REG_TBL_SIZE if an error is detected.
N************************************************************************************************************************
N*/
N
N#if OS_TASK_REG_TBL_SIZE > 0u
X#if 1u > 0u
NINT8U  OSTaskRegGetID (INT8U  *perr)
N{
N#if OS_CRITICAL_METHOD == 3u                                    /* Allocate storage for CPU status register           */
X#if 3u == 3u                                     
N    OS_CPU_SR  cpu_sr = 0u;
N#endif
N    INT8U      id;
N
N
N#ifdef OS_SAFETY_CRITICAL
S    if (perr == (INT8U *)0) {
S        OS_SAFETY_CRITICAL_EXCEPTION();
S        return ((INT8U)OS_TASK_REG_TBL_SIZE);
S    }
N#endif
N
N    OS_ENTER_CRITICAL();
X    {cpu_sr = OS_CPU_SR_Save();};
N    if (OSTaskRegNextAvailID >= OS_TASK_REG_TBL_SIZE) {         /* See if we exceeded the number of IDs available     */
X    if (OSTaskRegNextAvailID >= 1u) {          
N       *perr = OS_ERR_NO_MORE_ID_AVAIL;                         /* Yes, cannot allocate more task register IDs        */
X       *perr = 150u;                          
N        OS_EXIT_CRITICAL();
X        {OS_CPU_SR_Restore(cpu_sr);};
N        return ((INT8U)OS_TASK_REG_TBL_SIZE);
X        return ((INT8U)1u);
N    }
N     
N    id   = OSTaskRegNextAvailID;                                /* Assign the next available ID                       */
N    OSTaskRegNextAvailID++;                                     /* Increment available ID for next request            */
N    OS_EXIT_CRITICAL();
X    {OS_CPU_SR_Restore(cpu_sr);};
N   *perr = OS_ERR_NONE;
X   *perr = 0u;
N    return (id);
N}
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                              SET THE CURRENT VALUE OF A TASK VARIABLE
N*
N* Description: This function is called to change the current value of a task register.  Task registers
N*              are application specific and can be used to store task specific values such as 'error
N*              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
N*
N* Arguments  : prio      is the priority of the task you want to set the task register for.  If you
N*                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
N*
N*              id        is the 'id' of the desired task register.  Note that the 'id' must be less
N*                        than OS_TASK_REG_TBL_SIZE
N*
N*              value     is the desired value for the task register.
N*
N*              perr      is a pointer to a variable that will hold an error code related to this call.
N*
N*                        OS_ERR_NONE            if the call was successful
N*                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
N*                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
N*
N* Returns    : The current value of the task's variable or 0 if an error is detected.
N*
N* Note(s)    : The maximum number of task variables is 254
N*********************************************************************************************************
N*/
N
N#if OS_TASK_REG_TBL_SIZE > 0u
X#if 1u > 0u
Nvoid  OSTaskRegSet (INT8U    prio,
N                    INT8U    id,
N                    INT32U   value,
N                    INT8U   *perr)
N{
N#if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
X#if 3u == 3u                      
N    OS_CPU_SR  cpu_sr = 0u;
N#endif
N    OS_TCB    *ptcb;
N
N
N#ifdef OS_SAFETY_CRITICAL
S    if (perr == (INT8U *)0) {
S        OS_SAFETY_CRITICAL_EXCEPTION();
S        return;
S    }
N#endif
N
N#if OS_ARG_CHK_EN > 0u
X#if 0u > 0u
S    if (prio >= OS_LOWEST_PRIO) {
S        if (prio != OS_PRIO_SELF) {
S            *perr = OS_ERR_PRIO_INVALID;
S            return;
S        }
S    }
S    if (id >= OS_TASK_REG_TBL_SIZE) {
S        *perr = OS_ERR_ID_INVALID;
S        return;
S    }
N#endif
N    OS_ENTER_CRITICAL();
X    {cpu_sr = OS_CPU_SR_Save();};
N    if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
X    if (prio == 0xFFu) {                   
N        ptcb = OSTCBCur;
N    } else {
N        ptcb = OSTCBPrioTbl[prio];
N    }
N    ptcb->OSTCBRegTbl[id] = value;
N    OS_EXIT_CRITICAL();
X    {OS_CPU_SR_Restore(cpu_sr);};
N    *perr                 = OS_ERR_NONE;
X    *perr                 = 0u;
N}
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                    CATCH ACCIDENTAL TASK RETURN
N*
N* Description: This function is called if a task accidentally returns without deleting itself.  In other
N*              words, a task should either be an infinite loop or delete itself if it's done.
N*
N* Arguments  : none
N*
N* Returns    : none
N*
N* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
N*********************************************************************************************************
N*/
N
Nvoid  OS_TaskReturn (void)
N{
N    OSTaskReturnHook(OSTCBCur);                   /* Call hook to let user decide on what to do        */
N
N#if OS_TASK_DEL_EN > 0u
X#if 1u > 0u
N    (void)OSTaskDel(OS_PRIO_SELF);                /* Delete task if it accidentally returns!           */
X    (void)OSTaskDel(0xFFu);                 
N#else
S    for (;;) {
S        OSTimeDly(OS_TICKS_PER_SEC);
S    }
N#endif
N}
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          CLEAR TASK STACK
N*
N* Description: This function is used to clear the stack of a task (i.e. write all zeros)
N*
N* Arguments  : pbos     is a pointer to the task's bottom of stack.  If the configuration constant
N*                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
N*                       memory to low memory).  'pbos' will thus point to the lowest (valid) memory
N*                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
N*                       highest memory location of the stack and the stack will grow with increasing
N*                       memory locations.  'pbos' MUST point to a valid 'free' data item.
N*
N*              size     is the number of 'stack elements' to clear.
N*
N*              opt      contains additional information (or options) about the behavior of the task.  The
N*                       LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
N*                       specific.  See OS_TASK_OPT_??? in uCOS-II.H.
N*
N* Returns    : none
N*********************************************************************************************************
N*/
N#if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
X#if (1u > 0u) && (1u > 0u)
Nvoid  OS_TaskStkClr (OS_STK  *pbos,
N                     INT32U   size,
N                     INT16U   opt)
N{
N    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000u) {      /* See if stack checking has been enabled       */
X    if ((opt & 0x0001u) != 0x0000u) {       
N        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000u) {  /* See if stack needs to be cleared             */
X        if ((opt & 0x0002u) != 0x0000u) {   
N#if OS_STK_GROWTH == 1u
X#if 1u == 1u
N            while (size > 0u) {                        /* Stack grows from HIGH to LOW memory          */
N                size--;
N                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
N            }
N#else
S            while (size > 0u) {                        /* Stack grows from LOW to HIGH memory          */
S                size--;
S                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
S            }
N#endif
N        }
N    }
N}
N
N#endif
