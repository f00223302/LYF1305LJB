; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Output\stm32f2xx_i2c.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\Output\stm32f2xx_i2c.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\BSP -I..\BSP\UCOS-II -I..\BSP\STM32F2xx\inc -I..\BSP\CMSIS -I..\BSP\CMSIS\Device_Support -I..\BSP\UCOS-II -I..\..\uC-CPU -I..\..\uC-CPU\ARM-Cortex-M3 -I..\..\uC-LIB -I..\..\uC-LIB\Ports\ARM-Cortex-M3 -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3 -I..\App -I..\Prj -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DDEBUG -DLJB_CPU_MAIN -DUSE_CPU_F205RC --omf_browse=.\Output\stm32f2xx_i2c.crf ..\BSP\STM32F2xx\src\stm32f2xx_i2c.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;131      */
;;;132    void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;133    {
000002  4604              MOV      r4,r0
;;;134      /* Check the parameters */
;;;135      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;136    
;;;137      if (I2Cx == I2C1)
000004  48fa              LDR      r0,|L1.1008|
000006  4284              CMP      r4,r0
000008  d109              BNE      |L1.30|
;;;138      {
;;;139        /* Enable I2C1 reset state */
;;;140        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  0548              LSLS     r0,r1,#21
00000e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;141        /* Release I2C1 from reset state */
;;;142        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
000012  2100              MOVS     r1,#0
000014  f44f1000          MOV      r0,#0x200000
000018  f7fffffe          BL       RCC_APB1PeriphResetCmd
00001c  e018              B        |L1.80|
                  |L1.30|
;;;143      }
;;;144      else if (I2Cx == I2C2)
00001e  48f5              LDR      r0,|L1.1012|
000020  4284              CMP      r4,r0
000022  d109              BNE      |L1.56|
;;;145      {
;;;146        /* Enable I2C2 reset state */
;;;147        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
000024  2101              MOVS     r1,#1
000026  0588              LSLS     r0,r1,#22
000028  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;148        /* Release I2C2 from reset state */
;;;149        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
00002c  2100              MOVS     r1,#0
00002e  f44f0080          MOV      r0,#0x400000
000032  f7fffffe          BL       RCC_APB1PeriphResetCmd
000036  e00b              B        |L1.80|
                  |L1.56|
;;;150      }
;;;151      else 
;;;152      {
;;;153        if (I2Cx == I2C3)
000038  48ef              LDR      r0,|L1.1016|
00003a  4284              CMP      r4,r0
00003c  d108              BNE      |L1.80|
;;;154        {
;;;155          /* Enable I2C3 reset state */
;;;156          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
00003e  2101              MOVS     r1,#1
000040  05c8              LSLS     r0,r1,#23
000042  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;157          /* Release I2C3 from reset state */
;;;158          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
000046  2100              MOVS     r1,#0
000048  f44f0000          MOV      r0,#0x800000
00004c  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L1.80|
;;;159        }
;;;160      }
;;;161    }
000050  bd10              POP      {r4,pc}
;;;162    
                          ENDP

                  I2C_Init PROC
;;;174      */
;;;175    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000052  e92d47ff          PUSH     {r0-r10,lr}
;;;176    {
000056  4604              MOV      r4,r0
000058  460d              MOV      r5,r1
;;;177      uint16_t tmpreg = 0, freqrange = 0;
00005a  f04f0600          MOV      r6,#0
00005e  46b1              MOV      r9,r6
;;;178      uint16_t result = 0x04;
000060  f04f0704          MOV      r7,#4
;;;179      uint32_t pclk1 = 8000000;
000064  f8df8394          LDR      r8,|L1.1020|
;;;180      RCC_ClocksTypeDef  rcc_clocks;
;;;181      /* Check the parameters */
;;;182      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;183      assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
;;;184      assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
;;;185      assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
;;;186      assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
;;;187      assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
;;;188      assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
;;;189    
;;;190    /*---------------------------- I2Cx CR2 Configuration ------------------------*/
;;;191      /* Get the I2Cx CR2 value */
;;;192      tmpreg = I2Cx->CR2;
000068  88a6              LDRH     r6,[r4,#4]
;;;193      /* Clear frequency FREQ[5:0] bits */
;;;194      tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
00006a  f64f70c0          MOV      r0,#0xffc0
00006e  ea060600          AND      r6,r6,r0
;;;195      /* Get pclk1 frequency value */
;;;196      RCC_GetClocksFreq(&rcc_clocks);
000072  4668              MOV      r0,sp
000074  f7fffffe          BL       RCC_GetClocksFreq
;;;197      pclk1 = rcc_clocks.PCLK1_Frequency;
000078  f8dd8008          LDR      r8,[sp,#8]
;;;198      /* Set frequency bits depending on pclk1 value */
;;;199      freqrange = (uint16_t)(pclk1 / 1000000);
00007c  48e0              LDR      r0,|L1.1024|
00007e  fbb8f0f0          UDIV     r0,r8,r0
000082  fa1ff980          UXTH     r9,r0
;;;200      tmpreg |= freqrange;
000086  ea460609          ORR      r6,r6,r9
;;;201      /* Write to I2Cx CR2 */
;;;202      I2Cx->CR2 = tmpreg;
00008a  80a6              STRH     r6,[r4,#4]
;;;203    
;;;204    /*---------------------------- I2Cx CCR Configuration ------------------------*/
;;;205      /* Disable the selected I2C peripheral to configure TRISE */
;;;206      I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
00008c  8820              LDRH     r0,[r4,#0]
00008e  f64f71fe          MOV      r1,#0xfffe
000092  ea000001          AND      r0,r0,r1
000096  8020              STRH     r0,[r4,#0]
;;;207      /* Reset tmpreg value */
;;;208      /* Clear F/S, DUTY and CCR[11:0] bits */
;;;209      tmpreg = 0;
000098  f04f0600          MOV      r6,#0
;;;210    
;;;211      /* Configure speed in standard mode */
;;;212      if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
00009c  49d9              LDR      r1,|L1.1028|
00009e  6828              LDR      r0,[r5,#0]
0000a0  4288              CMP      r0,r1
0000a2  d80f              BHI      |L1.196|
;;;213      {
;;;214        /* Standard mode speed calculate */
;;;215        result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
0000a4  6828              LDR      r0,[r5,#0]
0000a6  ea4f0040          LSL      r0,r0,#1
0000aa  fbb8f0f0          UDIV     r0,r8,r0
0000ae  b287              UXTH     r7,r0
;;;216        /* Test if CCR value is under 0x4*/
;;;217        if (result < 0x04)
0000b0  2f04              CMP      r7,#4
0000b2  da01              BGE      |L1.184|
;;;218        {
;;;219          /* Set minimum allowed value */
;;;220          result = 0x04;  
0000b4  f04f0704          MOV      r7,#4
                  |L1.184|
;;;221        }
;;;222        /* Set speed value for standard mode */
;;;223        tmpreg |= result;	  
0000b8  ea460607          ORR      r6,r6,r7
;;;224        /* Set Maximum Rise Time for standard mode */
;;;225        I2Cx->TRISE = freqrange + 1; 
0000bc  f1090001          ADD      r0,r9,#1
0000c0  8420              STRH     r0,[r4,#0x20]
0000c2  e029              B        |L1.280|
                  |L1.196|
;;;226      }
;;;227      /* Configure speed in fast mode */
;;;228      /* To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency (I2C peripheral
;;;229         input clock) must be a multiple of 10 MHz */
;;;230      else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
;;;231      {
;;;232        if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
0000c4  88e8              LDRH     r0,[r5,#6]
0000c6  f5a0413f          SUB      r1,r0,#0xbf00
0000ca  39ff              SUBS     r1,r1,#0xff
0000cc  d106              BNE      |L1.220|
;;;233        {
;;;234          /* Fast mode speed calculate: Tlow/Thigh = 2 */
;;;235          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
0000ce  6828              LDR      r0,[r5,#0]
0000d0  eb000040          ADD      r0,r0,r0,LSL #1
0000d4  fbb8f0f0          UDIV     r0,r8,r0
0000d8  b287              UXTH     r7,r0
0000da  e009              B        |L1.240|
                  |L1.220|
;;;236        }
;;;237        else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
;;;238        {
;;;239          /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
;;;240          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
0000dc  6828              LDR      r0,[r5,#0]
0000de  eb0001c0          ADD      r1,r0,r0,LSL #3
0000e2  eb011000          ADD      r0,r1,r0,LSL #4
0000e6  fbb8f0f0          UDIV     r0,r8,r0
0000ea  b287              UXTH     r7,r0
;;;241          /* Set DUTY bit */
;;;242          result |= I2C_DutyCycle_16_9;
0000ec  f4474780          ORR      r7,r7,#0x4000
                  |L1.240|
;;;243        }
;;;244    
;;;245        /* Test if CCR value is under 0x1*/
;;;246        if ((result & I2C_CCR_CCR) == 0)
0000f0  0538              LSLS     r0,r7,#20
0000f2  0d00              LSRS     r0,r0,#20
0000f4  d101              BNE      |L1.250|
;;;247        {
;;;248          /* Set minimum allowed value */
;;;249          result |= (uint16_t)0x0001;  
0000f6  f0470701          ORR      r7,r7,#1
                  |L1.250|
;;;250        }
;;;251        /* Set speed value and set F/S bit for fast mode */
;;;252        tmpreg |= (uint16_t)(result | I2C_CCR_FS);
0000fa  f4474000          ORR      r0,r7,#0x8000
0000fe  ea400606          ORR      r6,r0,r6
;;;253        /* Set Maximum Rise Time for fast mode */
;;;254        I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
000102  f44f7096          MOV      r0,#0x12c
000106  fb09f000          MUL      r0,r9,r0
00010a  f44f717a          MOV      r1,#0x3e8
00010e  fb90f0f1          SDIV     r0,r0,r1
000112  f1000001          ADD      r0,r0,#1
000116  8420              STRH     r0,[r4,#0x20]
                  |L1.280|
;;;255      }
;;;256    
;;;257      /* Write to I2Cx CCR */
;;;258      I2Cx->CCR = tmpreg;
000118  83a6              STRH     r6,[r4,#0x1c]
;;;259      /* Enable the selected I2C peripheral */
;;;260      I2Cx->CR1 |= I2C_CR1_PE;
00011a  8820              LDRH     r0,[r4,#0]
00011c  f0400001          ORR      r0,r0,#1
000120  8020              STRH     r0,[r4,#0]
;;;261    
;;;262    /*---------------------------- I2Cx CR1 Configuration ------------------------*/
;;;263      /* Get the I2Cx CR1 value */
;;;264      tmpreg = I2Cx->CR1;
000122  8826              LDRH     r6,[r4,#0]
;;;265      /* Clear ACK, SMBTYPE and  SMBUS bits */
;;;266      tmpreg &= CR1_CLEAR_MASK;
000124  f64f30f5          MOV      r0,#0xfbf5
000128  ea060600          AND      r6,r6,r0
;;;267      /* Configure I2Cx: mode and acknowledgement */
;;;268      /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
;;;269      /* Set ACK bit according to I2C_Ack value */
;;;270      tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
00012c  88a8              LDRH     r0,[r5,#4]
00012e  8969              LDRH     r1,[r5,#0xa]
000130  ea400001          ORR      r0,r0,r1
000134  ea400606          ORR      r6,r0,r6
;;;271      /* Write to I2Cx CR1 */
;;;272      I2Cx->CR1 = tmpreg;
000138  8026              STRH     r6,[r4,#0]
;;;273    
;;;274    /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
;;;275      /* Set I2Cx Own Address1 and acknowledged address */
;;;276      I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
00013a  89a8              LDRH     r0,[r5,#0xc]
00013c  8929              LDRH     r1,[r5,#8]
00013e  ea400001          ORR      r0,r0,r1
000142  8120              STRH     r0,[r4,#8]
;;;277    }
000144  e8bd87ff          POP      {r0-r10,pc}
;;;278    
                          ENDP

                  I2C_StructInit PROC
;;;283      */
;;;284    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
000148  f2413188          MOV      r1,#0x1388
;;;285    {
;;;286    /*---------------- Reset I2C init structure parameters values ----------------*/
;;;287      /* initialize the I2C_ClockSpeed member */
;;;288      I2C_InitStruct->I2C_ClockSpeed = 5000;
00014c  6001              STR      r1,[r0,#0]
;;;289      /* Initialize the I2C_Mode member */
;;;290      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
00014e  f04f0100          MOV      r1,#0
000152  8081              STRH     r1,[r0,#4]
;;;291      /* Initialize the I2C_DutyCycle member */
;;;292      I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
000154  f64b71ff          MOV      r1,#0xbfff
000158  80c1              STRH     r1,[r0,#6]
;;;293      /* Initialize the I2C_OwnAddress1 member */
;;;294      I2C_InitStruct->I2C_OwnAddress1 = 0;
00015a  f04f0100          MOV      r1,#0
00015e  8101              STRH     r1,[r0,#8]
;;;295      /* Initialize the I2C_Ack member */
;;;296      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
000160  8141              STRH     r1,[r0,#0xa]
;;;297      /* Initialize the I2C_AcknowledgedAddress member */
;;;298      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
000162  f44f4180          MOV      r1,#0x4000
000166  8181              STRH     r1,[r0,#0xc]
;;;299    }
000168  4770              BX       lr
;;;300    
                          ENDP

                  I2C_Cmd PROC
;;;307      */
;;;308    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
00016a  b121              CBZ      r1,|L1.374|
;;;309    {
;;;310      /* Check the parameters */
;;;311      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;312      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;313      if (NewState != DISABLE)
;;;314      {
;;;315        /* Enable the selected I2C peripheral */
;;;316        I2Cx->CR1 |= I2C_CR1_PE;
00016c  8802              LDRH     r2,[r0,#0]
00016e  f0420201          ORR      r2,r2,#1
000172  8002              STRH     r2,[r0,#0]
000174  e005              B        |L1.386|
                  |L1.374|
;;;317      }
;;;318      else
;;;319      {
;;;320        /* Disable the selected I2C peripheral */
;;;321        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
000176  8802              LDRH     r2,[r0,#0]
000178  f64f73fe          MOV      r3,#0xfffe
00017c  ea020203          AND      r2,r2,r3
000180  8002              STRH     r2,[r0,#0]
                  |L1.386|
;;;322      }
;;;323    }
000182  4770              BX       lr
;;;324    
                          ENDP

                  I2C_GenerateSTART PROC
;;;331      */
;;;332    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
000184  b121              CBZ      r1,|L1.400|
;;;333    {
;;;334      /* Check the parameters */
;;;335      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;336      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;337      if (NewState != DISABLE)
;;;338      {
;;;339        /* Generate a START condition */
;;;340        I2Cx->CR1 |= I2C_CR1_START;
000186  8802              LDRH     r2,[r0,#0]
000188  f4427280          ORR      r2,r2,#0x100
00018c  8002              STRH     r2,[r0,#0]
00018e  e005              B        |L1.412|
                  |L1.400|
;;;341      }
;;;342      else
;;;343      {
;;;344        /* Disable the START condition generation */
;;;345        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
000190  8802              LDRH     r2,[r0,#0]
000192  f64f63ff          MOV      r3,#0xfeff
000196  ea020203          AND      r2,r2,r3
00019a  8002              STRH     r2,[r0,#0]
                  |L1.412|
;;;346      }
;;;347    }
00019c  4770              BX       lr
;;;348    
                          ENDP

                  I2C_GenerateSTOP PROC
;;;355      */
;;;356    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
00019e  b121              CBZ      r1,|L1.426|
;;;357    {
;;;358      /* Check the parameters */
;;;359      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;360      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;361      if (NewState != DISABLE)
;;;362      {
;;;363        /* Generate a STOP condition */
;;;364        I2Cx->CR1 |= I2C_CR1_STOP;
0001a0  8802              LDRH     r2,[r0,#0]
0001a2  f4427200          ORR      r2,r2,#0x200
0001a6  8002              STRH     r2,[r0,#0]
0001a8  e005              B        |L1.438|
                  |L1.426|
;;;365      }
;;;366      else
;;;367      {
;;;368        /* Disable the STOP condition generation */
;;;369        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
0001aa  8802              LDRH     r2,[r0,#0]
0001ac  f64f53ff          MOV      r3,#0xfdff
0001b0  ea020203          AND      r2,r2,r3
0001b4  8002              STRH     r2,[r0,#0]
                  |L1.438|
;;;370      }
;;;371    }
0001b6  4770              BX       lr
;;;372    
                          ENDP

                  I2C_Send7bitAddress PROC
;;;383      */
;;;384    void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
0001b8  b112              CBZ      r2,|L1.448|
;;;385    {
;;;386      /* Check the parameters */
;;;387      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;388      assert_param(IS_I2C_DIRECTION(I2C_Direction));
;;;389      /* Test on the direction to set/reset the read/write bit */
;;;390      if (I2C_Direction != I2C_Direction_Transmitter)
;;;391      {
;;;392        /* Set the address bit0 for read */
;;;393        Address |= I2C_OAR1_ADD0;
0001ba  f0410101          ORR      r1,r1,#1
0001be  e001              B        |L1.452|
                  |L1.448|
;;;394      }
;;;395      else
;;;396      {
;;;397        /* Reset the address bit0 for write */
;;;398        Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
0001c0  f00101fe          AND      r1,r1,#0xfe
                  |L1.452|
;;;399      }
;;;400      /* Send the address */
;;;401      I2Cx->DR = Address;
0001c4  8201              STRH     r1,[r0,#0x10]
;;;402    }
0001c6  4770              BX       lr
;;;403    
                          ENDP

                  I2C_AcknowledgeConfig PROC
;;;410      */
;;;411    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
0001c8  b121              CBZ      r1,|L1.468|
;;;412    {
;;;413      /* Check the parameters */
;;;414      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;415      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;416      if (NewState != DISABLE)
;;;417      {
;;;418        /* Enable the acknowledgement */
;;;419        I2Cx->CR1 |= I2C_CR1_ACK;
0001ca  8802              LDRH     r2,[r0,#0]
0001cc  f4426280          ORR      r2,r2,#0x400
0001d0  8002              STRH     r2,[r0,#0]
0001d2  e005              B        |L1.480|
                  |L1.468|
;;;420      }
;;;421      else
;;;422      {
;;;423        /* Disable the acknowledgement */
;;;424        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
0001d4  8802              LDRH     r2,[r0,#0]
0001d6  f64f33ff          MOV      r3,#0xfbff
0001da  ea020203          AND      r2,r2,r3
0001de  8002              STRH     r2,[r0,#0]
                  |L1.480|
;;;425      }
;;;426    }
0001e0  4770              BX       lr
;;;427    
                          ENDP

                  I2C_OwnAddress2Config PROC
;;;433      */
;;;434    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
0001e2  460a              MOV      r2,r1
;;;435    {
;;;436      uint16_t tmpreg = 0;
0001e4  f04f0100          MOV      r1,#0
;;;437    
;;;438      /* Check the parameters */
;;;439      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;440    
;;;441      /* Get the old register value */
;;;442      tmpreg = I2Cx->OAR2;
0001e8  8981              LDRH     r1,[r0,#0xc]
;;;443    
;;;444      /* Reset I2Cx Own address2 bit [7:1] */
;;;445      tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);
0001ea  f64f7301          MOV      r3,#0xff01
0001ee  ea010103          AND      r1,r1,r3
;;;446    
;;;447      /* Set I2Cx Own address2 */
;;;448      tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
0001f2  f00203fe          AND      r3,r2,#0xfe
0001f6  ea430101          ORR      r1,r3,r1
;;;449    
;;;450      /* Store the new register value */
;;;451      I2Cx->OAR2 = tmpreg;
0001fa  8181              STRH     r1,[r0,#0xc]
;;;452    }
0001fc  4770              BX       lr
;;;453    
                          ENDP

                  I2C_DualAddressCmd PROC
;;;460      */
;;;461    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
0001fe  b121              CBZ      r1,|L1.522|
;;;462    {
;;;463      /* Check the parameters */
;;;464      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;465      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;466      if (NewState != DISABLE)
;;;467      {
;;;468        /* Enable dual addressing mode */
;;;469        I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
000200  8982              LDRH     r2,[r0,#0xc]
000202  f0420201          ORR      r2,r2,#1
000206  8182              STRH     r2,[r0,#0xc]
000208  e005              B        |L1.534|
                  |L1.522|
;;;470      }
;;;471      else
;;;472      {
;;;473        /* Disable dual addressing mode */
;;;474        I2Cx->OAR2 &= (uint16_t)~((uint16_t)I2C_OAR2_ENDUAL);
00020a  8982              LDRH     r2,[r0,#0xc]
00020c  f64f73fe          MOV      r3,#0xfffe
000210  ea020203          AND      r2,r2,r3
000214  8182              STRH     r2,[r0,#0xc]
                  |L1.534|
;;;475      }
;;;476    }
000216  4770              BX       lr
;;;477    
                          ENDP

                  I2C_GeneralCallCmd PROC
;;;484      */
;;;485    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000218  b121              CBZ      r1,|L1.548|
;;;486    {
;;;487      /* Check the parameters */
;;;488      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;489      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;490      if (NewState != DISABLE)
;;;491      {
;;;492        /* Enable generall call */
;;;493        I2Cx->CR1 |= I2C_CR1_ENGC;
00021a  8802              LDRH     r2,[r0,#0]
00021c  f0420240          ORR      r2,r2,#0x40
000220  8002              STRH     r2,[r0,#0]
000222  e005              B        |L1.560|
                  |L1.548|
;;;494      }
;;;495      else
;;;496      {
;;;497        /* Disable generall call */
;;;498        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENGC);
000224  8802              LDRH     r2,[r0,#0]
000226  f64f73bf          MOV      r3,#0xffbf
00022a  ea020203          AND      r2,r2,r3
00022e  8002              STRH     r2,[r0,#0]
                  |L1.560|
;;;499      }
;;;500    }
000230  4770              BX       lr
;;;501    
                          ENDP

                  I2C_SoftwareResetCmd PROC
;;;510      */
;;;511    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000232  b121              CBZ      r1,|L1.574|
;;;512    {
;;;513      /* Check the parameters */
;;;514      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;515      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;516      if (NewState != DISABLE)
;;;517      {
;;;518        /* Peripheral under reset */
;;;519        I2Cx->CR1 |= I2C_CR1_SWRST;
000234  8802              LDRH     r2,[r0,#0]
000236  f4424200          ORR      r2,r2,#0x8000
00023a  8002              STRH     r2,[r0,#0]
00023c  e003              B        |L1.582|
                  |L1.574|
;;;520      }
;;;521      else
;;;522      {
;;;523        /* Peripheral not under reset */
;;;524        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_SWRST);
00023e  8802              LDRH     r2,[r0,#0]
000240  f3c2020e          UBFX     r2,r2,#0,#15
000244  8002              STRH     r2,[r0,#0]
                  |L1.582|
;;;525      }
;;;526    }
000246  4770              BX       lr
;;;527    
                          ENDP

                  I2C_StretchClockCmd PROC
;;;534      */
;;;535    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000248  b921              CBNZ     r1,|L1.596|
;;;536    {
;;;537      /* Check the parameters */
;;;538      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;539      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;540      if (NewState == DISABLE)
;;;541      {
;;;542        /* Enable the selected I2C Clock stretching */
;;;543        I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
00024a  8802              LDRH     r2,[r0,#0]
00024c  f0420280          ORR      r2,r2,#0x80
000250  8002              STRH     r2,[r0,#0]
000252  e005              B        |L1.608|
                  |L1.596|
;;;544      }
;;;545      else
;;;546      {
;;;547        /* Disable the selected I2C Clock stretching */
;;;548        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_NOSTRETCH);
000254  8802              LDRH     r2,[r0,#0]
000256  f64f737f          MOV      r3,#0xff7f
00025a  ea020203          AND      r2,r2,r3
00025e  8002              STRH     r2,[r0,#0]
                  |L1.608|
;;;549      }
;;;550    }
000260  4770              BX       lr
;;;551    
                          ENDP

                  I2C_FastModeDutyCycleConfig PROC
;;;560      */
;;;561    void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
000262  f5b14f80          CMP      r1,#0x4000
;;;562    {
;;;563      /* Check the parameters */
;;;564      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;565      assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
;;;566      if (I2C_DutyCycle != I2C_DutyCycle_16_9)
000266  d006              BEQ      |L1.630|
;;;567      {
;;;568        /* I2C fast mode Tlow/Thigh=2 */
;;;569        I2Cx->CCR &= I2C_DutyCycle_2;
000268  8b82              LDRH     r2,[r0,#0x1c]
00026a  f64b73ff          MOV      r3,#0xbfff
00026e  ea020203          AND      r2,r2,r3
000272  8382              STRH     r2,[r0,#0x1c]
000274  e003              B        |L1.638|
                  |L1.630|
;;;570      }
;;;571      else
;;;572      {
;;;573        /* I2C fast mode Tlow/Thigh=16/9 */
;;;574        I2Cx->CCR |= I2C_DutyCycle_16_9;
000276  8b82              LDRH     r2,[r0,#0x1c]
000278  f4424280          ORR      r2,r2,#0x4000
00027c  8382              STRH     r2,[r0,#0x1c]
                  |L1.638|
;;;575      }
;;;576    }
00027e  4770              BX       lr
;;;577    
                          ENDP

                  I2C_NACKPositionConfig PROC
;;;598      */
;;;599    void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)
000280  f5b16f00          CMP      r1,#0x800
;;;600    {
;;;601      /* Check the parameters */
;;;602      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;603      assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
;;;604      
;;;605      /* Check the input parameter */
;;;606      if (I2C_NACKPosition == I2C_NACKPosition_Next)
000284  d104              BNE      |L1.656|
;;;607      {
;;;608        /* Next byte in shift register is the last received byte */
;;;609        I2Cx->CR1 |= I2C_NACKPosition_Next;
000286  8802              LDRH     r2,[r0,#0]
000288  f4426200          ORR      r2,r2,#0x800
00028c  8002              STRH     r2,[r0,#0]
00028e  e005              B        |L1.668|
                  |L1.656|
;;;610      }
;;;611      else
;;;612      {
;;;613        /* Current byte in shift register is the last received byte */
;;;614        I2Cx->CR1 &= I2C_NACKPosition_Current;
000290  8802              LDRH     r2,[r0,#0]
000292  f24f73ff          MOV      r3,#0xf7ff
000296  ea020203          AND      r2,r2,r3
00029a  8002              STRH     r2,[r0,#0]
                  |L1.668|
;;;615      }
;;;616    }
00029c  4770              BX       lr
;;;617    
                          ENDP

                  I2C_SMBusAlertConfig PROC
;;;626      */
;;;627    void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
00029e  f5b15f00          CMP      r1,#0x2000
;;;628    {
;;;629      /* Check the parameters */
;;;630      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;631      assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
;;;632      if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
0002a2  d104              BNE      |L1.686|
;;;633      {
;;;634        /* Drive the SMBusAlert pin Low */
;;;635        I2Cx->CR1 |= I2C_SMBusAlert_Low;
0002a4  8802              LDRH     r2,[r0,#0]
0002a6  f4425200          ORR      r2,r2,#0x2000
0002aa  8002              STRH     r2,[r0,#0]
0002ac  e005              B        |L1.698|
                  |L1.686|
;;;636      }
;;;637      else
;;;638      {
;;;639        /* Drive the SMBusAlert pin High  */
;;;640        I2Cx->CR1 &= I2C_SMBusAlert_High;
0002ae  8802              LDRH     r2,[r0,#0]
0002b0  f64d73ff          MOV      r3,#0xdfff
0002b4  ea020203          AND      r2,r2,r3
0002b8  8002              STRH     r2,[r0,#0]
                  |L1.698|
;;;641      }
;;;642    }
0002ba  4770              BX       lr
;;;643    
                          ENDP

                  I2C_ARPCmd PROC
;;;650      */
;;;651    void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
0002bc  b121              CBZ      r1,|L1.712|
;;;652    {
;;;653      /* Check the parameters */
;;;654      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;655      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;656      if (NewState != DISABLE)
;;;657      {
;;;658        /* Enable the selected I2C ARP */
;;;659        I2Cx->CR1 |= I2C_CR1_ENARP;
0002be  8802              LDRH     r2,[r0,#0]
0002c0  f0420210          ORR      r2,r2,#0x10
0002c4  8002              STRH     r2,[r0,#0]
0002c6  e005              B        |L1.724|
                  |L1.712|
;;;660      }
;;;661      else
;;;662      {
;;;663        /* Disable the selected I2C ARP */
;;;664        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENARP);
0002c8  8802              LDRH     r2,[r0,#0]
0002ca  f64f73ef          MOV      r3,#0xffef
0002ce  ea020203          AND      r2,r2,r3
0002d2  8002              STRH     r2,[r0,#0]
                  |L1.724|
;;;665      }
;;;666    }
0002d4  4770              BX       lr
;;;667    /**
                          ENDP

                  I2C_SendData PROC
;;;688      */
;;;689    void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
0002d6  8201              STRH     r1,[r0,#0x10]
;;;690    {
;;;691      /* Check the parameters */
;;;692      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;693      /* Write in the DR register the data to be sent */
;;;694      I2Cx->DR = Data;
;;;695    }
0002d8  4770              BX       lr
;;;696    
                          ENDP

                  I2C_ReceiveData PROC
;;;701      */
;;;702    uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
0002da  4601              MOV      r1,r0
;;;703    {
;;;704      /* Check the parameters */
;;;705      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;706      /* Return the data in the DR register */
;;;707      return (uint8_t)I2Cx->DR;
0002dc  8a08              LDRH     r0,[r1,#0x10]
0002de  b2c0              UXTB     r0,r0
;;;708    }
0002e0  4770              BX       lr
;;;709    
                          ENDP

                  I2C_TransmitPEC PROC
;;;732      */
;;;733    void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
0002e2  b121              CBZ      r1,|L1.750|
;;;734    {
;;;735      /* Check the parameters */
;;;736      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;737      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;738      if (NewState != DISABLE)
;;;739      {
;;;740        /* Enable the selected I2C PEC transmission */
;;;741        I2Cx->CR1 |= I2C_CR1_PEC;
0002e4  8802              LDRH     r2,[r0,#0]
0002e6  f4425280          ORR      r2,r2,#0x1000
0002ea  8002              STRH     r2,[r0,#0]
0002ec  e005              B        |L1.762|
                  |L1.750|
;;;742      }
;;;743      else
;;;744      {
;;;745        /* Disable the selected I2C PEC transmission */
;;;746        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PEC);
0002ee  8802              LDRH     r2,[r0,#0]
0002f0  f64e73ff          MOV      r3,#0xefff
0002f4  ea020203          AND      r2,r2,r3
0002f8  8002              STRH     r2,[r0,#0]
                  |L1.762|
;;;747      }
;;;748    }
0002fa  4770              BX       lr
;;;749    
                          ENDP

                  I2C_PECPositionConfig PROC
;;;763      */
;;;764    void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
0002fc  f5b16f00          CMP      r1,#0x800
;;;765    {
;;;766      /* Check the parameters */
;;;767      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;768      assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
;;;769      if (I2C_PECPosition == I2C_PECPosition_Next)
000300  d104              BNE      |L1.780|
;;;770      {
;;;771        /* Next byte in shift register is PEC */
;;;772        I2Cx->CR1 |= I2C_PECPosition_Next;
000302  8802              LDRH     r2,[r0,#0]
000304  f4426200          ORR      r2,r2,#0x800
000308  8002              STRH     r2,[r0,#0]
00030a  e005              B        |L1.792|
                  |L1.780|
;;;773      }
;;;774      else
;;;775      {
;;;776        /* Current byte in shift register is PEC */
;;;777        I2Cx->CR1 &= I2C_PECPosition_Current;
00030c  8802              LDRH     r2,[r0,#0]
00030e  f24f73ff          MOV      r3,#0xf7ff
000312  ea020203          AND      r2,r2,r3
000316  8002              STRH     r2,[r0,#0]
                  |L1.792|
;;;778      }
;;;779    }
000318  4770              BX       lr
;;;780    
                          ENDP

                  I2C_CalculatePEC PROC
;;;787      */
;;;788    void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
00031a  b121              CBZ      r1,|L1.806|
;;;789    {
;;;790      /* Check the parameters */
;;;791      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;792      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;793      if (NewState != DISABLE)
;;;794      {
;;;795        /* Enable the selected I2C PEC calculation */
;;;796        I2Cx->CR1 |= I2C_CR1_ENPEC;
00031c  8802              LDRH     r2,[r0,#0]
00031e  f0420220          ORR      r2,r2,#0x20
000322  8002              STRH     r2,[r0,#0]
000324  e005              B        |L1.818|
                  |L1.806|
;;;797      }
;;;798      else
;;;799      {
;;;800        /* Disable the selected I2C PEC calculation */
;;;801        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENPEC);
000326  8802              LDRH     r2,[r0,#0]
000328  f64f73df          MOV      r3,#0xffdf
00032c  ea020203          AND      r2,r2,r3
000330  8002              STRH     r2,[r0,#0]
                  |L1.818|
;;;802      }
;;;803    }
000332  4770              BX       lr
;;;804    
                          ENDP

                  I2C_GetPEC PROC
;;;809      */
;;;810    uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
000334  4601              MOV      r1,r0
;;;811    {
;;;812      /* Check the parameters */
;;;813      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;814      /* Return the selected I2C PEC value */
;;;815      return ((I2Cx->SR2) >> 8);
000336  8b08              LDRH     r0,[r1,#0x18]
000338  ea4f2020          ASR      r0,r0,#8
;;;816    }
00033c  4770              BX       lr
;;;817    
                          ENDP

                  I2C_DMACmd PROC
;;;842      */
;;;843    void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
00033e  b121              CBZ      r1,|L1.842|
;;;844    {
;;;845      /* Check the parameters */
;;;846      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;847      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;848      if (NewState != DISABLE)
;;;849      {
;;;850        /* Enable the selected I2C DMA requests */
;;;851        I2Cx->CR2 |= I2C_CR2_DMAEN;
000340  8882              LDRH     r2,[r0,#4]
000342  f4426200          ORR      r2,r2,#0x800
000346  8082              STRH     r2,[r0,#4]
000348  e005              B        |L1.854|
                  |L1.842|
;;;852      }
;;;853      else
;;;854      {
;;;855        /* Disable the selected I2C DMA requests */
;;;856        I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_DMAEN);
00034a  8882              LDRH     r2,[r0,#4]
00034c  f24f73ff          MOV      r3,#0xf7ff
000350  ea020203          AND      r2,r2,r3
000354  8082              STRH     r2,[r0,#4]
                  |L1.854|
;;;857      }
;;;858    }
000356  4770              BX       lr
;;;859    
                          ENDP

                  I2C_DMALastTransferCmd PROC
;;;866      */
;;;867    void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000358  b121              CBZ      r1,|L1.868|
;;;868    {
;;;869      /* Check the parameters */
;;;870      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;871      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;872      if (NewState != DISABLE)
;;;873      {
;;;874        /* Next DMA transfer is the last transfer */
;;;875        I2Cx->CR2 |= I2C_CR2_LAST;
00035a  8882              LDRH     r2,[r0,#4]
00035c  f4425280          ORR      r2,r2,#0x1000
000360  8082              STRH     r2,[r0,#4]
000362  e005              B        |L1.880|
                  |L1.868|
;;;876      }
;;;877      else
;;;878      {
;;;879        /* Next DMA transfer is not the last transfer */
;;;880        I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_LAST);
000364  8882              LDRH     r2,[r0,#4]
000366  f64e73ff          MOV      r3,#0xefff
00036a  ea020203          AND      r2,r2,r3
00036e  8082              STRH     r2,[r0,#4]
                  |L1.880|
;;;881      }
;;;882    }
000370  4770              BX       lr
;;;883    
                          ENDP

                  I2C_ReadRegister PROC
;;;1004     */
;;;1005   uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
000372  4602              MOV      r2,r0
;;;1006   {
;;;1007     __IO uint32_t tmp = 0;
000374  f04f0300          MOV      r3,#0
;;;1008   
;;;1009     /* Check the parameters */
;;;1010     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1011     assert_param(IS_I2C_REGISTER(I2C_Register));
;;;1012   
;;;1013     tmp = (uint32_t) I2Cx;
000378  4613              MOV      r3,r2
;;;1014     tmp += I2C_Register;
00037a  440b              ADD      r3,r3,r1
;;;1015   
;;;1016     /* Return the selected register value */
;;;1017     return (*(__IO uint16_t *) tmp);
00037c  8818              LDRH     r0,[r3,#0]
;;;1018   }
00037e  4770              BX       lr
;;;1019   
                          ENDP

                  I2C_ITConfig PROC
;;;1031     */
;;;1032   void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
000380  b510              PUSH     {r4,lr}
;;;1033   {
;;;1034     /* Check the parameters */
;;;1035     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1036     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1037     assert_param(IS_I2C_CONFIG_IT(I2C_IT));
;;;1038     
;;;1039     if (NewState != DISABLE)
000382  b122              CBZ      r2,|L1.910|
;;;1040     {
;;;1041       /* Enable the selected I2C interrupts */
;;;1042       I2Cx->CR2 |= I2C_IT;
000384  8883              LDRH     r3,[r0,#4]
000386  ea430301          ORR      r3,r3,r1
00038a  8083              STRH     r3,[r0,#4]
00038c  e006              B        |L1.924|
                  |L1.910|
;;;1043     }
;;;1044     else
;;;1045     {
;;;1046       /* Disable the selected I2C interrupts */
;;;1047       I2Cx->CR2 &= (uint16_t)~I2C_IT;
00038e  8883              LDRH     r3,[r0,#4]
000390  ea6f0401          MVN      r4,r1
000394  b2a4              UXTH     r4,r4
000396  ea030304          AND      r3,r3,r4
00039a  8083              STRH     r3,[r0,#4]
                  |L1.924|
;;;1048     }
;;;1049   }
00039c  bd10              POP      {r4,pc}
;;;1050   
                          ENDP

                  I2C_CheckEvent PROC
;;;1090     */
;;;1091   ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
00039e  b570              PUSH     {r4-r6,lr}
;;;1092   {
0003a0  4602              MOV      r2,r0
;;;1093     uint32_t lastevent = 0;
0003a2  f04f0400          MOV      r4,#0
;;;1094     uint32_t flag1 = 0, flag2 = 0;
0003a6  4625              MOV      r5,r4
0003a8  4623              MOV      r3,r4
;;;1095     ErrorStatus status = ERROR;
0003aa  4618              MOV      r0,r3
;;;1096   
;;;1097     /* Check the parameters */
;;;1098     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1099     assert_param(IS_I2C_EVENT(I2C_EVENT));
;;;1100   
;;;1101     /* Read the I2Cx status register */
;;;1102     flag1 = I2Cx->SR1;
0003ac  8a95              LDRH     r5,[r2,#0x14]
;;;1103     flag2 = I2Cx->SR2;
0003ae  8b13              LDRH     r3,[r2,#0x18]
;;;1104     flag2 = flag2 << 16;
0003b0  ea4f4303          LSL      r3,r3,#16
;;;1105   
;;;1106     /* Get the last event value from I2C status register */
;;;1107     lastevent = (flag1 | flag2) & FLAG_MASK;
0003b4  ea450603          ORR      r6,r5,r3
0003b8  f026447f          BIC      r4,r6,#0xff000000
;;;1108   
;;;1109     /* Check whether the last event contains the I2C_EVENT */
;;;1110     if ((lastevent & I2C_EVENT) == I2C_EVENT)
0003bc  ea040601          AND      r6,r4,r1
0003c0  428e              CMP      r6,r1
0003c2  d102              BNE      |L1.970|
;;;1111     {
;;;1112       /* SUCCESS: last event is equal to I2C_EVENT */
;;;1113       status = SUCCESS;
0003c4  f04f0001          MOV      r0,#1
0003c8  e001              B        |L1.974|
                  |L1.970|
;;;1114     }
;;;1115     else
;;;1116     {
;;;1117       /* ERROR: last event is different from I2C_EVENT */
;;;1118       status = ERROR;
0003ca  f04f0000          MOV      r0,#0
                  |L1.974|
;;;1119     }
;;;1120     /* Return status */
;;;1121     return status;
;;;1122   }
0003ce  bd70              POP      {r4-r6,pc}
;;;1123   
                          ENDP

                  I2C_GetLastEvent PROC
;;;1138     */
;;;1139   uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
0003d0  b510              PUSH     {r4,lr}
;;;1140   {
0003d2  4601              MOV      r1,r0
;;;1141     uint32_t lastevent = 0;
0003d4  f04f0000          MOV      r0,#0
;;;1142     uint32_t flag1 = 0, flag2 = 0;
0003d8  4603              MOV      r3,r0
0003da  4602              MOV      r2,r0
;;;1143   
;;;1144     /* Check the parameters */
;;;1145     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1146   
;;;1147     /* Read the I2Cx status register */
;;;1148     flag1 = I2Cx->SR1;
0003dc  8a8b              LDRH     r3,[r1,#0x14]
;;;1149     flag2 = I2Cx->SR2;
0003de  8b0a              LDRH     r2,[r1,#0x18]
;;;1150     flag2 = flag2 << 16;
0003e0  ea4f4202          LSL      r2,r2,#16
;;;1151   
;;;1152     /* Get the last event value from I2C status register */
;;;1153     lastevent = (flag1 | flag2) & FLAG_MASK;
0003e4  ea430402          ORR      r4,r3,r2
0003e8  f024407f          BIC      r0,r4,#0xff000000
;;;1154   
;;;1155     /* Return status */
;;;1156     return lastevent;
;;;1157   }
0003ec  bd10              POP      {r4,pc}
0003ee  0000              DCW      0x0000
                  |L1.1008|
                          DCD      0x40005400
                  |L1.1012|
                          DCD      0x40005800
                  |L1.1016|
                          DCD      0x40005c00
                  |L1.1020|
                          DCD      0x007a1200
                  |L1.1024|
                          DCD      0x000f4240
                  |L1.1028|
                          DCD      0x000186a0
                          ENDP

                  I2C_GetFlagStatus PROC
;;;1193     */
;;;1194   FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000408  b530              PUSH     {r4,r5,lr}
;;;1195   {
00040a  4603              MOV      r3,r0
;;;1196     FlagStatus bitstatus = RESET;
00040c  f04f0000          MOV      r0,#0
;;;1197     __IO uint32_t i2creg = 0, i2cxbase = 0;
000410  4604              MOV      r4,r0
000412  4602              MOV      r2,r0
;;;1198   
;;;1199     /* Check the parameters */
;;;1200     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1201     assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
;;;1202   
;;;1203     /* Get the I2Cx peripheral base address */
;;;1204     i2cxbase = (uint32_t)I2Cx;
000414  461a              MOV      r2,r3
;;;1205     
;;;1206     /* Read flag register index */
;;;1207     i2creg = I2C_FLAG >> 28;
000416  ea4f7411          LSR      r4,r1,#28
;;;1208     
;;;1209     /* Get bit[23:0] of the flag */
;;;1210     I2C_FLAG &= FLAG_MASK;
00041a  f021417f          BIC      r1,r1,#0xff000000
;;;1211     
;;;1212     if(i2creg != 0)
00041e  b114              CBZ      r4,|L1.1062|
;;;1213     {
;;;1214       /* Get the I2Cx SR1 register address */
;;;1215       i2cxbase += 0x14;
000420  f1020214          ADD      r2,r2,#0x14
000424  e003              B        |L1.1070|
                  |L1.1062|
;;;1216     }
;;;1217     else
;;;1218     {
;;;1219       /* Flag in I2Cx SR2 Register */
;;;1220       I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
000426  ea4f4111          LSR      r1,r1,#16
;;;1221       /* Get the I2Cx SR2 register address */
;;;1222       i2cxbase += 0x18;
00042a  f1020218          ADD      r2,r2,#0x18
                  |L1.1070|
;;;1223     }
;;;1224     
;;;1225     if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
00042e  6815              LDR      r5,[r2,#0]
000430  420d              TST      r5,r1
000432  d002              BEQ      |L1.1082|
;;;1226     {
;;;1227       /* I2C_FLAG is set */
;;;1228       bitstatus = SET;
000434  f04f0001          MOV      r0,#1
000438  e001              B        |L1.1086|
                  |L1.1082|
;;;1229     }
;;;1230     else
;;;1231     {
;;;1232       /* I2C_FLAG is reset */
;;;1233       bitstatus = RESET;
00043a  f04f0000          MOV      r0,#0
                  |L1.1086|
;;;1234     }
;;;1235     
;;;1236     /* Return the I2C_FLAG status */
;;;1237     return  bitstatus;
;;;1238   }
00043e  bd30              POP      {r4,r5,pc}
;;;1239   
                          ENDP

                  I2C_ClearFlag PROC
;;;1270     */
;;;1271   void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000440  f04f0200          MOV      r2,#0
;;;1272   {
;;;1273     uint32_t flagpos = 0;
;;;1274     /* Check the parameters */
;;;1275     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1276     assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
;;;1277     /* Get the I2C flag position */
;;;1278     flagpos = I2C_FLAG & FLAG_MASK;
000444  f021427f          BIC      r2,r1,#0xff000000
;;;1279     /* Clear the selected I2C flag */
;;;1280     I2Cx->SR1 = (uint16_t)~flagpos;
000448  ea6f0302          MVN      r3,r2
00044c  8283              STRH     r3,[r0,#0x14]
;;;1281   }
00044e  4770              BX       lr
;;;1282   
                          ENDP

                  I2C_GetITStatus PROC
;;;1304     */
;;;1305   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000450  b530              PUSH     {r4,r5,lr}
;;;1306   {
000452  4602              MOV      r2,r0
;;;1307     ITStatus bitstatus = RESET;
000454  f04f0000          MOV      r0,#0
;;;1308     uint32_t enablestatus = 0;
000458  4603              MOV      r3,r0
;;;1309   
;;;1310     /* Check the parameters */
;;;1311     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1312     assert_param(IS_I2C_GET_IT(I2C_IT));
;;;1313   
;;;1314     /* Check if the interrupt source is enabled or not */
;;;1315     enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
00045a  8894              LDRH     r4,[r2,#4]
00045c  f00165e0          AND      r5,r1,#0x7000000
000460  ea044315          AND      r3,r4,r5,LSR #16
;;;1316     
;;;1317     /* Get bit[23:0] of the flag */
;;;1318     I2C_IT &= FLAG_MASK;
000464  f021417f          BIC      r1,r1,#0xff000000
;;;1319   
;;;1320     /* Check the status of the specified I2C flag */
;;;1321     if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
000468  8a94              LDRH     r4,[r2,#0x14]
00046a  420c              TST      r4,r1
00046c  d003              BEQ      |L1.1142|
00046e  b113              CBZ      r3,|L1.1142|
;;;1322     {
;;;1323       /* I2C_IT is set */
;;;1324       bitstatus = SET;
000470  f04f0001          MOV      r0,#1
000474  e001              B        |L1.1146|
                  |L1.1142|
;;;1325     }
;;;1326     else
;;;1327     {
;;;1328       /* I2C_IT is reset */
;;;1329       bitstatus = RESET;
000476  f04f0000          MOV      r0,#0
                  |L1.1146|
;;;1330     }
;;;1331     /* Return the I2C_IT status */
;;;1332     return  bitstatus;
;;;1333   }
00047a  bd30              POP      {r4,r5,pc}
;;;1334   
                          ENDP

                  I2C_ClearITPendingBit PROC
;;;1364     */
;;;1365   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
00047c  f04f0200          MOV      r2,#0
;;;1366   {
;;;1367     uint32_t flagpos = 0;
;;;1368     /* Check the parameters */
;;;1369     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1370     assert_param(IS_I2C_CLEAR_IT(I2C_IT));
;;;1371   
;;;1372     /* Get the I2C flag position */
;;;1373     flagpos = I2C_IT & FLAG_MASK;
000480  f021427f          BIC      r2,r1,#0xff000000
;;;1374   
;;;1375     /* Clear the selected I2C flag */
;;;1376     I2Cx->SR1 = (uint16_t)~flagpos;
000484  ea6f0302          MVN      r3,r2
000488  8283              STRH     r3,[r0,#0x14]
;;;1377   }
00048a  4770              BX       lr
;;;1378   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\BSP\\STM32F2xx\\src\\stm32f2xx_i2c.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f2xx_i2c_c_7174d409____REV16|
#line 112 "..\\BSP\\CMSIS\\core_cmInstr.h"
|__asm___15_stm32f2xx_i2c_c_7174d409____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f2xx_i2c_c_7174d409____REVSH|
#line 130
|__asm___15_stm32f2xx_i2c_c_7174d409____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
