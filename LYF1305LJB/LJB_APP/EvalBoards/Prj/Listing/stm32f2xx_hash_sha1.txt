; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Output\stm32f2xx_hash_sha1.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\Output\stm32f2xx_hash_sha1.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\BSP -I..\BSP\UCOS-II -I..\BSP\STM32F2xx\inc -I..\BSP\CMSIS -I..\BSP\CMSIS\Device_Support -I..\BSP\UCOS-II -I..\..\uC-CPU -I..\..\uC-CPU\ARM-Cortex-M3 -I..\..\uC-LIB -I..\..\uC-LIB\Ports\ARM-Cortex-M3 -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3 -I..\App -I..\Prj -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DDEBUG -DLJB_CPU_MAIN -DUSE_CPU_F205RC --omf_browse=.\Output\stm32f2xx_hash_sha1.crf ..\BSP\STM32F2xx\src\stm32f2xx_hash_sha1.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=1

                  HASH_SHA1 PROC
;;;86       */
;;;87     ErrorStatus HASH_SHA1(uint8_t *Input, uint32_t Ilen, uint8_t Output[20])
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;88     {
000004  b08b              SUB      sp,sp,#0x2c
000006  4606              MOV      r6,r0
000008  460d              MOV      r5,r1
00000a  4617              MOV      r7,r2
;;;89       HASH_InitTypeDef SHA1_HASH_InitStructure;
;;;90       HASH_MsgDigest SHA1_MessageDigest;
;;;91       __IO uint16_t nbvalidbitsdata = 0;
00000c  f04f0000          MOV      r0,#0
000010  9001              STR      r0,[sp,#4]
;;;92       uint32_t i = 0;
000012  4680              MOV      r8,r0
;;;93       __IO uint32_t counter = 0;
000014  4681              MOV      r9,r0
;;;94       uint32_t busystatus = 0;
000016  4682              MOV      r10,r0
;;;95       ErrorStatus status = SUCCESS;
000018  f04f0001          MOV      r0,#1
00001c  9000              STR      r0,[sp,#0]
;;;96       uint32_t inputaddr  = (uint32_t)Input;
00001e  46b3              MOV      r11,r6
;;;97       uint32_t outputaddr = (uint32_t)Output;
000020  463c              MOV      r4,r7
;;;98     
;;;99       /* Number of valid bits in last word of the Input data */
;;;100      nbvalidbitsdata = 8 * (Ilen % 4);
000022  ea4f7085          LSL      r0,r5,#30
000026  ea4f60d0          LSR      r0,r0,#27
00002a  9001              STR      r0,[sp,#4]
;;;101    
;;;102      /* HASH peripheral initialization */
;;;103      HASH_DeInit();
00002c  f7fffffe          BL       HASH_DeInit
;;;104    
;;;105      /* HASH Configuration */
;;;106      SHA1_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
000030  4640              MOV      r0,r8
000032  9007              STR      r0,[sp,#0x1c]
;;;107      SHA1_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HASH;
000034  9008              STR      r0,[sp,#0x20]
;;;108      SHA1_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
000036  f04f0020          MOV      r0,#0x20
00003a  9009              STR      r0,[sp,#0x24]
;;;109      HASH_Init(&SHA1_HASH_InitStructure);
00003c  a807              ADD      r0,sp,#0x1c
00003e  f7fffffe          BL       HASH_Init
;;;110    
;;;111      /* Configure the number of valid bits in last word of the data */
;;;112      HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
000042  9801              LDR      r0,[sp,#4]
000044  f7fffffe          BL       HASH_SetLastWordValidBitsNbr
;;;113    
;;;114      /* Write the Input block in the IN FIFO */
;;;115      for(i=0; i<Ilen; i+=4)
000048  bf00              NOP      
00004a  e007              B        |L1.92|
                  |L1.76|
;;;116      {
;;;117        HASH_DataIn(*(uint32_t*)inputaddr);
00004c  f8db0000          LDR      r0,[r11,#0]
000050  f7fffffe          BL       HASH_DataIn
;;;118        inputaddr+=4;
000054  f10b0b04          ADD      r11,r11,#4
000058  f1080804          ADD      r8,r8,#4              ;115
                  |L1.92|
00005c  45a8              CMP      r8,r5                 ;115
00005e  d3f5              BCC      |L1.76|
;;;119      }
;;;120    
;;;121      /* Start the HASH processor */
;;;122      HASH_StartDigest();
000060  f7fffffe          BL       HASH_StartDigest
;;;123    
;;;124      /* wait until the Busy flag is RESET */
;;;125      do
000064  bf00              NOP      
                  |L1.102|
;;;126      {
;;;127        busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
000066  2008              MOVS     r0,#8
000068  f7fffffe          BL       HASH_GetFlagStatus
00006c  4682              MOV      r10,r0
;;;128        counter++;
00006e  f1090901          ADD      r9,r9,#1
;;;129      }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
000072  f5b93f80          CMP      r9,#0x10000
000076  d002              BEQ      |L1.126|
000078  f1ba0f00          CMP      r10,#0
00007c  d1f3              BNE      |L1.102|
                  |L1.126|
;;;130    
;;;131      if (busystatus != RESET)
00007e  f1ba0f00          CMP      r10,#0
000082  d003              BEQ      |L1.140|
;;;132      {
;;;133         status = ERROR;
000084  f04f0000          MOV      r0,#0
000088  9000              STR      r0,[sp,#0]
00008a  e019              B        |L1.192|
                  |L1.140|
;;;134      }
;;;135      else
;;;136      {
;;;137        /* Read the message digest */
;;;138        HASH_GetDigest(&SHA1_MessageDigest);
00008c  a802              ADD      r0,sp,#8
00008e  f7fffffe          BL       HASH_GetDigest
;;;139        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[0]);
000092  9802              LDR      r0,[sp,#8]
000094  ba00              REV      r0,r0
000096  6020              STR      r0,[r4,#0]
;;;140        outputaddr+=4;
000098  f1040404          ADD      r4,r4,#4
;;;141        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[1]);
00009c  9803              LDR      r0,[sp,#0xc]
00009e  ba00              REV      r0,r0
0000a0  6020              STR      r0,[r4,#0]
;;;142        outputaddr+=4;
0000a2  f1040404          ADD      r4,r4,#4
;;;143        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[2]);
0000a6  9804              LDR      r0,[sp,#0x10]
0000a8  ba00              REV      r0,r0
0000aa  6020              STR      r0,[r4,#0]
;;;144        outputaddr+=4;
0000ac  f1040404          ADD      r4,r4,#4
;;;145        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[3]);
0000b0  9805              LDR      r0,[sp,#0x14]
0000b2  ba00              REV      r0,r0
0000b4  6020              STR      r0,[r4,#0]
;;;146        outputaddr+=4;
0000b6  f1040404          ADD      r4,r4,#4
;;;147        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[4]);
0000ba  9806              LDR      r0,[sp,#0x18]
0000bc  ba00              REV      r0,r0
0000be  6020              STR      r0,[r4,#0]
                  |L1.192|
;;;148      }
;;;149      return status;
0000c0  9800              LDR      r0,[sp,#0]
;;;150    }
0000c2  b00b              ADD      sp,sp,#0x2c
0000c4  e8bd8ff0          POP      {r4-r11,pc}
;;;151    
                          ENDP

                  HMAC_SHA1 PROC
;;;162      */
;;;163    ErrorStatus HMAC_SHA1(uint8_t *Key, uint32_t Keylen, uint8_t *Input,
0000c8  e92d4fff          PUSH     {r0-r11,lr}
;;;164                          uint32_t Ilen, uint8_t Output[20])
;;;165    {
0000cc  b08d              SUB      sp,sp,#0x34
0000ce  4682              MOV      r10,r0
0000d0  4688              MOV      r8,r1
0000d2  469b              MOV      r11,r3
;;;166      HASH_InitTypeDef SHA1_HASH_InitStructure;
;;;167      HASH_MsgDigest SHA1_MessageDigest;
;;;168      __IO uint16_t nbvalidbitsdata = 0;
0000d4  f04f0000          MOV      r0,#0
0000d8  9003              STR      r0,[sp,#0xc]
;;;169      __IO uint16_t nbvalidbitskey = 0;
0000da  9002              STR      r0,[sp,#8]
;;;170      uint32_t i = 0;
0000dc  4605              MOV      r5,r0
;;;171      __IO uint32_t counter = 0;
0000de  4606              MOV      r6,r0
;;;172      uint32_t busystatus = 0;
0000e0  4607              MOV      r7,r0
;;;173      ErrorStatus status = SUCCESS;
0000e2  f04f0001          MOV      r0,#1
0000e6  9001              STR      r0,[sp,#4]
;;;174      uint32_t keyaddr    = (uint32_t)Key;
0000e8  46d1              MOV      r9,r10
;;;175      uint32_t inputaddr  = (uint32_t)Input;
0000ea  980f              LDR      r0,[sp,#0x3c]
0000ec  9000              STR      r0,[sp,#0]
;;;176      uint32_t outputaddr = (uint32_t)Output;
0000ee  9c1a              LDR      r4,[sp,#0x68]
;;;177    
;;;178      /* Number of valid bits in last word of the Input data */
;;;179      nbvalidbitsdata = 8 * (Ilen % 4);
0000f0  ea4f708b          LSL      r0,r11,#30
0000f4  ea4f60d0          LSR      r0,r0,#27
0000f8  9003              STR      r0,[sp,#0xc]
;;;180    
;;;181      /* Number of valid bits in last word of the Key */
;;;182      nbvalidbitskey = 8 * (Keylen % 4);
0000fa  ea4f7088          LSL      r0,r8,#30
0000fe  ea4f60d0          LSR      r0,r0,#27
000102  9002              STR      r0,[sp,#8]
;;;183    
;;;184      /* HASH peripheral initialization */
;;;185      HASH_DeInit();
000104  f7fffffe          BL       HASH_DeInit
;;;186    
;;;187      /* HASH Configuration */
;;;188      SHA1_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
000108  4628              MOV      r0,r5
00010a  9009              STR      r0,[sp,#0x24]
;;;189      SHA1_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HMAC;
00010c  f04f0040          MOV      r0,#0x40
000110  900a              STR      r0,[sp,#0x28]
;;;190      SHA1_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
000112  f04f0020          MOV      r0,#0x20
000116  900b              STR      r0,[sp,#0x2c]
;;;191      if(Keylen > 64)
000118  f1b80f40          CMP      r8,#0x40
00011c  d903              BLS      |L1.294|
;;;192      {
;;;193        /* HMAC long Key */
;;;194        SHA1_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_LongKey;
00011e  f44f3080          MOV      r0,#0x10000
000122  900c              STR      r0,[sp,#0x30]
000124  e002              B        |L1.300|
                  |L1.294|
;;;195      }
;;;196      else
;;;197      {
;;;198        /* HMAC short Key */
;;;199        SHA1_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
000126  f04f0000          MOV      r0,#0
00012a  900c              STR      r0,[sp,#0x30]
                  |L1.300|
;;;200      }
;;;201      HASH_Init(&SHA1_HASH_InitStructure);
00012c  a809              ADD      r0,sp,#0x24
00012e  f7fffffe          BL       HASH_Init
;;;202    
;;;203      /* Configure the number of valid bits in last word of the Key */
;;;204      HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
000132  9802              LDR      r0,[sp,#8]
000134  f7fffffe          BL       HASH_SetLastWordValidBitsNbr
;;;205    
;;;206      /* Write the Key */
;;;207      for(i=0; i<Keylen; i+=4)
000138  f04f0500          MOV      r5,#0
00013c  e007              B        |L1.334|
                  |L1.318|
;;;208      {
;;;209        HASH_DataIn(*(uint32_t*)keyaddr);
00013e  f8d90000          LDR      r0,[r9,#0]
000142  f7fffffe          BL       HASH_DataIn
;;;210        keyaddr+=4;
000146  f1090904          ADD      r9,r9,#4
00014a  f1050504          ADD      r5,r5,#4              ;207
                  |L1.334|
00014e  4545              CMP      r5,r8                 ;207
000150  d3f5              BCC      |L1.318|
;;;211      }
;;;212    
;;;213      /* Start the HASH processor */
;;;214      HASH_StartDigest();
000152  f7fffffe          BL       HASH_StartDigest
;;;215    
;;;216      /* wait until the Busy flag is RESET */
;;;217      do
000156  bf00              NOP      
                  |L1.344|
;;;218      {
;;;219        busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
000158  2008              MOVS     r0,#8
00015a  f7fffffe          BL       HASH_GetFlagStatus
00015e  4607              MOV      r7,r0
;;;220        counter++;
000160  f1060601          ADD      r6,r6,#1
;;;221      }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
000164  f5b63f80          CMP      r6,#0x10000
000168  d001              BEQ      |L1.366|
00016a  2f00              CMP      r7,#0
00016c  d1f4              BNE      |L1.344|
                  |L1.366|
;;;222    
;;;223      if (busystatus != RESET)
00016e  b11f              CBZ      r7,|L1.376|
;;;224      {
;;;225         status = ERROR;
000170  f04f0000          MOV      r0,#0
000174  9001              STR      r0,[sp,#4]
000176  e066              B        |L1.582|
                  |L1.376|
;;;226      }
;;;227      else
;;;228      {
;;;229        /* Configure the number of valid bits in last word of the Input data */
;;;230        HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
000178  9803              LDR      r0,[sp,#0xc]
00017a  f7fffffe          BL       HASH_SetLastWordValidBitsNbr
;;;231    
;;;232        /* Write the Input block in the IN FIFO */
;;;233        for(i=0; i<Ilen; i+=4)
00017e  f04f0500          MOV      r5,#0
000182  e009              B        |L1.408|
                  |L1.388|
;;;234        {
;;;235          HASH_DataIn(*(uint32_t*)inputaddr);
000184  9900              LDR      r1,[sp,#0]
000186  6808              LDR      r0,[r1,#0]
000188  f7fffffe          BL       HASH_DataIn
;;;236          inputaddr+=4;
00018c  9800              LDR      r0,[sp,#0]
00018e  f1000004          ADD      r0,r0,#4
000192  9000              STR      r0,[sp,#0]
000194  f1050504          ADD      r5,r5,#4              ;233
                  |L1.408|
000198  455d              CMP      r5,r11                ;233
00019a  d3f3              BCC      |L1.388|
;;;237        }
;;;238    
;;;239        /* Start the HASH processor */
;;;240        HASH_StartDigest();
00019c  f7fffffe          BL       HASH_StartDigest
;;;241    
;;;242    
;;;243        /* wait until the Busy flag is RESET */
;;;244        counter =0;
0001a0  f04f0600          MOV      r6,#0
;;;245        do
0001a4  bf00              NOP      
                  |L1.422|
;;;246        {
;;;247          busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
0001a6  2008              MOVS     r0,#8
0001a8  f7fffffe          BL       HASH_GetFlagStatus
0001ac  4607              MOV      r7,r0
;;;248          counter++;
0001ae  f1060601          ADD      r6,r6,#1
;;;249        }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
0001b2  f5b63f80          CMP      r6,#0x10000
0001b6  d001              BEQ      |L1.444|
0001b8  2f00              CMP      r7,#0
0001ba  d1f4              BNE      |L1.422|
                  |L1.444|
;;;250    
;;;251        if (busystatus != RESET)
0001bc  b11f              CBZ      r7,|L1.454|
;;;252        {
;;;253          status = ERROR;
0001be  f04f0000          MOV      r0,#0
0001c2  9001              STR      r0,[sp,#4]
0001c4  e03f              B        |L1.582|
                  |L1.454|
;;;254        }
;;;255        else
;;;256        {  
;;;257          /* Configure the number of valid bits in last word of the Key */
;;;258          HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
0001c6  9802              LDR      r0,[sp,#8]
0001c8  f7fffffe          BL       HASH_SetLastWordValidBitsNbr
;;;259    
;;;260          /* Write the Key */
;;;261          keyaddr = (uint32_t)Key;
0001cc  46d1              MOV      r9,r10
;;;262          for(i=0; i<Keylen; i+=4)
0001ce  f04f0500          MOV      r5,#0
0001d2  e007              B        |L1.484|
                  |L1.468|
;;;263          {
;;;264            HASH_DataIn(*(uint32_t*)keyaddr);
0001d4  f8d90000          LDR      r0,[r9,#0]
0001d8  f7fffffe          BL       HASH_DataIn
;;;265            keyaddr+=4;
0001dc  f1090904          ADD      r9,r9,#4
0001e0  f1050504          ADD      r5,r5,#4              ;262
                  |L1.484|
0001e4  4545              CMP      r5,r8                 ;262
0001e6  d3f5              BCC      |L1.468|
;;;266          }
;;;267    
;;;268          /* Start the HASH processor */
;;;269          HASH_StartDigest();
0001e8  f7fffffe          BL       HASH_StartDigest
;;;270    
;;;271          /* wait until the Busy flag is RESET */
;;;272          counter =0;
0001ec  f04f0600          MOV      r6,#0
;;;273          do
0001f0  bf00              NOP      
                  |L1.498|
;;;274          {
;;;275            busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
0001f2  2008              MOVS     r0,#8
0001f4  f7fffffe          BL       HASH_GetFlagStatus
0001f8  4607              MOV      r7,r0
;;;276            counter++;
0001fa  f1060601          ADD      r6,r6,#1
;;;277          }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
0001fe  f5b63f80          CMP      r6,#0x10000
000202  d001              BEQ      |L1.520|
000204  2f00              CMP      r7,#0
000206  d1f4              BNE      |L1.498|
                  |L1.520|
;;;278    
;;;279          if (busystatus != RESET)
000208  b11f              CBZ      r7,|L1.530|
;;;280          {
;;;281            status = ERROR;
00020a  f04f0000          MOV      r0,#0
00020e  9001              STR      r0,[sp,#4]
000210  e019              B        |L1.582|
                  |L1.530|
;;;282          }
;;;283          else
;;;284          {
;;;285            /* Read the message digest */
;;;286            HASH_GetDigest(&SHA1_MessageDigest);
000212  a804              ADD      r0,sp,#0x10
000214  f7fffffe          BL       HASH_GetDigest
;;;287            *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[0]);
000218  9804              LDR      r0,[sp,#0x10]
00021a  ba00              REV      r0,r0
00021c  6020              STR      r0,[r4,#0]
;;;288            outputaddr+=4;
00021e  f1040404          ADD      r4,r4,#4
;;;289            *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[1]);
000222  9805              LDR      r0,[sp,#0x14]
000224  ba00              REV      r0,r0
000226  6020              STR      r0,[r4,#0]
;;;290            outputaddr+=4;
000228  f1040404          ADD      r4,r4,#4
;;;291            *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[2]);
00022c  9806              LDR      r0,[sp,#0x18]
00022e  ba00              REV      r0,r0
000230  6020              STR      r0,[r4,#0]
;;;292            outputaddr+=4;
000232  f1040404          ADD      r4,r4,#4
;;;293            *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[3]);
000236  9807              LDR      r0,[sp,#0x1c]
000238  ba00              REV      r0,r0
00023a  6020              STR      r0,[r4,#0]
;;;294            outputaddr+=4;
00023c  f1040404          ADD      r4,r4,#4
;;;295            *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[4]);
000240  9808              LDR      r0,[sp,#0x20]
000242  ba00              REV      r0,r0
000244  6020              STR      r0,[r4,#0]
                  |L1.582|
;;;296          }
;;;297        }  
;;;298      }
;;;299      return status;  
000246  9801              LDR      r0,[sp,#4]
;;;300    }
000248  b011              ADD      sp,sp,#0x44
00024a  e8bd8ff0          POP      {r4-r11,pc}
;;;301    /**
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\BSP\\STM32F2xx\\src\\stm32f2xx_hash_sha1.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___21_stm32f2xx_hash_sha1_c_328c56b9____REV16|
#line 112 "..\\BSP\\CMSIS\\core_cmInstr.h"
|__asm___21_stm32f2xx_hash_sha1_c_328c56b9____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___21_stm32f2xx_hash_sha1_c_328c56b9____REVSH|
#line 130
|__asm___21_stm32f2xx_hash_sha1_c_328c56b9____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
