; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Output\os_time.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\Output\os_time.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\BSP -I..\BSP\UCOS-II -I..\BSP\STM32F2xx\inc -I..\BSP\CMSIS -I..\BSP\CMSIS\Device_Support -I..\BSP\UCOS-II -I..\..\uC-CPU -I..\..\uC-CPU\ARM-Cortex-M3 -I..\..\uC-LIB -I..\..\uC-LIB\Ports\ARM-Cortex-M3 -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3 -I..\App -I..\Prj -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DDEBUG -DLJB_CPU_MAIN -DUSE_CPU_F205RC --omf_browse=.\Output\os_time.crf ..\..\uCOS-II\Source\os_time.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  OSTimeDly PROC
;;;45     
;;;46     void  OSTimeDly (INT32U ticks)
000000  b570              PUSH     {r4-r6,lr}
;;;47     {
000002  4605              MOV      r5,r0
;;;48         INT8U      y;
;;;49     #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;50         OS_CPU_SR  cpu_sr = 0u;
000004  f04f0600          MOV      r6,#0
;;;51     #endif
;;;52     
;;;53     
;;;54     
;;;55         if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
000008  486c              LDR      r0,|L1.444|
00000a  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000c  b100              CBZ      r0,|L1.16|
                  |L1.14|
;;;56             return;
;;;57         }
;;;58         if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
;;;59             return;
;;;60         }
;;;61         if (ticks > 0u) {                            /* 0 means no delay!                                  */
;;;62             OS_ENTER_CRITICAL();
;;;63             y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
;;;64             OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
;;;65             if (OSRdyTbl[y] == 0u) {
;;;66                 OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
;;;67             }
;;;68             OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
;;;69             OS_EXIT_CRITICAL();
;;;70             OS_Sched();                              /* Find next task to run!                             */
;;;71         }
;;;72     }
00000e  bd70              POP      {r4-r6,pc}
                  |L1.16|
000010  486b              LDR      r0,|L1.448|
000012  7800              LDRB     r0,[r0,#0]            ;58  ; OSLockNesting
000014  b100              CBZ      r0,|L1.24|
000016  e7fa              B        |L1.14|
                  |L1.24|
000018  b35d              CBZ      r5,|L1.114|
00001a  f7fffffe          BL       OS_CPU_SR_Save
00001e  4606              MOV      r6,r0                 ;62
000020  4868              LDR      r0,|L1.452|
000022  6800              LDR      r0,[r0,#0]            ;63  ; OSTCBCur
000024  f8904038          LDRB     r4,[r0,#0x38]         ;63
000028  4867              LDR      r0,|L1.456|
00002a  5d00              LDRB     r0,[r0,r4]            ;64
00002c  4965              LDR      r1,|L1.452|
00002e  6809              LDR      r1,[r1,#0]            ;64  ; OSTCBCur
000030  f8911039          LDRB     r1,[r1,#0x39]         ;64
000034  ea6f0101          MVN      r1,r1                 ;64
000038  b2c9              UXTB     r1,r1                 ;64
00003a  ea000001          AND      r0,r0,r1              ;64
00003e  4962              LDR      r1,|L1.456|
000040  5508              STRB     r0,[r1,r4]            ;64
000042  4608              MOV      r0,r1                 ;65
000044  5d00              LDRB     r0,[r0,r4]            ;65
000046  b960              CBNZ     r0,|L1.98|
000048  485e              LDR      r0,|L1.452|
00004a  6800              LDR      r0,[r0,#0]            ;66  ; OSTCBCur
00004c  f890003a          LDRB     r0,[r0,#0x3a]         ;66
000050  ea6f0000          MVN      r0,r0                 ;66
000054  b2c0              UXTB     r0,r0                 ;66
000056  495d              LDR      r1,|L1.460|
000058  7809              LDRB     r1,[r1,#0]            ;66  ; OSRdyGrp
00005a  ea000001          AND      r0,r0,r1              ;66
00005e  495b              LDR      r1,|L1.460|
000060  7008              STRB     r0,[r1,#0]            ;66
                  |L1.98|
000062  4858              LDR      r0,|L1.452|
000064  6800              LDR      r0,[r0,#0]            ;68  ; OSTCBCur
000066  6305              STR      r5,[r0,#0x30]         ;68
000068  4630              MOV      r0,r6                 ;69
00006a  f7fffffe          BL       OS_CPU_SR_Restore
00006e  f7fffffe          BL       OS_Sched
                  |L1.114|
000072  bf00              NOP      
000074  e7cb              B        |L1.14|
;;;73     /*$PAGE*/
                          ENDP

                  OSTimeDlyHMSM PROC
;;;100    #if OS_TIME_DLY_HMSM_EN > 0u
;;;101    INT8U  OSTimeDlyHMSM (INT8U   hours,
000076  e92d41f0          PUSH     {r4-r8,lr}
;;;102                          INT8U   minutes,
;;;103                          INT8U   seconds,
;;;104                          INT16U  ms)
;;;105    {
00007a  4605              MOV      r5,r0
00007c  460e              MOV      r6,r1
00007e  4617              MOV      r7,r2
000080  461c              MOV      r4,r3
;;;106        INT32U ticks;
;;;107    
;;;108    
;;;109        if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
000082  484e              LDR      r0,|L1.444|
000084  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000086  b110              CBZ      r0,|L1.142|
;;;110            return (OS_ERR_TIME_DLY_ISR);
000088  2055              MOVS     r0,#0x55
                  |L1.138|
;;;111        }
;;;112        if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
;;;113            return (OS_ERR_SCHED_LOCKED);
;;;114        }
;;;115    #if OS_ARG_CHK_EN > 0u
;;;116        if (hours == 0u) {
;;;117            if (minutes == 0u) {
;;;118                if (seconds == 0u) {
;;;119                    if (ms == 0u) {
;;;120                        return (OS_ERR_TIME_ZERO_DLY);
;;;121                    }
;;;122                }
;;;123            }
;;;124        }
;;;125        if (minutes > 59u) {
;;;126            return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
;;;127        }
;;;128        if (seconds > 59u) {
;;;129            return (OS_ERR_TIME_INVALID_SECONDS);
;;;130        }
;;;131        if (ms > 999u) {
;;;132            return (OS_ERR_TIME_INVALID_MS);
;;;133        }
;;;134    #endif
;;;135                                                     /* Compute the total number of clock ticks required.. */
;;;136                                                     /* .. (rounded to the nearest tick)                   */
;;;137        ticks = ((INT32U)hours * 3600uL + (INT32U)minutes * 60uL + (INT32U)seconds) * OS_TICKS_PER_SEC
;;;138              + OS_TICKS_PER_SEC * ((INT32U)ms + 500uL / OS_TICKS_PER_SEC) / 1000uL;
;;;139        OSTimeDly(ticks);
;;;140        return (OS_ERR_NONE);
;;;141    }
00008a  e8bd81f0          POP      {r4-r8,pc}
                  |L1.142|
00008e  484c              LDR      r0,|L1.448|
000090  7800              LDRB     r0,[r0,#0]            ;112  ; OSLockNesting
000092  b108              CBZ      r0,|L1.152|
000094  2032              MOVS     r0,#0x32              ;113
000096  e7f8              B        |L1.138|
                  |L1.152|
000098  f44f707a          MOV      r0,#0x3e8             ;137
00009c  fb04f000          MUL      r0,r4,r0              ;137
0000a0  f44f717a          MOV      r1,#0x3e8             ;137
0000a4  fbb0f1f1          UDIV     r1,r0,r1              ;137
0000a8  f44f6061          MOV      r0,#0xe10             ;137
0000ac  fb05f000          MUL      r0,r5,r0              ;137
0000b0  ebc61206          RSB      r2,r6,r6,LSL #4       ;137
0000b4  eb000082          ADD      r0,r0,r2,LSL #2       ;137
0000b8  4438              ADD      r0,r0,r7              ;137
0000ba  eb000240          ADD      r2,r0,r0,LSL #1       ;137
0000be  ebc210c0          RSB      r0,r2,r0,LSL #7       ;137
0000c2  eb0108c0          ADD      r8,r1,r0,LSL #3       ;137
0000c6  4640              MOV      r0,r8                 ;139
0000c8  f7fffffe          BL       OSTimeDly
0000cc  2000              MOVS     r0,#0                 ;140
0000ce  e7dc              B        |L1.138|
;;;142    #endif
                          ENDP

                  OSTimeDlyResume PROC
;;;163    #if OS_TIME_DLY_RESUME_EN > 0u
;;;164    INT8U  OSTimeDlyResume (INT8U prio)
0000d0  b570              PUSH     {r4-r6,lr}
;;;165    {
0000d2  4605              MOV      r5,r0
;;;166        OS_TCB    *ptcb;
;;;167    #if OS_CRITICAL_METHOD == 3u                                   /* Storage for CPU status register      */
;;;168        OS_CPU_SR  cpu_sr = 0u;
0000d4  f04f0600          MOV      r6,#0
;;;169    #endif
;;;170    
;;;171    
;;;172    
;;;173        if (prio >= OS_LOWEST_PRIO) {
0000d8  2d3f              CMP      r5,#0x3f
0000da  d301              BCC      |L1.224|
;;;174            return (OS_ERR_PRIO_INVALID);
0000dc  202a              MOVS     r0,#0x2a
                  |L1.222|
;;;175        }
;;;176        OS_ENTER_CRITICAL();
;;;177        ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
;;;178        if (ptcb == (OS_TCB *)0) {
;;;179            OS_EXIT_CRITICAL();
;;;180            return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
;;;181        }
;;;182        if (ptcb == OS_TCB_RESERVED) {
;;;183            OS_EXIT_CRITICAL();
;;;184            return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
;;;185        }
;;;186        if (ptcb->OSTCBDly == 0u) {                                /* See if task is delayed               */
;;;187            OS_EXIT_CRITICAL();
;;;188            return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
;;;189        }
;;;190    
;;;191        ptcb->OSTCBDly = 0u;                                       /* Clear the time delay                 */
;;;192        if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
;;;193            ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
;;;194            ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
;;;195        } else {
;;;196            ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
;;;197        }
;;;198        if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
;;;199            OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
;;;200            OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
;;;201            OS_EXIT_CRITICAL();
;;;202            OS_Sched();                                            /* See if this is new highest priority  */
;;;203        } else {
;;;204            OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
;;;205        }
;;;206        return (OS_ERR_NONE);
;;;207    }
0000de  bd70              POP      {r4-r6,pc}
                  |L1.224|
0000e0  f7fffffe          BL       OS_CPU_SR_Save
0000e4  4606              MOV      r6,r0                 ;176
0000e6  483a              LDR      r0,|L1.464|
0000e8  f8504025          LDR      r4,[r0,r5,LSL #2]     ;177
0000ec  b924              CBNZ     r4,|L1.248|
0000ee  4630              MOV      r0,r6                 ;179
0000f0  f7fffffe          BL       OS_CPU_SR_Restore
0000f4  2043              MOVS     r0,#0x43              ;180
0000f6  e7f2              B        |L1.222|
                  |L1.248|
0000f8  2c01              CMP      r4,#1                 ;182
0000fa  d104              BNE      |L1.262|
0000fc  4630              MOV      r0,r6                 ;183
0000fe  f7fffffe          BL       OS_CPU_SR_Restore
000102  2043              MOVS     r0,#0x43              ;184
000104  e7eb              B        |L1.222|
                  |L1.262|
000106  6b20              LDR      r0,[r4,#0x30]         ;186
000108  b920              CBNZ     r0,|L1.276|
00010a  4630              MOV      r0,r6                 ;187
00010c  f7fffffe          BL       OS_CPU_SR_Restore
000110  2050              MOVS     r0,#0x50              ;188
000112  e7e4              B        |L1.222|
                  |L1.276|
000114  f04f0000          MOV      r0,#0                 ;191
000118  6320              STR      r0,[r4,#0x30]         ;191
00011a  f8940034          LDRB     r0,[r4,#0x34]         ;192
00011e  f0100f37          TST      r0,#0x37              ;192
000122  d00a              BEQ      |L1.314|
000124  f8140f34          LDRB     r0,[r4,#0x34]!        ;193
000128  f0200037          BIC      r0,r0,#0x37           ;193
00012c  7020              STRB     r0,[r4,#0]            ;193
00012e  f04f0001          MOV      r0,#1                 ;194
000132  7060              STRB     r0,[r4,#1]            ;194
000134  f1a40434          SUB      r4,r4,#0x34           ;194
000138  e003              B        |L1.322|
                  |L1.314|
00013a  f04f0000          MOV      r0,#0                 ;196
00013e  f8840035          STRB     r0,[r4,#0x35]         ;196
                  |L1.322|
000142  f8940034          LDRB     r0,[r4,#0x34]         ;198
000146  f0100f08          TST      r0,#8                 ;198
00014a  d118              BNE      |L1.382|
00014c  f1040438          ADD      r4,r4,#0x38           ;199
000150  78a0              LDRB     r0,[r4,#2]            ;199
000152  491e              LDR      r1,|L1.460|
000154  7809              LDRB     r1,[r1,#0]            ;199  ; OSRdyGrp
000156  ea400001          ORR      r0,r0,r1              ;199
00015a  491c              LDR      r1,|L1.460|
00015c  7008              STRB     r0,[r1,#0]            ;199
00015e  7820              LDRB     r0,[r4,#0]            ;200
000160  4919              LDR      r1,|L1.456|
000162  5c08              LDRB     r0,[r1,r0]            ;200
000164  7861              LDRB     r1,[r4,#1]            ;200
000166  ea400001          ORR      r0,r0,r1              ;200
00016a  f8141938          LDRB     r1,[r4],#-0x38        ;200
00016e  4a16              LDR      r2,|L1.456|
000170  5450              STRB     r0,[r2,r1]            ;200
000172  4630              MOV      r0,r6                 ;201
000174  f7fffffe          BL       OS_CPU_SR_Restore
000178  f7fffffe          BL       OS_Sched
00017c  e002              B        |L1.388|
                  |L1.382|
00017e  4630              MOV      r0,r6                 ;204
000180  f7fffffe          BL       OS_CPU_SR_Restore
                  |L1.388|
000184  2000              MOVS     r0,#0                 ;206
000186  e7aa              B        |L1.222|
;;;208    #endif
                          ENDP

                  OSTimeGet PROC
;;;223    #if OS_TIME_GET_SET_EN > 0u
;;;224    INT32U  OSTimeGet (void)
000188  b570              PUSH     {r4-r6,lr}
;;;225    {
;;;226        INT32U     ticks;
;;;227    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;228        OS_CPU_SR  cpu_sr = 0u;
00018a  f04f0500          MOV      r5,#0
;;;229    #endif
;;;230    
;;;231    
;;;232    
;;;233        OS_ENTER_CRITICAL();
00018e  f7fffffe          BL       OS_CPU_SR_Save
000192  4605              MOV      r5,r0
;;;234        ticks = OSTime;
000194  480f              LDR      r0,|L1.468|
000196  6804              LDR      r4,[r0,#0]  ; OSTime
;;;235        OS_EXIT_CRITICAL();
000198  4628              MOV      r0,r5
00019a  f7fffffe          BL       OS_CPU_SR_Restore
;;;236        return (ticks);
00019e  4620              MOV      r0,r4
;;;237    }
0001a0  bd70              POP      {r4-r6,pc}
;;;238    #endif
                          ENDP

                  OSTimeSet PROC
;;;252    #if OS_TIME_GET_SET_EN > 0u
;;;253    void  OSTimeSet (INT32U ticks)
0001a2  b570              PUSH     {r4-r6,lr}
;;;254    {
0001a4  4604              MOV      r4,r0
;;;255    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;256        OS_CPU_SR  cpu_sr = 0u;
0001a6  f04f0500          MOV      r5,#0
;;;257    #endif
;;;258    
;;;259    
;;;260    
;;;261        OS_ENTER_CRITICAL();
0001aa  f7fffffe          BL       OS_CPU_SR_Save
0001ae  4605              MOV      r5,r0
;;;262        OSTime = ticks;
0001b0  4808              LDR      r0,|L1.468|
0001b2  6004              STR      r4,[r0,#0]  ; OSTime
;;;263        OS_EXIT_CRITICAL();
0001b4  4628              MOV      r0,r5
0001b6  f7fffffe          BL       OS_CPU_SR_Restore
;;;264    }
0001ba  bd70              POP      {r4-r6,pc}
;;;265    #endif
                          ENDP

                  |L1.444|
                          DCD      OSIntNesting
                  |L1.448|
                          DCD      OSLockNesting
                  |L1.452|
                          DCD      OSTCBCur
                  |L1.456|
                          DCD      OSRdyTbl
                  |L1.460|
                          DCD      OSRdyGrp
                  |L1.464|
                          DCD      OSTCBPrioTbl
                  |L1.468|
                          DCD      OSTime
