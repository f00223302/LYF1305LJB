; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Output\bsp_ser.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\Output\bsp_ser.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\BSP -I..\BSP\UCOS-II -I..\BSP\STM32F2xx\inc -I..\BSP\CMSIS -I..\BSP\CMSIS\Device_Support -I..\BSP\UCOS-II -I..\..\uC-CPU -I..\..\uC-CPU\ARM-Cortex-M3 -I..\..\uC-LIB -I..\..\uC-LIB\Ports\ARM-Cortex-M3 -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3 -I..\App -I..\Prj -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DDEBUG -DLJB_CPU_MAIN -DUSE_CPU_F205RC --omf_browse=.\Output\bsp_ser.crf ..\BSP\bsp_ser.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  BSP_Ser_ISR_Handler PROC
;;;199    
;;;200    void  BSP_Ser_ISR_Handler (void)
000000  b510              PUSH     {r4,lr}
;;;201    {
;;;202        CPU_REG32  status;
;;;203    
;;;204    
;;;205        status = USART3->SR;
000002  48b4              LDR      r0,|L1.724|
000004  8804              LDRH     r4,[r0,#0]
;;;206    
;;;207        if (DEF_BIT_IS_SET(status, DEF_BIT_05)) {
000006  f3c41040          UBFX     r0,r4,#5,#1
00000a  b160              CBZ      r0,|L1.38|
;;;208            BSP_SerRxData = USART_ReceiveData(USART3) & 0xFF;       /* Read one byte from the receive data register.      */
00000c  48b1              LDR      r0,|L1.724|
00000e  f7fffffe          BL       USART_ReceiveData
000012  49b1              LDR      r1,|L1.728|
000014  7008              STRB     r0,[r1,#0]
;;;209            USART_ClearITPendingBit(USART3, USART_IT_RXNE);         /* Clear the USART3 receive interrupt.                */
000016  f2405125          MOV      r1,#0x525
00001a  48ae              LDR      r0,|L1.724|
00001c  f7fffffe          BL       USART_ClearITPendingBit
;;;210            BSP_OS_SemPost(&BSP_SerRxWait);                         /* Post to the sempahore                              */
000020  48ae              LDR      r0,|L1.732|
000022  f7fffffe          BL       BSP_OS_SemPost
                  |L1.38|
;;;211        }
;;;212    
;;;213        if (DEF_BIT_IS_SET(status, DEF_BIT_07)) {
000026  f3c410c0          UBFX     r0,r4,#7,#1
00002a  b168              CBZ      r0,|L1.72|
;;;214            USART_ITConfig(USART3, USART_IT_TXE, DISABLE);
00002c  2200              MOVS     r2,#0
00002e  f2407127          MOV      r1,#0x727
000032  48a8              LDR      r0,|L1.724|
000034  f7fffffe          BL       USART_ITConfig
;;;215            USART_ClearITPendingBit(USART3, USART_IT_TXE);          /* Clear the USART3 receive interrupt.                */
000038  f2407127          MOV      r1,#0x727
00003c  48a5              LDR      r0,|L1.724|
00003e  f7fffffe          BL       USART_ClearITPendingBit
;;;216            BSP_OS_SemPost(&BSP_SerTxWait);                         /* Post to the semaphore                              */
000042  48a7              LDR      r0,|L1.736|
000044  f7fffffe          BL       BSP_OS_SemPost
                  |L1.72|
;;;217        }
;;;218    }
000048  bd10              POP      {r4,pc}
;;;219    
                          ENDP

                  BSP_Ser_Init PROC
;;;127    
;;;128    void  BSP_Ser_Init (CPU_INT32U  baud_rate)
00004a  b510              PUSH     {r4,lr}
;;;129    {
00004c  b088              SUB      sp,sp,#0x20
00004e  4604              MOV      r4,r0
;;;130        GPIO_InitTypeDef        GPIO_InitStructure;
;;;131        USART_InitTypeDef       USART_InitStructure;
;;;132        USART_ClockInitTypeDef  USART_CLK_InitStructure;
;;;133    
;;;134    
;;;135                                                                    /* ------------------ INIT OS OBJECTS ----------------- */
;;;136        BSP_OS_SemCreate(&BSP_SerTxWait,   0, "Serial Tx Wait");
000050  a2a4              ADR      r2,|L1.740|
000052  f04f0100          MOV      r1,#0
000056  48a2              LDR      r0,|L1.736|
000058  f7fffffe          BL       BSP_OS_SemCreate
;;;137        BSP_OS_SemCreate(&BSP_SerRxWait,   0, "Serial Rx Wait");
00005c  a2a5              ADR      r2,|L1.756|
00005e  2100              MOVS     r1,#0
000060  489e              LDR      r0,|L1.732|
000062  f7fffffe          BL       BSP_OS_SemCreate
;;;138        BSP_OS_SemCreate(&BSP_SerLock,     1, "Serial Lock");
000066  a2a7              ADR      r2,|L1.772|
000068  2101              MOVS     r1,#1
00006a  48a9              LDR      r0,|L1.784|
00006c  f7fffffe          BL       BSP_OS_SemCreate
;;;139    
;;;140                                                                    /* ----------------- INIT USART STRUCT ---------------- */
;;;141        USART_InitStructure.USART_BaudRate            = baud_rate;
000070  9402              STR      r4,[sp,#8]
;;;142        USART_InitStructure.USART_WordLength          = USART_WordLength_8b;
000072  f04f0000          MOV      r0,#0
000076  f8ad000c          STRH     r0,[sp,#0xc]
;;;143        USART_InitStructure.USART_StopBits            = USART_StopBits_1;
00007a  f8ad000e          STRH     r0,[sp,#0xe]
;;;144        USART_InitStructure.USART_Parity              = USART_Parity_No ;
00007e  f8ad0010          STRH     r0,[sp,#0x10]
;;;145        USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000082  f8ad0014          STRH     r0,[sp,#0x14]
;;;146        USART_InitStructure.USART_Mode                = USART_Mode_Rx | USART_Mode_Tx;
000086  f04f000c          MOV      r0,#0xc
00008a  f8ad0012          STRH     r0,[sp,#0x12]
;;;147    
;;;148        USART_CLK_InitStructure.USART_Clock           = USART_Clock_Disable;
00008e  f04f0000          MOV      r0,#0
000092  f8ad0000          STRH     r0,[sp,#0]
;;;149        USART_CLK_InitStructure.USART_CPOL            = USART_CPOL_Low;
000096  f8ad0002          STRH     r0,[sp,#2]
;;;150        USART_CLK_InitStructure.USART_CPHA            = USART_CPHA_2Edge;
00009a  f44f7000          MOV      r0,#0x200
00009e  f8ad0004          STRH     r0,[sp,#4]
;;;151        USART_CLK_InitStructure.USART_LastBit         = USART_LastBit_Disable;
0000a2  f04f0000          MOV      r0,#0
0000a6  f8ad0006          STRH     r0,[sp,#6]
;;;152    
;;;153    
;;;154        RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);       /* Enable GPIO clock.                                   */
0000aa  f04f0101          MOV      r1,#1
0000ae  f04f0004          MOV      r0,#4
0000b2  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;155        RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);      /* Enable UART clock.                                   */
0000b6  2101              MOVS     r1,#1
0000b8  0488              LSLS     r0,r1,#18
0000ba  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;156    
;;;157    
;;;158                                                                    /* ----------------- SETUP USART3 GPIO ---------------- */
;;;159                                                                    /* Configure GPIOC.5 as push-pull.                      */
;;;160        GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_10;
0000be  f44f6080          MOV      r0,#0x400
0000c2  9006              STR      r0,[sp,#0x18]
;;;161        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000c4  f04f0002          MOV      r0,#2
0000c8  f88d001d          STRB     r0,[sp,#0x1d]
;;;162        GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
0000cc  f88d001c          STRB     r0,[sp,#0x1c]
;;;163        GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
0000d0  f04f0000          MOV      r0,#0
0000d4  f88d001e          STRB     r0,[sp,#0x1e]
;;;164        GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
0000d8  f04f0001          MOV      r0,#1
0000dc  f88d001f          STRB     r0,[sp,#0x1f]
;;;165        GPIO_Init(GPIOC, &GPIO_InitStructure);
0000e0  a906              ADD      r1,sp,#0x18
0000e2  488c              LDR      r0,|L1.788|
0000e4  f7fffffe          BL       GPIO_Init
;;;166        GPIO_PinAFConfig(GPIOC, GPIO_PinSource10, GPIO_AF_USART3);
0000e8  2207              MOVS     r2,#7
0000ea  210a              MOVS     r1,#0xa
0000ec  4889              LDR      r0,|L1.788|
0000ee  f7fffffe          BL       GPIO_PinAFConfig
;;;167    
;;;168                                                                    /* Configure GPIOD.6 as input floating.                 */
;;;169        GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_11;
0000f2  f44f6000          MOV      r0,#0x800
0000f6  9006              STR      r0,[sp,#0x18]
;;;170        GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
0000f8  f04f0002          MOV      r0,#2
0000fc  f88d001c          STRB     r0,[sp,#0x1c]
;;;171        GPIO_Init(GPIOC, &GPIO_InitStructure);
000100  a906              ADD      r1,sp,#0x18
000102  4884              LDR      r0,|L1.788|
000104  f7fffffe          BL       GPIO_Init
;;;172        GPIO_PinAFConfig(GPIOC, GPIO_PinSource11, GPIO_AF_USART3);
000108  2207              MOVS     r2,#7
00010a  210b              MOVS     r1,#0xb
00010c  4881              LDR      r0,|L1.788|
00010e  f7fffffe          BL       GPIO_PinAFConfig
;;;173    
;;;174                                                                    /* ------------------ SETUP USART3 -------------------- */
;;;175        USART_Init(USART3, &USART_InitStructure);
000112  a902              ADD      r1,sp,#8
000114  486f              LDR      r0,|L1.724|
000116  f7fffffe          BL       USART_Init
;;;176        USART_ClockInit(USART3, &USART_CLK_InitStructure);
00011a  4669              MOV      r1,sp
00011c  486d              LDR      r0,|L1.724|
00011e  f7fffffe          BL       USART_ClockInit
;;;177        USART_Cmd(USART3, ENABLE);
000122  2101              MOVS     r1,#1
000124  486b              LDR      r0,|L1.724|
000126  f7fffffe          BL       USART_Cmd
;;;178    
;;;179        BSP_IntVectSet(BSP_INT_ID_USART3, BSP_Ser_ISR_Handler);
00012a  497b              LDR      r1,|L1.792|
00012c  2027              MOVS     r0,#0x27
00012e  f7fffffe          BL       BSP_IntVectSet
;;;180        BSP_IntEn(BSP_INT_ID_USART3);
000132  2027              MOVS     r0,#0x27
000134  f7fffffe          BL       BSP_IntEn
;;;181    }
000138  b008              ADD      sp,sp,#0x20
00013a  bd10              POP      {r4,pc}
;;;182    
                          ENDP

                  BSP_Ser_WrByteUnlocked PROC
;;;414    
;;;415    void  BSP_Ser_WrByteUnlocked (CPU_INT08U c)
00013c  b510              PUSH     {r4,lr}
;;;416    {
00013e  4604              MOV      r4,r0
;;;417    
;;;418        USART_SendData(USART3, c);
000140  4621              MOV      r1,r4
000142  4864              LDR      r0,|L1.724|
000144  f7fffffe          BL       USART_SendData
;;;419    
;;;420        USART_ITConfig(USART3, USART_IT_TXE, ENABLE);
000148  2201              MOVS     r2,#1
00014a  f2407127          MOV      r1,#0x727
00014e  4861              LDR      r0,|L1.724|
000150  f7fffffe          BL       USART_ITConfig
;;;421        BSP_OS_SemWait(&BSP_SerTxWait, 10);
000154  210a              MOVS     r1,#0xa
000156  4862              LDR      r0,|L1.736|
000158  f7fffffe          BL       BSP_OS_SemWait
;;;422        USART_ITConfig(USART3, USART_IT_TXE, DISABLE);
00015c  2200              MOVS     r2,#0
00015e  f2407127          MOV      r1,#0x727
000162  485c              LDR      r0,|L1.724|
000164  f7fffffe          BL       USART_ITConfig
;;;423    }
000168  bd10              POP      {r4,pc}
;;;424    
                          ENDP

                  BSP_Ser_WrStr PROC
;;;467    
;;;468    void  BSP_Ser_WrStr (CPU_CHAR  *p_str)
00016a  b570              PUSH     {r4-r6,lr}
;;;469    {
00016c  4604              MOV      r4,r0
;;;470        CPU_BOOLEAN  err;
;;;471    
;;;472        err = BSP_OS_SemWait(&BSP_SerLock, 0);                      /* Obtain access to the serial interface              */
00016e  f04f0100          MOV      r1,#0
000172  4867              LDR      r0,|L1.784|
000174  f7fffffe          BL       BSP_OS_SemWait
000178  4605              MOV      r5,r0
;;;473    
;;;474        if (err != DEF_OK ) {
00017a  2d01              CMP      r5,#1
00017c  d000              BEQ      |L1.384|
                  |L1.382|
;;;475            return;
;;;476        }
;;;477    
;;;478        while ((*p_str) != (CPU_CHAR )0) {
;;;479    
;;;480            if (*p_str == ASCII_CHAR_LINE_FEED) {
;;;481                BSP_Ser_WrByteUnlocked(ASCII_CHAR_CARRIAGE_RETURN);
;;;482                BSP_Ser_WrByteUnlocked(ASCII_CHAR_LINE_FEED);
;;;483                p_str++;
;;;484            } else {
;;;485                BSP_Ser_WrByteUnlocked(*p_str++);
;;;486            }
;;;487        }
;;;488    
;;;489        BSP_OS_SemPost(&BSP_SerLock);                               /* Release access to the serial interface             */
;;;490    }
00017e  bd70              POP      {r4-r6,pc}
                  |L1.384|
000180  e00f              B        |L1.418|
                  |L1.386|
000182  7820              LDRB     r0,[r4,#0]            ;480
000184  280a              CMP      r0,#0xa               ;480
000186  d108              BNE      |L1.410|
000188  200d              MOVS     r0,#0xd               ;481
00018a  f7fffffe          BL       BSP_Ser_WrByteUnlocked
00018e  200a              MOVS     r0,#0xa               ;482
000190  f7fffffe          BL       BSP_Ser_WrByteUnlocked
000194  f1040401          ADD      r4,r4,#1              ;483
000198  e003              B        |L1.418|
                  |L1.410|
00019a  f8140b01          LDRB     r0,[r4],#1            ;485
00019e  f7fffffe          BL       BSP_Ser_WrByteUnlocked
                  |L1.418|
0001a2  7820              LDRB     r0,[r4,#0]            ;478
0001a4  2800              CMP      r0,#0                 ;478
0001a6  d1ec              BNE      |L1.386|
0001a8  4859              LDR      r0,|L1.784|
0001aa  f7fffffe          BL       BSP_OS_SemPost
0001ae  bf00              NOP      
0001b0  e7e5              B        |L1.382|
;;;491    
                          ENDP

                  BSP_Ser_Printf PROC
;;;239    
;;;240    void  BSP_Ser_Printf (CPU_CHAR *format, ...)
0001b2  b40f              PUSH     {r0-r3}
;;;241    {
0001b4  b500              PUSH     {lr}
0001b6  b097              SUB      sp,sp,#0x5c
;;;242        CPU_CHAR  buf_str[BSP_SER_PRINTF_STR_BUF_SIZE + 1u];
;;;243        va_list   v_args;
;;;244    
;;;245    
;;;246        va_start(v_args, format);
0001b8  a819              ADD      r0,sp,#0x64
0001ba  9001              STR      r0,[sp,#4]
;;;247       (void)vsnprintf((char       *)&buf_str[0],
0001bc  2151              MOVS     r1,#0x51
0001be  a802              ADD      r0,sp,#8
0001c0  9b01              LDR      r3,[sp,#4]
0001c2  9a18              LDR      r2,[sp,#0x60]
0001c4  f7fffffe          BL       __c89vsnprintf
;;;248                       (CPU_SIZE_T  ) sizeof(buf_str),
;;;249                       (char const *) format,
;;;250                                      v_args);
;;;251        va_end(v_args);
0001c8  f04f0000          MOV      r0,#0
0001cc  9001              STR      r0,[sp,#4]
;;;252    
;;;253        BSP_Ser_WrStr((CPU_CHAR *)&buf_str[0]);
0001ce  a802              ADD      r0,sp,#8
0001d0  f7fffffe          BL       BSP_Ser_WrStr
;;;254    }
0001d4  b017              ADD      sp,sp,#0x5c
0001d6  f85dfb14          LDR      pc,[sp],#0x14
;;;255    
                          ENDP

                  BSP_Ser_RdByteUnlocked PROC
;;;306    
;;;307    CPU_INT08U  BSP_Ser_RdByteUnlocked (void)
0001da  b510              PUSH     {r4,lr}
;;;308    {
;;;309    
;;;310        CPU_INT08U   rx_byte;
;;;311    
;;;312    
;;;313        USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);              /* Enable the Receive not emptyt interrupt            */
0001dc  2201              MOVS     r2,#1
0001de  f2405125          MOV      r1,#0x525
0001e2  483c              LDR      r0,|L1.724|
0001e4  f7fffffe          BL       USART_ITConfig
;;;314    
;;;315        BSP_OS_SemWait(&BSP_SerRxWait, 0);                          /* Wait until a data is received                      */
0001e8  2100              MOVS     r1,#0
0001ea  483c              LDR      r0,|L1.732|
0001ec  f7fffffe          BL       BSP_OS_SemWait
;;;316    
;;;317        USART_ITConfig(USART3, USART_IT_RXNE, DISABLE);             /* Disable the Receive not empty interrupt            */
0001f0  2200              MOVS     r2,#0
0001f2  f2405125          MOV      r1,#0x525
0001f6  4837              LDR      r0,|L1.724|
0001f8  f7fffffe          BL       USART_ITConfig
;;;318    
;;;319        rx_byte = BSP_SerRxData;                                    /* Read the data form the temporal register          */
0001fc  4836              LDR      r0,|L1.728|
0001fe  7804              LDRB     r4,[r0,#0]  ; BSP_SerRxData
;;;320    
;;;321        return (rx_byte);
000200  4620              MOV      r0,r4
;;;322    }
000202  bd10              POP      {r4,pc}
;;;323    
                          ENDP

                  BSP_Ser_RdByte PROC
;;;274    
;;;275    CPU_INT08U  BSP_Ser_RdByte (void)
000204  b510              PUSH     {r4,lr}
;;;276    {
;;;277        CPU_INT08U  rx_byte;
;;;278    
;;;279    
;;;280        BSP_OS_SemWait(&BSP_SerLock, 0);                            /* Obtain access to the serial interface              */
000206  2100              MOVS     r1,#0
000208  4841              LDR      r0,|L1.784|
00020a  f7fffffe          BL       BSP_OS_SemWait
;;;281    
;;;282        rx_byte = BSP_Ser_RdByteUnlocked();
00020e  f7fffffe          BL       BSP_Ser_RdByteUnlocked
000212  4604              MOV      r4,r0
;;;283    
;;;284        BSP_OS_SemPost(&BSP_SerLock);                               /* Release access to the serial interface             */
000214  483e              LDR      r0,|L1.784|
000216  f7fffffe          BL       BSP_OS_SemPost
;;;285    
;;;286        return (rx_byte);
00021a  4620              MOV      r0,r4
;;;287    }
00021c  bd10              POP      {r4,pc}
;;;288    
                          ENDP

                  BSP_Ser_RdStr PROC
;;;341    
;;;342    void  BSP_Ser_RdStr (CPU_CHAR    *p_str,
00021e  e92d41f0          PUSH     {r4-r8,lr}
;;;343                         CPU_INT16U   len)
;;;344    {
000222  4606              MOV      r6,r0
000224  460f              MOV      r7,r1
;;;345        CPU_CHAR     rx_data;
;;;346        CPU_CHAR     rx_buf_ix;
;;;347        CPU_BOOLEAN  err;
;;;348    
;;;349    
;;;350        rx_buf_ix = 0;
000226  f04f0400          MOV      r4,#0
;;;351        p_str[0]  = 0;
00022a  4620              MOV      r0,r4
00022c  7030              STRB     r0,[r6,#0]
;;;352    
;;;353        err = BSP_OS_SemWait(&BSP_SerLock, 0);                      /* Obtain access to the serial interface              */
00022e  4601              MOV      r1,r0
000230  4837              LDR      r0,|L1.784|
000232  f7fffffe          BL       BSP_OS_SemWait
000236  4680              MOV      r8,r0
;;;354    
;;;355        if (err != DEF_OK ) {
000238  f1b80f01          CMP      r8,#1
00023c  d001              BEQ      |L1.578|
                  |L1.574|
;;;356            return;
;;;357        }
;;;358    
;;;359        while (DEF_TRUE)
;;;360        {
;;;361            rx_data = BSP_Ser_RdByteUnlocked();
;;;362    
;;;363            if ((rx_data == ASCII_CHAR_CARRIAGE_RETURN) ||          /* Is it '\r' or '\n' character  ?                    */
;;;364                (rx_data == ASCII_CHAR_LINE_FEED      )) {
;;;365    
;;;366                BSP_Ser_WrByteUnlocked((CPU_INT08U)ASCII_CHAR_LINE_FEED);
;;;367                BSP_Ser_WrByteUnlocked((CPU_INT08U)ASCII_CHAR_CARRIAGE_RETURN);
;;;368    
;;;369                p_str[rx_buf_ix] = 0;                              /* set the null character at the end of the string     */
;;;370                break;                                             /* exit the loop                                       */
;;;371            }
;;;372    
;;;373            if (rx_data == ASCII_CHAR_BACKSPACE) {                 /* Is backspace character                              */
;;;374                if (rx_buf_ix > 0) {
;;;375                    BSP_Ser_WrByteUnlocked((CPU_INT08U)ASCII_CHAR_BACKSPACE);
;;;376                    BSP_Ser_WrByteUnlocked((CPU_INT08U)ASCII_CHAR_SPACE);
;;;377                    BSP_Ser_WrByteUnlocked((CPU_INT08U)ASCII_CHAR_BACKSPACE);
;;;378    
;;;379                    rx_buf_ix--;                                   /* Decrement the index                                 */
;;;380                    p_str[rx_buf_ix] = 0;
;;;381                }
;;;382            }
;;;383    
;;;384            if (ASCII_IsPrint(rx_data)) {                           /* Is it a printable character ... ?                  */
;;;385                BSP_Ser_WrByteUnlocked((CPU_INT08U)rx_data);        /* Echo-back                                          */
;;;386                p_str[rx_buf_ix] = rx_data;                         /* Save the received character in the buffer          */
;;;387                rx_buf_ix++;                                        /* Increment the buffer index                         */
;;;388                if (rx_buf_ix >= len) {
;;;389                   rx_buf_ix = len;
;;;390                }
;;;391            }
;;;392        }
;;;393    
;;;394        BSP_OS_SemPost(&BSP_SerLock);                               /* Release access to the serial interface            */
;;;395    }
00023e  e8bd81f0          POP      {r4-r8,pc}
                  |L1.578|
000242  e031              B        |L1.680|
                  |L1.580|
000244  f7fffffe          BL       BSP_Ser_RdByteUnlocked
000248  4605              MOV      r5,r0                 ;361
00024a  2d0d              CMP      r5,#0xd               ;363
00024c  d001              BEQ      |L1.594|
00024e  2d0a              CMP      r5,#0xa               ;364
000250  d109              BNE      |L1.614|
                  |L1.594|
000252  200a              MOVS     r0,#0xa               ;366
000254  f7fffffe          BL       BSP_Ser_WrByteUnlocked
000258  200d              MOVS     r0,#0xd               ;367
00025a  f7fffffe          BL       BSP_Ser_WrByteUnlocked
00025e  f04f0000          MOV      r0,#0                 ;369
000262  5530              STRB     r0,[r6,r4]            ;369
000264  e021              B        |L1.682|
                  |L1.614|
000266  2d08              CMP      r5,#8                 ;373
000268  d110              BNE      |L1.652|
00026a  2c00              CMP      r4,#0                 ;374
00026c  dd0e              BLE      |L1.652|
00026e  2008              MOVS     r0,#8                 ;375
000270  f7fffffe          BL       BSP_Ser_WrByteUnlocked
000274  2020              MOVS     r0,#0x20              ;376
000276  f7fffffe          BL       BSP_Ser_WrByteUnlocked
00027a  2008              MOVS     r0,#8                 ;377
00027c  f7fffffe          BL       BSP_Ser_WrByteUnlocked
000280  f1a40001          SUB      r0,r4,#1              ;379
000284  b2c4              UXTB     r4,r0                 ;379
000286  f04f0000          MOV      r0,#0                 ;380
00028a  5530              STRB     r0,[r6,r4]            ;380
                  |L1.652|
00028c  4628              MOV      r0,r5                 ;384
00028e  f7fffffe          BL       ASCII_IsPrint
000292  b148              CBZ      r0,|L1.680|
000294  4628              MOV      r0,r5                 ;385
000296  f7fffffe          BL       BSP_Ser_WrByteUnlocked
00029a  5535              STRB     r5,[r6,r4]            ;386
00029c  f1040001          ADD      r0,r4,#1              ;387
0002a0  b2c4              UXTB     r4,r0                 ;387
0002a2  42bc              CMP      r4,r7                 ;388
0002a4  db00              BLT      |L1.680|
0002a6  b2fc              UXTB     r4,r7                 ;389
                  |L1.680|
0002a8  e7cc              B        |L1.580|
                  |L1.682|
0002aa  bf00              NOP                            ;370
0002ac  4818              LDR      r0,|L1.784|
0002ae  f7fffffe          BL       BSP_OS_SemPost
0002b2  bf00              NOP      
0002b4  e7c3              B        |L1.574|
;;;396    
                          ENDP

                  BSP_Ser_WrByte PROC
;;;441    
;;;442    void  BSP_Ser_WrByte(CPU_INT08U  c)
0002b6  b510              PUSH     {r4,lr}
;;;443    {
0002b8  4604              MOV      r4,r0
;;;444        BSP_OS_SemWait(&BSP_SerLock, 0);                            /* Obtain access to the serial interface              */
0002ba  f04f0100          MOV      r1,#0
0002be  4814              LDR      r0,|L1.784|
0002c0  f7fffffe          BL       BSP_OS_SemWait
;;;445    
;;;446        BSP_Ser_WrByteUnlocked(c);
0002c4  4620              MOV      r0,r4
0002c6  f7fffffe          BL       BSP_Ser_WrByteUnlocked
;;;447    
;;;448        BSP_OS_SemPost(&BSP_SerLock);                               /* Release access to the serial interface             */
0002ca  4811              LDR      r0,|L1.784|
0002cc  f7fffffe          BL       BSP_OS_SemPost
;;;449    }
0002d0  bd10              POP      {r4,pc}
;;;450    
                          ENDP

0002d2  0000              DCW      0x0000
                  |L1.724|
                          DCD      0x40004800
                  |L1.728|
                          DCD      BSP_SerRxData
                  |L1.732|
                          DCD      BSP_SerRxWait
                  |L1.736|
                          DCD      BSP_SerTxWait
                  |L1.740|
0002e4  53657269          DCB      "Serial Tx Wait",0
0002e8  616c2054
0002ec  78205761
0002f0  697400  
0002f3  00                DCB      0
                  |L1.756|
0002f4  53657269          DCB      "Serial Rx Wait",0
0002f8  616c2052
0002fc  78205761
000300  697400  
000303  00                DCB      0
                  |L1.772|
000304  53657269          DCB      "Serial Lock",0
000308  616c204c
00030c  6f636b00
                  |L1.784|
                          DCD      BSP_SerLock
                  |L1.788|
                          DCD      0x40020800
                  |L1.792|
                          DCD      BSP_Ser_ISR_Handler

                          AREA ||.data||, DATA, ALIGN=2

                  BSP_SerTxWait
                          DCD      0x00000000
                  BSP_SerRxWait
                          DCD      0x00000000
                  BSP_SerLock
                          DCD      0x00000000
                  BSP_SerRxData
00000c  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\BSP\\bsp_ser.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_bsp_ser_c_eba2ab2b____REV16|
#line 112 "..\\BSP\\CMSIS\\core_cmInstr.h"
|__asm___9_bsp_ser_c_eba2ab2b____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_bsp_ser_c_eba2ab2b____REVSH|
#line 130
|__asm___9_bsp_ser_c_eba2ab2b____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
