; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Output\bsp_rtc.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\Output\bsp_rtc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\BSP -I..\BSP\UCOS-II -I..\BSP\STM32F2xx\inc -I..\BSP\CMSIS -I..\BSP\CMSIS\Device_Support -I..\BSP\UCOS-II -I..\..\uC-CPU -I..\..\uC-CPU\ARM-Cortex-M3 -I..\..\uC-LIB -I..\..\uC-LIB\Ports\ARM-Cortex-M3 -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3 -I..\App -I..\Prj -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DDEBUG -DLJB_CPU_MAIN -DUSE_CPU_F205RC --omf_browse=.\Output\bsp_rtc.crf ..\BSP\bsp_rtc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  BSP_RTC_IsrHandler PROC
;;;267    ////RTC Alarm interrupt isr:
;;;268    void BSP_RTC_IsrHandler(void)
000000  b510              PUSH     {r4,lr}
;;;269    {
;;;270    	if(RTC_GetITStatus(RTC_IT_ALRA) != RESET)
000002  f44f5080          MOV      r0,#0x1000
000006  f7fffffe          BL       RTC_GetITStatus
00000a  b1c8              CBZ      r0,|L1.64|
;;;271    	{
;;;272    		/* Get the current Time */
;;;273    		RTC_GetTime(RTC_Format_BIN, &RTC_TimeStructure);
00000c  4979              LDR      r1,|L1.500|
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       RTC_GetTime
;;;274    		/* Get the current Date */
;;;275    		RTC_GetDate(RTC_Format_BIN, &RTC_DateStructure);
000014  4978              LDR      r1,|L1.504|
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       RTC_GetDate
;;;276    		
;;;277    		if (BSP_Info.RTCCalBack)
00001c  4877              LDR      r0,|L1.508|
00001e  f8d00124          LDR      r0,[r0,#0x124]  ; BSP_Info
000022  b128              CBZ      r0,|L1.48|
;;;278    			BSP_Info.RTCCalBack(0, NULL);
000024  4875              LDR      r0,|L1.508|
000026  2100              MOVS     r1,#0
000028  f8d02124          LDR      r2,[r0,#0x124]  ; BSP_Info
00002c  4608              MOV      r0,r1
00002e  4790              BLX      r2
                  |L1.48|
;;;279    		
;;;280    		RTC_ClearITPendingBit(RTC_IT_ALRA);
000030  f44f5080          MOV      r0,#0x1000
000034  f7fffffe          BL       RTC_ClearITPendingBit
;;;281    		EXTI_ClearITPendingBit(EXTI_Line17);
000038  f44f3000          MOV      r0,#0x20000
00003c  f7fffffe          BL       EXTI_ClearITPendingBit
                  |L1.64|
;;;282    	} 
;;;283    }
000040  bd10              POP      {r4,pc}
;;;284    
                          ENDP

                  RTC_TimeRegulate PROC
;;;200      */
;;;201    void RTC_TimeRegulate(void)
000042  b51f              PUSH     {r0-r4,lr}
;;;202    {
;;;203    	RTC_AlarmTypeDef  RTC_AlarmStructure;
;;;204    	
;;;205    	RTC_printf("\r==============Time Settings=====================================\n");
;;;206    	
;;;207    	RTC_TimeStructure.RTC_H12 = RTC_H12_AM;
000044  f04f0000          MOV      r0,#0
000048  496a              LDR      r1,|L1.500|
00004a  70c8              STRB     r0,[r1,#3]
;;;208      
;;;209    	RTC_TimeStructure.RTC_Hours = RTC_DEF_HOUR;
00004c  7008              STRB     r0,[r1,#0]
;;;210        RTC_TimeStructure.RTC_Minutes = RTC_DEF_MINUTE;
00004e  7048              STRB     r0,[r1,#1]
;;;211        RTC_TimeStructure.RTC_Seconds = RTC_DEF_SECOND;
000050  7088              STRB     r0,[r1,#2]
;;;212    	/* Configure the RTC time register */
;;;213    	if(RTC_SetTime(RTC_Format_BCD, &RTC_TimeStructure) == ERROR)
000052  f04f0001          MOV      r0,#1
000056  f7fffffe          BL       RTC_SetTime
;;;214    	{
;;;215    		RTC_printf("\n>> !! RTC Set Time failed. !! <<\n");
;;;216    	} 
;;;217    	else
;;;218    	{
;;;219    		RTC_printf("\n>> !! RTC Set Time success. !! <<\n");
;;;220    	}
;;;221    	
;;;222    	
;;;223    	RTC_printf("\r==============Date Settings=====================================\n");
;;;224    	RTC_DateStructure.RTC_Year = RTC_DEF_YEAR;
00005a  f04f0013          MOV      r0,#0x13
00005e  4966              LDR      r1,|L1.504|
000060  70c8              STRB     r0,[r1,#3]
;;;225    	RTC_DateStructure.RTC_Month = RTC_DEF_MONTH;
000062  f04f0010          MOV      r0,#0x10
000066  7048              STRB     r0,[r1,#1]
;;;226    	RTC_DateStructure.RTC_Date = RTC_DEF_DATE;
000068  7088              STRB     r0,[r1,#2]
;;;227    	RTC_DateStructure.RTC_WeekDay = RTC_DEF_DAY;
00006a  f04f0002          MOV      r0,#2
00006e  7008              STRB     r0,[r1,#0]
;;;228    	/* Configure the RTC time register */
;;;229    	if(RTC_SetDate(RTC_Format_BCD, &RTC_DateStructure) == ERROR)
000070  f04f0001          MOV      r0,#1
000074  f7fffffe          BL       RTC_SetDate
000078  b120              CBZ      r0,|L1.132|
;;;230    	{
;;;231    		RTC_printf("\n>> !! RTC Set Date failed. !! <<\n");
;;;232    	} 
;;;233    	else
;;;234    	{
;;;235    		RTC_printf("\n>> !! RTC Set Time success. !! <<\n");
;;;236    		/* Indicator for the RTC configuration */
;;;237    		RTC_WriteBackupRegister(RTC_BKP_DR0, 0x32F2);
00007a  f24321f2          MOV      r1,#0x32f2
00007e  2000              MOVS     r0,#0
000080  f7fffffe          BL       RTC_WriteBackupRegister
                  |L1.132|
;;;238    	}
;;;239    
;;;240    	
;;;241    	/* Disable the Alarm A */
;;;242    	RTC_AlarmCmd(RTC_Alarm_A, DISABLE);
000084  2100              MOVS     r1,#0
000086  f44f7080          MOV      r0,#0x100
00008a  f7fffffe          BL       RTC_AlarmCmd
;;;243    
;;;244    	RTC_printf("\r==============Alarm A Settings=====================================\n");
;;;245    	RTC_AlarmStructure.RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
00008e  f04f0000          MOV      r0,#0
000092  f88d0003          STRB     r0,[sp,#3]
;;;246    	
;;;247        RTC_AlarmStructure.RTC_AlarmTime.RTC_Hours = 0x00;
000096  f88d0000          STRB     r0,[sp,#0]
;;;248        RTC_AlarmStructure.RTC_AlarmTime.RTC_Minutes = 0x00;
00009a  f88d0001          STRB     r0,[sp,#1]
;;;249        RTC_AlarmStructure.RTC_AlarmTime.RTC_Seconds = 0x00;
00009e  f88d0002          STRB     r0,[sp,#2]
;;;250    	
;;;251    	/* Set the Alarm A */
;;;252    	RTC_AlarmStructure.RTC_AlarmDateWeekDay = 0x31;
0000a2  f04f0031          MOV      r0,#0x31
0000a6  f88d000c          STRB     r0,[sp,#0xc]
;;;253    	RTC_AlarmStructure.RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
0000aa  f04f0000          MOV      r0,#0
0000ae  9002              STR      r0,[sp,#8]
;;;254    	RTC_AlarmStructure.RTC_AlarmMask = RTC_AlarmMask_All;
0000b0  f04f3080          MOV      r0,#0x80808080
0000b4  9001              STR      r0,[sp,#4]
;;;255    
;;;256    	/* Configure the RTC Alarm A register */
;;;257    	RTC_SetAlarm(RTC_Format_BCD, RTC_Alarm_A, &RTC_AlarmStructure);
0000b6  466a              MOV      r2,sp
0000b8  f44f7180          MOV      r1,#0x100
0000bc  f04f0001          MOV      r0,#1
0000c0  f7fffffe          BL       RTC_SetAlarm
;;;258    
;;;259    	/* Enable the RTC Alarm A Interrupt */
;;;260    	RTC_ITConfig(RTC_IT_ALRA, ENABLE);
0000c4  2101              MOVS     r1,#1
0000c6  0308              LSLS     r0,r1,#12
0000c8  f7fffffe          BL       RTC_ITConfig
;;;261       
;;;262    	/* Enable the alarm  A */
;;;263    	RTC_AlarmCmd(RTC_Alarm_A, ENABLE);
0000cc  2101              MOVS     r1,#1
0000ce  0208              LSLS     r0,r1,#8
0000d0  f7fffffe          BL       RTC_AlarmCmd
;;;264    }
0000d4  bd1f              POP      {r0-r4,pc}
;;;265    
                          ENDP

                  RTC_Config PROC
;;;164      */
;;;165    void RTC_Config(void)
0000d6  b510              PUSH     {r4,lr}
;;;166    {
;;;167    	/* Enable the PWR clock */
;;;168    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
0000d8  2101              MOVS     r1,#1
0000da  0708              LSLS     r0,r1,#28
0000dc  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;169    
;;;170    	/* Allow access to RTC */
;;;171    	PWR_BackupAccessCmd(ENABLE);
0000e0  2001              MOVS     r0,#1
0000e2  f7fffffe          BL       PWR_BackupAccessCmd
;;;172       
;;;173    	///LSE used as RTC source clock
;;;174    	/* Enable the LSE OSC */
;;;175    	RCC_LSEConfig(RCC_LSE_ON);
0000e6  2001              MOVS     r0,#1
0000e8  f7fffffe          BL       RCC_LSEConfig
;;;176    
;;;177    	/* Wait till LSE is ready */  
;;;178    	while(RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET)
0000ec  bf00              NOP      
                  |L1.238|
0000ee  2041              MOVS     r0,#0x41
0000f0  f7fffffe          BL       RCC_GetFlagStatus
0000f4  2800              CMP      r0,#0
0000f6  d0fa              BEQ      |L1.238|
;;;179    	{
;;;180    	}
;;;181    
;;;182    	/* Select the RTC Clock Source */
;;;183    	RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
0000f8  f44f7080          MOV      r0,#0x100
0000fc  f7fffffe          BL       RCC_RTCCLKConfig
;;;184      
;;;185    	SynchPrediv = 0xFF;
000100  f04f00ff          MOV      r0,#0xff
000104  493e              LDR      r1,|L1.512|
000106  6008              STR      r0,[r1,#0]  ; SynchPrediv
;;;186    	AsynchPrediv = 0x7F;
000108  f04f007f          MOV      r0,#0x7f
00010c  493d              LDR      r1,|L1.516|
00010e  6008              STR      r0,[r1,#0]  ; AsynchPrediv
;;;187    
;;;188      
;;;189    	/* Enable the RTC Clock */
;;;190    	RCC_RTCCLKCmd(ENABLE);
000110  f04f0001          MOV      r0,#1
000114  f7fffffe          BL       RCC_RTCCLKCmd
;;;191    
;;;192    	/* Wait for RTC APB registers synchronisation */
;;;193    	RTC_WaitForSynchro();
000118  f7fffffe          BL       RTC_WaitForSynchro
;;;194    }
00011c  bd10              POP      {r4,pc}
;;;195    
                          ENDP

                  BSP_InitRTC PROC
;;;64     /////////////////////////////////////////////////////////////////////////////
;;;65     void BSP_InitRTC(void)
00011e  b500              PUSH     {lr}
;;;66     {
000120  b085              SUB      sp,sp,#0x14
;;;67     	RTC_InitTypeDef RTC_InitStructure;
;;;68     	EXTI_InitTypeDef  EXTI_InitStructure;
;;;69     	
;;;70     	if (RTC_ReadBackupRegister(RTC_BKP_DR0) != 0x32F2){ 
000122  2000              MOVS     r0,#0
000124  f7fffffe          BL       RTC_ReadBackupRegister
000128  f5a05148          SUB      r1,r0,#0x3200
00012c  39f2              SUBS     r1,r1,#0xf2
00012e  d010              BEQ      |L1.338|
;;;71     		
;;;72     		/* RTC configuration  */
;;;73     		RTC_Config();
000130  f7fffffe          BL       RTC_Config
;;;74     
;;;75     		/* Configure the RTC data register and RTC prescaler */
;;;76     		RTC_InitStructure.RTC_AsynchPrediv = AsynchPrediv;
000134  4833              LDR      r0,|L1.516|
000136  6800              LDR      r0,[r0,#0]  ; AsynchPrediv
000138  9003              STR      r0,[sp,#0xc]
;;;77     		RTC_InitStructure.RTC_SynchPrediv = SynchPrediv;
00013a  4831              LDR      r0,|L1.512|
00013c  6800              LDR      r0,[r0,#0]  ; SynchPrediv
00013e  9004              STR      r0,[sp,#0x10]
;;;78     		RTC_InitStructure.RTC_HourFormat = RTC_HourFormat_24;
000140  f04f0000          MOV      r0,#0
000144  9002              STR      r0,[sp,#8]
;;;79        
;;;80     		/* Check on RTC init */
;;;81     		if (RTC_Init(&RTC_InitStructure) == ERROR)
000146  a802              ADD      r0,sp,#8
000148  f7fffffe          BL       RTC_Init
;;;82     		{
;;;83     			RTC_printf("\n\r        /!\\***** RTC Prescaler Config failed ********/!\\ \n");
;;;84     		}
;;;85     
;;;86     		/* Configure the time register */
;;;87     		RTC_TimeRegulate(); 
00014c  f7fffffe          BL       RTC_TimeRegulate
000150  e017              B        |L1.386|
                  |L1.338|
;;;88     	}
;;;89     	else{
;;;90     		/* Check if the Power On Reset flag is set */
;;;91     		if (RCC_GetFlagStatus(RCC_FLAG_PORRST) != RESET)
000152  207b              MOVS     r0,#0x7b
000154  f7fffffe          BL       RCC_GetFlagStatus
000158  b910              CBNZ     r0,|L1.352|
;;;92     		{
;;;93     			RTC_printf("\r\n Power On Reset occurred....\n");
;;;94     		}
;;;95     		/* Check if the Pin Reset flag is set */
;;;96     		else if (RCC_GetFlagStatus(RCC_FLAG_PINRST) != RESET)
00015a  207a              MOVS     r0,#0x7a
00015c  f7fffffe          BL       RCC_GetFlagStatus
                  |L1.352|
;;;97     		{
;;;98     			RTC_printf("\r\n External Reset occurred....\n");
;;;99     		}
;;;100    
;;;101    		RTC_printf("\r No need to configure RTC....\n");
;;;102        
;;;103    		/* Enable the PWR clock */
;;;104    		RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
000160  2101              MOVS     r1,#1
000162  0708              LSLS     r0,r1,#28
000164  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;105    
;;;106    		/* Allow access to RTC */
;;;107    		PWR_BackupAccessCmd(ENABLE);
000168  2001              MOVS     r0,#1
00016a  f7fffffe          BL       PWR_BackupAccessCmd
;;;108    
;;;109    		/* Wait for RTC APB registers synchronisation */
;;;110    		RTC_WaitForSynchro();
00016e  f7fffffe          BL       RTC_WaitForSynchro
;;;111    
;;;112    		/* Clear the RTC Alarm Flag */
;;;113    		RTC_ClearFlag(RTC_FLAG_ALRAF);
000172  f44f7080          MOV      r0,#0x100
000176  f7fffffe          BL       RTC_ClearFlag
;;;114    
;;;115    		/* Clear the EXTI Line 17 Pending bit (Connected internally to RTC Alarm) */
;;;116    		EXTI_ClearITPendingBit(EXTI_Line17);
00017a  f44f3000          MOV      r0,#0x20000
00017e  f7fffffe          BL       EXTI_ClearITPendingBit
                  |L1.386|
;;;117    	}
;;;118    	
;;;119    	
;;;120    	/* RTC Alarm A Interrupt Configuration */
;;;121    	EXTI_ClearITPendingBit(EXTI_Line17);
000182  f44f3000          MOV      r0,#0x20000
000186  f7fffffe          BL       EXTI_ClearITPendingBit
;;;122    	EXTI_InitStructure.EXTI_Line = EXTI_Line17;
00018a  f44f3000          MOV      r0,#0x20000
00018e  9000              STR      r0,[sp,#0]
;;;123    	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
000190  f04f0000          MOV      r0,#0
000194  f88d0004          STRB     r0,[sp,#4]
;;;124    	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
000198  f04f0008          MOV      r0,#8
00019c  f88d0005          STRB     r0,[sp,#5]
;;;125    	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
0001a0  f04f0001          MOV      r0,#1
0001a4  f88d0006          STRB     r0,[sp,#6]
;;;126    	EXTI_Init(&EXTI_InitStructure);
0001a8  4668              MOV      r0,sp
0001aa  f7fffffe          BL       EXTI_Init
;;;127      	
;;;128    	///允许中断
;;;129    	///中断设置
;;;130    	BSP_IntVectSet(BSP_INT_ID_RTC, BSP_RTC_IsrHandler);
0001ae  f2af11af          ADR      r1,BSP_RTC_IsrHandler + 1
0001b2  2003              MOVS     r0,#3
0001b4  f7fffffe          BL       BSP_IntVectSet
;;;131        BSP_IntEn(BSP_INT_ID_RTC);
0001b8  2003              MOVS     r0,#3
0001ba  f7fffffe          BL       BSP_IntEn
;;;132    
;;;133    }
0001be  b005              ADD      sp,sp,#0x14
0001c0  bd00              POP      {pc}
;;;134    
                          ENDP

                  BSP_SetDateTime PROC
;;;135    
;;;136    void BSP_SetDateTime(RTC_TimeTypeDef *Time, RTC_DateTypeDef *Date)
0001c2  b570              PUSH     {r4-r6,lr}
;;;137    {
0001c4  4604              MOV      r4,r0
0001c6  460d              MOV      r5,r1
;;;138    	ErrorStatus status;
;;;139    	
;;;140    	Time->RTC_H12     = RTC_H12_AM;
0001c8  f04f0000          MOV      r0,#0
0001cc  70e0              STRB     r0,[r4,#3]
;;;141      
;;;142    	/* Disable the Alarm A */
;;;143    	RTC_AlarmCmd(RTC_Alarm_A, DISABLE);
0001ce  4601              MOV      r1,r0
0001d0  f44f7080          MOV      r0,#0x100
0001d4  f7fffffe          BL       RTC_AlarmCmd
;;;144    	
;;;145    	status = RTC_SetDateTime(RTC_Format_BIN, Date, Time);
0001d8  4622              MOV      r2,r4
0001da  4629              MOV      r1,r5
0001dc  2000              MOVS     r0,#0
0001de  f7fffffe          BL       RTC_SetDateTime
0001e2  4606              MOV      r6,r0
;;;146    	if (status == ERROR){
;;;147    	}
;;;148    	else{
;;;149    	}
;;;150    	
;;;151    	/* Enable the Alarm A */
;;;152    	RTC_AlarmCmd(RTC_Alarm_A, ENABLE);
0001e4  f04f0101          MOV      r1,#1
0001e8  f44f7080          MOV      r0,#0x100
0001ec  f7fffffe          BL       RTC_AlarmCmd
;;;153    }
0001f0  bd70              POP      {r4-r6,pc}
;;;154    
                          ENDP

0001f2  0000              DCW      0x0000
                  |L1.500|
                          DCD      RTC_TimeStructure
                  |L1.504|
                          DCD      RTC_DateStructure
                  |L1.508|
                          DCD      BSP_Info
                  |L1.512|
                          DCD      SynchPrediv
                  |L1.516|
                          DCD      AsynchPrediv

                          AREA ||.data||, DATA, ALIGN=2

                  AsynchPrediv
                          DCD      0x00000000
                  SynchPrediv
                          DCD      0x00000000
                  RTC_TimeStructure
                          DCD      0x00000000
                  RTC_DateStructure
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\BSP\\bsp_rtc.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_bsp_rtc_c_0ef083ce____REV16|
#line 112 "..\\BSP\\CMSIS\\core_cmInstr.h"
|__asm___9_bsp_rtc_c_0ef083ce____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_bsp_rtc_c_0ef083ce____REVSH|
#line 130
|__asm___9_bsp_rtc_c_0ef083ce____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
