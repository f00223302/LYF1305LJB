; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Output\stm32f2xx_hash.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\Output\stm32f2xx_hash.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\BSP -I..\BSP\UCOS-II -I..\BSP\STM32F2xx\inc -I..\BSP\CMSIS -I..\BSP\CMSIS\Device_Support -I..\BSP\UCOS-II -I..\..\uC-CPU -I..\..\uC-CPU\ARM-Cortex-M3 -I..\..\uC-LIB -I..\..\uC-LIB\Ports\ARM-Cortex-M3 -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3 -I..\App -I..\Prj -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DDEBUG -DLJB_CPU_MAIN -DUSE_CPU_F205RC --omf_browse=.\Output\stm32f2xx_hash.crf ..\BSP\STM32F2xx\src\stm32f2xx_hash.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  HASH_DeInit PROC
;;;170      */
;;;171    void HASH_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;172    {
;;;173      /* Enable HASH reset state */
;;;174      RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, ENABLE);
000002  2101              MOVS     r1,#1
000004  2020              MOVS     r0,#0x20
000006  f7fffffe          BL       RCC_AHB2PeriphResetCmd
;;;175      /* Release HASH from reset state */
;;;176      RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  2020              MOVS     r0,#0x20
00000e  f7fffffe          BL       RCC_AHB2PeriphResetCmd
;;;177    }
000012  bd10              POP      {r4,pc}
;;;178    
                          ENDP

                  HASH_Init PROC
;;;190      */
;;;191    void HASH_Init(HASH_InitTypeDef* HASH_InitStruct)
000014  4976              LDR      r1,|L1.496|
;;;192    {
;;;193      /* Check the parameters */
;;;194      assert_param(IS_HASH_ALGOSELECTION(HASH_InitStruct->HASH_AlgoSelection));
;;;195      assert_param(IS_HASH_DATATYPE(HASH_InitStruct->HASH_DataType));
;;;196      assert_param(IS_HASH_ALGOMODE(HASH_InitStruct->HASH_AlgoMode));
;;;197      
;;;198      /* Configure the Algorithm used, algorithm mode and the datatype */
;;;199      HASH->CR &= ~ (HASH_CR_ALGO | HASH_CR_DATATYPE | HASH_CR_MODE);
000016  6809              LDR      r1,[r1,#0]
000018  f02101f0          BIC      r1,r1,#0xf0
00001c  4a74              LDR      r2,|L1.496|
00001e  6011              STR      r1,[r2,#0]
;;;200      HASH->CR |= (HASH_InitStruct->HASH_AlgoSelection | \
000020  6882              LDR      r2,[r0,#8]
000022  6801              LDR      r1,[r0,#0]
000024  ea410102          ORR      r1,r1,r2
000028  6842              LDR      r2,[r0,#4]
00002a  ea410102          ORR      r1,r1,r2
00002e  4a70              LDR      r2,|L1.496|
000030  6812              LDR      r2,[r2,#0]
000032  ea410102          ORR      r1,r1,r2
000036  4a6e              LDR      r2,|L1.496|
000038  6011              STR      r1,[r2,#0]
;;;201                   HASH_InitStruct->HASH_DataType | \
;;;202                   HASH_InitStruct->HASH_AlgoMode);
;;;203      
;;;204      /* if algorithm mode is HMAC, set the Key */  
;;;205      if(HASH_InitStruct->HASH_AlgoMode == HASH_AlgoMode_HMAC) 
00003a  6841              LDR      r1,[r0,#4]
00003c  2940              CMP      r1,#0x40
00003e  d10b              BNE      |L1.88|
;;;206      {
;;;207        assert_param(IS_HASH_HMAC_KEYTYPE(HASH_InitStruct->HASH_HMACKeyType));
;;;208        HASH->CR &= ~HASH_CR_LKEY;
000040  4611              MOV      r1,r2
000042  6809              LDR      r1,[r1,#0]
000044  f4213180          BIC      r1,r1,#0x10000
000048  6011              STR      r1,[r2,#0]
;;;209        HASH->CR |= HASH_InitStruct->HASH_HMACKeyType;
00004a  4611              MOV      r1,r2
00004c  6809              LDR      r1,[r1,#0]
00004e  68c2              LDR      r2,[r0,#0xc]
000050  ea410102          ORR      r1,r1,r2
000054  4a66              LDR      r2,|L1.496|
000056  6011              STR      r1,[r2,#0]
                  |L1.88|
;;;210      }
;;;211    
;;;212      /* Reset the HASH processor core, so that the HASH will be ready to compute 
;;;213         the message digest of a new message */
;;;214      HASH->CR |= HASH_CR_INIT;  
000058  4965              LDR      r1,|L1.496|
00005a  6809              LDR      r1,[r1,#0]
00005c  f0410104          ORR      r1,r1,#4
000060  4a63              LDR      r2,|L1.496|
000062  6011              STR      r1,[r2,#0]
;;;215    }
000064  4770              BX       lr
;;;216    
                          ENDP

                  HASH_StructInit PROC
;;;224      */
;;;225    void HASH_StructInit(HASH_InitTypeDef* HASH_InitStruct)
000066  f04f0100          MOV      r1,#0
;;;226    {
;;;227      /* Initialize the HASH_AlgoSelection member */
;;;228      HASH_InitStruct->HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
00006a  6001              STR      r1,[r0,#0]
;;;229    
;;;230      /* Initialize the HASH_AlgoMode member */
;;;231      HASH_InitStruct->HASH_AlgoMode = HASH_AlgoMode_HASH;
00006c  6041              STR      r1,[r0,#4]
;;;232    
;;;233      /* Initialize the HASH_DataType member */
;;;234      HASH_InitStruct->HASH_DataType = HASH_DataType_32b;
00006e  6081              STR      r1,[r0,#8]
;;;235    
;;;236      /* Initialize the HASH_HMACKeyType member */
;;;237      HASH_InitStruct->HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
000070  60c1              STR      r1,[r0,#0xc]
;;;238    }
000072  4770              BX       lr
;;;239    
                          ENDP

                  HASH_Reset PROC
;;;248      */
;;;249    void HASH_Reset(void)
000074  485e              LDR      r0,|L1.496|
;;;250    {
;;;251      /* Reset the HASH processor core */
;;;252      HASH->CR |= HASH_CR_INIT;
000076  6800              LDR      r0,[r0,#0]
000078  f0400004          ORR      r0,r0,#4
00007c  495c              LDR      r1,|L1.496|
00007e  6008              STR      r0,[r1,#0]
;;;253    }
000080  4770              BX       lr
;;;254    /**
                          ENDP

                  HASH_SetLastWordValidBitsNbr PROC
;;;290      */
;;;291    void HASH_SetLastWordValidBitsNbr(uint16_t ValidNumber)
000082  495c              LDR      r1,|L1.500|
;;;292    {
;;;293      /* Check the parameters */
;;;294      assert_param(IS_HASH_VALIDBITSNUMBER(ValidNumber));
;;;295      
;;;296      /* Configure the Number of valid bits in last word of the message */
;;;297      HASH->STR &= ~(HASH_STR_NBW);
000084  6809              LDR      r1,[r1,#0]
000086  f021011f          BIC      r1,r1,#0x1f
00008a  4a5a              LDR      r2,|L1.500|
00008c  6011              STR      r1,[r2,#0]
;;;298      HASH->STR |= ValidNumber;
00008e  4611              MOV      r1,r2
000090  6809              LDR      r1,[r1,#0]
000092  ea410100          ORR      r1,r1,r0
000096  6011              STR      r1,[r2,#0]
;;;299    }
000098  4770              BX       lr
;;;300    
                          ENDP

                  HASH_DataIn PROC
;;;305      */
;;;306    void HASH_DataIn(uint32_t Data)
00009a  4957              LDR      r1,|L1.504|
;;;307    {
;;;308      /* Write in the DIN register a new data */
;;;309      HASH->DIN = Data;
00009c  6008              STR      r0,[r1,#0]
;;;310    }
00009e  4770              BX       lr
;;;311    
                          ENDP

                  HASH_GetInFIFOWordsNbr PROC
;;;316      */
;;;317    uint8_t HASH_GetInFIFOWordsNbr(void)
0000a0  4853              LDR      r0,|L1.496|
;;;318    {
;;;319      /* Return the value of NBW bits */
;;;320      return ((HASH->CR & HASH_CR_NBW) >> 8);
0000a2  6800              LDR      r0,[r0,#0]
0000a4  f3c02003          UBFX     r0,r0,#8,#4
;;;321    }
0000a8  4770              BX       lr
;;;322    
                          ENDP

                  HASH_GetDigest PROC
;;;330      */
;;;331    void HASH_GetDigest(HASH_MsgDigest* HASH_MessageDigest)
0000aa  4954              LDR      r1,|L1.508|
;;;332    {
;;;333      /* Get the data field */
;;;334      HASH_MessageDigest->Data[0] = HASH->HR[0];
0000ac  6809              LDR      r1,[r1,#0]
0000ae  6001              STR      r1,[r0,#0]
;;;335      HASH_MessageDigest->Data[1] = HASH->HR[1];
0000b0  494f              LDR      r1,|L1.496|
0000b2  6909              LDR      r1,[r1,#0x10]
0000b4  6041              STR      r1,[r0,#4]
;;;336      HASH_MessageDigest->Data[2] = HASH->HR[2];
0000b6  494e              LDR      r1,|L1.496|
0000b8  6949              LDR      r1,[r1,#0x14]
0000ba  6081              STR      r1,[r0,#8]
;;;337      HASH_MessageDigest->Data[3] = HASH->HR[3];
0000bc  494c              LDR      r1,|L1.496|
0000be  6989              LDR      r1,[r1,#0x18]
0000c0  60c1              STR      r1,[r0,#0xc]
;;;338      HASH_MessageDigest->Data[4] = HASH->HR[4];
0000c2  494b              LDR      r1,|L1.496|
0000c4  69c9              LDR      r1,[r1,#0x1c]
0000c6  6101              STR      r1,[r0,#0x10]
;;;339    }
0000c8  4770              BX       lr
;;;340    
                          ENDP

                  HASH_StartDigest PROC
;;;345      */
;;;346    void HASH_StartDigest(void)
0000ca  484a              LDR      r0,|L1.500|
;;;347    {
;;;348      /* Start the Digest calculation */
;;;349      HASH->STR |= HASH_STR_DCAL;
0000cc  6800              LDR      r0,[r0,#0]
0000ce  f4407080          ORR      r0,r0,#0x100
0000d2  4948              LDR      r1,|L1.500|
0000d4  6008              STR      r0,[r1,#0]
;;;350    }
0000d6  4770              BX       lr
;;;351    /**
                          ENDP

                  HASH_SaveContext PROC
;;;388      */
;;;389    void HASH_SaveContext(HASH_Context* HASH_ContextSave)
0000d8  f04f0100          MOV      r1,#0
;;;390    {
;;;391      uint8_t i = 0;
;;;392      
;;;393      /* save context registers */
;;;394      HASH_ContextSave->HASH_IMR = HASH->IMR;  
0000dc  4a48              LDR      r2,|L1.512|
0000de  6812              LDR      r2,[r2,#0]
0000e0  6002              STR      r2,[r0,#0]
;;;395      HASH_ContextSave->HASH_STR = HASH->STR;      
0000e2  4a44              LDR      r2,|L1.500|
0000e4  6812              LDR      r2,[r2,#0]
0000e6  6042              STR      r2,[r0,#4]
;;;396      HASH_ContextSave->HASH_CR  = HASH->CR;     
0000e8  4a41              LDR      r2,|L1.496|
0000ea  6812              LDR      r2,[r2,#0]
0000ec  6082              STR      r2,[r0,#8]
;;;397      for(i=0; i<=50;i++)
0000ee  bf00              NOP      
0000f0  e009              B        |L1.262|
                  |L1.242|
;;;398      {
;;;399         HASH_ContextSave->HASH_CSR[i] = HASH->CSR[i];
0000f2  4a44              LDR      r2,|L1.516|
0000f4  f8523021          LDR      r3,[r2,r1,LSL #2]
0000f8  f100020c          ADD      r2,r0,#0xc
0000fc  f8423021          STR      r3,[r2,r1,LSL #2]
000100  f1010201          ADD      r2,r1,#1              ;397
000104  b2d1              UXTB     r1,r2                 ;397
                  |L1.262|
000106  2932              CMP      r1,#0x32              ;397
000108  ddf3              BLE      |L1.242|
;;;400      }   
;;;401    }
00010a  4770              BX       lr
;;;402    
                          ENDP

                  HASH_RestoreContext PROC
;;;410      */
;;;411    void HASH_RestoreContext(HASH_Context* HASH_ContextRestore)  
00010c  f04f0100          MOV      r1,#0
;;;412    {
;;;413      uint8_t i = 0;
;;;414      
;;;415      /* restore context registers */
;;;416      HASH->IMR = HASH_ContextRestore->HASH_IMR;   
000110  4b3b              LDR      r3,|L1.512|
000112  6802              LDR      r2,[r0,#0]
000114  601a              STR      r2,[r3,#0]
;;;417      HASH->STR = HASH_ContextRestore->HASH_STR;     
000116  4b37              LDR      r3,|L1.500|
000118  6842              LDR      r2,[r0,#4]
00011a  601a              STR      r2,[r3,#0]
;;;418      HASH->CR = HASH_ContextRestore->HASH_CR;
00011c  4b34              LDR      r3,|L1.496|
00011e  6882              LDR      r2,[r0,#8]
000120  601a              STR      r2,[r3,#0]
;;;419      
;;;420      /* Initialize the hash processor */
;;;421      HASH->CR |= HASH_CR_INIT; 
000122  461a              MOV      r2,r3
000124  6812              LDR      r2,[r2,#0]
000126  f0420204          ORR      r2,r2,#4
00012a  601a              STR      r2,[r3,#0]
;;;422      
;;;423       /* continue restoring context registers */     
;;;424      for(i=0; i<=50;i++)
00012c  bf00              NOP      
00012e  e009              B        |L1.324|
                  |L1.304|
;;;425      {
;;;426         HASH->CSR[i] = HASH_ContextRestore->HASH_CSR[i];
000130  f100020c          ADD      r2,r0,#0xc
000134  f8523021          LDR      r3,[r2,r1,LSL #2]
000138  4a32              LDR      r2,|L1.516|
00013a  f8423021          STR      r3,[r2,r1,LSL #2]
00013e  f1010201          ADD      r2,r1,#1              ;424
000142  b2d1              UXTB     r1,r2                 ;424
                  |L1.324|
000144  2932              CMP      r1,#0x32              ;424
000146  ddf3              BLE      |L1.304|
;;;427      }   
;;;428    }
000148  4770              BX       lr
;;;429    /**
                          ENDP

                  HASH_DMACmd PROC
;;;459      */
;;;460    void HASH_DMACmd(FunctionalState NewState)
00014a  b130              CBZ      r0,|L1.346|
;;;461    {
;;;462      /* Check the parameters */
;;;463      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;464    
;;;465      if (NewState != DISABLE)
;;;466      {
;;;467        /* Enable the HASH DMA request */
;;;468        HASH->CR |= HASH_CR_DMAE;
00014c  4928              LDR      r1,|L1.496|
00014e  6809              LDR      r1,[r1,#0]
000150  f0410108          ORR      r1,r1,#8
000154  4a26              LDR      r2,|L1.496|
000156  6011              STR      r1,[r2,#0]
000158  e005              B        |L1.358|
                  |L1.346|
;;;469      }
;;;470      else
;;;471      {
;;;472        /* Disable the HASH DMA request */
;;;473        HASH->CR &= ~HASH_CR_DMAE;
00015a  4925              LDR      r1,|L1.496|
00015c  6809              LDR      r1,[r1,#0]
00015e  f0210108          BIC      r1,r1,#8
000162  4a23              LDR      r2,|L1.496|
000164  6011              STR      r1,[r2,#0]
                  |L1.358|
;;;474      }
;;;475    }
000166  4770              BX       lr
;;;476    /**
                          ENDP

                  HASH_ITConfig PROC
;;;554      */
;;;555    void HASH_ITConfig(uint8_t HASH_IT, FunctionalState NewState)
000168  b131              CBZ      r1,|L1.376|
;;;556    {
;;;557      /* Check the parameters */
;;;558      assert_param(IS_HASH_IT(HASH_IT));
;;;559      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;560    
;;;561      if (NewState != DISABLE)
;;;562      {
;;;563        /* Enable the selected HASH interrupt */
;;;564        HASH->IMR |= HASH_IT;
00016a  4a25              LDR      r2,|L1.512|
00016c  6812              LDR      r2,[r2,#0]
00016e  ea420200          ORR      r2,r2,r0
000172  4b23              LDR      r3,|L1.512|
000174  601a              STR      r2,[r3,#0]
000176  e008              B        |L1.394|
                  |L1.376|
;;;565      }
;;;566      else
;;;567      {
;;;568        /* Disable the selected HASH interrupt */
;;;569        HASH->IMR &= (uint8_t) ~HASH_IT;
000178  4a21              LDR      r2,|L1.512|
00017a  6812              LDR      r2,[r2,#0]
00017c  ea6f0300          MVN      r3,r0
000180  b2db              UXTB     r3,r3
000182  ea020203          AND      r2,r2,r3
000186  4b1e              LDR      r3,|L1.512|
000188  601a              STR      r2,[r3,#0]
                  |L1.394|
;;;570      }
;;;571    }
00018a  4770              BX       lr
;;;572    
                          ENDP

                  HASH_GetFlagStatus PROC
;;;583      */
;;;584    FlagStatus HASH_GetFlagStatus(uint16_t HASH_FLAG)
00018c  4601              MOV      r1,r0
;;;585    {
;;;586      FlagStatus bitstatus = RESET;
00018e  f04f0000          MOV      r0,#0
;;;587      uint32_t tempreg = 0;
000192  4602              MOV      r2,r0
;;;588    
;;;589      /* Check the parameters */
;;;590      assert_param(IS_HASH_GET_FLAG(HASH_FLAG));
;;;591    
;;;592      /* check if the FLAG is in CR register */
;;;593      if ((HASH_FLAG & HASH_FLAG_DINNE) != (uint16_t)RESET ) 
000194  f4115f80          TST      r1,#0x1000
000198  d002              BEQ      |L1.416|
;;;594      {
;;;595        tempreg = HASH->CR;
00019a  4b15              LDR      r3,|L1.496|
00019c  681a              LDR      r2,[r3,#0]
00019e  e001              B        |L1.420|
                  |L1.416|
;;;596      }
;;;597      else /* The FLAG is in SR register */
;;;598      {
;;;599        tempreg = HASH->SR;
0001a0  4b19              LDR      r3,|L1.520|
0001a2  681a              LDR      r2,[r3,#0]
                  |L1.420|
;;;600      }
;;;601    
;;;602      /* Check the status of the specified HASH flag */
;;;603      if ((tempreg & HASH_FLAG) != (uint16_t)RESET)
0001a4  420a              TST      r2,r1
0001a6  d002              BEQ      |L1.430|
;;;604      {
;;;605        /* HASH is set */
;;;606        bitstatus = SET;
0001a8  f04f0001          MOV      r0,#1
0001ac  e001              B        |L1.434|
                  |L1.430|
;;;607      }
;;;608      else
;;;609      {
;;;610        /* HASH_FLAG is reset */
;;;611        bitstatus = RESET;
0001ae  f04f0000          MOV      r0,#0
                  |L1.434|
;;;612      }
;;;613    
;;;614      /* Return the HASH_FLAG status */
;;;615      return  bitstatus;
;;;616    }
0001b2  4770              BX       lr
;;;617    /**
                          ENDP

                  HASH_ClearFlag PROC
;;;624      */
;;;625    void HASH_ClearFlag(uint16_t HASH_FLAG)
0001b4  ea6f0100          MVN      r1,r0
;;;626    {
;;;627      /* Check the parameters */
;;;628      assert_param(IS_HASH_CLEAR_FLAG(HASH_FLAG));
;;;629      
;;;630      /* Clear the selected HASH flags */
;;;631      HASH->SR = ~(uint32_t)HASH_FLAG;
0001b8  4a13              LDR      r2,|L1.520|
0001ba  6011              STR      r1,[r2,#0]
;;;632    }
0001bc  4770              BX       lr
;;;633    /**
                          ENDP

                  HASH_GetITStatus PROC
;;;640      */
;;;641    ITStatus HASH_GetITStatus(uint8_t HASH_IT)
0001be  4601              MOV      r1,r0
;;;642    {
;;;643      ITStatus bitstatus = RESET;
0001c0  f04f0000          MOV      r0,#0
;;;644      uint32_t tmpreg = 0;
0001c4  4602              MOV      r2,r0
;;;645    
;;;646      /* Check the parameters */
;;;647      assert_param(IS_HASH_GET_IT(HASH_IT));  
;;;648    
;;;649    
;;;650      /* Check the status of the specified HASH interrupt */
;;;651      tmpreg =  HASH->SR;
0001c6  4b10              LDR      r3,|L1.520|
0001c8  681a              LDR      r2,[r3,#0]
;;;652    
;;;653      if (((HASH->IMR & tmpreg) & HASH_IT) != RESET)
0001ca  4b0d              LDR      r3,|L1.512|
0001cc  681b              LDR      r3,[r3,#0]
0001ce  ea030302          AND      r3,r3,r2
0001d2  420b              TST      r3,r1
0001d4  d002              BEQ      |L1.476|
;;;654      {
;;;655        /* HASH_IT is set */
;;;656        bitstatus = SET;
0001d6  f04f0001          MOV      r0,#1
0001da  e001              B        |L1.480|
                  |L1.476|
;;;657      }
;;;658      else
;;;659      {
;;;660        /* HASH_IT is reset */
;;;661        bitstatus = RESET;
0001dc  f04f0000          MOV      r0,#0
                  |L1.480|
;;;662      }
;;;663      /* Return the HASH_IT status */
;;;664      return bitstatus;
;;;665    }
0001e0  4770              BX       lr
;;;666    
                          ENDP

                  HASH_ClearITPendingBit PROC
;;;674      */
;;;675    void HASH_ClearITPendingBit(uint8_t HASH_IT)
0001e2  ea6f0100          MVN      r1,r0
;;;676    {
;;;677      /* Check the parameters */
;;;678      assert_param(IS_HASH_IT(HASH_IT));
;;;679    
;;;680      /* Clear the selected HASH interrupt pending bit */
;;;681      HASH->SR = (uint8_t)~HASH_IT;
0001e6  b2c9              UXTB     r1,r1
0001e8  4a07              LDR      r2,|L1.520|
0001ea  6011              STR      r1,[r2,#0]
;;;682    }
0001ec  4770              BX       lr
;;;683    
                          ENDP

0001ee  0000              DCW      0x0000
                  |L1.496|
                          DCD      0x50060400
                  |L1.500|
                          DCD      0x50060408
                  |L1.504|
                          DCD      0x50060404
                  |L1.508|
                          DCD      0x5006040c
                  |L1.512|
                          DCD      0x50060420
                  |L1.516|
                          DCD      0x500604f8
                  |L1.520|
                          DCD      0x50060424

;*** Start embedded assembler ***

#line 1 "..\\BSP\\STM32F2xx\\src\\stm32f2xx_hash.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_stm32f2xx_hash_c_90573c7c____REV16|
#line 112 "..\\BSP\\CMSIS\\core_cmInstr.h"
|__asm___16_stm32f2xx_hash_c_90573c7c____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_stm32f2xx_hash_c_90573c7c____REVSH|
#line 130
|__asm___16_stm32f2xx_hash_c_90573c7c____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
