; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Output\stm32f2xx_pwr.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\Output\stm32f2xx_pwr.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\BSP -I..\BSP\UCOS-II -I..\BSP\STM32F2xx\inc -I..\BSP\CMSIS -I..\BSP\CMSIS\Device_Support -I..\BSP\UCOS-II -I..\..\uC-CPU -I..\..\uC-CPU\ARM-Cortex-M3 -I..\..\uC-LIB -I..\..\uC-LIB\Ports\ARM-Cortex-M3 -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3 -I..\App -I..\Prj -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DDEBUG -DLJB_CPU_MAIN -DUSE_CPU_F205RC --omf_browse=.\Output\stm32f2xx_pwr.crf ..\BSP\STM32F2xx\src\stm32f2xx_pwr.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  PWR_DeInit PROC
;;;114      */
;;;115    void PWR_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;116    {
;;;117      RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
000002  2101              MOVS     r1,#1
000004  0708              LSLS     r0,r1,#28
000006  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;118      RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  f04f5080          MOV      r0,#0x10000000
000010  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;119    }
000014  bd10              POP      {r4,pc}
;;;120    
                          ENDP

                  PWR_BackupAccessCmd PROC
;;;129      */
;;;130    void PWR_BackupAccessCmd(FunctionalState NewState)
000016  4930              LDR      r1,|L1.216|
;;;131    {
;;;132      /* Check the parameters */
;;;133      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;134      
;;;135      *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
000018  6208              STR      r0,[r1,#0x20]
;;;136    }
00001a  4770              BX       lr
;;;137    
                          ENDP

                  PWR_PVDLevelConfig PROC
;;;175      */
;;;176    void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
00001c  4601              MOV      r1,r0
;;;177    {
;;;178      uint32_t tmpreg = 0;
00001e  f04f0000          MOV      r0,#0
;;;179      
;;;180      /* Check the parameters */
;;;181      assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
;;;182      
;;;183      tmpreg = PWR->CR;
000022  4a2e              LDR      r2,|L1.220|
000024  6810              LDR      r0,[r2,#0]
;;;184      
;;;185      /* Clear PLS[7:5] bits */
;;;186      tmpreg &= CR_PLS_MASK;
000026  f02000e0          BIC      r0,r0,#0xe0
;;;187      
;;;188      /* Set PLS[7:5] bits according to PWR_PVDLevel value */
;;;189      tmpreg |= PWR_PVDLevel;
00002a  ea400001          ORR      r0,r0,r1
;;;190      
;;;191      /* Store the new value */
;;;192      PWR->CR = tmpreg;
00002e  6010              STR      r0,[r2,#0]
;;;193    }
000030  4770              BX       lr
;;;194    
                          ENDP

                  PWR_PVDCmd PROC
;;;200      */
;;;201    void PWR_PVDCmd(FunctionalState NewState)
000032  4929              LDR      r1,|L1.216|
;;;202    {
;;;203      /* Check the parameters */
;;;204      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;205      
;;;206      *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
000034  6108              STR      r0,[r1,#0x10]
;;;207    }
000036  4770              BX       lr
;;;208    
                          ENDP

                  PWR_WakeUpPinCmd PROC
;;;234      */
;;;235    void PWR_WakeUpPinCmd(FunctionalState NewState)
000038  4929              LDR      r1,|L1.224|
;;;236    {
;;;237      /* Check the parameters */  
;;;238      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;239    
;;;240      *(__IO uint32_t *) CSR_EWUP_BB = (uint32_t)NewState;
00003a  6008              STR      r0,[r1,#0]
;;;241    }
00003c  4770              BX       lr
;;;242    
                          ENDP

                  PWR_BackupRegulatorCmd PROC
;;;282      */
;;;283    void PWR_BackupRegulatorCmd(FunctionalState NewState)
00003e  4929              LDR      r1,|L1.228|
;;;284    {
;;;285      /* Check the parameters */
;;;286      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;287    
;;;288      *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)NewState;
000040  6008              STR      r0,[r1,#0]
;;;289    }
000042  4770              BX       lr
;;;290    
                          ENDP

                  PWR_FlashPowerDownCmd PROC
;;;317      */
;;;318    void PWR_FlashPowerDownCmd(FunctionalState NewState)
000044  4924              LDR      r1,|L1.216|
;;;319    {
;;;320      /* Check the parameters */
;;;321      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;322    
;;;323      *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)NewState;
000046  6248              STR      r0,[r1,#0x24]
;;;324    }
000048  4770              BX       lr
;;;325    
                          ENDP

                  PWR_EnterSTOPMode PROC
;;;457      */
;;;458    void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
00004a  b510              PUSH     {r4,lr}
;;;459    {
00004c  4602              MOV      r2,r0
;;;460      uint32_t tmpreg = 0;
00004e  f04f0000          MOV      r0,#0
;;;461      
;;;462      /* Check the parameters */
;;;463      assert_param(IS_PWR_REGULATOR(PWR_Regulator));
;;;464      assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
;;;465      
;;;466      /* Select the regulator state in STOP mode ---------------------------------*/
;;;467      tmpreg = PWR->CR;
000052  4b22              LDR      r3,|L1.220|
000054  6818              LDR      r0,[r3,#0]
;;;468      /* Clear PDDS and LPDSR bits */
;;;469      tmpreg &= CR_DS_MASK;
000056  f0200003          BIC      r0,r0,#3
;;;470      
;;;471      /* Set LPDSR bit according to PWR_Regulator value */
;;;472      tmpreg |= PWR_Regulator;
00005a  ea400002          ORR      r0,r0,r2
;;;473      
;;;474      /* Store the new value */
;;;475      PWR->CR = tmpreg;
00005e  6018              STR      r0,[r3,#0]
;;;476      
;;;477      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;478      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000060  4b21              LDR      r3,|L1.232|
000062  681b              LDR      r3,[r3,#0]
000064  f0430304          ORR      r3,r3,#4
000068  4c1f              LDR      r4,|L1.232|
00006a  6023              STR      r3,[r4,#0]
;;;479      
;;;480      /* Select STOP mode entry --------------------------------------------------*/
;;;481      if(PWR_STOPEntry == PWR_STOPEntry_WFI)
00006c  2901              CMP      r1,#1
00006e  d101              BNE      |L1.116|
;;;482      {   
;;;483        /* Request Wait For Interrupt */
;;;484        __WFI();
000070  bf30              WFI      
000072  e000              B        |L1.118|
                  |L1.116|
;;;485      }
;;;486      else
;;;487      {
;;;488        /* Request Wait For Event */
;;;489        __WFE();
000074  bf20              WFE      
                  |L1.118|
;;;490      }
;;;491      /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;492      SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
000076  4b1c              LDR      r3,|L1.232|
000078  681b              LDR      r3,[r3,#0]
00007a  f0230304          BIC      r3,r3,#4
00007e  4c1a              LDR      r4,|L1.232|
000080  6023              STR      r3,[r4,#0]
;;;493    }
000082  bd10              POP      {r4,pc}
;;;494    
                          ENDP

                  PWR_EnterSTANDBYMode PROC
;;;505      */
;;;506    void PWR_EnterSTANDBYMode(void)
000084  4815              LDR      r0,|L1.220|
;;;507    {
;;;508      /* Clear Wakeup flag */
;;;509      PWR->CR |= PWR_CR_CWUF;
000086  6800              LDR      r0,[r0,#0]
000088  f0400004          ORR      r0,r0,#4
00008c  4913              LDR      r1,|L1.220|
00008e  6008              STR      r0,[r1,#0]
;;;510      
;;;511      /* Select STANDBY mode */
;;;512      PWR->CR |= PWR_CR_PDDS;
000090  4608              MOV      r0,r1
000092  6800              LDR      r0,[r0,#0]
000094  f0400002          ORR      r0,r0,#2
000098  6008              STR      r0,[r1,#0]
;;;513      
;;;514      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;515      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
00009a  4813              LDR      r0,|L1.232|
00009c  6800              LDR      r0,[r0,#0]
00009e  f0400004          ORR      r0,r0,#4
0000a2  4911              LDR      r1,|L1.232|
0000a4  6008              STR      r0,[r1,#0]
;;;516      
;;;517    /* This option is used to ensure that store operations are completed */
;;;518    #if defined ( __CC_ARM   )
;;;519      __force_stores();
0000a6  bf00              NOP      
0000a8  bf00              NOP      
;;;520    #endif
;;;521      /* Request Wait For Interrupt */
;;;522      __WFI();
0000aa  bf30              WFI      
;;;523    }
0000ac  4770              BX       lr
;;;524    
                          ENDP

                  PWR_GetFlagStatus PROC
;;;560      */
;;;561    FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
0000ae  4601              MOV      r1,r0
;;;562    {
;;;563      FlagStatus bitstatus = RESET;
0000b0  f04f0000          MOV      r0,#0
;;;564      
;;;565      /* Check the parameters */
;;;566      assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
;;;567      
;;;568      if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
0000b4  4a09              LDR      r2,|L1.220|
0000b6  6852              LDR      r2,[r2,#4]
0000b8  420a              TST      r2,r1
0000ba  d002              BEQ      |L1.194|
;;;569      {
;;;570        bitstatus = SET;
0000bc  f04f0001          MOV      r0,#1
0000c0  e001              B        |L1.198|
                  |L1.194|
;;;571      }
;;;572      else
;;;573      {
;;;574        bitstatus = RESET;
0000c2  f04f0000          MOV      r0,#0
                  |L1.198|
;;;575      }
;;;576      /* Return the flag status */
;;;577      return bitstatus;
;;;578    }
0000c6  4770              BX       lr
;;;579    
                          ENDP

                  PWR_ClearFlag PROC
;;;587      */
;;;588    void PWR_ClearFlag(uint32_t PWR_FLAG)
0000c8  4904              LDR      r1,|L1.220|
;;;589    {
;;;590      /* Check the parameters */
;;;591      assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
;;;592             
;;;593      PWR->CR |=  PWR_FLAG << 2;
0000ca  6809              LDR      r1,[r1,#0]
0000cc  ea410180          ORR      r1,r1,r0,LSL #2
0000d0  4a02              LDR      r2,|L1.220|
0000d2  6011              STR      r1,[r2,#0]
;;;594    }
0000d4  4770              BX       lr
;;;595    
                          ENDP

0000d6  0000              DCW      0x0000
                  |L1.216|
                          DCD      0x420e0000
                  |L1.220|
                          DCD      0x40007000
                  |L1.224|
                          DCD      0x420e00a0
                  |L1.228|
                          DCD      0x420e00a4
                  |L1.232|
                          DCD      0xe000ed10

;*** Start embedded assembler ***

#line 1 "..\\BSP\\STM32F2xx\\src\\stm32f2xx_pwr.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f2xx_pwr_c_0c2a8b75____REV16|
#line 112 "..\\BSP\\CMSIS\\core_cmInstr.h"
|__asm___15_stm32f2xx_pwr_c_0c2a8b75____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f2xx_pwr_c_0c2a8b75____REVSH|
#line 130
|__asm___15_stm32f2xx_pwr_c_0c2a8b75____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
