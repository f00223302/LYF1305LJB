; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Output\stm32f2xx_fsmc.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\Output\stm32f2xx_fsmc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\BSP -I..\BSP\UCOS-II -I..\BSP\STM32F2xx\inc -I..\BSP\CMSIS -I..\BSP\CMSIS\Device_Support -I..\BSP\UCOS-II -I..\..\uC-CPU -I..\..\uC-CPU\ARM-Cortex-M3 -I..\..\uC-LIB -I..\..\uC-LIB\Ports\ARM-Cortex-M3 -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3 -I..\App -I..\Prj -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DDEBUG -DLJB_CPU_MAIN -DUSE_CPU_F205RC --omf_browse=.\Output\stm32f2xx_fsmc.crf ..\BSP\STM32F2xx\src\stm32f2xx_fsmc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  FSMC_NORSRAMDeInit PROC
;;;115      */
;;;116    void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
000000  b930              CBNZ     r0,|L1.16|
;;;117    {
;;;118      /* Check the parameter */
;;;119      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;120      
;;;121      /* FSMC_Bank1_NORSRAM1 */
;;;122      if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
;;;123      {
;;;124        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
000002  f24301db          MOV      r1,#0x30db
000006  f04f4220          MOV      r2,#0xa0000000
00000a  f8421020          STR      r1,[r2,r0,LSL #2]
00000e  e005              B        |L1.28|
                  |L1.16|
;;;125      }
;;;126      /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
;;;127      else
;;;128      {   
;;;129        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
000010  f24301d2          MOV      r1,#0x30d2
000014  f04f4220          MOV      r2,#0xa0000000
000018  f8421020          STR      r1,[r2,r0,LSL #2]
                  |L1.28|
;;;130      }
;;;131      FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
00001c  f06f4270          MVN      r2,#0xf0000000
000020  f1000101          ADD      r1,r0,#1
000024  f04f4320          MOV      r3,#0xa0000000
000028  f8432021          STR      r2,[r3,r1,LSL #2]
;;;132      FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
00002c  4611              MOV      r1,r2
00002e  461a              MOV      r2,r3
000030  eb020280          ADD      r2,r2,r0,LSL #2
000034  f8c21104          STR      r1,[r2,#0x104]
;;;133    }
000038  4770              BX       lr
;;;134    
                          ENDP

                  FSMC_NORSRAMInit PROC
;;;142      */
;;;143    void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
00003a  e9d01201          LDRD     r1,r2,[r0,#4]
;;;144    { 
;;;145      /* Check the parameters */
;;;146      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
;;;147      assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
;;;148      assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
;;;149      assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
;;;150      assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
;;;151      assert_param(IS_FSMC_ASYNWAIT(FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait));
;;;152      assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
;;;153      assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
;;;154      assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
;;;155      assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
;;;156      assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
;;;157      assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
;;;158      assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  
;;;159      assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
;;;160      assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
;;;161      assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
;;;162      assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
;;;163      assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
;;;164      assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
;;;165      assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
;;;166      
;;;167      /* Bank1 NOR/SRAM control register configuration */ 
;;;168      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
00003e  ea410102          ORR      r1,r1,r2
000042  68c2              LDR      r2,[r0,#0xc]
000044  ea410102          ORR      r1,r1,r2
000048  6902              LDR      r2,[r0,#0x10]
00004a  ea410102          ORR      r1,r1,r2
00004e  6942              LDR      r2,[r0,#0x14]
000050  ea410102          ORR      r1,r1,r2
000054  6982              LDR      r2,[r0,#0x18]
000056  ea410102          ORR      r1,r1,r2
00005a  69c2              LDR      r2,[r0,#0x1c]
00005c  ea410102          ORR      r1,r1,r2
000060  6a02              LDR      r2,[r0,#0x20]
000062  ea410102          ORR      r1,r1,r2
000066  6a42              LDR      r2,[r0,#0x24]
000068  ea410102          ORR      r1,r1,r2
00006c  6a82              LDR      r2,[r0,#0x28]
00006e  ea410102          ORR      r1,r1,r2
000072  6ac2              LDR      r2,[r0,#0x2c]
000074  ea410102          ORR      r1,r1,r2
000078  6b02              LDR      r2,[r0,#0x30]
00007a  ea410102          ORR      r1,r1,r2
00007e  f04f4320          MOV      r3,#0xa0000000
000082  6802              LDR      r2,[r0,#0]
000084  f8431022          STR      r1,[r3,r2,LSL #2]
;;;169                (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
;;;170                FSMC_NORSRAMInitStruct->FSMC_MemoryType |
;;;171                FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
;;;172                FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
;;;173                FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
;;;174                FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
;;;175                FSMC_NORSRAMInitStruct->FSMC_WrapMode |
;;;176                FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
;;;177                FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
;;;178                FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
;;;179                FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
;;;180                FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
;;;181      if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
000088  6881              LDR      r1,[r0,#8]
00008a  2908              CMP      r1,#8
00008c  d108              BNE      |L1.160|
;;;182      {
;;;183        FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_SET;
00008e  461a              MOV      r2,r3
000090  6801              LDR      r1,[r0,#0]
000092  f8521021          LDR      r1,[r2,r1,LSL #2]
000096  f0410140          ORR      r1,r1,#0x40
00009a  6802              LDR      r2,[r0,#0]
00009c  f8431022          STR      r1,[r3,r2,LSL #2]
                  |L1.160|
;;;184      }
;;;185      /* Bank1 NOR/SRAM timing register configuration */
;;;186      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
0000a0  6b41              LDR      r1,[r0,#0x34]
0000a2  6809              LDR      r1,[r1,#0]
0000a4  6b42              LDR      r2,[r0,#0x34]
0000a6  6852              LDR      r2,[r2,#4]
0000a8  ea411102          ORR      r1,r1,r2,LSL #4
0000ac  6b42              LDR      r2,[r0,#0x34]
0000ae  6892              LDR      r2,[r2,#8]
0000b0  ea412102          ORR      r1,r1,r2,LSL #8
0000b4  6b42              LDR      r2,[r0,#0x34]
0000b6  68d2              LDR      r2,[r2,#0xc]
0000b8  ea414102          ORR      r1,r1,r2,LSL #16
0000bc  6b42              LDR      r2,[r0,#0x34]
0000be  6912              LDR      r2,[r2,#0x10]
0000c0  ea415102          ORR      r1,r1,r2,LSL #20
0000c4  6b42              LDR      r2,[r0,#0x34]
0000c6  6952              LDR      r2,[r2,#0x14]
0000c8  ea416102          ORR      r1,r1,r2,LSL #24
0000cc  6b42              LDR      r2,[r0,#0x34]
0000ce  6992              LDR      r2,[r2,#0x18]
0000d0  ea410102          ORR      r1,r1,r2
0000d4  6802              LDR      r2,[r0,#0]
0000d6  f1020201          ADD      r2,r2,#1
0000da  f04f4320          MOV      r3,#0xa0000000
0000de  f8431022          STR      r1,[r3,r2,LSL #2]
;;;187                (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
;;;188                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
;;;189                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;190                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
;;;191                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
;;;192                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
;;;193                 FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
;;;194                
;;;195        
;;;196      /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
;;;197      if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
0000e2  6ac1              LDR      r1,[r0,#0x2c]
0000e4  f5b14f80          CMP      r1,#0x4000
0000e8  d11b              BNE      |L1.290|
;;;198      {
;;;199        assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
;;;200        assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
;;;201        assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
;;;202        assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
;;;203        assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
;;;204        assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
;;;205        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
0000ea  6b81              LDR      r1,[r0,#0x38]
0000ec  6809              LDR      r1,[r1,#0]
0000ee  6b82              LDR      r2,[r0,#0x38]
0000f0  6852              LDR      r2,[r2,#4]
0000f2  ea411102          ORR      r1,r1,r2,LSL #4
0000f6  6b82              LDR      r2,[r0,#0x38]
0000f8  6892              LDR      r2,[r2,#8]
0000fa  ea412102          ORR      r1,r1,r2,LSL #8
0000fe  6b82              LDR      r2,[r0,#0x38]
000100  6912              LDR      r2,[r2,#0x10]
000102  ea415102          ORR      r1,r1,r2,LSL #20
000106  6b82              LDR      r2,[r0,#0x38]
000108  6952              LDR      r2,[r2,#0x14]
00010a  ea416102          ORR      r1,r1,r2,LSL #24
00010e  6b82              LDR      r2,[r0,#0x38]
000110  6992              LDR      r2,[r2,#0x18]
000112  ea410102          ORR      r1,r1,r2
000116  6802              LDR      r2,[r0,#0]
000118  eb030282          ADD      r2,r3,r2,LSL #2
00011c  f8c21104          STR      r1,[r2,#0x104]
000120  e008              B        |L1.308|
                  |L1.290|
;;;206                  (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
;;;207                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
;;;208                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;209                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
;;;210                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
;;;211                   FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
;;;212      }
;;;213      else
;;;214      {
;;;215        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
000122  f06f4170          MVN      r1,#0xf0000000
000126  f04f4320          MOV      r3,#0xa0000000
00012a  6802              LDR      r2,[r0,#0]
00012c  eb030282          ADD      r2,r3,r2,LSL #2
000130  f8c21104          STR      r1,[r2,#0x104]
                  |L1.308|
;;;216      }
;;;217    }
000134  4770              BX       lr
;;;218    
                          ENDP

                  FSMC_NORSRAMStructInit PROC
;;;224      */
;;;225    void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000136  f04f0100          MOV      r1,#0
;;;226    {  
;;;227      /* Reset NOR/SRAM Init structure parameters values */
;;;228      FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
00013a  6001              STR      r1,[r0,#0]
;;;229      FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
00013c  f04f0102          MOV      r1,#2
000140  6041              STR      r1,[r0,#4]
;;;230      FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
000142  f04f0100          MOV      r1,#0
000146  6081              STR      r1,[r0,#8]
;;;231      FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
000148  60c1              STR      r1,[r0,#0xc]
;;;232      FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
00014a  6101              STR      r1,[r0,#0x10]
;;;233      FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
00014c  6141              STR      r1,[r0,#0x14]
;;;234      FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
00014e  6181              STR      r1,[r0,#0x18]
;;;235      FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
000150  61c1              STR      r1,[r0,#0x1c]
;;;236      FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
000152  6201              STR      r1,[r0,#0x20]
;;;237      FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
000154  f44f5180          MOV      r1,#0x1000
000158  6241              STR      r1,[r0,#0x24]
;;;238      FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
00015a  f44f5100          MOV      r1,#0x2000
00015e  6281              STR      r1,[r0,#0x28]
;;;239      FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
000160  f04f0100          MOV      r1,#0
000164  62c1              STR      r1,[r0,#0x2c]
;;;240      FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
000166  6301              STR      r1,[r0,#0x30]
;;;241      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
000168  f04f010f          MOV      r1,#0xf
00016c  6b42              LDR      r2,[r0,#0x34]
00016e  6011              STR      r1,[r2,#0]
;;;242      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
000170  6b42              LDR      r2,[r0,#0x34]
000172  6051              STR      r1,[r2,#4]
;;;243      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
000174  f04f01ff          MOV      r1,#0xff
000178  6b42              LDR      r2,[r0,#0x34]
00017a  6091              STR      r1,[r2,#8]
;;;244      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
00017c  f04f010f          MOV      r1,#0xf
000180  6b42              LDR      r2,[r0,#0x34]
000182  60d1              STR      r1,[r2,#0xc]
;;;245      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
000184  6b42              LDR      r2,[r0,#0x34]
000186  6111              STR      r1,[r2,#0x10]
;;;246      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
000188  6b42              LDR      r2,[r0,#0x34]
00018a  6151              STR      r1,[r2,#0x14]
;;;247      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
00018c  f04f0100          MOV      r1,#0
000190  6b42              LDR      r2,[r0,#0x34]
000192  6191              STR      r1,[r2,#0x18]
;;;248      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
000194  f04f010f          MOV      r1,#0xf
000198  6b82              LDR      r2,[r0,#0x38]
00019a  6011              STR      r1,[r2,#0]
;;;249      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
00019c  6b82              LDR      r2,[r0,#0x38]
00019e  6051              STR      r1,[r2,#4]
;;;250      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
0001a0  f04f01ff          MOV      r1,#0xff
0001a4  6b82              LDR      r2,[r0,#0x38]
0001a6  6091              STR      r1,[r2,#8]
;;;251      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
0001a8  f04f010f          MOV      r1,#0xf
0001ac  6b82              LDR      r2,[r0,#0x38]
0001ae  60d1              STR      r1,[r2,#0xc]
;;;252      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
0001b0  6b82              LDR      r2,[r0,#0x38]
0001b2  6111              STR      r1,[r2,#0x10]
;;;253      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
0001b4  6b82              LDR      r2,[r0,#0x38]
0001b6  6151              STR      r1,[r2,#0x14]
;;;254      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
0001b8  f04f0100          MOV      r1,#0
0001bc  6b82              LDR      r2,[r0,#0x38]
0001be  6191              STR      r1,[r2,#0x18]
;;;255    }
0001c0  4770              BX       lr
;;;256    
                          ENDP

                  FSMC_NORSRAMCmd PROC
;;;267      */
;;;268    void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
0001c2  b151              CBZ      r1,|L1.474|
;;;269    {
;;;270      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;271      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;272      
;;;273      if (NewState != DISABLE)
;;;274      {
;;;275        /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
;;;276        FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_SET;
0001c4  f04f4220          MOV      r2,#0xa0000000
0001c8  f8522020          LDR      r2,[r2,r0,LSL #2]
0001cc  f0420201          ORR      r2,r2,#1
0001d0  f04f4320          MOV      r3,#0xa0000000
0001d4  f8432020          STR      r2,[r3,r0,LSL #2]
0001d8  e00a              B        |L1.496|
                  |L1.474|
;;;277      }
;;;278      else
;;;279      {
;;;280        /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
;;;281        FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_RESET;
0001da  f04f4220          MOV      r2,#0xa0000000
0001de  f8522020          LDR      r2,[r2,r0,LSL #2]
0001e2  4bf9              LDR      r3,|L1.1480|
0001e4  ea020203          AND      r2,r2,r3
0001e8  f04f4320          MOV      r3,#0xa0000000
0001ec  f8432020          STR      r2,[r3,r0,LSL #2]
                  |L1.496|
;;;282      }
;;;283    }
0001f0  4770              BX       lr
;;;284    /**
                          ENDP

                  FSMC_NANDDeInit PROC
;;;338      */
;;;339    void FSMC_NANDDeInit(uint32_t FSMC_Bank)
0001f2  2810              CMP      r0,#0x10
;;;340    {
;;;341      /* Check the parameter */
;;;342      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;343      
;;;344      if(FSMC_Bank == FSMC_Bank2_NAND)
0001f4  d10c              BNE      |L1.528|
;;;345      {
;;;346        /* Set the FSMC_Bank2 registers to their reset values */
;;;347        FSMC_Bank2->PCR2 = 0x00000018;
0001f6  f04f0118          MOV      r1,#0x18
0001fa  f04f4220          MOV      r2,#0xa0000000
0001fe  6611              STR      r1,[r2,#0x60]
;;;348        FSMC_Bank2->SR2 = 0x00000040;
000200  f04f0140          MOV      r1,#0x40
000204  6651              STR      r1,[r2,#0x64]
;;;349        FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
000206  f04f31fc          MOV      r1,#0xfcfcfcfc
00020a  6691              STR      r1,[r2,#0x68]
;;;350        FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
00020c  66d1              STR      r1,[r2,#0x6c]
00020e  e011              B        |L1.564|
                  |L1.528|
;;;351      }
;;;352      /* FSMC_Bank3_NAND */  
;;;353      else
;;;354      {
;;;355        /* Set the FSMC_Bank3 registers to their reset values */
;;;356        FSMC_Bank3->PCR3 = 0x00000018;
000210  f04f0118          MOV      r1,#0x18
000214  4aed              LDR      r2,|L1.1484|
000216  6011              STR      r1,[r2,#0]
;;;357        FSMC_Bank3->SR3 = 0x00000040;
000218  f04f0140          MOV      r1,#0x40
00021c  f04f4220          MOV      r2,#0xa0000000
000220  f8c21084          STR      r1,[r2,#0x84]
;;;358        FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
000224  f04f31fc          MOV      r1,#0xfcfcfcfc
000228  4ae9              LDR      r2,|L1.1488|
00022a  6011              STR      r1,[r2,#0]
;;;359        FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
00022c  f04f4220          MOV      r2,#0xa0000000
000230  f8c2108c          STR      r1,[r2,#0x8c]
                  |L1.564|
;;;360      }  
;;;361    }
000234  4770              BX       lr
;;;362    
                          ENDP

                  FSMC_NANDInit PROC
;;;369      */
;;;370    void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
000236  b530              PUSH     {r4,r5,lr}
;;;371    {
;;;372      uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
000238  f04f0100          MOV      r1,#0
00023c  460a              MOV      r2,r1
00023e  460b              MOV      r3,r1
;;;373        
;;;374      /* Check the parameters */
;;;375      assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
;;;376      assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
;;;377      assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
;;;378      assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
;;;379      assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
;;;380      assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
;;;381      assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
;;;382      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;383      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;384      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;385      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;386      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;387      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;388      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;389      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;390      
;;;391      /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
;;;392      tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
000240  6844              LDR      r4,[r0,#4]
000242  f0440408          ORR      r4,r4,#8
000246  6885              LDR      r5,[r0,#8]
000248  ea440405          ORR      r4,r4,r5
00024c  68c5              LDR      r5,[r0,#0xc]
00024e  ea440405          ORR      r4,r4,r5
000252  6905              LDR      r5,[r0,#0x10]
000254  ea440405          ORR      r4,r4,r5
000258  6945              LDR      r5,[r0,#0x14]
00025a  ea442445          ORR      r4,r4,r5,LSL #9
00025e  6985              LDR      r5,[r0,#0x18]
000260  ea443145          ORR      r1,r4,r5,LSL #13
;;;393                PCR_MEMORYTYPE_NAND |
;;;394                FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
;;;395                FSMC_NANDInitStruct->FSMC_ECC |
;;;396                FSMC_NANDInitStruct->FSMC_ECCPageSize |
;;;397                (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
;;;398                (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
;;;399                
;;;400      /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
;;;401      tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
000264  69c4              LDR      r4,[r0,#0x1c]
000266  6824              LDR      r4,[r4,#0]
000268  69c5              LDR      r5,[r0,#0x1c]
00026a  686d              LDR      r5,[r5,#4]
00026c  ea442405          ORR      r4,r4,r5,LSL #8
000270  69c5              LDR      r5,[r0,#0x1c]
000272  68ad              LDR      r5,[r5,#8]
000274  ea444405          ORR      r4,r4,r5,LSL #16
000278  69c5              LDR      r5,[r0,#0x1c]
00027a  68ed              LDR      r5,[r5,#0xc]
00027c  ea446205          ORR      r2,r4,r5,LSL #24
;;;402                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;403                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;404                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;405                
;;;406      /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;407      tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
000280  6a04              LDR      r4,[r0,#0x20]
000282  6824              LDR      r4,[r4,#0]
000284  6a05              LDR      r5,[r0,#0x20]
000286  686d              LDR      r5,[r5,#4]
000288  ea442405          ORR      r4,r4,r5,LSL #8
00028c  6a05              LDR      r5,[r0,#0x20]
00028e  68ad              LDR      r5,[r5,#8]
000290  ea444405          ORR      r4,r4,r5,LSL #16
000294  6a05              LDR      r5,[r0,#0x20]
000296  68ed              LDR      r5,[r5,#0xc]
000298  ea446305          ORR      r3,r4,r5,LSL #24
;;;408                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;409                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;410                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
;;;411      
;;;412      if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
00029c  6804              LDR      r4,[r0,#0]
00029e  2c10              CMP      r4,#0x10
0002a0  d105              BNE      |L1.686|
;;;413      {
;;;414        /* FSMC_Bank2_NAND registers configuration */
;;;415        FSMC_Bank2->PCR2 = tmppcr;
0002a2  f04f4420          MOV      r4,#0xa0000000
0002a6  6621              STR      r1,[r4,#0x60]
;;;416        FSMC_Bank2->PMEM2 = tmppmem;
0002a8  66a2              STR      r2,[r4,#0x68]
;;;417        FSMC_Bank2->PATT2 = tmppatt;
0002aa  66e3              STR      r3,[r4,#0x6c]
0002ac  e007              B        |L1.702|
                  |L1.686|
;;;418      }
;;;419      else
;;;420      {
;;;421        /* FSMC_Bank3_NAND registers configuration */
;;;422        FSMC_Bank3->PCR3 = tmppcr;
0002ae  4cc7              LDR      r4,|L1.1484|
0002b0  6021              STR      r1,[r4,#0]
;;;423        FSMC_Bank3->PMEM3 = tmppmem;
0002b2  f04f4420          MOV      r4,#0xa0000000
0002b6  f8c42088          STR      r2,[r4,#0x88]
;;;424        FSMC_Bank3->PATT3 = tmppatt;
0002ba  4cc6              LDR      r4,|L1.1492|
0002bc  6023              STR      r3,[r4,#0]
                  |L1.702|
;;;425      }
;;;426    }
0002be  bd30              POP      {r4,r5,pc}
;;;427    
                          ENDP

                  FSMC_NANDStructInit PROC
;;;434      */
;;;435    void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
0002c0  f04f0110          MOV      r1,#0x10
;;;436    { 
;;;437      /* Reset NAND Init structure parameters values */
;;;438      FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
0002c4  6001              STR      r1,[r0,#0]
;;;439      FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
0002c6  f04f0100          MOV      r1,#0
0002ca  6041              STR      r1,[r0,#4]
;;;440      FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
0002cc  6081              STR      r1,[r0,#8]
;;;441      FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
0002ce  60c1              STR      r1,[r0,#0xc]
;;;442      FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
0002d0  6101              STR      r1,[r0,#0x10]
;;;443      FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
0002d2  6141              STR      r1,[r0,#0x14]
;;;444      FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
0002d4  6181              STR      r1,[r0,#0x18]
;;;445      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
0002d6  f04f01fc          MOV      r1,#0xfc
0002da  69c2              LDR      r2,[r0,#0x1c]
0002dc  6011              STR      r1,[r2,#0]
;;;446      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
0002de  69c2              LDR      r2,[r0,#0x1c]
0002e0  6051              STR      r1,[r2,#4]
;;;447      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
0002e2  69c2              LDR      r2,[r0,#0x1c]
0002e4  6091              STR      r1,[r2,#8]
;;;448      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
0002e6  69c2              LDR      r2,[r0,#0x1c]
0002e8  60d1              STR      r1,[r2,#0xc]
;;;449      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
0002ea  6a02              LDR      r2,[r0,#0x20]
0002ec  6011              STR      r1,[r2,#0]
;;;450      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
0002ee  6a02              LDR      r2,[r0,#0x20]
0002f0  6051              STR      r1,[r2,#4]
;;;451      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
0002f2  6a02              LDR      r2,[r0,#0x20]
0002f4  6091              STR      r1,[r2,#8]
;;;452      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
0002f6  6a02              LDR      r2,[r0,#0x20]
0002f8  60d1              STR      r1,[r2,#0xc]
;;;453    }
0002fa  4770              BX       lr
;;;454    
                          ENDP

                  FSMC_NANDCmd PROC
;;;463      */
;;;464    void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
0002fc  b199              CBZ      r1,|L1.806|
;;;465    {
;;;466      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;467      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;468      
;;;469      if (NewState != DISABLE)
;;;470      {
;;;471        /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
;;;472        if(FSMC_Bank == FSMC_Bank2_NAND)
0002fe  2810              CMP      r0,#0x10
000300  d108              BNE      |L1.788|
;;;473        {
;;;474          FSMC_Bank2->PCR2 |= PCR_PBKEN_SET;
000302  f04f4220          MOV      r2,#0xa0000000
000306  6e12              LDR      r2,[r2,#0x60]
000308  f0420204          ORR      r2,r2,#4
00030c  f04f4320          MOV      r3,#0xa0000000
000310  661a              STR      r2,[r3,#0x60]
000312  e01d              B        |L1.848|
                  |L1.788|
;;;475        }
;;;476        else
;;;477        {
;;;478          FSMC_Bank3->PCR3 |= PCR_PBKEN_SET;
000314  4aad              LDR      r2,|L1.1484|
000316  6812              LDR      r2,[r2,#0]
000318  f0420204          ORR      r2,r2,#4
00031c  f04f4320          MOV      r3,#0xa0000000
000320  f8c32080          STR      r2,[r3,#0x80]
000324  e014              B        |L1.848|
                  |L1.806|
;;;479        }
;;;480      }
;;;481      else
;;;482      {
;;;483        /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
;;;484        if(FSMC_Bank == FSMC_Bank2_NAND)
000326  2810              CMP      r0,#0x10
000328  d109              BNE      |L1.830|
;;;485        {
;;;486          FSMC_Bank2->PCR2 &= PCR_PBKEN_RESET;
00032a  f04f4220          MOV      r2,#0xa0000000
00032e  6e12              LDR      r2,[r2,#0x60]
000330  4ba9              LDR      r3,|L1.1496|
000332  ea020203          AND      r2,r2,r3
000336  f04f4320          MOV      r3,#0xa0000000
00033a  661a              STR      r2,[r3,#0x60]
00033c  e008              B        |L1.848|
                  |L1.830|
;;;487        }
;;;488        else
;;;489        {
;;;490          FSMC_Bank3->PCR3 &= PCR_PBKEN_RESET;
00033e  4aa3              LDR      r2,|L1.1484|
000340  6812              LDR      r2,[r2,#0]
000342  4ba5              LDR      r3,|L1.1496|
000344  ea020203          AND      r2,r2,r3
000348  f04f4320          MOV      r3,#0xa0000000
00034c  f8c32080          STR      r2,[r3,#0x80]
                  |L1.848|
;;;491        }
;;;492      }
;;;493    }
000350  4770              BX       lr
;;;494    /**
                          ENDP

                  FSMC_NANDECCCmd PROC
;;;503      */
;;;504    void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000352  b199              CBZ      r1,|L1.892|
;;;505    {
;;;506      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;507      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;508      
;;;509      if (NewState != DISABLE)
;;;510      {
;;;511        /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
;;;512        if(FSMC_Bank == FSMC_Bank2_NAND)
000354  2810              CMP      r0,#0x10
000356  d108              BNE      |L1.874|
;;;513        {
;;;514          FSMC_Bank2->PCR2 |= PCR_ECCEN_SET;
000358  f04f4220          MOV      r2,#0xa0000000
00035c  6e12              LDR      r2,[r2,#0x60]
00035e  f0420240          ORR      r2,r2,#0x40
000362  f04f4320          MOV      r3,#0xa0000000
000366  661a              STR      r2,[r3,#0x60]
000368  e01d              B        |L1.934|
                  |L1.874|
;;;515        }
;;;516        else
;;;517        {
;;;518          FSMC_Bank3->PCR3 |= PCR_ECCEN_SET;
00036a  4a98              LDR      r2,|L1.1484|
00036c  6812              LDR      r2,[r2,#0]
00036e  f0420240          ORR      r2,r2,#0x40
000372  f04f4320          MOV      r3,#0xa0000000
000376  f8c32080          STR      r2,[r3,#0x80]
00037a  e014              B        |L1.934|
                  |L1.892|
;;;519        }
;;;520      }
;;;521      else
;;;522      {
;;;523        /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
;;;524        if(FSMC_Bank == FSMC_Bank2_NAND)
00037c  2810              CMP      r0,#0x10
00037e  d109              BNE      |L1.916|
;;;525        {
;;;526          FSMC_Bank2->PCR2 &= PCR_ECCEN_RESET;
000380  f04f4220          MOV      r2,#0xa0000000
000384  6e12              LDR      r2,[r2,#0x60]
000386  4b95              LDR      r3,|L1.1500|
000388  ea020203          AND      r2,r2,r3
00038c  f04f4320          MOV      r3,#0xa0000000
000390  661a              STR      r2,[r3,#0x60]
000392  e008              B        |L1.934|
                  |L1.916|
;;;527        }
;;;528        else
;;;529        {
;;;530          FSMC_Bank3->PCR3 &= PCR_ECCEN_RESET;
000394  4a8d              LDR      r2,|L1.1484|
000396  6812              LDR      r2,[r2,#0]
000398  4b90              LDR      r3,|L1.1500|
00039a  ea020203          AND      r2,r2,r3
00039e  f04f4320          MOV      r3,#0xa0000000
0003a2  f8c32080          STR      r2,[r3,#0x80]
                  |L1.934|
;;;531        }
;;;532      }
;;;533    }
0003a6  4770              BX       lr
;;;534    
                          ENDP

                  FSMC_GetECC PROC
;;;542      */
;;;543    uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
0003a8  4601              MOV      r1,r0
;;;544    {
;;;545      uint32_t eccval = 0x00000000;
0003aa  f04f0000          MOV      r0,#0
;;;546      
;;;547      if(FSMC_Bank == FSMC_Bank2_NAND)
0003ae  2910              CMP      r1,#0x10
0003b0  d103              BNE      |L1.954|
;;;548      {
;;;549        /* Get the ECCR2 register value */
;;;550        eccval = FSMC_Bank2->ECCR2;
0003b2  f04f4220          MOV      r2,#0xa0000000
0003b6  6f50              LDR      r0,[r2,#0x74]
0003b8  e001              B        |L1.958|
                  |L1.954|
;;;551      }
;;;552      else
;;;553      {
;;;554        /* Get the ECCR3 register value */
;;;555        eccval = FSMC_Bank3->ECCR3;
0003ba  4a89              LDR      r2,|L1.1504|
0003bc  6810              LDR      r0,[r2,#0]
                  |L1.958|
;;;556      }
;;;557      /* Return the error correction code value */
;;;558      return(eccval);
;;;559    }
0003be  4770              BX       lr
;;;560    /**
                          ENDP

                  FSMC_PCCARDDeInit PROC
;;;606      */
;;;607    void FSMC_PCCARDDeInit(void)
0003c0  f04f0018          MOV      r0,#0x18
;;;608    {
;;;609      /* Set the FSMC_Bank4 registers to their reset values */
;;;610      FSMC_Bank4->PCR4 = 0x00000018; 
0003c4  4987              LDR      r1,|L1.1508|
0003c6  6008              STR      r0,[r1,#0]
;;;611      FSMC_Bank4->SR4 = 0x00000000;	
0003c8  f04f0000          MOV      r0,#0
0003cc  f04f4120          MOV      r1,#0xa0000000
0003d0  f8c100a4          STR      r0,[r1,#0xa4]
;;;612      FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
0003d4  f04f30fc          MOV      r0,#0xfcfcfcfc
0003d8  4983              LDR      r1,|L1.1512|
0003da  6008              STR      r0,[r1,#0]
;;;613      FSMC_Bank4->PATT4 = 0xFCFCFCFC;
0003dc  f1010104          ADD      r1,r1,#4
0003e0  6008              STR      r0,[r1,#0]
;;;614      FSMC_Bank4->PIO4 = 0xFCFCFCFC;
0003e2  f1010104          ADD      r1,r1,#4
0003e6  6008              STR      r0,[r1,#0]
;;;615    }
0003e8  4770              BX       lr
;;;616    
                          ENDP

                  FSMC_PCCARDInit PROC
;;;623      */
;;;624    void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
0003ea  6801              LDR      r1,[r0,#0]
;;;625    {
;;;626      /* Check the parameters */
;;;627      assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
;;;628      assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
;;;629      assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
;;;630     
;;;631      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;632      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;633      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;634      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;635      
;;;636      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;637      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;638      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;639      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;640      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
;;;641      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
;;;642      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
;;;643      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
;;;644      
;;;645      /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
;;;646      FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
0003ec  f0410110          ORR      r1,r1,#0x10
0003f0  6842              LDR      r2,[r0,#4]
0003f2  ea412142          ORR      r1,r1,r2,LSL #9
0003f6  6882              LDR      r2,[r0,#8]
0003f8  ea413142          ORR      r1,r1,r2,LSL #13
0003fc  4a79              LDR      r2,|L1.1508|
0003fe  6011              STR      r1,[r2,#0]
;;;647                         FSMC_MemoryDataWidth_16b |  
;;;648                         (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
;;;649                         (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
;;;650                
;;;651      /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
;;;652      FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
000400  68c1              LDR      r1,[r0,#0xc]
000402  6809              LDR      r1,[r1,#0]
000404  68c2              LDR      r2,[r0,#0xc]
000406  6852              LDR      r2,[r2,#4]
000408  ea412102          ORR      r1,r1,r2,LSL #8
00040c  68c2              LDR      r2,[r0,#0xc]
00040e  6892              LDR      r2,[r2,#8]
000410  ea414102          ORR      r1,r1,r2,LSL #16
000414  68c2              LDR      r2,[r0,#0xc]
000416  68d2              LDR      r2,[r2,#0xc]
000418  ea416102          ORR      r1,r1,r2,LSL #24
00041c  4a72              LDR      r2,|L1.1512|
00041e  6011              STR      r1,[r2,#0]
;;;653                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;654                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;655                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;656                
;;;657      /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;658      FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
000420  6901              LDR      r1,[r0,#0x10]
000422  6809              LDR      r1,[r1,#0]
000424  6902              LDR      r2,[r0,#0x10]
000426  6852              LDR      r2,[r2,#4]
000428  ea412102          ORR      r1,r1,r2,LSL #8
00042c  6902              LDR      r2,[r0,#0x10]
00042e  6892              LDR      r2,[r2,#8]
000430  ea414102          ORR      r1,r1,r2,LSL #16
000434  6902              LDR      r2,[r0,#0x10]
000436  68d2              LDR      r2,[r2,#0xc]
000438  ea416102          ORR      r1,r1,r2,LSL #24
00043c  4a6b              LDR      r2,|L1.1516|
00043e  6011              STR      r1,[r2,#0]
;;;659                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;660                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;661                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
;;;662                
;;;663      /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
;;;664      FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
000440  6941              LDR      r1,[r0,#0x14]
000442  6809              LDR      r1,[r1,#0]
000444  6942              LDR      r2,[r0,#0x14]
000446  6852              LDR      r2,[r2,#4]
000448  ea412102          ORR      r1,r1,r2,LSL #8
00044c  6942              LDR      r2,[r0,#0x14]
00044e  6892              LDR      r2,[r2,#8]
000450  ea414102          ORR      r1,r1,r2,LSL #16
000454  6942              LDR      r2,[r0,#0x14]
000456  68d2              LDR      r2,[r2,#0xc]
000458  ea416102          ORR      r1,r1,r2,LSL #24
00045c  f04f4220          MOV      r2,#0xa0000000
000460  f8c210b0          STR      r1,[r2,#0xb0]
;;;665                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;666                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;667                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
;;;668    }
000464  4770              BX       lr
;;;669    
                          ENDP

                  FSMC_PCCARDStructInit PROC
;;;675      */
;;;676    void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
000466  f04f0100          MOV      r1,#0
;;;677    {
;;;678      /* Reset PCCARD Init structure parameters values */
;;;679      FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
00046a  6001              STR      r1,[r0,#0]
;;;680      FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
00046c  6041              STR      r1,[r0,#4]
;;;681      FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
00046e  6081              STR      r1,[r0,#8]
;;;682      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000470  f04f01fc          MOV      r1,#0xfc
000474  68c2              LDR      r2,[r0,#0xc]
000476  6011              STR      r1,[r2,#0]
;;;683      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000478  68c2              LDR      r2,[r0,#0xc]
00047a  6051              STR      r1,[r2,#4]
;;;684      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00047c  68c2              LDR      r2,[r0,#0xc]
00047e  6091              STR      r1,[r2,#8]
;;;685      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000480  68c2              LDR      r2,[r0,#0xc]
000482  60d1              STR      r1,[r2,#0xc]
;;;686      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000484  6902              LDR      r2,[r0,#0x10]
000486  6011              STR      r1,[r2,#0]
;;;687      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000488  6902              LDR      r2,[r0,#0x10]
00048a  6051              STR      r1,[r2,#4]
;;;688      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00048c  6902              LDR      r2,[r0,#0x10]
00048e  6091              STR      r1,[r2,#8]
;;;689      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
000490  6902              LDR      r2,[r0,#0x10]
000492  60d1              STR      r1,[r2,#0xc]
;;;690      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000494  6942              LDR      r2,[r0,#0x14]
000496  6011              STR      r1,[r2,#0]
;;;691      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000498  6942              LDR      r2,[r0,#0x14]
00049a  6051              STR      r1,[r2,#4]
;;;692      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00049c  6942              LDR      r2,[r0,#0x14]
00049e  6091              STR      r1,[r2,#8]
;;;693      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
0004a0  6942              LDR      r2,[r0,#0x14]
0004a2  60d1              STR      r1,[r2,#0xc]
;;;694    }
0004a4  4770              BX       lr
;;;695    
                          ENDP

                  FSMC_PCCARDCmd PROC
;;;701      */
;;;702    void FSMC_PCCARDCmd(FunctionalState NewState)
0004a6  b140              CBZ      r0,|L1.1210|
;;;703    {
;;;704      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;705      
;;;706      if (NewState != DISABLE)
;;;707      {
;;;708        /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
;;;709        FSMC_Bank4->PCR4 |= PCR_PBKEN_SET;
0004a8  494e              LDR      r1,|L1.1508|
0004aa  6809              LDR      r1,[r1,#0]
0004ac  f0410104          ORR      r1,r1,#4
0004b0  f04f4220          MOV      r2,#0xa0000000
0004b4  f8c210a0          STR      r1,[r2,#0xa0]
0004b8  e008              B        |L1.1228|
                  |L1.1210|
;;;710      }
;;;711      else
;;;712      {
;;;713        /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
;;;714        FSMC_Bank4->PCR4 &= PCR_PBKEN_RESET;
0004ba  494a              LDR      r1,|L1.1508|
0004bc  6809              LDR      r1,[r1,#0]
0004be  4a46              LDR      r2,|L1.1496|
0004c0  ea010102          AND      r1,r1,r2
0004c4  f04f4220          MOV      r2,#0xa0000000
0004c8  f8c210a0          STR      r1,[r2,#0xa0]
                  |L1.1228|
;;;715      }
;;;716    }
0004cc  4770              BX       lr
;;;717    /**
                          ENDP

                  FSMC_ITConfig PROC
;;;748      */
;;;749    void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
0004ce  b510              PUSH     {r4,lr}
;;;750    {
;;;751      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;752      assert_param(IS_FSMC_IT(FSMC_IT));	
;;;753      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;754      
;;;755      if (NewState != DISABLE)
0004d0  b1fa              CBZ      r2,|L1.1298|
;;;756      {
;;;757        /* Enable the selected FSMC_Bank2 interrupts */
;;;758        if(FSMC_Bank == FSMC_Bank2_NAND)
0004d2  2810              CMP      r0,#0x10
0004d4  d108              BNE      |L1.1256|
;;;759        {
;;;760          FSMC_Bank2->SR2 |= FSMC_IT;
0004d6  f04f4320          MOV      r3,#0xa0000000
0004da  6e5b              LDR      r3,[r3,#0x64]
0004dc  ea430301          ORR      r3,r3,r1
0004e0  f04f4420          MOV      r4,#0xa0000000
0004e4  6663              STR      r3,[r4,#0x64]
0004e6  e033              B        |L1.1360|
                  |L1.1256|
;;;761        }
;;;762        /* Enable the selected FSMC_Bank3 interrupts */
;;;763        else if (FSMC_Bank == FSMC_Bank3_NAND)
0004e8  f5b07f80          CMP      r0,#0x100
0004ec  d108              BNE      |L1.1280|
;;;764        {
;;;765          FSMC_Bank3->SR3 |= FSMC_IT;
0004ee  4b40              LDR      r3,|L1.1520|
0004f0  681b              LDR      r3,[r3,#0]
0004f2  ea430301          ORR      r3,r3,r1
0004f6  f04f4420          MOV      r4,#0xa0000000
0004fa  f8c43084          STR      r3,[r4,#0x84]
0004fe  e027              B        |L1.1360|
                  |L1.1280|
;;;766        }
;;;767        /* Enable the selected FSMC_Bank4 interrupts */
;;;768        else
;;;769        {
;;;770          FSMC_Bank4->SR4 |= FSMC_IT;    
000500  4b3c              LDR      r3,|L1.1524|
000502  681b              LDR      r3,[r3,#0]
000504  ea430301          ORR      r3,r3,r1
000508  f04f4420          MOV      r4,#0xa0000000
00050c  f8c430a4          STR      r3,[r4,#0xa4]
000510  e01e              B        |L1.1360|
                  |L1.1298|
;;;771        }
;;;772      }
;;;773      else
;;;774      {
;;;775        /* Disable the selected FSMC_Bank2 interrupts */
;;;776        if(FSMC_Bank == FSMC_Bank2_NAND)
000512  2810              CMP      r0,#0x10
000514  d108              BNE      |L1.1320|
;;;777        {
;;;778          
;;;779          FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
000516  f04f4320          MOV      r3,#0xa0000000
00051a  6e5b              LDR      r3,[r3,#0x64]
00051c  ea230301          BIC      r3,r3,r1
000520  f04f4420          MOV      r4,#0xa0000000
000524  6663              STR      r3,[r4,#0x64]
000526  e013              B        |L1.1360|
                  |L1.1320|
;;;780        }
;;;781        /* Disable the selected FSMC_Bank3 interrupts */
;;;782        else if (FSMC_Bank == FSMC_Bank3_NAND)
000528  f5b07f80          CMP      r0,#0x100
00052c  d108              BNE      |L1.1344|
;;;783        {
;;;784          FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
00052e  4b30              LDR      r3,|L1.1520|
000530  681b              LDR      r3,[r3,#0]
000532  ea230301          BIC      r3,r3,r1
000536  f04f4420          MOV      r4,#0xa0000000
00053a  f8c43084          STR      r3,[r4,#0x84]
00053e  e007              B        |L1.1360|
                  |L1.1344|
;;;785        }
;;;786        /* Disable the selected FSMC_Bank4 interrupts */
;;;787        else
;;;788        {
;;;789          FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
000540  4b2c              LDR      r3,|L1.1524|
000542  681b              LDR      r3,[r3,#0]
000544  ea230301          BIC      r3,r3,r1
000548  f04f4420          MOV      r4,#0xa0000000
00054c  f8c430a4          STR      r3,[r4,#0xa4]
                  |L1.1360|
;;;790        }
;;;791      }
;;;792    }
000550  bd10              POP      {r4,pc}
;;;793    
                          ENDP

                  FSMC_GetFlagStatus PROC
;;;808      */
;;;809    FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
000552  b510              PUSH     {r4,lr}
;;;810    {
000554  4602              MOV      r2,r0
;;;811      FlagStatus bitstatus = RESET;
000556  f04f0000          MOV      r0,#0
;;;812      uint32_t tmpsr = 0x00000000;
00055a  4603              MOV      r3,r0
;;;813      
;;;814      /* Check the parameters */
;;;815      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;816      assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
;;;817      
;;;818      if(FSMC_Bank == FSMC_Bank2_NAND)
00055c  2a10              CMP      r2,#0x10
00055e  d103              BNE      |L1.1384|
;;;819      {
;;;820        tmpsr = FSMC_Bank2->SR2;
000560  f04f4420          MOV      r4,#0xa0000000
000564  6e63              LDR      r3,[r4,#0x64]
000566  e007              B        |L1.1400|
                  |L1.1384|
;;;821      }  
;;;822      else if(FSMC_Bank == FSMC_Bank3_NAND)
000568  f5b27f80          CMP      r2,#0x100
00056c  d102              BNE      |L1.1396|
;;;823      {
;;;824        tmpsr = FSMC_Bank3->SR3;
00056e  4c20              LDR      r4,|L1.1520|
000570  6823              LDR      r3,[r4,#0]
000572  e001              B        |L1.1400|
                  |L1.1396|
;;;825      }
;;;826      /* FSMC_Bank4_PCCARD*/
;;;827      else
;;;828      {
;;;829        tmpsr = FSMC_Bank4->SR4;
000574  4c1f              LDR      r4,|L1.1524|
000576  6823              LDR      r3,[r4,#0]
                  |L1.1400|
;;;830      } 
;;;831      
;;;832      /* Get the flag status */
;;;833      if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
000578  420b              TST      r3,r1
00057a  d002              BEQ      |L1.1410|
;;;834      {
;;;835        bitstatus = SET;
00057c  f04f0001          MOV      r0,#1
000580  e001              B        |L1.1414|
                  |L1.1410|
;;;836      }
;;;837      else
;;;838      {
;;;839        bitstatus = RESET;
000582  f04f0000          MOV      r0,#0
                  |L1.1414|
;;;840      }
;;;841      /* Return the flag status */
;;;842      return bitstatus;
;;;843    }
000586  bd10              POP      {r4,pc}
;;;844    
                          ENDP

                  FSMC_ClearFlag PROC
;;;858      */
;;;859    void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
000588  2810              CMP      r0,#0x10
;;;860    {
;;;861     /* Check the parameters */
;;;862      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;863      assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
;;;864        
;;;865      if(FSMC_Bank == FSMC_Bank2_NAND)
00058a  d108              BNE      |L1.1438|
;;;866      {
;;;867        FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
00058c  f04f4220          MOV      r2,#0xa0000000
000590  6e52              LDR      r2,[r2,#0x64]
000592  ea220201          BIC      r2,r2,r1
000596  f04f4320          MOV      r3,#0xa0000000
00059a  665a              STR      r2,[r3,#0x64]
00059c  e013              B        |L1.1478|
                  |L1.1438|
;;;868      }  
;;;869      else if(FSMC_Bank == FSMC_Bank3_NAND)
00059e  f5b07f80          CMP      r0,#0x100
0005a2  d108              BNE      |L1.1462|
;;;870      {
;;;871        FSMC_Bank3->SR3 &= ~FSMC_FLAG;
0005a4  4a12              LDR      r2,|L1.1520|
0005a6  6812              LDR      r2,[r2,#0]
0005a8  ea220201          BIC      r2,r2,r1
0005ac  f04f4320          MOV      r3,#0xa0000000
0005b0  f8c32084          STR      r2,[r3,#0x84]
0005b4  e007              B        |L1.1478|
                  |L1.1462|
;;;872      }
;;;873      /* FSMC_Bank4_PCCARD*/
;;;874      else
;;;875      {
;;;876        FSMC_Bank4->SR4 &= ~FSMC_FLAG;
0005b6  4a0f              LDR      r2,|L1.1524|
0005b8  6812              LDR      r2,[r2,#0]
0005ba  ea220201          BIC      r2,r2,r1
0005be  f04f4320          MOV      r3,#0xa0000000
0005c2  f8c320a4          STR      r2,[r3,#0xa4]
                  |L1.1478|
;;;877      }
;;;878    }
0005c6  4770              BX       lr
                  |L1.1480|
                          DCD      0x000ffffe
                  |L1.1484|
                          DCD      0xa0000080
                  |L1.1488|
                          DCD      0xa0000088
                  |L1.1492|
                          DCD      0xa000008c
                  |L1.1496|
                          DCD      0x000ffffb
                  |L1.1500|
                          DCD      0x000fffbf
                  |L1.1504|
                          DCD      0xa0000094
                  |L1.1508|
                          DCD      0xa00000a0
                  |L1.1512|
                          DCD      0xa00000a8
                  |L1.1516|
                          DCD      0xa00000ac
                  |L1.1520|
                          DCD      0xa0000084
                  |L1.1524|
                          DCD      0xa00000a4
                          ENDP

                  FSMC_GetITStatus PROC
;;;893      */
;;;894    ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
0005f8  b570              PUSH     {r4-r6,lr}
;;;895    {
0005fa  4602              MOV      r2,r0
;;;896      ITStatus bitstatus = RESET;
0005fc  f04f0000          MOV      r0,#0
;;;897      uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
000600  4603              MOV      r3,r0
000602  4604              MOV      r4,r0
000604  4605              MOV      r5,r0
;;;898      
;;;899      /* Check the parameters */
;;;900      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;901      assert_param(IS_FSMC_GET_IT(FSMC_IT));
;;;902      
;;;903      if(FSMC_Bank == FSMC_Bank2_NAND)
000606  2a10              CMP      r2,#0x10
000608  d103              BNE      |L1.1554|
;;;904      {
;;;905        tmpsr = FSMC_Bank2->SR2;
00060a  f04f4620          MOV      r6,#0xa0000000
00060e  6e73              LDR      r3,[r6,#0x64]
000610  e007              B        |L1.1570|
                  |L1.1554|
;;;906      }  
;;;907      else if(FSMC_Bank == FSMC_Bank3_NAND)
000612  f5b27f80          CMP      r2,#0x100
000616  d102              BNE      |L1.1566|
;;;908      {
;;;909        tmpsr = FSMC_Bank3->SR3;
000618  4e18              LDR      r6,|L1.1660|
00061a  6833              LDR      r3,[r6,#0]
00061c  e001              B        |L1.1570|
                  |L1.1566|
;;;910      }
;;;911      /* FSMC_Bank4_PCCARD*/
;;;912      else
;;;913      {
;;;914        tmpsr = FSMC_Bank4->SR4;
00061e  4e18              LDR      r6,|L1.1664|
000620  6833              LDR      r3,[r6,#0]
                  |L1.1570|
;;;915      } 
;;;916      
;;;917      itstatus = tmpsr & FSMC_IT;
000622  ea030401          AND      r4,r3,r1
;;;918      
;;;919      itenable = tmpsr & (FSMC_IT >> 3);
000626  ea0305d1          AND      r5,r3,r1,LSR #3
;;;920      if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
00062a  b11c              CBZ      r4,|L1.1588|
00062c  b115              CBZ      r5,|L1.1588|
;;;921      {
;;;922        bitstatus = SET;
00062e  f04f0001          MOV      r0,#1
000632  e001              B        |L1.1592|
                  |L1.1588|
;;;923      }
;;;924      else
;;;925      {
;;;926        bitstatus = RESET;
000634  f04f0000          MOV      r0,#0
                  |L1.1592|
;;;927      }
;;;928      return bitstatus; 
;;;929    }
000638  bd70              POP      {r4-r6,pc}
;;;930    
                          ENDP

                  FSMC_ClearITPendingBit PROC
;;;944      */
;;;945    void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
00063a  2810              CMP      r0,#0x10
;;;946    {
;;;947      /* Check the parameters */
;;;948      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;949      assert_param(IS_FSMC_IT(FSMC_IT));
;;;950        
;;;951      if(FSMC_Bank == FSMC_Bank2_NAND)
00063c  d108              BNE      |L1.1616|
;;;952      {
;;;953        FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
00063e  f04f4220          MOV      r2,#0xa0000000
000642  6e52              LDR      r2,[r2,#0x64]
000644  ea2202d1          BIC      r2,r2,r1,LSR #3
000648  f04f4320          MOV      r3,#0xa0000000
00064c  665a              STR      r2,[r3,#0x64]
00064e  e013              B        |L1.1656|
                  |L1.1616|
;;;954      }  
;;;955      else if(FSMC_Bank == FSMC_Bank3_NAND)
000650  f5b07f80          CMP      r0,#0x100
000654  d108              BNE      |L1.1640|
;;;956      {
;;;957        FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
000656  4a09              LDR      r2,|L1.1660|
000658  6812              LDR      r2,[r2,#0]
00065a  ea2202d1          BIC      r2,r2,r1,LSR #3
00065e  f04f4320          MOV      r3,#0xa0000000
000662  f8c32084          STR      r2,[r3,#0x84]
000666  e007              B        |L1.1656|
                  |L1.1640|
;;;958      }
;;;959      /* FSMC_Bank4_PCCARD*/
;;;960      else
;;;961      {
;;;962        FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
000668  4a05              LDR      r2,|L1.1664|
00066a  6812              LDR      r2,[r2,#0]
00066c  ea2202d1          BIC      r2,r2,r1,LSR #3
000670  f04f4320          MOV      r3,#0xa0000000
000674  f8c320a4          STR      r2,[r3,#0xa4]
                  |L1.1656|
;;;963      }
;;;964    }
000678  4770              BX       lr
;;;965    
                          ENDP

00067a  0000              DCW      0x0000
                  |L1.1660|
                          DCD      0xa0000084
                  |L1.1664|
                          DCD      0xa00000a4

;*** Start embedded assembler ***

#line 1 "..\\BSP\\STM32F2xx\\src\\stm32f2xx_fsmc.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_stm32f2xx_fsmc_c_2e710976____REV16|
#line 112 "..\\BSP\\CMSIS\\core_cmInstr.h"
|__asm___16_stm32f2xx_fsmc_c_2e710976____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_stm32f2xx_fsmc_c_2e710976____REVSH|
#line 130
|__asm___16_stm32f2xx_fsmc_c_2e710976____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
