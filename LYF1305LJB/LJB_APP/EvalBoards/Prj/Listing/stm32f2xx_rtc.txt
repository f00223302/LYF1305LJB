; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Output\stm32f2xx_rtc.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\Output\stm32f2xx_rtc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\BSP -I..\BSP\UCOS-II -I..\BSP\STM32F2xx\inc -I..\BSP\CMSIS -I..\BSP\CMSIS\Device_Support -I..\BSP\UCOS-II -I..\..\uC-CPU -I..\..\uC-CPU\ARM-Cortex-M3 -I..\..\uC-LIB -I..\..\uC-LIB\Ports\ARM-Cortex-M3 -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3 -I..\App -I..\Prj -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DDEBUG -DLJB_CPU_MAIN -DUSE_CPU_F205RC --omf_browse=.\Output\stm32f2xx_rtc.crf ..\BSP\STM32F2xx\src\stm32f2xx_rtc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RTC_WaitForSynchro PROC
;;;585      */
;;;586    ErrorStatus RTC_WaitForSynchro(void)
000000  b510              PUSH     {r4,lr}
;;;587    {
;;;588      __IO uint32_t synchrocounter = 0;
000002  f04f0100          MOV      r1,#0
;;;589      ErrorStatus status = ERROR;
000006  4608              MOV      r0,r1
;;;590      uint32_t synchrostatus = 0x00;
000008  4602              MOV      r2,r0
;;;591    
;;;592      /* Disable the write protection for RTC registers */
;;;593      RTC->WPR = 0xCA;
00000a  f04f03ca          MOV      r3,#0xca
00000e  4cfe              LDR      r4,|L1.1032|
000010  6023              STR      r3,[r4,#0]
;;;594      RTC->WPR = 0x53;
000012  f04f0353          MOV      r3,#0x53
000016  6023              STR      r3,[r4,#0]
;;;595        
;;;596      /* Clear RSF flag */
;;;597      RTC->ISR &= (uint32_t)RTC_RSF_MASK;
000018  4bfc              LDR      r3,|L1.1036|
00001a  681b              LDR      r3,[r3,#0]
00001c  f02303a0          BIC      r3,r3,#0xa0
000020  4cfa              LDR      r4,|L1.1036|
000022  6023              STR      r3,[r4,#0]
;;;598        
;;;599      /* Wait the registers to be synchronised */
;;;600      do
000024  bf00              NOP      
                  |L1.38|
;;;601      {
;;;602        synchrostatus = RTC->ISR & RTC_ISR_RSF;
000026  4bf9              LDR      r3,|L1.1036|
000028  681b              LDR      r3,[r3,#0]
00002a  f0030220          AND      r2,r3,#0x20
;;;603        synchrocounter++;  
00002e  f1010101          ADD      r1,r1,#1
;;;604      } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
000032  f5b14f00          CMP      r1,#0x8000
000036  d001              BEQ      |L1.60|
000038  2a00              CMP      r2,#0
00003a  d0f4              BEQ      |L1.38|
                  |L1.60|
;;;605        
;;;606      if ((RTC->ISR & RTC_ISR_RSF) != RESET)
00003c  4bf3              LDR      r3,|L1.1036|
00003e  681b              LDR      r3,[r3,#0]
000040  f0130f20          TST      r3,#0x20
000044  d002              BEQ      |L1.76|
;;;607      {
;;;608        status = SUCCESS;
000046  f04f0001          MOV      r0,#1
00004a  e001              B        |L1.80|
                  |L1.76|
;;;609      }
;;;610      else
;;;611      {
;;;612        status = ERROR;
00004c  f04f0000          MOV      r0,#0
                  |L1.80|
;;;613      }        
;;;614    
;;;615      /* Enable the write protection for RTC registers */
;;;616      RTC->WPR = 0xFF; 
000050  f04f03ff          MOV      r3,#0xff
000054  4cec              LDR      r4,|L1.1032|
000056  6023              STR      r3,[r4,#0]
;;;617        
;;;618      return (status); 
;;;619    }
000058  bd10              POP      {r4,pc}
;;;620    
                          ENDP

                  RTC_EnterInitMode PROC
;;;518      */
;;;519    ErrorStatus RTC_EnterInitMode(void)
00005a  b510              PUSH     {r4,lr}
;;;520    {
;;;521      __IO uint32_t initcounter = 0x00;
00005c  f04f0100          MOV      r1,#0
;;;522      ErrorStatus status = ERROR;
000060  4608              MOV      r0,r1
;;;523      uint32_t initstatus = 0x00;
000062  4602              MOV      r2,r0
;;;524         
;;;525      /* Check if the Initialization mode is set */
;;;526      if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
000064  4be9              LDR      r3,|L1.1036|
000066  681b              LDR      r3,[r3,#0]
000068  f0130f40          TST      r3,#0x40
00006c  d11a              BNE      |L1.164|
;;;527      {
;;;528        /* Set the Initialization mode */
;;;529        RTC->ISR = (uint32_t)RTC_INIT_MASK;
00006e  f04f33ff          MOV      r3,#0xffffffff
000072  4ce6              LDR      r4,|L1.1036|
000074  6023              STR      r3,[r4,#0]
;;;530        
;;;531        /* Wait till RTC is in INIT state and if Time out is reached exit */
;;;532        do
000076  bf00              NOP      
                  |L1.120|
;;;533        {
;;;534          initstatus = RTC->ISR & RTC_ISR_INITF;
000078  4be4              LDR      r3,|L1.1036|
00007a  681b              LDR      r3,[r3,#0]
00007c  f0030240          AND      r2,r3,#0x40
;;;535          initcounter++;  
000080  f1010101          ADD      r1,r1,#1
;;;536        } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
000084  f5b13f80          CMP      r1,#0x10000
000088  d001              BEQ      |L1.142|
00008a  2a00              CMP      r2,#0
00008c  d0f4              BEQ      |L1.120|
                  |L1.142|
;;;537        
;;;538        if ((RTC->ISR & RTC_ISR_INITF) != RESET)
00008e  4bdf              LDR      r3,|L1.1036|
000090  681b              LDR      r3,[r3,#0]
000092  f0130f40          TST      r3,#0x40
000096  d002              BEQ      |L1.158|
;;;539        {
;;;540          status = SUCCESS;
000098  f04f0001          MOV      r0,#1
00009c  e004              B        |L1.168|
                  |L1.158|
;;;541        }
;;;542        else
;;;543        {
;;;544          status = ERROR;
00009e  f04f0000          MOV      r0,#0
0000a2  e001              B        |L1.168|
                  |L1.164|
;;;545        }        
;;;546      }
;;;547      else
;;;548      {
;;;549        status = SUCCESS;  
0000a4  f04f0001          MOV      r0,#1
                  |L1.168|
;;;550      } 
;;;551        
;;;552      return (status);  
;;;553    }
0000a8  bd10              POP      {r4,pc}
;;;554    
                          ENDP

                  RTC_DeInit PROC
;;;345      */
;;;346    ErrorStatus RTC_DeInit(void)
0000aa  b570              PUSH     {r4-r6,lr}
;;;347    {
;;;348      __IO uint32_t wutcounter = 0x00;
0000ac  f04f0400          MOV      r4,#0
;;;349      uint32_t wutwfstatus = 0x00;
0000b0  4625              MOV      r5,r4
;;;350      ErrorStatus status = ERROR;
0000b2  4626              MOV      r6,r4
;;;351      
;;;352      /* Disable the write protection for RTC registers */
;;;353      RTC->WPR = 0xCA;
0000b4  f04f00ca          MOV      r0,#0xca
0000b8  49d3              LDR      r1,|L1.1032|
0000ba  6008              STR      r0,[r1,#0]
;;;354      RTC->WPR = 0x53;
0000bc  f04f0053          MOV      r0,#0x53
0000c0  6008              STR      r0,[r1,#0]
;;;355    
;;;356      /* Set Initialization mode */
;;;357      if (RTC_EnterInitMode() == ERROR)
0000c2  f7fffffe          BL       RTC_EnterInitMode
0000c6  b900              CBNZ     r0,|L1.202|
;;;358      {
;;;359        status = ERROR;
0000c8  e048              B        |L1.348|
                  |L1.202|
;;;360      }  
;;;361      else
;;;362      {
;;;363        /* Reset TR, DR and CR registers */
;;;364        RTC->TR = (uint32_t)0x00000000;
0000ca  f04f0000          MOV      r0,#0
0000ce  49d0              LDR      r1,|L1.1040|
0000d0  6008              STR      r0,[r1,#0]
;;;365        RTC->DR = (uint32_t)0x00002101;
0000d2  f2421001          MOV      r0,#0x2101
0000d6  f1010104          ADD      r1,r1,#4
0000da  6008              STR      r0,[r1,#0]
;;;366        /* Reset All CR bits except CR[2:0] */
;;;367        RTC->CR &= (uint32_t)0x00000007;
0000dc  f1010004          ADD      r0,r1,#4
0000e0  6800              LDR      r0,[r0,#0]
0000e2  f0000007          AND      r0,r0,#7
0000e6  f1010104          ADD      r1,r1,#4
0000ea  6008              STR      r0,[r1,#0]
;;;368      
;;;369        /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;370        do
0000ec  bf00              NOP      
                  |L1.238|
;;;371        {
;;;372          wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
0000ee  48c7              LDR      r0,|L1.1036|
0000f0  6800              LDR      r0,[r0,#0]
0000f2  f0000504          AND      r5,r0,#4
;;;373          wutcounter++;  
0000f6  f1040401          ADD      r4,r4,#1
;;;374        } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
0000fa  f5b43f80          CMP      r4,#0x10000
0000fe  d001              BEQ      |L1.260|
000100  2d00              CMP      r5,#0
000102  d0f4              BEQ      |L1.238|
                  |L1.260|
;;;375        
;;;376        if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
000104  48c1              LDR      r0,|L1.1036|
000106  6800              LDR      r0,[r0,#0]
000108  f0100f04          TST      r0,#4
00010c  d102              BNE      |L1.276|
;;;377        {
;;;378          status = ERROR;
00010e  f04f0600          MOV      r6,#0
000112  e023              B        |L1.348|
                  |L1.276|
;;;379        }
;;;380        else
;;;381        {
;;;382          /* Reset all RTC CR register bits */
;;;383          RTC->CR &= (uint32_t)0x00000000;
000114  48bf              LDR      r0,|L1.1044|
000116  6800              LDR      r0,[r0,#0]
000118  f04f0000          MOV      r0,#0
00011c  49bd              LDR      r1,|L1.1044|
00011e  6008              STR      r0,[r1,#0]
;;;384          RTC->WUTR = (uint32_t)0x0000FFFF;
000120  f64f70ff          MOV      r0,#0xffff
000124  49bc              LDR      r1,|L1.1048|
000126  6008              STR      r0,[r1,#0]
;;;385          RTC->PRER = (uint32_t)0x007F00FF;
000128  48bc              LDR      r0,|L1.1052|
00012a  f1a10104          SUB      r1,r1,#4
00012e  6008              STR      r0,[r1,#0]
;;;386          RTC->CALIBR = (uint32_t)0x00000000;
000130  f04f0000          MOV      r0,#0
000134  49ba              LDR      r1,|L1.1056|
000136  6008              STR      r0,[r1,#0]
;;;387          RTC->ALRMAR = (uint32_t)0x00000000;        
000138  f1010104          ADD      r1,r1,#4
00013c  6008              STR      r0,[r1,#0]
;;;388          RTC->ALRMBR = (uint32_t)0x00000000;
00013e  f1010104          ADD      r1,r1,#4
000142  6008              STR      r0,[r1,#0]
;;;389          
;;;390          /* Reset ISR register and exit initialization mode */
;;;391          RTC->ISR = (uint32_t)0x00000000;
000144  49b1              LDR      r1,|L1.1036|
000146  6008              STR      r0,[r1,#0]
;;;392          
;;;393          /* Reset Tamper and alternate functions configuration register */
;;;394          RTC->TAFCR = 0x00000000;
000148  49b6              LDR      r1,|L1.1060|
00014a  6008              STR      r0,[r1,#0]
;;;395      
;;;396          if(RTC_WaitForSynchro() == ERROR)
00014c  f7fffffe          BL       RTC_WaitForSynchro
000150  b910              CBNZ     r0,|L1.344|
;;;397          {
;;;398            status = ERROR;
000152  f04f0600          MOV      r6,#0
000156  e001              B        |L1.348|
                  |L1.344|
;;;399          }
;;;400          else
;;;401          {
;;;402            status = SUCCESS;      
000158  f04f0601          MOV      r6,#1
                  |L1.348|
;;;403          }
;;;404        }
;;;405      }
;;;406      
;;;407      /* Enable the write protection for RTC registers */
;;;408      RTC->WPR = 0xFF;  
00015c  f04f00ff          MOV      r0,#0xff
000160  49a9              LDR      r1,|L1.1032|
000162  6008              STR      r0,[r1,#0]
;;;409      
;;;410      return status;
000164  4630              MOV      r0,r6
;;;411    }
000166  bd70              POP      {r4-r6,pc}
;;;412    
                          ENDP

                  RTC_ExitInitMode PROC
;;;563      */
;;;564    void RTC_ExitInitMode(void)
000168  48a8              LDR      r0,|L1.1036|
;;;565    { 
;;;566      /* Exit Initialization mode */
;;;567      RTC->ISR &= (uint32_t)~RTC_ISR_INIT;  
00016a  6800              LDR      r0,[r0,#0]
00016c  f0200080          BIC      r0,r0,#0x80
000170  49a6              LDR      r1,|L1.1036|
000172  6008              STR      r0,[r1,#0]
;;;568    }
000174  4770              BX       lr
;;;569    
                          ENDP

                  RTC_Init PROC
;;;423      */
;;;424    ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
000176  b530              PUSH     {r4,r5,lr}
;;;425    {
000178  4604              MOV      r4,r0
;;;426      ErrorStatus status = ERROR;
00017a  f04f0500          MOV      r5,#0
;;;427      
;;;428      /* Check the parameters */
;;;429      assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
;;;430      assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
;;;431      assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));
;;;432    
;;;433      /* Disable the write protection for RTC registers */
;;;434      RTC->WPR = 0xCA;
00017e  f04f00ca          MOV      r0,#0xca
000182  49a1              LDR      r1,|L1.1032|
000184  6008              STR      r0,[r1,#0]
;;;435      RTC->WPR = 0x53;
000186  f04f0053          MOV      r0,#0x53
00018a  6008              STR      r0,[r1,#0]
;;;436    
;;;437      /* Set Initialization mode */
;;;438      if (RTC_EnterInitMode() == ERROR)
00018c  f7fffffe          BL       RTC_EnterInitMode
000190  b900              CBNZ     r0,|L1.404|
;;;439      {
;;;440        status = ERROR;
000192  e01a              B        |L1.458|
                  |L1.404|
;;;441      } 
;;;442      else
;;;443      {
;;;444        /* Clear RTC CR FMT Bit */
;;;445        RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
000194  489f              LDR      r0,|L1.1044|
000196  6800              LDR      r0,[r0,#0]
000198  f0200040          BIC      r0,r0,#0x40
00019c  499d              LDR      r1,|L1.1044|
00019e  6008              STR      r0,[r1,#0]
;;;446        /* Set RTC_CR register */
;;;447        RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
0001a0  4608              MOV      r0,r1
0001a2  6800              LDR      r0,[r0,#0]
0001a4  6821              LDR      r1,[r4,#0]
0001a6  ea400001          ORR      r0,r0,r1
0001aa  499a              LDR      r1,|L1.1044|
0001ac  6008              STR      r0,[r1,#0]
;;;448      
;;;449        /* Configure the RTC PRER */
;;;450        RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
0001ae  499e              LDR      r1,|L1.1064|
0001b0  68a0              LDR      r0,[r4,#8]
0001b2  6008              STR      r0,[r1,#0]
;;;451        RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
0001b4  4608              MOV      r0,r1
0001b6  6800              LDR      r0,[r0,#0]
0001b8  6861              LDR      r1,[r4,#4]
0001ba  ea404001          ORR      r0,r0,r1,LSL #16
0001be  499a              LDR      r1,|L1.1064|
0001c0  6008              STR      r0,[r1,#0]
;;;452    
;;;453        /* Exit Initialization mode */
;;;454        RTC_ExitInitMode();
0001c2  f7fffffe          BL       RTC_ExitInitMode
;;;455    
;;;456        status = SUCCESS;    
0001c6  f04f0501          MOV      r5,#1
                  |L1.458|
;;;457      }
;;;458      /* Enable the write protection for RTC registers */
;;;459      RTC->WPR = 0xFF; 
0001ca  f04f00ff          MOV      r0,#0xff
0001ce  498e              LDR      r1,|L1.1032|
0001d0  6008              STR      r0,[r1,#0]
;;;460      
;;;461      return status;
0001d2  4628              MOV      r0,r5
;;;462    }
0001d4  bd30              POP      {r4,r5,pc}
;;;463    
                          ENDP

                  RTC_StructInit PROC
;;;469      */
;;;470    void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
0001d6  f04f0100          MOV      r1,#0
;;;471    {
;;;472      /* Initialize the RTC_HourFormat member */
;;;473      RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
0001da  6001              STR      r1,[r0,#0]
;;;474        
;;;475      /* Initialize the RTC_AsynchPrediv member */
;;;476      RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
0001dc  f04f017f          MOV      r1,#0x7f
0001e0  6041              STR      r1,[r0,#4]
;;;477    
;;;478      /* Initialize the RTC_SynchPrediv member */
;;;479      RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
0001e2  f04f01ff          MOV      r1,#0xff
0001e6  6081              STR      r1,[r0,#8]
;;;480    }
0001e8  4770              BX       lr
;;;481    
                          ENDP

                  RTC_WriteProtectionCmd PROC
;;;491      */
;;;492    void RTC_WriteProtectionCmd(FunctionalState NewState)
0001ea  b120              CBZ      r0,|L1.502|
;;;493    {
;;;494      /* Check the parameters */
;;;495      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;496        
;;;497      if (NewState != DISABLE)
;;;498      {
;;;499        /* Enable the write protection for RTC registers */
;;;500        RTC->WPR = 0xFF;   
0001ec  f04f01ff          MOV      r1,#0xff
0001f0  4a85              LDR      r2,|L1.1032|
0001f2  6011              STR      r1,[r2,#0]
0001f4  e006              B        |L1.516|
                  |L1.502|
;;;501      }
;;;502      else
;;;503      {
;;;504        /* Disable the write protection for RTC registers */
;;;505        RTC->WPR = 0xCA;
0001f6  f04f01ca          MOV      r1,#0xca
0001fa  4a83              LDR      r2,|L1.1032|
0001fc  6011              STR      r1,[r2,#0]
;;;506        RTC->WPR = 0x53;    
0001fe  f04f0153          MOV      r1,#0x53
000202  6011              STR      r1,[r2,#0]
                  |L1.516|
;;;507      }
;;;508    }
000204  4770              BX       lr
;;;509    
                          ENDP

                  RTC_RefClockCmd PROC
;;;628      */
;;;629    ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
000206  b530              PUSH     {r4,r5,lr}
;;;630    { 
000208  4604              MOV      r4,r0
;;;631      ErrorStatus status = ERROR;
00020a  f04f0500          MOV      r5,#0
;;;632      
;;;633      /* Check the parameters */
;;;634      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;635      
;;;636      /* Disable the write protection for RTC registers */
;;;637      RTC->WPR = 0xCA;
00020e  f04f00ca          MOV      r0,#0xca
000212  497d              LDR      r1,|L1.1032|
000214  6008              STR      r0,[r1,#0]
;;;638      RTC->WPR = 0x53;
000216  f04f0053          MOV      r0,#0x53
00021a  6008              STR      r0,[r1,#0]
;;;639        
;;;640      /* Set Initialization mode */
;;;641      if (RTC_EnterInitMode() == ERROR)
00021c  f7fffffe          BL       RTC_EnterInitMode
000220  b900              CBNZ     r0,|L1.548|
;;;642      {
;;;643        status = ERROR;
000222  e011              B        |L1.584|
                  |L1.548|
;;;644      } 
;;;645      else
;;;646      {  
;;;647        if (NewState != DISABLE)
000224  b134              CBZ      r4,|L1.564|
;;;648        {
;;;649          /* Enable the RTC reference clock detection */
;;;650          RTC->CR |= RTC_CR_REFCKON;   
000226  487b              LDR      r0,|L1.1044|
000228  6800              LDR      r0,[r0,#0]
00022a  f0400010          ORR      r0,r0,#0x10
00022e  4979              LDR      r1,|L1.1044|
000230  6008              STR      r0,[r1,#0]
000232  e005              B        |L1.576|
                  |L1.564|
;;;651        }
;;;652        else
;;;653        {
;;;654          /* Disable the RTC reference clock detection */
;;;655          RTC->CR &= ~RTC_CR_REFCKON;    
000234  4877              LDR      r0,|L1.1044|
000236  6800              LDR      r0,[r0,#0]
000238  f0200010          BIC      r0,r0,#0x10
00023c  4975              LDR      r1,|L1.1044|
00023e  6008              STR      r0,[r1,#0]
                  |L1.576|
;;;656        }
;;;657        /* Exit Initialization mode */
;;;658        RTC_ExitInitMode();
000240  f7fffffe          BL       RTC_ExitInitMode
;;;659        
;;;660        status = SUCCESS;
000244  f04f0501          MOV      r5,#1
                  |L1.584|
;;;661      }
;;;662      
;;;663      /* Enable the write protection for RTC registers */
;;;664      RTC->WPR = 0xFF;  
000248  f04f00ff          MOV      r0,#0xff
00024c  496e              LDR      r1,|L1.1032|
00024e  6008              STR      r0,[r1,#0]
;;;665      
;;;666      return status; 
000250  4628              MOV      r0,r5
;;;667    }
000252  bd30              POP      {r4,r5,pc}
;;;668    
                          ENDP

                  RTC_ByteToBcd2 PROC
;;;2339     */
;;;2340   static uint8_t RTC_ByteToBcd2(uint8_t Value)
000254  4601              MOV      r1,r0
;;;2341   {
;;;2342     uint8_t bcdhigh = 0;
000256  f04f0200          MOV      r2,#0
;;;2343     
;;;2344     while (Value >= 10)
00025a  e005              B        |L1.616|
                  |L1.604|
;;;2345     {
;;;2346       bcdhigh++;
00025c  f1020001          ADD      r0,r2,#1
000260  b2c2              UXTB     r2,r0
;;;2347       Value -= 10;
000262  f1a1000a          SUB      r0,r1,#0xa
000266  b2c1              UXTB     r1,r0
                  |L1.616|
000268  290a              CMP      r1,#0xa               ;2344
00026a  daf7              BGE      |L1.604|
;;;2348     }
;;;2349     
;;;2350     return  ((uint8_t)(bcdhigh << 4) | Value);
00026c  0710              LSLS     r0,r2,#28
00026e  ea416010          ORR      r0,r1,r0,LSR #24
;;;2351   }
000272  4770              BX       lr
;;;2352   
                          ENDP

                  RTC_Bcd2ToByte PROC
;;;2357     */
;;;2358   static uint8_t RTC_Bcd2ToByte(uint8_t Value)
000274  4601              MOV      r1,r0
;;;2359   {
;;;2360     uint8_t tmp = 0;
000276  bf00              NOP      
;;;2361     tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
000278  ea4f1011          LSR      r0,r1,#4
00027c  eb000080          ADD      r0,r0,r0,LSL #2
000280  ea4f0240          LSL      r2,r0,#1
;;;2362     return (tmp + (Value & (uint8_t)0x0F));
000284  f001000f          AND      r0,r1,#0xf
000288  4410              ADD      r0,r0,r2
00028a  b2c0              UXTB     r0,r0
;;;2363   }
00028c  4770              BX       lr
;;;2364   
                          ENDP

                  RTC_SetTime PROC
;;;699      */
;;;700    ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
00028e  e92d41f0          PUSH     {r4-r8,lr}
;;;701    {
000292  4605              MOV      r5,r0
000294  460c              MOV      r4,r1
;;;702      uint32_t tmpreg = 0;
000296  f04f0600          MOV      r6,#0
;;;703      ErrorStatus status = ERROR;
00029a  4637              MOV      r7,r6
;;;704        
;;;705      /* Check the parameters */
;;;706      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;707      
;;;708      if (RTC_Format == RTC_Format_BIN)
00029c  b955              CBNZ     r5,|L1.692|
;;;709      {
;;;710        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
00029e  485d              LDR      r0,|L1.1044|
0002a0  6800              LDR      r0,[r0,#0]
0002a2  f0100f40          TST      r0,#0x40
0002a6  d000              BEQ      |L1.682|
;;;711        {
;;;712          assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
;;;713          assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
0002a8  e003              B        |L1.690|
                  |L1.682|
;;;714        } 
;;;715        else
;;;716        {
;;;717          RTC_TimeStruct->RTC_H12 = 0x00;
0002aa  f04f0000          MOV      r0,#0
0002ae  70e0              STRB     r0,[r4,#3]
;;;718          assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
0002b0  bf00              NOP      
                  |L1.690|
;;;719        }
;;;720        assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
;;;721        assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
0002b2  e00e              B        |L1.722|
                  |L1.692|
;;;722      }
;;;723      else
;;;724      {
;;;725        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
0002b4  4857              LDR      r0,|L1.1044|
0002b6  6800              LDR      r0,[r0,#0]
0002b8  f0100f40          TST      r0,#0x40
0002bc  d004              BEQ      |L1.712|
;;;726        {
;;;727          tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
0002be  7820              LDRB     r0,[r4,#0]
0002c0  f7fffffe          BL       RTC_Bcd2ToByte
0002c4  4606              MOV      r6,r0
;;;728          assert_param(IS_RTC_HOUR12(tmpreg));
;;;729          assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
0002c6  e003              B        |L1.720|
                  |L1.712|
;;;730        } 
;;;731        else
;;;732        {
;;;733          RTC_TimeStruct->RTC_H12 = 0x00;
0002c8  f04f0000          MOV      r0,#0
0002cc  70e0              STRB     r0,[r4,#3]
;;;734          assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
0002ce  bf00              NOP      
                  |L1.720|
;;;735        }
;;;736        assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
;;;737        assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
0002d0  bf00              NOP      
                  |L1.722|
;;;738      }
;;;739      
;;;740      /* Check the input parameters format */
;;;741      if (RTC_Format != RTC_Format_BIN)
0002d2  b165              CBZ      r5,|L1.750|
;;;742      {
;;;743        tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
0002d4  7820              LDRB     r0,[r4,#0]
0002d6  ea4f4000          LSL      r0,r0,#16
0002da  7861              LDRB     r1,[r4,#1]
0002dc  ea402001          ORR      r0,r0,r1,LSL #8
0002e0  78a1              LDRB     r1,[r4,#2]
0002e2  ea400001          ORR      r0,r0,r1
0002e6  78e1              LDRB     r1,[r4,#3]
0002e8  ea404601          ORR      r6,r0,r1,LSL #16
0002ec  e011              B        |L1.786|
                  |L1.750|
;;;744                 ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;745                 ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
;;;746                 ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
;;;747      }  
;;;748      else
;;;749      {
;;;750        tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
0002ee  7820              LDRB     r0,[r4,#0]
0002f0  f7fffffe          BL       RTC_ByteToBcd2
0002f4  ea4f4800          LSL      r8,r0,#16
0002f8  7860              LDRB     r0,[r4,#1]
0002fa  f7fffffe          BL       RTC_ByteToBcd2
0002fe  ea482800          ORR      r8,r8,r0,LSL #8
000302  78a0              LDRB     r0,[r4,#2]
000304  f7fffffe          BL       RTC_ByteToBcd2
000308  ea480800          ORR      r8,r8,r0
00030c  78e0              LDRB     r0,[r4,#3]
00030e  ea484600          ORR      r6,r8,r0,LSL #16
                  |L1.786|
;;;751                       ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;752                       ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
;;;753                       (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
;;;754      }  
;;;755    
;;;756      /* Disable the write protection for RTC registers */
;;;757      RTC->WPR = 0xCA;
000312  f04f00ca          MOV      r0,#0xca
000316  493c              LDR      r1,|L1.1032|
000318  6008              STR      r0,[r1,#0]
;;;758      RTC->WPR = 0x53;
00031a  f04f0053          MOV      r0,#0x53
00031e  6008              STR      r0,[r1,#0]
;;;759    
;;;760      /* Set Initialization mode */
;;;761      if (RTC_EnterInitMode() == ERROR)
000320  f7fffffe          BL       RTC_EnterInitMode
000324  b910              CBNZ     r0,|L1.812|
;;;762      {
;;;763        status = ERROR;
000326  f04f0700          MOV      r7,#0
00032a  e00e              B        |L1.842|
                  |L1.812|
;;;764      } 
;;;765      else
;;;766      {
;;;767        /* Set the RTC_TR register */
;;;768        RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
00032c  483f              LDR      r0,|L1.1068|
00032e  ea060000          AND      r0,r6,r0
000332  4937              LDR      r1,|L1.1040|
000334  6008              STR      r0,[r1,#0]
;;;769    
;;;770        /* Exit Initialization mode */
;;;771        RTC_ExitInitMode(); 
000336  f7fffffe          BL       RTC_ExitInitMode
;;;772    
;;;773        if(RTC_WaitForSynchro() == ERROR)
00033a  f7fffffe          BL       RTC_WaitForSynchro
00033e  b910              CBNZ     r0,|L1.838|
;;;774        {
;;;775          status = ERROR;
000340  f04f0700          MOV      r7,#0
000344  e001              B        |L1.842|
                  |L1.838|
;;;776        }
;;;777        else
;;;778        {
;;;779          status = SUCCESS;
000346  f04f0701          MOV      r7,#1
                  |L1.842|
;;;780        }
;;;781      
;;;782      }
;;;783      /* Enable the write protection for RTC registers */
;;;784      RTC->WPR = 0xFF; 
00034a  f04f00ff          MOV      r0,#0xff
00034e  492e              LDR      r1,|L1.1032|
000350  6008              STR      r0,[r1,#0]
;;;785        
;;;786      return status;
000352  4638              MOV      r0,r7
;;;787    }
000354  e8bd81f0          POP      {r4-r8,pc}
;;;788    
                          ENDP

                  RTC_TimeStructInit PROC
;;;795      */
;;;796    void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
000358  f04f0100          MOV      r1,#0
;;;797    {
;;;798      /* Time = 00h:00min:00sec */
;;;799      RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
00035c  70c1              STRB     r1,[r0,#3]
;;;800      RTC_TimeStruct->RTC_Hours = 0;
00035e  7001              STRB     r1,[r0,#0]
;;;801      RTC_TimeStruct->RTC_Minutes = 0;
000360  7041              STRB     r1,[r0,#1]
;;;802      RTC_TimeStruct->RTC_Seconds = 0; 
000362  7081              STRB     r1,[r0,#2]
;;;803    }
000364  4770              BX       lr
;;;804    
                          ENDP

                  RTC_GetTime PROC
;;;814      */
;;;815    void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
000366  b570              PUSH     {r4-r6,lr}
;;;816    {
000368  4606              MOV      r6,r0
00036a  460c              MOV      r4,r1
;;;817      uint32_t tmpreg = 0;
00036c  f04f0500          MOV      r5,#0
;;;818    
;;;819      /* Check the parameters */
;;;820      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;821    
;;;822      /* Get the RTC_TR register */
;;;823      tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
000370  4827              LDR      r0,|L1.1040|
000372  6800              LDR      r0,[r0,#0]
000374  492d              LDR      r1,|L1.1068|
000376  ea000501          AND      r5,r0,r1
;;;824      
;;;825      /* Fill the structure fields with the read parameters */
;;;826      RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
00037a  f3c54005          UBFX     r0,r5,#16,#6
00037e  7020              STRB     r0,[r4,#0]
;;;827      RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
000380  f3c52006          UBFX     r0,r5,#8,#7
000384  7060              STRB     r0,[r4,#1]
;;;828      RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
000386  f005007f          AND      r0,r5,#0x7f
00038a  70a0              STRB     r0,[r4,#2]
;;;829      RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
00038c  f4050080          AND      r0,r5,#0x400000
000390  ea4f4010          LSR      r0,r0,#16
000394  70e0              STRB     r0,[r4,#3]
;;;830    
;;;831      /* Check the input parameters format */
;;;832      if (RTC_Format == RTC_Format_BIN)
000396  b95e              CBNZ     r6,|L1.944|
;;;833      {
;;;834        /* Convert the structure parameters to Binary format */
;;;835        RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
000398  7820              LDRB     r0,[r4,#0]
00039a  f7fffffe          BL       RTC_Bcd2ToByte
00039e  7020              STRB     r0,[r4,#0]
;;;836        RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
0003a0  7860              LDRB     r0,[r4,#1]
0003a2  f7fffffe          BL       RTC_Bcd2ToByte
0003a6  7060              STRB     r0,[r4,#1]
;;;837        RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
0003a8  78a0              LDRB     r0,[r4,#2]
0003aa  f7fffffe          BL       RTC_Bcd2ToByte
0003ae  70a0              STRB     r0,[r4,#2]
                  |L1.944|
;;;838      }
;;;839    }
0003b0  bd70              POP      {r4-r6,pc}
;;;840    
                          ENDP

                  RTC_SetDate PROC
;;;852      */
;;;853    ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
0003b2  e92d41f0          PUSH     {r4-r8,lr}
;;;854    {
0003b6  4605              MOV      r5,r0
0003b8  460c              MOV      r4,r1
;;;855      uint32_t tmpreg = 0;
0003ba  f04f0600          MOV      r6,#0
;;;856      ErrorStatus status = ERROR;
0003be  4637              MOV      r7,r6
;;;857      
;;;858      /* Check the parameters */
;;;859      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;860    
;;;861      if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
0003c0  b955              CBNZ     r5,|L1.984|
0003c2  7860              LDRB     r0,[r4,#1]
0003c4  f0000010          AND      r0,r0,#0x10
0003c8  2810              CMP      r0,#0x10
0003ca  d105              BNE      |L1.984|
;;;862      {
;;;863        RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
0003cc  7860              LDRB     r0,[r4,#1]
0003ce  f0200010          BIC      r0,r0,#0x10
0003d2  f100000a          ADD      r0,r0,#0xa
0003d6  7060              STRB     r0,[r4,#1]
                  |L1.984|
;;;864      }  
;;;865      if (RTC_Format == RTC_Format_BIN)
0003d8  b905              CBNZ     r5,|L1.988|
;;;866      {
;;;867        assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
;;;868        assert_param(IS_RTC_MONTH(RTC_DateStruct->RTC_Month));
;;;869        assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
0003da  e008              B        |L1.1006|
                  |L1.988|
;;;870      }
;;;871      else
;;;872      {
;;;873        assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
;;;874        tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
0003dc  7860              LDRB     r0,[r4,#1]
0003de  f7fffffe          BL       RTC_Bcd2ToByte
0003e2  4606              MOV      r6,r0
;;;875        assert_param(IS_RTC_MONTH(tmpreg));
;;;876        tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
0003e4  78a0              LDRB     r0,[r4,#2]
0003e6  f7fffffe          BL       RTC_Bcd2ToByte
0003ea  4606              MOV      r6,r0
;;;877        assert_param(IS_RTC_DATE(tmpreg));
0003ec  bf00              NOP      
                  |L1.1006|
;;;878      }
;;;879      assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
;;;880    
;;;881      /* Check the input parameters format */
;;;882      if (RTC_Format != RTC_Format_BIN)
0003ee  b155              CBZ      r5,|L1.1030|
;;;883      {
;;;884        tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
0003f0  78e0              LDRB     r0,[r4,#3]
0003f2  ea4f4000          LSL      r0,r0,#16
0003f6  7861              LDRB     r1,[r4,#1]
0003f8  ea402001          ORR      r0,r0,r1,LSL #8
0003fc  78a1              LDRB     r1,[r4,#2]
0003fe  ea400001          ORR      r0,r0,r1
000402  7821              LDRB     r1,[r4,#0]
000404  e014              B        |L1.1072|
                  |L1.1030|
000406  e016              B        |L1.1078|
                  |L1.1032|
                          DCD      0x40002824
                  |L1.1036|
                          DCD      0x4000280c
                  |L1.1040|
                          DCD      0x40002800
                  |L1.1044|
                          DCD      0x40002808
                  |L1.1048|
                          DCD      0x40002814
                  |L1.1052|
                          DCD      0x007f00ff
                  |L1.1056|
                          DCD      0x40002818
                  |L1.1060|
                          DCD      0x40002840
                  |L1.1064|
                          DCD      0x40002810
                  |L1.1068|
                          DCD      0x007f7f7f
                  |L1.1072|
000430  ea403641          ORR      r6,r0,r1,LSL #13
000434  e011              B        |L1.1114|
                  |L1.1078|
;;;885                  (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
;;;886                  ((uint32_t)RTC_DateStruct->RTC_Date) | \
;;;887                  (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
;;;888      }  
;;;889      else
;;;890      {
;;;891        tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
000436  78e0              LDRB     r0,[r4,#3]
000438  f7fffffe          BL       RTC_ByteToBcd2
00043c  ea4f4800          LSL      r8,r0,#16
000440  7860              LDRB     r0,[r4,#1]
000442  f7fffffe          BL       RTC_ByteToBcd2
000446  ea482800          ORR      r8,r8,r0,LSL #8
00044a  78a0              LDRB     r0,[r4,#2]
00044c  f7fffffe          BL       RTC_ByteToBcd2
000450  ea480800          ORR      r8,r8,r0
000454  7820              LDRB     r0,[r4,#0]
000456  ea483640          ORR      r6,r8,r0,LSL #13
                  |L1.1114|
;;;892                  ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
;;;893                  ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
;;;894                  ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
;;;895      }
;;;896    
;;;897      /* Disable the write protection for RTC registers */
;;;898      RTC->WPR = 0xCA;
00045a  f04f00ca          MOV      r0,#0xca
00045e  49f9              LDR      r1,|L1.2116|
000460  6008              STR      r0,[r1,#0]
;;;899      RTC->WPR = 0x53;
000462  f04f0053          MOV      r0,#0x53
000466  6008              STR      r0,[r1,#0]
;;;900    
;;;901      /* Set Initialization mode */
;;;902      if (RTC_EnterInitMode() == ERROR)
000468  f7fffffe          BL       RTC_EnterInitMode
00046c  b910              CBNZ     r0,|L1.1140|
;;;903      {
;;;904        status = ERROR;
00046e  f04f0700          MOV      r7,#0
000472  e00e              B        |L1.1170|
                  |L1.1140|
;;;905      } 
;;;906      else
;;;907      {
;;;908        /* Set the RTC_DR register */
;;;909        RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
000474  48f4              LDR      r0,|L1.2120|
000476  ea060000          AND      r0,r6,r0
00047a  49f4              LDR      r1,|L1.2124|
00047c  6008              STR      r0,[r1,#0]
;;;910    
;;;911        /* Exit Initialization mode */
;;;912        RTC_ExitInitMode(); 
00047e  f7fffffe          BL       RTC_ExitInitMode
;;;913    
;;;914        if(RTC_WaitForSynchro() == ERROR)
000482  f7fffffe          BL       RTC_WaitForSynchro
000486  b910              CBNZ     r0,|L1.1166|
;;;915        {
;;;916          status = ERROR;
000488  f04f0700          MOV      r7,#0
00048c  e001              B        |L1.1170|
                  |L1.1166|
;;;917        }
;;;918        else
;;;919        {
;;;920          status = SUCCESS;
00048e  f04f0701          MOV      r7,#1
                  |L1.1170|
;;;921        }
;;;922      }
;;;923      /* Enable the write protection for RTC registers */
;;;924      RTC->WPR = 0xFF;   
000492  f04f00ff          MOV      r0,#0xff
000496  49eb              LDR      r1,|L1.2116|
000498  6008              STR      r0,[r1,#0]
;;;925      
;;;926      return status;
00049a  4638              MOV      r0,r7
;;;927    }
00049c  e8bd81f0          POP      {r4-r8,pc}
;;;928    
                          ENDP

                  RTC_SetDateTime PROC
;;;930    
;;;931    ErrorStatus RTC_SetDateTime(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct, RTC_TimeTypeDef* RTC_TimeStruct)
0004a0  e92d47f0          PUSH     {r4-r10,lr}
;;;932    {
0004a4  4606              MOV      r6,r0
0004a6  460c              MOV      r4,r1
0004a8  4615              MOV      r5,r2
;;;933    	uint32_t tmpreg = 0;
0004aa  f04f0700          MOV      r7,#0
;;;934    	ErrorStatus status = ERROR;
0004ae  46b8              MOV      r8,r7
;;;935    	
;;;936    	/* Check the parameters */
;;;937    	assert_param(IS_RTC_FORMAT(RTC_Format));
;;;938      
;;;939    	if (RTC_Format == RTC_Format_BIN)
0004b0  b95e              CBNZ     r6,|L1.1226|
;;;940    	{
;;;941    		if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
0004b2  48e6              LDR      r0,|L1.2124|
0004b4  1d00              ADDS     r0,r0,#4
0004b6  6800              LDR      r0,[r0,#0]
0004b8  f0100f40          TST      r0,#0x40
0004bc  d000              BEQ      |L1.1216|
;;;942    		{
;;;943    			assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
;;;944    			assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
0004be  e003              B        |L1.1224|
                  |L1.1216|
;;;945    		} 
;;;946    		else
;;;947    		{
;;;948    			RTC_TimeStruct->RTC_H12 = 0x00;
0004c0  f04f0000          MOV      r0,#0
0004c4  70e8              STRB     r0,[r5,#3]
;;;949    			assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
0004c6  bf00              NOP      
                  |L1.1224|
;;;950    		}
;;;951    		assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
;;;952    		assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
0004c8  e00f              B        |L1.1258|
                  |L1.1226|
;;;953    	}
;;;954    	else
;;;955    	{
;;;956    		if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
0004ca  48e0              LDR      r0,|L1.2124|
0004cc  1d00              ADDS     r0,r0,#4
0004ce  6800              LDR      r0,[r0,#0]
0004d0  f0100f40          TST      r0,#0x40
0004d4  d004              BEQ      |L1.1248|
;;;957    		{
;;;958    			tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
0004d6  7828              LDRB     r0,[r5,#0]
0004d8  f7fffffe          BL       RTC_Bcd2ToByte
0004dc  4607              MOV      r7,r0
;;;959    			assert_param(IS_RTC_HOUR12(tmpreg));
;;;960    			assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
0004de  e003              B        |L1.1256|
                  |L1.1248|
;;;961    		} 
;;;962    		else
;;;963    		{
;;;964    			RTC_TimeStruct->RTC_H12 = 0x00;
0004e0  f04f0000          MOV      r0,#0
0004e4  70e8              STRB     r0,[r5,#3]
;;;965    			assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
0004e6  bf00              NOP      
                  |L1.1256|
;;;966    		}
;;;967    		assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
;;;968    		assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
0004e8  bf00              NOP      
                  |L1.1258|
;;;969    	}
;;;970      
;;;971    	/* Check the input parameters format */
;;;972    	if (RTC_Format != RTC_Format_BIN)
0004ea  b166              CBZ      r6,|L1.1286|
;;;973    	{
;;;974    		tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
0004ec  7828              LDRB     r0,[r5,#0]
0004ee  ea4f4000          LSL      r0,r0,#16
0004f2  7869              LDRB     r1,[r5,#1]
0004f4  ea402001          ORR      r0,r0,r1,LSL #8
0004f8  78a9              LDRB     r1,[r5,#2]
0004fa  ea400001          ORR      r0,r0,r1
0004fe  78e9              LDRB     r1,[r5,#3]
000500  ea404701          ORR      r7,r0,r1,LSL #16
000504  e011              B        |L1.1322|
                  |L1.1286|
;;;975    				((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;976    				((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
;;;977    				((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
;;;978    	}  
;;;979    	else
;;;980    	{
;;;981    		tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
000506  7828              LDRB     r0,[r5,#0]
000508  f7fffffe          BL       RTC_ByteToBcd2
00050c  ea4f4900          LSL      r9,r0,#16
000510  7868              LDRB     r0,[r5,#1]
000512  f7fffffe          BL       RTC_ByteToBcd2
000516  ea492900          ORR      r9,r9,r0,LSL #8
00051a  78a8              LDRB     r0,[r5,#2]
00051c  f7fffffe          BL       RTC_ByteToBcd2
000520  ea490900          ORR      r9,r9,r0
000524  78e8              LDRB     r0,[r5,#3]
000526  ea494700          ORR      r7,r9,r0,LSL #16
                  |L1.1322|
;;;982    				((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;983    				((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
;;;984    				(((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
;;;985    	}  
;;;986    
;;;987    	/* Disable the write protection for RTC registers */
;;;988    	RTC->WPR = 0xCA;
00052a  f04f00ca          MOV      r0,#0xca
00052e  49c5              LDR      r1,|L1.2116|
000530  6008              STR      r0,[r1,#0]
;;;989    	RTC->WPR = 0x53;
000532  f04f0053          MOV      r0,#0x53
000536  6008              STR      r0,[r1,#0]
;;;990    
;;;991    	/* Set Initialization mode */
;;;992    	if (RTC_EnterInitMode() == ERROR)
000538  f7fffffe          BL       RTC_EnterInitMode
00053c  b910              CBNZ     r0,|L1.1348|
;;;993    	{
;;;994    		status = ERROR;
00053e  f04f0800          MOV      r8,#0
000542  e006              B        |L1.1362|
                  |L1.1348|
;;;995    	} 
;;;996    	else
;;;997    	{
;;;998    		/* Set the RTC_TR register */
;;;999    		RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
000544  48c2              LDR      r0,|L1.2128|
000546  ea070000          AND      r0,r7,r0
00054a  49c2              LDR      r1,|L1.2132|
00054c  6008              STR      r0,[r1,#0]
;;;1000   		status = SUCCESS;
00054e  f04f0801          MOV      r8,#1
                  |L1.1362|
;;;1001   	}
;;;1002   	if (status == ERROR){
000552  f1b80f00          CMP      r8,#0
000556  d106              BNE      |L1.1382|
;;;1003   		/* Enable the write protection for RTC registers */
;;;1004   		RTC->WPR = 0xFF; 
000558  f04f00ff          MOV      r0,#0xff
00055c  49b9              LDR      r1,|L1.2116|
00055e  6008              STR      r0,[r1,#0]
;;;1005   		return status;
000560  4640              MOV      r0,r8
                  |L1.1378|
;;;1006   	}
;;;1007     
;;;1008   
;;;1009   	if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
;;;1010   	{
;;;1011   		RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
;;;1012   	}  
;;;1013   	if (RTC_Format == RTC_Format_BIN)
;;;1014   	{
;;;1015   		assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
;;;1016   		assert_param(IS_RTC_MONTH(RTC_DateStruct->RTC_Month));
;;;1017   		assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
;;;1018   	}
;;;1019   	else
;;;1020   	{
;;;1021   		assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
;;;1022   		tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
;;;1023   		assert_param(IS_RTC_MONTH(tmpreg));
;;;1024   		tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
;;;1025   		assert_param(IS_RTC_DATE(tmpreg));
;;;1026   	}
;;;1027   	assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
;;;1028   
;;;1029   	/* Check the input parameters format */
;;;1030   	if (RTC_Format != RTC_Format_BIN)
;;;1031   	{
;;;1032   		tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
;;;1033   				(((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
;;;1034   				((uint32_t)RTC_DateStruct->RTC_Date) | \
;;;1035   				(((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
;;;1036   	}  
;;;1037   	else
;;;1038   	{
;;;1039   		tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
;;;1040   				((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
;;;1041   				((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
;;;1042   				((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
;;;1043   	}
;;;1044   
;;;1045       /* Set the RTC_DR register */
;;;1046       RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
;;;1047   
;;;1048       /* Exit Initialization mode */
;;;1049       RTC_ExitInitMode(); 
;;;1050   
;;;1051       if(RTC_WaitForSynchro() == ERROR)
;;;1052       {
;;;1053   		status = ERROR;
;;;1054       }
;;;1055   	else
;;;1056       {
;;;1057   		status = SUCCESS;
;;;1058   	}
;;;1059   	
;;;1060   	/* Enable the write protection for RTC registers */
;;;1061   	RTC->WPR = 0xFF;   
;;;1062   	
;;;1063   	return status;
;;;1064   }
000562  e8bd87f0          POP      {r4-r10,pc}
                  |L1.1382|
000566  b956              CBNZ     r6,|L1.1406|
000568  7860              LDRB     r0,[r4,#1]            ;1009
00056a  f0000010          AND      r0,r0,#0x10           ;1009
00056e  2810              CMP      r0,#0x10              ;1009
000570  d105              BNE      |L1.1406|
000572  7860              LDRB     r0,[r4,#1]            ;1011
000574  f0200010          BIC      r0,r0,#0x10           ;1011
000578  f100000a          ADD      r0,r0,#0xa            ;1011
00057c  7060              STRB     r0,[r4,#1]            ;1011
                  |L1.1406|
00057e  b906              CBNZ     r6,|L1.1410|
000580  e008              B        |L1.1428|
                  |L1.1410|
000582  7860              LDRB     r0,[r4,#1]            ;1022
000584  f7fffffe          BL       RTC_Bcd2ToByte
000588  4607              MOV      r7,r0                 ;1022
00058a  78a0              LDRB     r0,[r4,#2]            ;1024
00058c  f7fffffe          BL       RTC_Bcd2ToByte
000590  4607              MOV      r7,r0                 ;1024
000592  bf00              NOP                            ;1025
                  |L1.1428|
000594  b166              CBZ      r6,|L1.1456|
000596  78e0              LDRB     r0,[r4,#3]            ;1032
000598  ea4f4000          LSL      r0,r0,#16             ;1032
00059c  7861              LDRB     r1,[r4,#1]            ;1032
00059e  ea402001          ORR      r0,r0,r1,LSL #8       ;1032
0005a2  78a1              LDRB     r1,[r4,#2]            ;1032
0005a4  ea400001          ORR      r0,r0,r1              ;1032
0005a8  7821              LDRB     r1,[r4,#0]            ;1032
0005aa  ea403741          ORR      r7,r0,r1,LSL #13      ;1032
0005ae  e011              B        |L1.1492|
                  |L1.1456|
0005b0  78e0              LDRB     r0,[r4,#3]            ;1039
0005b2  f7fffffe          BL       RTC_ByteToBcd2
0005b6  ea4f4900          LSL      r9,r0,#16             ;1039
0005ba  7860              LDRB     r0,[r4,#1]            ;1039
0005bc  f7fffffe          BL       RTC_ByteToBcd2
0005c0  ea492900          ORR      r9,r9,r0,LSL #8       ;1039
0005c4  78a0              LDRB     r0,[r4,#2]            ;1039
0005c6  f7fffffe          BL       RTC_ByteToBcd2
0005ca  ea490900          ORR      r9,r9,r0              ;1039
0005ce  7820              LDRB     r0,[r4,#0]            ;1039
0005d0  ea493740          ORR      r7,r9,r0,LSL #13      ;1039
                  |L1.1492|
0005d4  489c              LDR      r0,|L1.2120|
0005d6  ea070000          AND      r0,r7,r0              ;1046
0005da  499c              LDR      r1,|L1.2124|
0005dc  6008              STR      r0,[r1,#0]            ;1046
0005de  f7fffffe          BL       RTC_ExitInitMode
0005e2  f7fffffe          BL       RTC_WaitForSynchro
0005e6  b910              CBNZ     r0,|L1.1518|
0005e8  f04f0800          MOV      r8,#0                 ;1053
0005ec  e001              B        |L1.1522|
                  |L1.1518|
0005ee  f04f0801          MOV      r8,#1                 ;1057
                  |L1.1522|
0005f2  f04f00ff          MOV      r0,#0xff              ;1061
0005f6  4993              LDR      r1,|L1.2116|
0005f8  6008              STR      r0,[r1,#0]            ;1061
0005fa  4640              MOV      r0,r8                 ;1063
0005fc  e7b1              B        |L1.1378|
;;;1065   
                          ENDP

                  RTC_DateStructInit PROC
;;;1073     */
;;;1074   void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
0005fe  f04f0101          MOV      r1,#1
;;;1075   {
;;;1076     /* Monday, January 01 xx00 */
;;;1077     RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
000602  7001              STRB     r1,[r0,#0]
;;;1078     RTC_DateStruct->RTC_Date = 1;
000604  7081              STRB     r1,[r0,#2]
;;;1079     RTC_DateStruct->RTC_Month = RTC_Month_January;
000606  7041              STRB     r1,[r0,#1]
;;;1080     RTC_DateStruct->RTC_Year = 0;
000608  f04f0100          MOV      r1,#0
00060c  70c1              STRB     r1,[r0,#3]
;;;1081   }
00060e  4770              BX       lr
;;;1082   
                          ENDP

                  RTC_GetDate PROC
;;;1092     */
;;;1093   void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
000610  b570              PUSH     {r4-r6,lr}
;;;1094   {
000612  4606              MOV      r6,r0
000614  460c              MOV      r4,r1
;;;1095     uint32_t tmpreg = 0;
000616  f04f0500          MOV      r5,#0
;;;1096   
;;;1097     /* Check the parameters */
;;;1098     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1099     
;;;1100     /* Get the RTC_TR register */
;;;1101     tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
00061a  488c              LDR      r0,|L1.2124|
00061c  6800              LDR      r0,[r0,#0]
00061e  498a              LDR      r1,|L1.2120|
000620  ea000501          AND      r5,r0,r1
;;;1102   
;;;1103     /* Fill the structure fields with the read parameters */
;;;1104     RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
000624  ea4f4015          LSR      r0,r5,#16
000628  70e0              STRB     r0,[r4,#3]
;;;1105     RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
00062a  f3c52004          UBFX     r0,r5,#8,#5
00062e  7060              STRB     r0,[r4,#1]
;;;1106     RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
000630  f005003f          AND      r0,r5,#0x3f
000634  70a0              STRB     r0,[r4,#2]
;;;1107     RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);  
000636  f3c53042          UBFX     r0,r5,#13,#3
00063a  7020              STRB     r0,[r4,#0]
;;;1108   
;;;1109     /* Check the input parameters format */
;;;1110     if (RTC_Format == RTC_Format_BIN)
00063c  b96e              CBNZ     r6,|L1.1626|
;;;1111     {
;;;1112       /* Convert the structure parameters to Binary format */
;;;1113       RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
00063e  78e0              LDRB     r0,[r4,#3]
000640  f7fffffe          BL       RTC_Bcd2ToByte
000644  70e0              STRB     r0,[r4,#3]
;;;1114       RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
000646  7860              LDRB     r0,[r4,#1]
000648  f7fffffe          BL       RTC_Bcd2ToByte
00064c  7060              STRB     r0,[r4,#1]
;;;1115       RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
00064e  78a0              LDRB     r0,[r4,#2]
000650  f7fffffe          BL       RTC_Bcd2ToByte
000654  70a0              STRB     r0,[r4,#2]
;;;1116       RTC_DateStruct->RTC_WeekDay = (uint8_t)(RTC_DateStruct->RTC_WeekDay);   
000656  7820              LDRB     r0,[r4,#0]
000658  7020              STRB     r0,[r4,#0]
                  |L1.1626|
;;;1117     }
;;;1118   }
00065a  bd70              POP      {r4-r6,pc}
;;;1119   
                          ENDP

                  RTC_SetAlarm PROC
;;;1153     */
;;;1154   void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
00065c  e92d41f0          PUSH     {r4-r8,lr}
;;;1155   {
000660  4605              MOV      r5,r0
000662  460e              MOV      r6,r1
000664  4614              MOV      r4,r2
;;;1156     uint32_t tmpreg = 0;
000666  f04f0700          MOV      r7,#0
;;;1157     
;;;1158     /* Check the parameters */
;;;1159     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1160     assert_param(IS_RTC_ALARM(RTC_Alarm));
;;;1161     assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
;;;1162     assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));
;;;1163   
;;;1164     if (RTC_Format == RTC_Format_BIN)
00066a  b975              CBNZ     r5,|L1.1674|
;;;1165     {
;;;1166       if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
00066c  4877              LDR      r0,|L1.2124|
00066e  1d00              ADDS     r0,r0,#4
000670  6800              LDR      r0,[r0,#0]
000672  f0100f40          TST      r0,#0x40
000676  d000              BEQ      |L1.1658|
;;;1167       {
;;;1168         assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
;;;1169         assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
000678  e003              B        |L1.1666|
                  |L1.1658|
;;;1170       } 
;;;1171       else
;;;1172       {
;;;1173         RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
00067a  f04f0000          MOV      r0,#0
00067e  70e0              STRB     r0,[r4,#3]
;;;1174         assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
000680  bf00              NOP      
                  |L1.1666|
;;;1175       }
;;;1176       assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
;;;1177       assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
;;;1178       
;;;1179       if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
000682  68a0              LDR      r0,[r4,#8]
000684  b900              CBNZ     r0,|L1.1672|
;;;1180       {
;;;1181         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
000686  e01b              B        |L1.1728|
                  |L1.1672|
;;;1182       }
;;;1183       else
;;;1184       {
;;;1185         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
000688  e01a              B        |L1.1728|
                  |L1.1674|
;;;1186       }
;;;1187     }
;;;1188     else
;;;1189     {
;;;1190       if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
00068a  4870              LDR      r0,|L1.2124|
00068c  1d00              ADDS     r0,r0,#4
00068e  6800              LDR      r0,[r0,#0]
000690  f0100f40          TST      r0,#0x40
000694  d004              BEQ      |L1.1696|
;;;1191       {
;;;1192         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
000696  7820              LDRB     r0,[r4,#0]
000698  f7fffffe          BL       RTC_Bcd2ToByte
00069c  4607              MOV      r7,r0
;;;1193         assert_param(IS_RTC_HOUR12(tmpreg));
;;;1194         assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
00069e  e003              B        |L1.1704|
                  |L1.1696|
;;;1195       } 
;;;1196       else
;;;1197       {
;;;1198         RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
0006a0  f04f0000          MOV      r0,#0
0006a4  70e0              STRB     r0,[r4,#3]
;;;1199         assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
0006a6  bf00              NOP      
                  |L1.1704|
;;;1200       }
;;;1201       
;;;1202       assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
;;;1203       assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
;;;1204       
;;;1205       if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
0006a8  68a0              LDR      r0,[r4,#8]
0006aa  b920              CBNZ     r0,|L1.1718|
;;;1206       {
;;;1207         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
0006ac  7b20              LDRB     r0,[r4,#0xc]
0006ae  f7fffffe          BL       RTC_Bcd2ToByte
0006b2  4607              MOV      r7,r0
;;;1208         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
0006b4  e004              B        |L1.1728|
                  |L1.1718|
;;;1209       }
;;;1210       else
;;;1211       {
;;;1212         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
0006b6  7b20              LDRB     r0,[r4,#0xc]
0006b8  f7fffffe          BL       RTC_Bcd2ToByte
0006bc  4607              MOV      r7,r0
;;;1213         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
0006be  bf00              NOP      
                  |L1.1728|
;;;1214       }    
;;;1215     }
;;;1216   
;;;1217     /* Check the input parameters format */
;;;1218     if (RTC_Format != RTC_Format_BIN)
0006c0  b1ad              CBZ      r5,|L1.1774|
;;;1219     {
;;;1220       tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
0006c2  7820              LDRB     r0,[r4,#0]
0006c4  ea4f4000          LSL      r0,r0,#16
0006c8  7861              LDRB     r1,[r4,#1]
0006ca  ea402001          ORR      r0,r0,r1,LSL #8
0006ce  78a1              LDRB     r1,[r4,#2]
0006d0  ea400001          ORR      r0,r0,r1
0006d4  78e1              LDRB     r1,[r4,#3]
0006d6  ea404001          ORR      r0,r0,r1,LSL #16
0006da  7b21              LDRB     r1,[r4,#0xc]
0006dc  ea406001          ORR      r0,r0,r1,LSL #24
0006e0  68a1              LDR      r1,[r4,#8]
0006e2  ea400001          ORR      r0,r0,r1
0006e6  6861              LDR      r1,[r4,#4]
0006e8  ea400701          ORR      r7,r0,r1
0006ec  e01c              B        |L1.1832|
                  |L1.1774|
;;;1221                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
;;;1222                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
;;;1223                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
;;;1224                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
;;;1225                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
;;;1226                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
;;;1227     }  
;;;1228     else
;;;1229     {
;;;1230       tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
0006ee  7820              LDRB     r0,[r4,#0]
0006f0  f7fffffe          BL       RTC_ByteToBcd2
0006f4  ea4f4800          LSL      r8,r0,#16
0006f8  7860              LDRB     r0,[r4,#1]
0006fa  f7fffffe          BL       RTC_ByteToBcd2
0006fe  ea482800          ORR      r8,r8,r0,LSL #8
000702  78a0              LDRB     r0,[r4,#2]
000704  f7fffffe          BL       RTC_ByteToBcd2
000708  ea480800          ORR      r8,r8,r0
00070c  78e0              LDRB     r0,[r4,#3]
00070e  ea484800          ORR      r8,r8,r0,LSL #16
000712  7b20              LDRB     r0,[r4,#0xc]
000714  f7fffffe          BL       RTC_ByteToBcd2
000718  ea486000          ORR      r0,r8,r0,LSL #24
00071c  68a1              LDR      r1,[r4,#8]
00071e  ea400001          ORR      r0,r0,r1
000722  6861              LDR      r1,[r4,#4]
000724  ea400701          ORR      r7,r0,r1
                  |L1.1832|
;;;1231                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
;;;1232                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
;;;1233                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
;;;1234                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
;;;1235                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
;;;1236                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
;;;1237     } 
;;;1238   
;;;1239     /* Disable the write protection for RTC registers */
;;;1240     RTC->WPR = 0xCA;
000728  f04f00ca          MOV      r0,#0xca
00072c  4945              LDR      r1,|L1.2116|
00072e  6008              STR      r0,[r1,#0]
;;;1241     RTC->WPR = 0x53;
000730  f04f0053          MOV      r0,#0x53
000734  6008              STR      r0,[r1,#0]
;;;1242   
;;;1243     /* Configure the Alarm register */
;;;1244     if (RTC_Alarm == RTC_Alarm_A)
000736  f5b67f80          CMP      r6,#0x100
00073a  d102              BNE      |L1.1858|
;;;1245     {
;;;1246       RTC->ALRMAR = (uint32_t)tmpreg;
00073c  4846              LDR      r0,|L1.2136|
00073e  6007              STR      r7,[r0,#0]
000740  e001              B        |L1.1862|
                  |L1.1858|
;;;1247     }
;;;1248     else
;;;1249     {
;;;1250       RTC->ALRMBR = (uint32_t)tmpreg;
000742  4846              LDR      r0,|L1.2140|
000744  6007              STR      r7,[r0,#0]
                  |L1.1862|
;;;1251     }
;;;1252   
;;;1253     /* Enable the write protection for RTC registers */
;;;1254     RTC->WPR = 0xFF;   
000746  f04f00ff          MOV      r0,#0xff
00074a  493e              LDR      r1,|L1.2116|
00074c  6008              STR      r0,[r1,#0]
;;;1255   }
00074e  e8bd81f0          POP      {r4-r8,pc}
;;;1256   
                          ENDP

                  RTC_AlarmStructInit PROC
;;;1264     */
;;;1265   void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
000752  f04f0100          MOV      r1,#0
;;;1266   {
;;;1267     /* Alarm Time Settings : Time = 00h:00mn:00sec */
;;;1268     RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
000756  70c1              STRB     r1,[r0,#3]
;;;1269     RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
000758  7001              STRB     r1,[r0,#0]
;;;1270     RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
00075a  7041              STRB     r1,[r0,#1]
;;;1271     RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
00075c  7081              STRB     r1,[r0,#2]
;;;1272   
;;;1273     /* Alarm Date Settings : Date = 1st day of the month */
;;;1274     RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
00075e  6081              STR      r1,[r0,#8]
;;;1275     RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
000760  f04f0101          MOV      r1,#1
000764  7301              STRB     r1,[r0,#0xc]
;;;1276   
;;;1277     /* Alarm Masks Settings : Mask =  all fields are not masked */
;;;1278     RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
000766  f04f0100          MOV      r1,#0
00076a  6041              STR      r1,[r0,#4]
;;;1279   }
00076c  4770              BX       lr
;;;1280   
                          ENDP

                  RTC_GetAlarm PROC
;;;1294     */
;;;1295   void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
00076e  e92d41f0          PUSH     {r4-r8,lr}
;;;1296   {
000772  4606              MOV      r6,r0
000774  460f              MOV      r7,r1
000776  4614              MOV      r4,r2
;;;1297     uint32_t tmpreg = 0;
000778  f04f0500          MOV      r5,#0
;;;1298   
;;;1299     /* Check the parameters */
;;;1300     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1301     assert_param(IS_RTC_ALARM(RTC_Alarm)); 
;;;1302   
;;;1303     /* Get the RTC_ALRMxR register */
;;;1304     if (RTC_Alarm == RTC_Alarm_A)
00077c  f5b77f80          CMP      r7,#0x100
000780  d102              BNE      |L1.1928|
;;;1305     {
;;;1306       tmpreg = (uint32_t)(RTC->ALRMAR);
000782  4835              LDR      r0,|L1.2136|
000784  6805              LDR      r5,[r0,#0]
000786  e001              B        |L1.1932|
                  |L1.1928|
;;;1307     }
;;;1308     else
;;;1309     {
;;;1310       tmpreg = (uint32_t)(RTC->ALRMBR);
000788  4834              LDR      r0,|L1.2140|
00078a  6805              LDR      r5,[r0,#0]
                  |L1.1932|
;;;1311     }
;;;1312   
;;;1313     /* Fill the structure with the read parameters */
;;;1314     RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
00078c  f3c54005          UBFX     r0,r5,#16,#6
000790  7020              STRB     r0,[r4,#0]
;;;1315                                                        RTC_ALRMAR_HU)) >> 16);
;;;1316     RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
000792  f3c52006          UBFX     r0,r5,#8,#7
000796  7060              STRB     r0,[r4,#1]
;;;1317                                                        RTC_ALRMAR_MNU)) >> 8);
;;;1318     RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
000798  f005007f          AND      r0,r5,#0x7f
00079c  70a0              STRB     r0,[r4,#2]
;;;1319                                                        RTC_ALRMAR_SU));
;;;1320     RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
00079e  f4050080          AND      r0,r5,#0x400000
0007a2  ea4f4010          LSR      r0,r0,#16
0007a6  70e0              STRB     r0,[r4,#3]
;;;1321     RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
0007a8  f3c56005          UBFX     r0,r5,#24,#6
0007ac  7320              STRB     r0,[r4,#0xc]
;;;1322     RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
0007ae  f0054080          AND      r0,r5,#0x40000000
0007b2  60a0              STR      r0,[r4,#8]
;;;1323     RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
0007b4  f0053080          AND      r0,r5,#0x80808080
0007b8  6060              STR      r0,[r4,#4]
;;;1324   
;;;1325     if (RTC_Format == RTC_Format_BIN)
0007ba  b97e              CBNZ     r6,|L1.2012|
;;;1326     {
;;;1327       RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
0007bc  7820              LDRB     r0,[r4,#0]
0007be  f7fffffe          BL       RTC_Bcd2ToByte
0007c2  7020              STRB     r0,[r4,#0]
;;;1328                                                           RTC_AlarmTime.RTC_Hours);
;;;1329       RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
0007c4  7860              LDRB     r0,[r4,#1]
0007c6  f7fffffe          BL       RTC_Bcd2ToByte
0007ca  7060              STRB     r0,[r4,#1]
;;;1330                                                           RTC_AlarmTime.RTC_Minutes);
;;;1331       RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
0007cc  78a0              LDRB     r0,[r4,#2]
0007ce  f7fffffe          BL       RTC_Bcd2ToByte
0007d2  70a0              STRB     r0,[r4,#2]
;;;1332                                                           RTC_AlarmTime.RTC_Seconds);
;;;1333       RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
0007d4  7b20              LDRB     r0,[r4,#0xc]
0007d6  f7fffffe          BL       RTC_Bcd2ToByte
0007da  7320              STRB     r0,[r4,#0xc]
                  |L1.2012|
;;;1334     }  
;;;1335   }
0007dc  e8bd81f0          POP      {r4-r8,pc}
;;;1336   
                          ENDP

                  RTC_AlarmCmd PROC
;;;1348     */
;;;1349   ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
0007e0  b570              PUSH     {r4-r6,lr}
;;;1350   {
0007e2  4602              MOV      r2,r0
;;;1351     __IO uint32_t alarmcounter = 0x00;
0007e4  f04f0300          MOV      r3,#0
;;;1352     uint32_t alarmstatus = 0x00;
0007e8  461c              MOV      r4,r3
;;;1353     ErrorStatus status = ERROR;
0007ea  4618              MOV      r0,r3
;;;1354       
;;;1355     /* Check the parameters */
;;;1356     assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
;;;1357     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1358   
;;;1359     /* Disable the write protection for RTC registers */
;;;1360     RTC->WPR = 0xCA;
0007ec  f04f05ca          MOV      r5,#0xca
0007f0  4e14              LDR      r6,|L1.2116|
0007f2  6035              STR      r5,[r6,#0]
;;;1361     RTC->WPR = 0x53;
0007f4  f04f0553          MOV      r5,#0x53
0007f8  6035              STR      r5,[r6,#0]
;;;1362   
;;;1363     /* Configure the Alarm state */
;;;1364     if (NewState != DISABLE)
0007fa  b141              CBZ      r1,|L1.2062|
;;;1365     {
;;;1366       RTC->CR |= (uint32_t)RTC_Alarm;
0007fc  4d18              LDR      r5,|L1.2144|
0007fe  682d              LDR      r5,[r5,#0]
000800  ea450502          ORR      r5,r5,r2
000804  4e16              LDR      r6,|L1.2144|
000806  6035              STR      r5,[r6,#0]
;;;1367   
;;;1368       status = SUCCESS;    
000808  f04f0001          MOV      r0,#1
00080c  e02e              B        |L1.2156|
                  |L1.2062|
;;;1369     }
;;;1370     else
;;;1371     { 
;;;1372       /* Disable the Alarm in RTC_CR register */
;;;1373       RTC->CR &= (uint32_t)~RTC_Alarm;
00080e  4d14              LDR      r5,|L1.2144|
000810  682d              LDR      r5,[r5,#0]
000812  ea250502          BIC      r5,r5,r2
000816  4e12              LDR      r6,|L1.2144|
000818  6035              STR      r5,[r6,#0]
;;;1374      
;;;1375       /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
;;;1376       do
00081a  bf00              NOP      
                  |L1.2076|
;;;1377       {
;;;1378         alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
00081c  4d11              LDR      r5,|L1.2148|
00081e  682d              LDR      r5,[r5,#0]
000820  ea052412          AND      r4,r5,r2,LSR #8
;;;1379         alarmcounter++;  
000824  f1030301          ADD      r3,r3,#1
;;;1380       } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
000828  f5b33f80          CMP      r3,#0x10000
00082c  d001              BEQ      |L1.2098|
00082e  2c00              CMP      r4,#0
000830  d0f4              BEQ      |L1.2076|
                  |L1.2098|
;;;1381       
;;;1382       if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
000832  4d0c              LDR      r5,|L1.2148|
000834  682d              LDR      r5,[r5,#0]
000836  ea152f12          TST      r5,r2,LSR #8
00083a  d115              BNE      |L1.2152|
;;;1383       {
;;;1384         status = ERROR;
00083c  f04f0000          MOV      r0,#0
000840  e014              B        |L1.2156|
000842  0000              DCW      0x0000
                  |L1.2116|
                          DCD      0x40002824
                  |L1.2120|
                          DCD      0x00ffff3f
                  |L1.2124|
                          DCD      0x40002804
                  |L1.2128|
                          DCD      0x007f7f7f
                  |L1.2132|
                          DCD      0x40002800
                  |L1.2136|
                          DCD      0x4000281c
                  |L1.2140|
                          DCD      0x40002820
                  |L1.2144|
                          DCD      0x40002808
                  |L1.2148|
                          DCD      0x4000280c
                  |L1.2152|
;;;1385       } 
;;;1386       else
;;;1387       {
;;;1388         status = SUCCESS;
000868  f04f0001          MOV      r0,#1
                  |L1.2156|
;;;1389       }        
;;;1390     } 
;;;1391   
;;;1392     /* Enable the write protection for RTC registers */
;;;1393     RTC->WPR = 0xFF; 
00086c  f04f05ff          MOV      r5,#0xff
000870  4ef8              LDR      r6,|L1.3156|
000872  6035              STR      r5,[r6,#0]
;;;1394     
;;;1395     return status;
;;;1396   }
000874  bd70              POP      {r4-r6,pc}
;;;1397   
                          ENDP

                  RTC_WakeUpClockConfig PROC
;;;1429     */
;;;1430   void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock)
000876  f04f01ca          MOV      r1,#0xca
;;;1431   {
;;;1432     /* Check the parameters */
;;;1433     assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));
;;;1434   
;;;1435     /* Disable the write protection for RTC registers */
;;;1436     RTC->WPR = 0xCA;
00087a  4af6              LDR      r2,|L1.3156|
00087c  6011              STR      r1,[r2,#0]
;;;1437     RTC->WPR = 0x53;
00087e  f04f0153          MOV      r1,#0x53
000882  6011              STR      r1,[r2,#0]
;;;1438   
;;;1439     /* Clear the Wakeup Timer clock source bits in CR register */
;;;1440     RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
000884  49f4              LDR      r1,|L1.3160|
000886  6809              LDR      r1,[r1,#0]
000888  f0210107          BIC      r1,r1,#7
00088c  4af2              LDR      r2,|L1.3160|
00088e  6011              STR      r1,[r2,#0]
;;;1441   
;;;1442     /* Configure the clock source */
;;;1443     RTC->CR |= (uint32_t)RTC_WakeUpClock;
000890  4611              MOV      r1,r2
000892  6809              LDR      r1,[r1,#0]
000894  ea410100          ORR      r1,r1,r0
000898  6011              STR      r1,[r2,#0]
;;;1444     
;;;1445     /* Enable the write protection for RTC registers */
;;;1446     RTC->WPR = 0xFF; 
00089a  f04f01ff          MOV      r1,#0xff
00089e  4aed              LDR      r2,|L1.3156|
0008a0  6011              STR      r1,[r2,#0]
;;;1447   }
0008a2  4770              BX       lr
;;;1448   
                          ENDP

                  RTC_SetWakeUpCounter PROC
;;;1456     */
;;;1457   void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter)
0008a4  f04f01ca          MOV      r1,#0xca
;;;1458   {
;;;1459     /* Check the parameters */
;;;1460     assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
;;;1461     
;;;1462     /* Disable the write protection for RTC registers */
;;;1463     RTC->WPR = 0xCA;
0008a8  4aea              LDR      r2,|L1.3156|
0008aa  6011              STR      r1,[r2,#0]
;;;1464     RTC->WPR = 0x53;
0008ac  f04f0153          MOV      r1,#0x53
0008b0  6011              STR      r1,[r2,#0]
;;;1465     
;;;1466     /* Configure the Wakeup Timer counter */
;;;1467     RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
0008b2  49ea              LDR      r1,|L1.3164|
0008b4  6008              STR      r0,[r1,#0]
;;;1468     
;;;1469     /* Enable the write protection for RTC registers */
;;;1470     RTC->WPR = 0xFF; 
0008b6  f04f01ff          MOV      r1,#0xff
0008ba  6011              STR      r1,[r2,#0]
;;;1471   }
0008bc  4770              BX       lr
;;;1472   
                          ENDP

                  RTC_GetWakeUpCounter PROC
;;;1477     */
;;;1478   uint32_t RTC_GetWakeUpCounter(void)
0008be  48e7              LDR      r0,|L1.3164|
;;;1479   {
;;;1480     /* Get the counter value */
;;;1481     return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
0008c0  6800              LDR      r0,[r0,#0]
0008c2  b280              UXTH     r0,r0
;;;1482   }
0008c4  4770              BX       lr
;;;1483   
                          ENDP

                  RTC_WakeUpCmd PROC
;;;1489     */
;;;1490   ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
0008c6  b530              PUSH     {r4,r5,lr}
;;;1491   {
0008c8  4601              MOV      r1,r0
;;;1492     __IO uint32_t wutcounter = 0x00;
0008ca  f04f0200          MOV      r2,#0
;;;1493     uint32_t wutwfstatus = 0x00;
0008ce  4613              MOV      r3,r2
;;;1494     ErrorStatus status = ERROR;
0008d0  4610              MOV      r0,r2
;;;1495     
;;;1496     /* Check the parameters */
;;;1497     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1498   
;;;1499     /* Disable the write protection for RTC registers */
;;;1500     RTC->WPR = 0xCA;
0008d2  f04f04ca          MOV      r4,#0xca
0008d6  4ddf              LDR      r5,|L1.3156|
0008d8  602c              STR      r4,[r5,#0]
;;;1501     RTC->WPR = 0x53;
0008da  f04f0453          MOV      r4,#0x53
0008de  602c              STR      r4,[r5,#0]
;;;1502   
;;;1503     if (NewState != DISABLE)
0008e0  b141              CBZ      r1,|L1.2292|
;;;1504     {
;;;1505       /* Enable the Wakeup Timer */
;;;1506       RTC->CR |= (uint32_t)RTC_CR_WUTE;
0008e2  4cdd              LDR      r4,|L1.3160|
0008e4  6824              LDR      r4,[r4,#0]
0008e6  f4446480          ORR      r4,r4,#0x400
0008ea  4ddb              LDR      r5,|L1.3160|
0008ec  602c              STR      r4,[r5,#0]
;;;1507       status = SUCCESS;    
0008ee  f04f0001          MOV      r0,#1
0008f2  e01b              B        |L1.2348|
                  |L1.2292|
;;;1508     }
;;;1509     else
;;;1510     {
;;;1511       /* Disable the Wakeup Timer */
;;;1512       RTC->CR &= (uint32_t)~RTC_CR_WUTE;
0008f4  4cd8              LDR      r4,|L1.3160|
0008f6  6824              LDR      r4,[r4,#0]
0008f8  f4246480          BIC      r4,r4,#0x400
0008fc  4dd6              LDR      r5,|L1.3160|
0008fe  602c              STR      r4,[r5,#0]
;;;1513       /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;1514       do
000900  bf00              NOP      
                  |L1.2306|
;;;1515       {
;;;1516         wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
000902  4cd7              LDR      r4,|L1.3168|
000904  6824              LDR      r4,[r4,#0]
000906  f0040304          AND      r3,r4,#4
;;;1517         wutcounter++;  
00090a  f1020201          ADD      r2,r2,#1
;;;1518       } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
00090e  f5b23f80          CMP      r2,#0x10000
000912  d001              BEQ      |L1.2328|
000914  2b00              CMP      r3,#0
000916  d0f4              BEQ      |L1.2306|
                  |L1.2328|
;;;1519       
;;;1520       if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
000918  4cd1              LDR      r4,|L1.3168|
00091a  6824              LDR      r4,[r4,#0]
00091c  f0140f04          TST      r4,#4
000920  d102              BNE      |L1.2344|
;;;1521       {
;;;1522         status = ERROR;
000922  f04f0000          MOV      r0,#0
000926  e001              B        |L1.2348|
                  |L1.2344|
;;;1523       }
;;;1524       else
;;;1525       {
;;;1526         status = SUCCESS;
000928  f04f0001          MOV      r0,#1
                  |L1.2348|
;;;1527       }    
;;;1528     }
;;;1529   
;;;1530     /* Enable the write protection for RTC registers */
;;;1531     RTC->WPR = 0xFF; 
00092c  f04f04ff          MOV      r4,#0xff
000930  4dc8              LDR      r5,|L1.3156|
000932  602c              STR      r4,[r5,#0]
;;;1532     
;;;1533     return status;
;;;1534   }
000934  bd30              POP      {r4,r5,pc}
;;;1535   
                          ENDP

                  RTC_DayLightSavingConfig PROC
;;;1566     */
;;;1567   void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
000936  f04f02ca          MOV      r2,#0xca
;;;1568   {
;;;1569     /* Check the parameters */
;;;1570     assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
;;;1571     assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));
;;;1572   
;;;1573     /* Disable the write protection for RTC registers */
;;;1574     RTC->WPR = 0xCA;
00093a  4bc6              LDR      r3,|L1.3156|
00093c  601a              STR      r2,[r3,#0]
;;;1575     RTC->WPR = 0x53;
00093e  f04f0253          MOV      r2,#0x53
000942  601a              STR      r2,[r3,#0]
;;;1576   
;;;1577     /* Clear the bits to be configured */
;;;1578     RTC->CR &= (uint32_t)~(RTC_CR_BCK);
000944  4ac4              LDR      r2,|L1.3160|
000946  6812              LDR      r2,[r2,#0]
000948  f4222280          BIC      r2,r2,#0x40000
00094c  4bc2              LDR      r3,|L1.3160|
00094e  601a              STR      r2,[r3,#0]
;;;1579   
;;;1580     /* Configure the RTC_CR register */
;;;1581     RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
000950  461a              MOV      r2,r3
000952  6812              LDR      r2,[r2,#0]
000954  ea400301          ORR      r3,r0,r1
000958  ea420203          ORR      r2,r2,r3
00095c  4bbe              LDR      r3,|L1.3160|
00095e  601a              STR      r2,[r3,#0]
;;;1582   
;;;1583     /* Enable the write protection for RTC registers */
;;;1584     RTC->WPR = 0xFF; 
000960  f04f02ff          MOV      r2,#0xff
000964  4bbb              LDR      r3,|L1.3156|
000966  601a              STR      r2,[r3,#0]
;;;1585   }
000968  4770              BX       lr
;;;1586   
                          ENDP

                  RTC_GetStoreOperation PROC
;;;1593     */
;;;1594   uint32_t RTC_GetStoreOperation(void)
00096a  48bb              LDR      r0,|L1.3160|
;;;1595   {
;;;1596     return (RTC->CR & RTC_CR_BCK);
00096c  6800              LDR      r0,[r0,#0]
00096e  f4002080          AND      r0,r0,#0x40000
;;;1597   }
000972  4770              BX       lr
;;;1598   
                          ENDP

                  RTC_OutputConfig PROC
;;;1632     */
;;;1633   void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
000974  f04f02ca          MOV      r2,#0xca
;;;1634   {
;;;1635     /* Check the parameters */
;;;1636     assert_param(IS_RTC_OUTPUT(RTC_Output));
;;;1637     assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));
;;;1638   
;;;1639     /* Disable the write protection for RTC registers */
;;;1640     RTC->WPR = 0xCA;
000978  4bb6              LDR      r3,|L1.3156|
00097a  601a              STR      r2,[r3,#0]
;;;1641     RTC->WPR = 0x53;
00097c  f04f0253          MOV      r2,#0x53
000980  601a              STR      r2,[r3,#0]
;;;1642   
;;;1643     /* Clear the bits to be configured */
;;;1644     RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
000982  4ab5              LDR      r2,|L1.3160|
000984  6812              LDR      r2,[r2,#0]
000986  f42202e0          BIC      r2,r2,#0x700000
00098a  4bb3              LDR      r3,|L1.3160|
00098c  601a              STR      r2,[r3,#0]
;;;1645   
;;;1646     /* Configure the output selection and polarity */
;;;1647     RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
00098e  461a              MOV      r2,r3
000990  6812              LDR      r2,[r2,#0]
000992  ea400301          ORR      r3,r0,r1
000996  ea420203          ORR      r2,r2,r3
00099a  4baf              LDR      r3,|L1.3160|
00099c  601a              STR      r2,[r3,#0]
;;;1648   
;;;1649     /* Enable the write protection for RTC registers */
;;;1650     RTC->WPR = 0xFF; 
00099e  f04f02ff          MOV      r2,#0xff
0009a2  4bac              LDR      r3,|L1.3156|
0009a4  601a              STR      r2,[r3,#0]
;;;1651   }
0009a6  4770              BX       lr
;;;1652   
                          ENDP

                  RTC_CoarseCalibConfig PROC
;;;1686     */
;;;1687   ErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value)
0009a8  b570              PUSH     {r4-r6,lr}
;;;1688   {
0009aa  4604              MOV      r4,r0
0009ac  460d              MOV      r5,r1
;;;1689     ErrorStatus status = ERROR;
0009ae  f04f0600          MOV      r6,#0
;;;1690      
;;;1691     /* Check the parameters */
;;;1692     assert_param(IS_RTC_CALIB_SIGN(RTC_CalibSign));
;;;1693     assert_param(IS_RTC_CALIB_VALUE(Value)); 
;;;1694   
;;;1695     /* Disable the write protection for RTC registers */
;;;1696     RTC->WPR = 0xCA;
0009b2  f04f00ca          MOV      r0,#0xca
0009b6  49a7              LDR      r1,|L1.3156|
0009b8  6008              STR      r0,[r1,#0]
;;;1697     RTC->WPR = 0x53;
0009ba  f04f0053          MOV      r0,#0x53
0009be  6008              STR      r0,[r1,#0]
;;;1698   
;;;1699     /* Set Initialization mode */
;;;1700     if (RTC_EnterInitMode() == ERROR)
0009c0  f7fffffe          BL       RTC_EnterInitMode
0009c4  b900              CBNZ     r0,|L1.2504|
;;;1701     {
;;;1702       status = ERROR;
0009c6  e007              B        |L1.2520|
                  |L1.2504|
;;;1703     } 
;;;1704     else
;;;1705     {
;;;1706       /* Set the coarse calibration value */
;;;1707       RTC->CALIBR = (uint32_t)(RTC_CalibSign | Value);
0009c8  ea440005          ORR      r0,r4,r5
0009cc  49a5              LDR      r1,|L1.3172|
0009ce  6008              STR      r0,[r1,#0]
;;;1708       /* Exit Initialization mode */
;;;1709       RTC_ExitInitMode();
0009d0  f7fffffe          BL       RTC_ExitInitMode
;;;1710       
;;;1711       status = SUCCESS;
0009d4  f04f0601          MOV      r6,#1
                  |L1.2520|
;;;1712     } 
;;;1713   
;;;1714     /* Enable the write protection for RTC registers */
;;;1715     RTC->WPR = 0xFF; 
0009d8  f04f00ff          MOV      r0,#0xff
0009dc  499d              LDR      r1,|L1.3156|
0009de  6008              STR      r0,[r1,#0]
;;;1716     
;;;1717     return status;
0009e0  4630              MOV      r0,r6
;;;1718   }
0009e2  bd70              POP      {r4-r6,pc}
;;;1719   
                          ENDP

                  RTC_CoarseCalibCmd PROC
;;;1727     */
;;;1728   ErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState)
0009e4  b530              PUSH     {r4,r5,lr}
;;;1729   {
0009e6  4604              MOV      r4,r0
;;;1730     ErrorStatus status = ERROR;
0009e8  f04f0500          MOV      r5,#0
;;;1731     
;;;1732     /* Check the parameters */
;;;1733     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1734   
;;;1735     /* Disable the write protection for RTC registers */
;;;1736     RTC->WPR = 0xCA;
0009ec  f04f00ca          MOV      r0,#0xca
0009f0  4998              LDR      r1,|L1.3156|
0009f2  6008              STR      r0,[r1,#0]
;;;1737     RTC->WPR = 0x53;
0009f4  f04f0053          MOV      r0,#0x53
0009f8  6008              STR      r0,[r1,#0]
;;;1738     
;;;1739     /* Set Initialization mode */
;;;1740     if (RTC_EnterInitMode() == ERROR)
0009fa  f7fffffe          BL       RTC_EnterInitMode
0009fe  b900              CBNZ     r0,|L1.2562|
;;;1741     {
;;;1742       status =  ERROR;
000a00  e011              B        |L1.2598|
                  |L1.2562|
;;;1743     }
;;;1744     else
;;;1745     {
;;;1746       if (NewState != DISABLE)
000a02  b134              CBZ      r4,|L1.2578|
;;;1747       {
;;;1748         /* Enable the Coarse Calibration */
;;;1749         RTC->CR |= (uint32_t)RTC_CR_DCE;
000a04  4894              LDR      r0,|L1.3160|
000a06  6800              LDR      r0,[r0,#0]
000a08  f0400080          ORR      r0,r0,#0x80
000a0c  4992              LDR      r1,|L1.3160|
000a0e  6008              STR      r0,[r1,#0]
000a10  e005              B        |L1.2590|
                  |L1.2578|
;;;1750       }
;;;1751       else
;;;1752       { 
;;;1753         /* Disable the Coarse Calibration */
;;;1754         RTC->CR &= (uint32_t)~RTC_CR_DCE;
000a12  4891              LDR      r0,|L1.3160|
000a14  6800              LDR      r0,[r0,#0]
000a16  f0200080          BIC      r0,r0,#0x80
000a1a  498f              LDR      r1,|L1.3160|
000a1c  6008              STR      r0,[r1,#0]
                  |L1.2590|
;;;1755       }
;;;1756       /* Exit Initialization mode */
;;;1757       RTC_ExitInitMode();
000a1e  f7fffffe          BL       RTC_ExitInitMode
;;;1758       
;;;1759       status = SUCCESS;
000a22  f04f0501          MOV      r5,#1
                  |L1.2598|
;;;1760     } 
;;;1761     
;;;1762     /* Enable the write protection for RTC registers */
;;;1763     RTC->WPR = 0xFF; 
000a26  f04f00ff          MOV      r0,#0xff
000a2a  498a              LDR      r1,|L1.3156|
000a2c  6008              STR      r0,[r1,#0]
;;;1764     
;;;1765     return status;
000a2e  4628              MOV      r0,r5
;;;1766   }
000a30  bd30              POP      {r4,r5,pc}
;;;1767   
                          ENDP

                  RTC_CalibOutputCmd PROC
;;;1773     */
;;;1774   void RTC_CalibOutputCmd(FunctionalState NewState)
000a32  f04f01ca          MOV      r1,#0xca
;;;1775   {
;;;1776     /* Check the parameters */
;;;1777     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1778     
;;;1779     /* Disable the write protection for RTC registers */
;;;1780     RTC->WPR = 0xCA;
000a36  4a87              LDR      r2,|L1.3156|
000a38  6011              STR      r1,[r2,#0]
;;;1781     RTC->WPR = 0x53;
000a3a  f04f0153          MOV      r1,#0x53
000a3e  6011              STR      r1,[r2,#0]
;;;1782     
;;;1783     if (NewState != DISABLE)
000a40  b130              CBZ      r0,|L1.2640|
;;;1784     {
;;;1785       /* Enable the RTC clock output */
;;;1786       RTC->CR |= (uint32_t)RTC_CR_COE;
000a42  4985              LDR      r1,|L1.3160|
000a44  6809              LDR      r1,[r1,#0]
000a46  f4410100          ORR      r1,r1,#0x800000
000a4a  4a83              LDR      r2,|L1.3160|
000a4c  6011              STR      r1,[r2,#0]
000a4e  e005              B        |L1.2652|
                  |L1.2640|
;;;1787     }
;;;1788     else
;;;1789     { 
;;;1790       /* Disable the RTC clock output */
;;;1791       RTC->CR &= (uint32_t)~RTC_CR_COE;
000a50  4981              LDR      r1,|L1.3160|
000a52  6809              LDR      r1,[r1,#0]
000a54  f4210100          BIC      r1,r1,#0x800000
000a58  4a7f              LDR      r2,|L1.3160|
000a5a  6011              STR      r1,[r2,#0]
                  |L1.2652|
;;;1792     }
;;;1793     
;;;1794     /* Enable the write protection for RTC registers */
;;;1795     RTC->WPR = 0xFF; 
000a5c  f04f01ff          MOV      r1,#0xff
000a60  4a7c              LDR      r2,|L1.3156|
000a62  6011              STR      r1,[r2,#0]
;;;1796   }
000a64  4770              BX       lr
;;;1797   
                          ENDP

                  RTC_TimeStampCmd PROC
;;;1828     */
;;;1829   void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
000a66  b510              PUSH     {r4,lr}
;;;1830   {
000a68  460a              MOV      r2,r1
;;;1831     uint32_t tmpreg = 0;
000a6a  f04f0100          MOV      r1,#0
;;;1832   
;;;1833     /* Check the parameters */
;;;1834     assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
;;;1835     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1836   
;;;1837     /* Get the RTC_CR register and clear the bits to be configured */
;;;1838     tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
000a6e  4b7a              LDR      r3,|L1.3160|
000a70  681b              LDR      r3,[r3,#0]
000a72  f6400408          MOV      r4,#0x808
000a76  ea230104          BIC      r1,r3,r4
;;;1839   
;;;1840     /* Get the new configuration */
;;;1841     if (NewState != DISABLE)
000a7a  b122              CBZ      r2,|L1.2694|
;;;1842     {
;;;1843       tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
000a7c  f4406300          ORR      r3,r0,#0x800
000a80  ea430101          ORR      r1,r3,r1
000a84  e001              B        |L1.2698|
                  |L1.2694|
;;;1844     }
;;;1845     else
;;;1846     {
;;;1847       tmpreg |= (uint32_t)(RTC_TimeStampEdge);
000a86  ea410100          ORR      r1,r1,r0
                  |L1.2698|
;;;1848     }
;;;1849   
;;;1850     /* Disable the write protection for RTC registers */
;;;1851     RTC->WPR = 0xCA;
000a8a  f04f03ca          MOV      r3,#0xca
000a8e  4c71              LDR      r4,|L1.3156|
000a90  6023              STR      r3,[r4,#0]
;;;1852     RTC->WPR = 0x53;
000a92  f04f0353          MOV      r3,#0x53
000a96  6023              STR      r3,[r4,#0]
;;;1853   
;;;1854     /* Configure the Time Stamp TSEDGE and Enable bits */
;;;1855     RTC->CR = (uint32_t)tmpreg;
000a98  4b6f              LDR      r3,|L1.3160|
000a9a  6019              STR      r1,[r3,#0]
;;;1856   
;;;1857     /* Enable the write protection for RTC registers */
;;;1858     RTC->WPR = 0xFF; 
000a9c  f04f03ff          MOV      r3,#0xff
000aa0  6023              STR      r3,[r4,#0]
;;;1859   }
000aa2  bd10              POP      {r4,pc}
;;;1860   
                          ENDP

                  RTC_GetTimeStamp PROC
;;;1872     */
;;;1873   void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
000aa4  e92d41f0          PUSH     {r4-r8,lr}
;;;1874                                         RTC_DateTypeDef* RTC_StampDateStruct)
;;;1875   {
000aa8  4680              MOV      r8,r0
000aaa  460c              MOV      r4,r1
000aac  4615              MOV      r5,r2
;;;1876     uint32_t tmptime = 0, tmpdate = 0;
000aae  f04f0600          MOV      r6,#0
000ab2  4637              MOV      r7,r6
;;;1877   
;;;1878     /* Check the parameters */
;;;1879     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1880   
;;;1881     /* Get the TimeStamp time and date registers values */
;;;1882     tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
000ab4  486c              LDR      r0,|L1.3176|
000ab6  6800              LDR      r0,[r0,#0]
000ab8  496c              LDR      r1,|L1.3180|
000aba  ea000601          AND      r6,r0,r1
;;;1883     tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
000abe  486c              LDR      r0,|L1.3184|
000ac0  6800              LDR      r0,[r0,#0]
000ac2  496c              LDR      r1,|L1.3188|
000ac4  ea000701          AND      r7,r0,r1
;;;1884   
;;;1885     /* Fill the Time structure fields with the read parameters */
;;;1886     RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
000ac8  f3c64005          UBFX     r0,r6,#16,#6
000acc  7020              STRB     r0,[r4,#0]
;;;1887     RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
000ace  f3c62006          UBFX     r0,r6,#8,#7
000ad2  7060              STRB     r0,[r4,#1]
;;;1888     RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
000ad4  f006007f          AND      r0,r6,#0x7f
000ad8  70a0              STRB     r0,[r4,#2]
;;;1889     RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
000ada  f4060080          AND      r0,r6,#0x400000
000ade  ea4f4010          LSR      r0,r0,#16
000ae2  70e0              STRB     r0,[r4,#3]
;;;1890   
;;;1891     /* Fill the Date structure fields with the read parameters */
;;;1892     RTC_StampDateStruct->RTC_Year = 0;
000ae4  f04f0000          MOV      r0,#0
000ae8  70e8              STRB     r0,[r5,#3]
;;;1893     RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
000aea  f3c72004          UBFX     r0,r7,#8,#5
000aee  7068              STRB     r0,[r5,#1]
;;;1894     RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
000af0  f007003f          AND      r0,r7,#0x3f
000af4  70a8              STRB     r0,[r5,#2]
;;;1895     RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
000af6  f3c73042          UBFX     r0,r7,#13,#3
000afa  7028              STRB     r0,[r5,#0]
;;;1896   
;;;1897     /* Check the input parameters format */
;;;1898     if (RTC_Format == RTC_Format_BIN)
000afc  f1b80f00          CMP      r8,#0
000b00  d117              BNE      |L1.2866|
;;;1899     {
;;;1900       /* Convert the Time structure parameters to Binary format */
;;;1901       RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
000b02  7820              LDRB     r0,[r4,#0]
000b04  f7fffffe          BL       RTC_Bcd2ToByte
000b08  7020              STRB     r0,[r4,#0]
;;;1902       RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
000b0a  7860              LDRB     r0,[r4,#1]
000b0c  f7fffffe          BL       RTC_Bcd2ToByte
000b10  7060              STRB     r0,[r4,#1]
;;;1903       RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
000b12  78a0              LDRB     r0,[r4,#2]
000b14  f7fffffe          BL       RTC_Bcd2ToByte
000b18  70a0              STRB     r0,[r4,#2]
;;;1904   
;;;1905       /* Convert the Date structure parameters to Binary format */
;;;1906       RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
000b1a  7868              LDRB     r0,[r5,#1]
000b1c  f7fffffe          BL       RTC_Bcd2ToByte
000b20  7068              STRB     r0,[r5,#1]
;;;1907       RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
000b22  78a8              LDRB     r0,[r5,#2]
000b24  f7fffffe          BL       RTC_Bcd2ToByte
000b28  70a8              STRB     r0,[r5,#2]
;;;1908       RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
000b2a  7828              LDRB     r0,[r5,#0]
000b2c  f7fffffe          BL       RTC_Bcd2ToByte
000b30  7028              STRB     r0,[r5,#0]
                  |L1.2866|
;;;1909     }
;;;1910   }
000b32  e8bd81f0          POP      {r4-r8,pc}
;;;1911   
                          ENDP

                  RTC_TamperTriggerConfig PROC
;;;1938     */
;;;1939   void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
000b36  b931              CBNZ     r1,|L1.2886|
;;;1940   {
;;;1941     /* Check the parameters */
;;;1942     assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
;;;1943     assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
;;;1944    
;;;1945     if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
;;;1946     {  
;;;1947       /* Configure the RTC_TAFCR register */
;;;1948       RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
000b38  4a4f              LDR      r2,|L1.3192|
000b3a  6812              LDR      r2,[r2,#0]
000b3c  ea220240          BIC      r2,r2,r0,LSL #1
000b40  4b4d              LDR      r3,|L1.3192|
000b42  601a              STR      r2,[r3,#0]
000b44  e005              B        |L1.2898|
                  |L1.2886|
;;;1949     }
;;;1950     else
;;;1951     { 
;;;1952       /* Configure the RTC_TAFCR register */
;;;1953       RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
000b46  4a4c              LDR      r2,|L1.3192|
000b48  6812              LDR      r2,[r2,#0]
000b4a  ea420240          ORR      r2,r2,r0,LSL #1
000b4e  4b4a              LDR      r3,|L1.3192|
000b50  601a              STR      r2,[r3,#0]
                  |L1.2898|
;;;1954     }  
;;;1955   }
000b52  4770              BX       lr
;;;1956   
                          ENDP

                  RTC_TamperCmd PROC
;;;1964     */
;;;1965   void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
000b54  b131              CBZ      r1,|L1.2916|
;;;1966   {
;;;1967     /* Check the parameters */
;;;1968     assert_param(IS_RTC_TAMPER(RTC_Tamper));  
;;;1969     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1970     
;;;1971     if (NewState != DISABLE)
;;;1972     {
;;;1973       /* Enable the selected Tamper pin */
;;;1974       RTC->TAFCR |= (uint32_t)RTC_Tamper;
000b56  4a48              LDR      r2,|L1.3192|
000b58  6812              LDR      r2,[r2,#0]
000b5a  ea420200          ORR      r2,r2,r0
000b5e  4b46              LDR      r3,|L1.3192|
000b60  601a              STR      r2,[r3,#0]
000b62  e005              B        |L1.2928|
                  |L1.2916|
;;;1975     }
;;;1976     else
;;;1977     {
;;;1978       /* Disable the selected Tamper pin */
;;;1979       RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
000b64  4a44              LDR      r2,|L1.3192|
000b66  6812              LDR      r2,[r2,#0]
000b68  ea220200          BIC      r2,r2,r0
000b6c  4b42              LDR      r3,|L1.3192|
000b6e  601a              STR      r2,[r3,#0]
                  |L1.2928|
;;;1980     }  
;;;1981   }
000b70  4770              BX       lr
;;;1982   
                          ENDP

                  RTC_WriteBackupRegister PROC
;;;2006     */
;;;2007   void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
000b72  f04f0200          MOV      r2,#0
;;;2008   {
;;;2009     __IO uint32_t tmp = 0;
;;;2010     
;;;2011     /* Check the parameters */
;;;2012     assert_param(IS_RTC_BKP(RTC_BKP_DR));
;;;2013   
;;;2014     tmp = RTC_BASE + 0x50;
000b76  4a41              LDR      r2,|L1.3196|
;;;2015     tmp += (RTC_BKP_DR * 4);
000b78  eb020280          ADD      r2,r2,r0,LSL #2
;;;2016   
;;;2017     /* Write the specified register */
;;;2018     *(__IO uint32_t *)tmp = (uint32_t)Data;
000b7c  6011              STR      r1,[r2,#0]
;;;2019   }
000b7e  4770              BX       lr
;;;2020   
                          ENDP

                  RTC_ReadBackupRegister PROC
;;;2027     */
;;;2028   uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
000b80  4601              MOV      r1,r0
;;;2029   {
;;;2030     __IO uint32_t tmp = 0;
000b82  f04f0200          MOV      r2,#0
;;;2031     
;;;2032     /* Check the parameters */
;;;2033     assert_param(IS_RTC_BKP(RTC_BKP_DR));
;;;2034   
;;;2035     tmp = RTC_BASE + 0x50;
000b86  4a3d              LDR      r2,|L1.3196|
;;;2036     tmp += (RTC_BKP_DR * 4);
000b88  eb020281          ADD      r2,r2,r1,LSL #2
;;;2037     
;;;2038     /* Read the specified register */
;;;2039     return (*(__IO uint32_t *)tmp);
000b8c  6810              LDR      r0,[r2,#0]
;;;2040   }
000b8e  4770              BX       lr
;;;2041   
                          ENDP

                  RTC_TamperPinSelection PROC
;;;2067     */
;;;2068   void RTC_TamperPinSelection(uint32_t RTC_TamperPin)
000b90  4939              LDR      r1,|L1.3192|
;;;2069   {
;;;2070     /* Check the parameters */
;;;2071     assert_param(IS_RTC_TAMPER_PIN(RTC_TamperPin));
;;;2072     
;;;2073     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPINSEL);
000b92  6809              LDR      r1,[r1,#0]
000b94  f4213180          BIC      r1,r1,#0x10000
000b98  4a37              LDR      r2,|L1.3192|
000b9a  6011              STR      r1,[r2,#0]
;;;2074     RTC->TAFCR |= (uint32_t)(RTC_TamperPin);  
000b9c  4611              MOV      r1,r2
000b9e  6809              LDR      r1,[r1,#0]
000ba0  ea410100          ORR      r1,r1,r0
000ba4  6011              STR      r1,[r2,#0]
;;;2075   }
000ba6  4770              BX       lr
;;;2076   
                          ENDP

                  RTC_TimeStampPinSelection PROC
;;;2084     */
;;;2085   void RTC_TimeStampPinSelection(uint32_t RTC_TimeStampPin)
000ba8  4933              LDR      r1,|L1.3192|
;;;2086   {
;;;2087     /* Check the parameters */
;;;2088     assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
;;;2089     
;;;2090     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TSINSEL);
000baa  6809              LDR      r1,[r1,#0]
000bac  f4213100          BIC      r1,r1,#0x20000
000bb0  4a31              LDR      r2,|L1.3192|
000bb2  6011              STR      r1,[r2,#0]
;;;2091     RTC->TAFCR |= (uint32_t)(RTC_TimeStampPin);  
000bb4  4611              MOV      r1,r2
000bb6  6809              LDR      r1,[r1,#0]
000bb8  ea410100          ORR      r1,r1,r0
000bbc  6011              STR      r1,[r2,#0]
;;;2092   }
000bbe  4770              BX       lr
;;;2093   
                          ENDP

                  RTC_OutputTypeConfig PROC
;;;2103     */
;;;2104   void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
000bc0  492d              LDR      r1,|L1.3192|
;;;2105   {
;;;2106     /* Check the parameters */
;;;2107     assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
;;;2108     
;;;2109     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
000bc2  6809              LDR      r1,[r1,#0]
000bc4  f4212180          BIC      r1,r1,#0x40000
000bc8  4a2b              LDR      r2,|L1.3192|
000bca  6011              STR      r1,[r2,#0]
;;;2110     RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
000bcc  4611              MOV      r1,r2
000bce  6809              LDR      r1,[r1,#0]
000bd0  ea410100          ORR      r1,r1,r0
000bd4  6011              STR      r1,[r2,#0]
;;;2111   }
000bd6  4770              BX       lr
;;;2112   
                          ENDP

                  RTC_ITConfig PROC
;;;2174     */
;;;2175   void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
000bd8  f04f02ca          MOV      r2,#0xca
;;;2176   {
;;;2177     /* Check the parameters */
;;;2178     assert_param(IS_RTC_CONFIG_IT(RTC_IT));
;;;2179     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2180   
;;;2181     /* Disable the write protection for RTC registers */
;;;2182     RTC->WPR = 0xCA;
000bdc  4b1d              LDR      r3,|L1.3156|
000bde  601a              STR      r2,[r3,#0]
;;;2183     RTC->WPR = 0x53;
000be0  f04f0253          MOV      r2,#0x53
000be4  601a              STR      r2,[r3,#0]
;;;2184   
;;;2185     if (NewState != DISABLE)
000be6  b181              CBZ      r1,|L1.3082|
;;;2186     {
;;;2187       /* Configure the Interrupts in the RTC_CR register */
;;;2188       RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
000be8  4a1b              LDR      r2,|L1.3160|
000bea  6812              LDR      r2,[r2,#0]
000bec  f0200304          BIC      r3,r0,#4
000bf0  ea420203          ORR      r2,r2,r3
000bf4  4b18              LDR      r3,|L1.3160|
000bf6  601a              STR      r2,[r3,#0]
;;;2189       /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;2190       RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
000bf8  4a1f              LDR      r2,|L1.3192|
000bfa  6812              LDR      r2,[r2,#0]
000bfc  f0000304          AND      r3,r0,#4
000c00  ea420203          ORR      r2,r2,r3
000c04  4b1c              LDR      r3,|L1.3192|
000c06  601a              STR      r2,[r3,#0]
000c08  e00f              B        |L1.3114|
                  |L1.3082|
;;;2191     }
;;;2192     else
;;;2193     {
;;;2194       /* Configure the Interrupts in the RTC_CR register */
;;;2195       RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
000c0a  4a13              LDR      r2,|L1.3160|
000c0c  6812              LDR      r2,[r2,#0]
000c0e  f0200304          BIC      r3,r0,#4
000c12  ea220203          BIC      r2,r2,r3
000c16  4b10              LDR      r3,|L1.3160|
000c18  601a              STR      r2,[r3,#0]
;;;2196       /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;2197       RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
000c1a  4a17              LDR      r2,|L1.3192|
000c1c  6812              LDR      r2,[r2,#0]
000c1e  f0000304          AND      r3,r0,#4
000c22  ea220203          BIC      r2,r2,r3
000c26  4b14              LDR      r3,|L1.3192|
000c28  601a              STR      r2,[r3,#0]
                  |L1.3114|
;;;2198     }
;;;2199     /* Enable the write protection for RTC registers */
;;;2200     RTC->WPR = 0xFF; 
000c2a  f04f02ff          MOV      r2,#0xff
000c2e  4b09              LDR      r3,|L1.3156|
000c30  601a              STR      r2,[r3,#0]
;;;2201   }
000c32  4770              BX       lr
;;;2202   
                          ENDP

                  RTC_GetFlagStatus PROC
;;;2220     */
;;;2221   FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
000c34  b510              PUSH     {r4,lr}
;;;2222   {
000c36  4601              MOV      r1,r0
;;;2223     FlagStatus bitstatus = RESET;
000c38  f04f0000          MOV      r0,#0
;;;2224     uint32_t tmpreg = 0;
000c3c  4602              MOV      r2,r0
;;;2225     
;;;2226     /* Check the parameters */
;;;2227     assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
;;;2228     
;;;2229     /* Get all the flags */
;;;2230     tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
000c3e  4b08              LDR      r3,|L1.3168|
000c40  681b              LDR      r3,[r3,#0]
000c42  f6437477          MOV      r4,#0x3f77
000c46  ea030204          AND      r2,r3,r4
;;;2231     
;;;2232     /* Return the status of the flag */
;;;2233     if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
000c4a  420a              TST      r2,r1
000c4c  d018              BEQ      |L1.3200|
;;;2234     {
;;;2235       bitstatus = SET;
000c4e  f04f0001          MOV      r0,#1
000c52  e017              B        |L1.3204|
                  |L1.3156|
                          DCD      0x40002824
                  |L1.3160|
                          DCD      0x40002808
                  |L1.3164|
                          DCD      0x40002814
                  |L1.3168|
                          DCD      0x4000280c
                  |L1.3172|
                          DCD      0x40002818
                  |L1.3176|
                          DCD      0x40002830
                  |L1.3180|
                          DCD      0x007f7f7f
                  |L1.3184|
                          DCD      0x40002834
                  |L1.3188|
                          DCD      0x00ffff3f
                  |L1.3192|
                          DCD      0x40002840
                  |L1.3196|
                          DCD      0x40002850
                  |L1.3200|
;;;2236     }
;;;2237     else
;;;2238     {
;;;2239       bitstatus = RESET;
000c80  f04f0000          MOV      r0,#0
                  |L1.3204|
;;;2240     }
;;;2241     return bitstatus;
;;;2242   }
000c84  bd10              POP      {r4,pc}
;;;2243   
                          ENDP

                  RTC_ClearFlag PROC
;;;2256     */
;;;2257   void RTC_ClearFlag(uint32_t RTC_FLAG)
000c86  b281              UXTH     r1,r0
;;;2258   {
;;;2259     /* Check the parameters */
;;;2260     assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));
;;;2261   
;;;2262     /* Clear the Flags in the RTC_ISR register */
;;;2263     RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));  
000c88  f0410180          ORR      r1,r1,#0x80
000c8c  4a1c              LDR      r2,|L1.3328|
000c8e  6812              LDR      r2,[r2,#0]
000c90  f0020280          AND      r2,r2,#0x80
000c94  ea620101          ORN      r1,r2,r1
000c98  4a19              LDR      r2,|L1.3328|
000c9a  6011              STR      r1,[r2,#0]
;;;2264   }
000c9c  4770              BX       lr
;;;2265   
                          ENDP

                  RTC_GetITStatus PROC
;;;2276     */
;;;2277   ITStatus RTC_GetITStatus(uint32_t RTC_IT)
000c9e  b530              PUSH     {r4,r5,lr}
;;;2278   {
000ca0  4601              MOV      r1,r0
;;;2279     ITStatus bitstatus = RESET;
000ca2  f04f0000          MOV      r0,#0
;;;2280     uint32_t tmpreg = 0, enablestatus = 0;
000ca6  4602              MOV      r2,r0
000ca8  4603              MOV      r3,r0
;;;2281    
;;;2282     /* Check the parameters */
;;;2283     assert_param(IS_RTC_GET_IT(RTC_IT));
;;;2284     
;;;2285     /* Get the TAMPER Interrupt enable bit and pending bit */
;;;2286     tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
000caa  4c16              LDR      r4,|L1.3332|
000cac  6824              LDR      r4,[r4,#0]
000cae  f0040204          AND      r2,r4,#4
;;;2287    
;;;2288     /* Get the Interrupt enable Status */
;;;2289     enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & (RTC_IT >> 15)));
000cb2  4c15              LDR      r4,|L1.3336|
000cb4  6824              LDR      r4,[r4,#0]
000cb6  ea040401          AND      r4,r4,r1
000cba  ea0235d1          AND      r5,r2,r1,LSR #15
000cbe  ea440305          ORR      r3,r4,r5
;;;2290     
;;;2291     /* Get the Interrupt pending bit */
;;;2292     tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
000cc2  4c0f              LDR      r4,|L1.3328|
000cc4  6824              LDR      r4,[r4,#0]
000cc6  ea041211          AND      r2,r4,r1,LSR #4
;;;2293     
;;;2294     /* Get the status of the Interrupt */
;;;2295     if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
000cca  b12b              CBZ      r3,|L1.3288|
000ccc  0414              LSLS     r4,r2,#16
000cce  0c24              LSRS     r4,r4,#16
000cd0  d002              BEQ      |L1.3288|
;;;2296     {
;;;2297       bitstatus = SET;
000cd2  f04f0001          MOV      r0,#1
000cd6  e001              B        |L1.3292|
                  |L1.3288|
;;;2298     }
;;;2299     else
;;;2300     {
;;;2301       bitstatus = RESET;
000cd8  f04f0000          MOV      r0,#0
                  |L1.3292|
;;;2302     }
;;;2303     return bitstatus;
;;;2304   }
000cdc  bd30              POP      {r4,r5,pc}
;;;2305   
                          ENDP

                  RTC_ClearITPendingBit PROC
;;;2316     */
;;;2317   void RTC_ClearITPendingBit(uint32_t RTC_IT)
000cde  f04f0100          MOV      r1,#0
;;;2318   {
;;;2319     uint32_t tmpreg = 0;
;;;2320   
;;;2321     /* Check the parameters */
;;;2322     assert_param(IS_RTC_CLEAR_IT(RTC_IT));
;;;2323   
;;;2324     /* Get the RTC_ISR Interrupt pending bits mask */
;;;2325     tmpreg = (uint32_t)(RTC_IT >> 4);
000ce2  ea4f1110          LSR      r1,r0,#4
;;;2326   
;;;2327     /* Clear the interrupt pending bits in the RTC_ISR register */
;;;2328     RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
000ce6  b28a              UXTH     r2,r1
000ce8  f0420280          ORR      r2,r2,#0x80
000cec  4b04              LDR      r3,|L1.3328|
000cee  681b              LDR      r3,[r3,#0]
000cf0  f0030380          AND      r3,r3,#0x80
000cf4  ea630202          ORN      r2,r3,r2
000cf8  4b01              LDR      r3,|L1.3328|
000cfa  601a              STR      r2,[r3,#0]
;;;2329   }
000cfc  4770              BX       lr
;;;2330   
                          ENDP

000cfe  0000              DCW      0x0000
                  |L1.3328|
                          DCD      0x4000280c
                  |L1.3332|
                          DCD      0x40002840
                  |L1.3336|
                          DCD      0x40002808

;*** Start embedded assembler ***

#line 1 "..\\BSP\\STM32F2xx\\src\\stm32f2xx_rtc.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f2xx_rtc_c_81435638____REV16|
#line 112 "..\\BSP\\CMSIS\\core_cmInstr.h"
|__asm___15_stm32f2xx_rtc_c_81435638____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f2xx_rtc_c_81435638____REVSH|
#line 130
|__asm___15_stm32f2xx_rtc_c_81435638____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
