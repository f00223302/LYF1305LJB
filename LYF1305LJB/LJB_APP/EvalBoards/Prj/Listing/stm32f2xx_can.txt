; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Output\stm32f2xx_can.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\Output\stm32f2xx_can.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\BSP -I..\BSP\UCOS-II -I..\BSP\STM32F2xx\inc -I..\BSP\CMSIS -I..\BSP\CMSIS\Device_Support -I..\BSP\UCOS-II -I..\..\uC-CPU -I..\..\uC-CPU\ARM-Cortex-M3 -I..\..\uC-LIB -I..\..\uC-LIB\Ports\ARM-Cortex-M3 -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3 -I..\App -I..\Prj -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DDEBUG -DLJB_CPU_MAIN -DUSE_CPU_F205RC --omf_browse=.\Output\stm32f2xx_can.crf ..\BSP\STM32F2xx\src\stm32f2xx_can.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  CAN_DeInit PROC
;;;161      */
;;;162    void CAN_DeInit(CAN_TypeDef* CANx)
000000  b510              PUSH     {r4,lr}
;;;163    {
000002  4604              MOV      r4,r0
;;;164      /* Check the parameters */
;;;165      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;166     
;;;167      if (CANx == CAN1)
000004  48fe              LDR      r0,|L1.1024|
000006  4284              CMP      r4,r0
000008  d109              BNE      |L1.30|
;;;168      {
;;;169        /* Enable CAN1 reset state */
;;;170        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  0648              LSLS     r0,r1,#25
00000e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;171        /* Release CAN1 from reset state */
;;;172        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
000012  2100              MOVS     r1,#0
000014  f04f7000          MOV      r0,#0x2000000
000018  f7fffffe          BL       RCC_APB1PeriphResetCmd
00001c  e008              B        |L1.48|
                  |L1.30|
;;;173      }
;;;174      else
;;;175      {  
;;;176        /* Enable CAN2 reset state */
;;;177        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
00001e  2101              MOVS     r1,#1
000020  0688              LSLS     r0,r1,#26
000022  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;178        /* Release CAN2 from reset state */
;;;179        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
000026  2100              MOVS     r1,#0
000028  f04f6080          MOV      r0,#0x4000000
00002c  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L1.48|
;;;180      }
;;;181    }
000030  bd10              POP      {r4,pc}
;;;182    
                          ENDP

                  CAN_Init PROC
;;;191      */
;;;192    uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
000032  b530              PUSH     {r4,r5,lr}
;;;193    {
000034  4602              MOV      r2,r0
;;;194      uint8_t InitStatus = CAN_InitStatus_Failed;
000036  f04f0000          MOV      r0,#0
;;;195      uint32_t wait_ack = 0x00000000;
00003a  4603              MOV      r3,r0
;;;196      /* Check the parameters */
;;;197      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;198      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
;;;199      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
;;;200      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
;;;201      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
;;;202      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
;;;203      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
;;;204      assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
;;;205      assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
;;;206      assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
;;;207      assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
;;;208      assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
;;;209    
;;;210      /* Exit from sleep mode */
;;;211      CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
00003c  6814              LDR      r4,[r2,#0]
00003e  f0240402          BIC      r4,r4,#2
000042  6014              STR      r4,[r2,#0]
;;;212    
;;;213      /* Request initialisation */
;;;214      CANx->MCR |= CAN_MCR_INRQ ;
000044  6814              LDR      r4,[r2,#0]
000046  f0440401          ORR      r4,r4,#1
00004a  6014              STR      r4,[r2,#0]
;;;215    
;;;216      /* Wait the acknowledge */
;;;217      while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
00004c  e001              B        |L1.82|
                  |L1.78|
;;;218      {
;;;219        wait_ack++;
00004e  f1030301          ADD      r3,r3,#1
                  |L1.82|
000052  6854              LDR      r4,[r2,#4]            ;217
000054  f0040401          AND      r4,r4,#1              ;217
000058  2c01              CMP      r4,#1                 ;217
00005a  d003              BEQ      |L1.100|
00005c  f5a3447f          SUB      r4,r3,#0xff00         ;217
000060  3cff              SUBS     r4,r4,#0xff           ;217
000062  d1f4              BNE      |L1.78|
                  |L1.100|
;;;220      }
;;;221    
;;;222      /* Check acknowledge */
;;;223      if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
000064  6854              LDR      r4,[r2,#4]
000066  f0040401          AND      r4,r4,#1
00006a  2c01              CMP      r4,#1
00006c  d002              BEQ      |L1.116|
;;;224      {
;;;225        InitStatus = CAN_InitStatus_Failed;
00006e  f04f0000          MOV      r0,#0
000072  e075              B        |L1.352|
                  |L1.116|
;;;226      }
;;;227      else 
;;;228      {
;;;229        /* Set the time triggered communication mode */
;;;230        if (CAN_InitStruct->CAN_TTCM == ENABLE)
000074  798c              LDRB     r4,[r1,#6]
000076  2c01              CMP      r4,#1
000078  d104              BNE      |L1.132|
;;;231        {
;;;232          CANx->MCR |= CAN_MCR_TTCM;
00007a  6814              LDR      r4,[r2,#0]
00007c  f0440480          ORR      r4,r4,#0x80
000080  6014              STR      r4,[r2,#0]
000082  e003              B        |L1.140|
                  |L1.132|
;;;233        }
;;;234        else
;;;235        {
;;;236          CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
000084  6814              LDR      r4,[r2,#0]
000086  f0240480          BIC      r4,r4,#0x80
00008a  6014              STR      r4,[r2,#0]
                  |L1.140|
;;;237        }
;;;238    
;;;239        /* Set the automatic bus-off management */
;;;240        if (CAN_InitStruct->CAN_ABOM == ENABLE)
00008c  79cc              LDRB     r4,[r1,#7]
00008e  2c01              CMP      r4,#1
000090  d104              BNE      |L1.156|
;;;241        {
;;;242          CANx->MCR |= CAN_MCR_ABOM;
000092  6814              LDR      r4,[r2,#0]
000094  f0440440          ORR      r4,r4,#0x40
000098  6014              STR      r4,[r2,#0]
00009a  e003              B        |L1.164|
                  |L1.156|
;;;243        }
;;;244        else
;;;245        {
;;;246          CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
00009c  6814              LDR      r4,[r2,#0]
00009e  f0240440          BIC      r4,r4,#0x40
0000a2  6014              STR      r4,[r2,#0]
                  |L1.164|
;;;247        }
;;;248    
;;;249        /* Set the automatic wake-up mode */
;;;250        if (CAN_InitStruct->CAN_AWUM == ENABLE)
0000a4  7a0c              LDRB     r4,[r1,#8]
0000a6  2c01              CMP      r4,#1
0000a8  d104              BNE      |L1.180|
;;;251        {
;;;252          CANx->MCR |= CAN_MCR_AWUM;
0000aa  6814              LDR      r4,[r2,#0]
0000ac  f0440420          ORR      r4,r4,#0x20
0000b0  6014              STR      r4,[r2,#0]
0000b2  e003              B        |L1.188|
                  |L1.180|
;;;253        }
;;;254        else
;;;255        {
;;;256          CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
0000b4  6814              LDR      r4,[r2,#0]
0000b6  f0240420          BIC      r4,r4,#0x20
0000ba  6014              STR      r4,[r2,#0]
                  |L1.188|
;;;257        }
;;;258    
;;;259        /* Set the no automatic retransmission */
;;;260        if (CAN_InitStruct->CAN_NART == ENABLE)
0000bc  7a4c              LDRB     r4,[r1,#9]
0000be  2c01              CMP      r4,#1
0000c0  d104              BNE      |L1.204|
;;;261        {
;;;262          CANx->MCR |= CAN_MCR_NART;
0000c2  6814              LDR      r4,[r2,#0]
0000c4  f0440410          ORR      r4,r4,#0x10
0000c8  6014              STR      r4,[r2,#0]
0000ca  e003              B        |L1.212|
                  |L1.204|
;;;263        }
;;;264        else
;;;265        {
;;;266          CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
0000cc  6814              LDR      r4,[r2,#0]
0000ce  f0240410          BIC      r4,r4,#0x10
0000d2  6014              STR      r4,[r2,#0]
                  |L1.212|
;;;267        }
;;;268    
;;;269        /* Set the receive FIFO locked mode */
;;;270        if (CAN_InitStruct->CAN_RFLM == ENABLE)
0000d4  7a8c              LDRB     r4,[r1,#0xa]
0000d6  2c01              CMP      r4,#1
0000d8  d104              BNE      |L1.228|
;;;271        {
;;;272          CANx->MCR |= CAN_MCR_RFLM;
0000da  6814              LDR      r4,[r2,#0]
0000dc  f0440408          ORR      r4,r4,#8
0000e0  6014              STR      r4,[r2,#0]
0000e2  e003              B        |L1.236|
                  |L1.228|
;;;273        }
;;;274        else
;;;275        {
;;;276          CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
0000e4  6814              LDR      r4,[r2,#0]
0000e6  f0240408          BIC      r4,r4,#8
0000ea  6014              STR      r4,[r2,#0]
                  |L1.236|
;;;277        }
;;;278    
;;;279        /* Set the transmit FIFO priority */
;;;280        if (CAN_InitStruct->CAN_TXFP == ENABLE)
0000ec  7acc              LDRB     r4,[r1,#0xb]
0000ee  2c01              CMP      r4,#1
0000f0  d104              BNE      |L1.252|
;;;281        {
;;;282          CANx->MCR |= CAN_MCR_TXFP;
0000f2  6814              LDR      r4,[r2,#0]
0000f4  f0440404          ORR      r4,r4,#4
0000f8  6014              STR      r4,[r2,#0]
0000fa  e003              B        |L1.260|
                  |L1.252|
;;;283        }
;;;284        else
;;;285        {
;;;286          CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
0000fc  6814              LDR      r4,[r2,#0]
0000fe  f0240404          BIC      r4,r4,#4
000102  6014              STR      r4,[r2,#0]
                  |L1.260|
;;;287        }
;;;288    
;;;289        /* Set the bit timing register */
;;;290        CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
000104  788c              LDRB     r4,[r1,#2]
000106  ea4f7484          LSL      r4,r4,#30
00010a  78cd              LDRB     r5,[r1,#3]
00010c  ea446405          ORR      r4,r4,r5,LSL #24
000110  790d              LDRB     r5,[r1,#4]
000112  ea444405          ORR      r4,r4,r5,LSL #16
000116  794d              LDRB     r5,[r1,#5]
000118  ea445405          ORR      r4,r4,r5,LSL #20
00011c  880d              LDRH     r5,[r1,#0]
00011e  f1a50501          SUB      r5,r5,#1
000122  ea440405          ORR      r4,r4,r5
000126  61d4              STR      r4,[r2,#0x1c]
;;;291                    ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
;;;292                    ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
;;;293                    ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
;;;294                   ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
;;;295    
;;;296        /* Request leave initialisation */
;;;297        CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
000128  6814              LDR      r4,[r2,#0]
00012a  f0240401          BIC      r4,r4,#1
00012e  6014              STR      r4,[r2,#0]
;;;298    
;;;299       /* Wait the acknowledge */
;;;300       wait_ack = 0;
000130  f04f0300          MOV      r3,#0
;;;301    
;;;302       while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
000134  e001              B        |L1.314|
                  |L1.310|
;;;303       {
;;;304         wait_ack++;
000136  f1030301          ADD      r3,r3,#1
                  |L1.314|
00013a  6854              LDR      r4,[r2,#4]            ;302
00013c  f0040401          AND      r4,r4,#1              ;302
000140  2c01              CMP      r4,#1                 ;302
000142  d103              BNE      |L1.332|
000144  f5a3447f          SUB      r4,r3,#0xff00         ;302
000148  3cff              SUBS     r4,r4,#0xff           ;302
00014a  d1f4              BNE      |L1.310|
                  |L1.332|
;;;305       }
;;;306    
;;;307        /* ...and check acknowledged */
;;;308        if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
00014c  6854              LDR      r4,[r2,#4]
00014e  f0040401          AND      r4,r4,#1
000152  2c01              CMP      r4,#1
000154  d102              BNE      |L1.348|
;;;309        {
;;;310          InitStatus = CAN_InitStatus_Failed;
000156  f04f0000          MOV      r0,#0
00015a  e001              B        |L1.352|
                  |L1.348|
;;;311        }
;;;312        else
;;;313        {
;;;314          InitStatus = CAN_InitStatus_Success ;
00015c  f04f0001          MOV      r0,#1
                  |L1.352|
;;;315        }
;;;316      }
;;;317    
;;;318      /* At this step, return the status of initialization */
;;;319      return InitStatus;
;;;320    }
000160  bd30              POP      {r4,r5,pc}
;;;321    
                          ENDP

                  CAN_FilterInit PROC
;;;328      */
;;;329    void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
000162  b510              PUSH     {r4,lr}
;;;330    {
;;;331      uint32_t filter_number_bit_pos = 0;
000164  f04f0100          MOV      r1,#0
;;;332      /* Check the parameters */
;;;333      assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
;;;334      assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
;;;335      assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
;;;336      assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
;;;337      assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
;;;338    
;;;339      filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
000168  7a83              LDRB     r3,[r0,#0xa]
00016a  f04f0201          MOV      r2,#1
00016e  fa02f103          LSL      r1,r2,r3
;;;340    
;;;341      /* Initialisation mode for the filter */
;;;342      CAN1->FMR |= FMR_FINIT;
000172  4aa4              LDR      r2,|L1.1028|
000174  6812              LDR      r2,[r2,#0]
000176  f0420201          ORR      r2,r2,#1
00017a  4ba2              LDR      r3,|L1.1028|
00017c  601a              STR      r2,[r3,#0]
;;;343    
;;;344      /* Filter Deactivation */
;;;345      CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
00017e  4aa2              LDR      r2,|L1.1032|
000180  6812              LDR      r2,[r2,#0]
000182  ea220201          BIC      r2,r2,r1
000186  4ba0              LDR      r3,|L1.1032|
000188  601a              STR      r2,[r3,#0]
;;;346    
;;;347      /* Filter Scale */
;;;348      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
00018a  7b02              LDRB     r2,[r0,#0xc]
00018c  b9b2              CBNZ     r2,|L1.444|
;;;349      {
;;;350        /* 16-bit scale for the filter */
;;;351        CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
00018e  4a9f              LDR      r2,|L1.1036|
000190  6812              LDR      r2,[r2,#0]
000192  ea220201          BIC      r2,r2,r1
000196  4b9d              LDR      r3,|L1.1036|
000198  601a              STR      r2,[r3,#0]
;;;352    
;;;353        /* First 16-bit identifier and First 16-bit mask */
;;;354        /* Or First 16-bit identifier and Second 16-bit identifier */
;;;355        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
00019a  8842              LDRH     r2,[r0,#2]
00019c  88c3              LDRH     r3,[r0,#6]
00019e  ea424303          ORR      r3,r2,r3,LSL #16
0001a2  4a9b              LDR      r2,|L1.1040|
0001a4  7a84              LDRB     r4,[r0,#0xa]
0001a6  f8423034          STR      r3,[r2,r4,LSL #3]
;;;356           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
;;;357            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
;;;358    
;;;359        /* Second 16-bit identifier and Second 16-bit mask */
;;;360        /* Or Third 16-bit identifier and Fourth 16-bit identifier */
;;;361        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
0001aa  8802              LDRH     r2,[r0,#0]
0001ac  8883              LDRH     r3,[r0,#4]
0001ae  ea424303          ORR      r3,r2,r3,LSL #16
0001b2  4a97              LDR      r2,|L1.1040|
0001b4  7a84              LDRB     r4,[r0,#0xa]
0001b6  eb0202c4          ADD      r2,r2,r4,LSL #3
0001ba  6053              STR      r3,[r2,#4]
                  |L1.444|
;;;362           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;363            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
;;;364      }
;;;365    
;;;366      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
0001bc  7b02              LDRB     r2,[r0,#0xc]
0001be  2a01              CMP      r2,#1
0001c0  d116              BNE      |L1.496|
;;;367      {
;;;368        /* 32-bit scale for the filter */
;;;369        CAN1->FS1R |= filter_number_bit_pos;
0001c2  4a92              LDR      r2,|L1.1036|
0001c4  6812              LDR      r2,[r2,#0]
0001c6  ea420201          ORR      r2,r2,r1
0001ca  4b90              LDR      r3,|L1.1036|
0001cc  601a              STR      r2,[r3,#0]
;;;370        /* 32-bit identifier or First 32-bit identifier */
;;;371        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
0001ce  8842              LDRH     r2,[r0,#2]
0001d0  8803              LDRH     r3,[r0,#0]
0001d2  ea424303          ORR      r3,r2,r3,LSL #16
0001d6  4a8e              LDR      r2,|L1.1040|
0001d8  7a84              LDRB     r4,[r0,#0xa]
0001da  f8423034          STR      r3,[r2,r4,LSL #3]
;;;372           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
;;;373            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
;;;374        /* 32-bit mask or Second 32-bit identifier */
;;;375        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
0001de  88c2              LDRH     r2,[r0,#6]
0001e0  8883              LDRH     r3,[r0,#4]
0001e2  ea424303          ORR      r3,r2,r3,LSL #16
0001e6  4a8a              LDR      r2,|L1.1040|
0001e8  7a84              LDRB     r4,[r0,#0xa]
0001ea  eb0202c4          ADD      r2,r2,r4,LSL #3
0001ee  6053              STR      r3,[r2,#4]
                  |L1.496|
;;;376           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;377            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
;;;378      }
;;;379    
;;;380      /* Filter Mode */
;;;381      if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
0001f0  7ac2              LDRB     r2,[r0,#0xb]
0001f2  b932              CBNZ     r2,|L1.514|
;;;382      {
;;;383        /*Id/Mask mode for the filter*/
;;;384        CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
0001f4  4a87              LDR      r2,|L1.1044|
0001f6  6812              LDR      r2,[r2,#0]
0001f8  ea220201          BIC      r2,r2,r1
0001fc  4b85              LDR      r3,|L1.1044|
0001fe  601a              STR      r2,[r3,#0]
000200  e005              B        |L1.526|
                  |L1.514|
;;;385      }
;;;386      else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
;;;387      {
;;;388        /*Identifier list mode for the filter*/
;;;389        CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
000202  4a84              LDR      r2,|L1.1044|
000204  6812              LDR      r2,[r2,#0]
000206  ea420201          ORR      r2,r2,r1
00020a  4b82              LDR      r3,|L1.1044|
00020c  601a              STR      r2,[r3,#0]
                  |L1.526|
;;;390      }
;;;391    
;;;392      /* Filter FIFO assignment */
;;;393      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
00020e  8902              LDRH     r2,[r0,#8]
000210  b92a              CBNZ     r2,|L1.542|
;;;394      {
;;;395        /* FIFO 0 assignation for the filter */
;;;396        CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
000212  4a81              LDR      r2,|L1.1048|
000214  6812              LDR      r2,[r2,#0]
000216  ea220201          BIC      r2,r2,r1
00021a  4b7f              LDR      r3,|L1.1048|
00021c  601a              STR      r2,[r3,#0]
                  |L1.542|
;;;397      }
;;;398    
;;;399      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
00021e  8902              LDRH     r2,[r0,#8]
000220  2a01              CMP      r2,#1
000222  d105              BNE      |L1.560|
;;;400      {
;;;401        /* FIFO 1 assignation for the filter */
;;;402        CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
000224  4a7c              LDR      r2,|L1.1048|
000226  6812              LDR      r2,[r2,#0]
000228  ea420201          ORR      r2,r2,r1
00022c  4b7a              LDR      r3,|L1.1048|
00022e  601a              STR      r2,[r3,#0]
                  |L1.560|
;;;403      }
;;;404      
;;;405      /* Filter activation */
;;;406      if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
000230  7b42              LDRB     r2,[r0,#0xd]
000232  2a01              CMP      r2,#1
000234  d105              BNE      |L1.578|
;;;407      {
;;;408        CAN1->FA1R |= filter_number_bit_pos;
000236  4a74              LDR      r2,|L1.1032|
000238  6812              LDR      r2,[r2,#0]
00023a  ea420201          ORR      r2,r2,r1
00023e  4b72              LDR      r3,|L1.1032|
000240  601a              STR      r2,[r3,#0]
                  |L1.578|
;;;409      }
;;;410    
;;;411      /* Leave the initialisation mode for the filter */
;;;412      CAN1->FMR &= ~FMR_FINIT;
000242  4a70              LDR      r2,|L1.1028|
000244  6812              LDR      r2,[r2,#0]
000246  f0220201          BIC      r2,r2,#1
00024a  4b6e              LDR      r3,|L1.1028|
00024c  601a              STR      r2,[r3,#0]
;;;413    }
00024e  bd10              POP      {r4,pc}
;;;414    
                          ENDP

                  CAN_StructInit PROC
;;;419      */
;;;420    void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
000250  f04f0100          MOV      r1,#0
;;;421    {
;;;422      /* Reset CAN init structure parameters values */
;;;423      
;;;424      /* Initialize the time triggered communication mode */
;;;425      CAN_InitStruct->CAN_TTCM = DISABLE;
000254  7181              STRB     r1,[r0,#6]
;;;426      
;;;427      /* Initialize the automatic bus-off management */
;;;428      CAN_InitStruct->CAN_ABOM = DISABLE;
000256  71c1              STRB     r1,[r0,#7]
;;;429      
;;;430      /* Initialize the automatic wake-up mode */
;;;431      CAN_InitStruct->CAN_AWUM = DISABLE;
000258  7201              STRB     r1,[r0,#8]
;;;432      
;;;433      /* Initialize the no automatic retransmission */
;;;434      CAN_InitStruct->CAN_NART = DISABLE;
00025a  7241              STRB     r1,[r0,#9]
;;;435      
;;;436      /* Initialize the receive FIFO locked mode */
;;;437      CAN_InitStruct->CAN_RFLM = DISABLE;
00025c  7281              STRB     r1,[r0,#0xa]
;;;438      
;;;439      /* Initialize the transmit FIFO priority */
;;;440      CAN_InitStruct->CAN_TXFP = DISABLE;
00025e  72c1              STRB     r1,[r0,#0xb]
;;;441      
;;;442      /* Initialize the CAN_Mode member */
;;;443      CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
000260  7081              STRB     r1,[r0,#2]
;;;444      
;;;445      /* Initialize the CAN_SJW member */
;;;446      CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
000262  70c1              STRB     r1,[r0,#3]
;;;447      
;;;448      /* Initialize the CAN_BS1 member */
;;;449      CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
000264  f04f0103          MOV      r1,#3
000268  7101              STRB     r1,[r0,#4]
;;;450      
;;;451      /* Initialize the CAN_BS2 member */
;;;452      CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
00026a  f04f0102          MOV      r1,#2
00026e  7141              STRB     r1,[r0,#5]
;;;453      
;;;454      /* Initialize the CAN_Prescaler member */
;;;455      CAN_InitStruct->CAN_Prescaler = 1;
000270  f04f0101          MOV      r1,#1
000274  8001              STRH     r1,[r0,#0]
;;;456    }
000276  4770              BX       lr
;;;457    
                          ENDP

                  CAN_SlaveStartBank PROC
;;;462      */
;;;463    void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
000278  4962              LDR      r1,|L1.1028|
;;;464    {
;;;465      /* Check the parameters */
;;;466      assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
;;;467      
;;;468      /* Enter Initialisation mode for the filter */
;;;469      CAN1->FMR |= FMR_FINIT;
00027a  6809              LDR      r1,[r1,#0]
00027c  f0410101          ORR      r1,r1,#1
000280  4a60              LDR      r2,|L1.1028|
000282  6011              STR      r1,[r2,#0]
;;;470      
;;;471      /* Select the start slave bank */
;;;472      CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
000284  4611              MOV      r1,r2
000286  6809              LDR      r1,[r1,#0]
000288  f643720e          MOV      r2,#0x3f0e
00028c  ea210102          BIC      r1,r1,r2
000290  4a5c              LDR      r2,|L1.1028|
000292  6011              STR      r1,[r2,#0]
;;;473      CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
000294  4611              MOV      r1,r2
000296  6809              LDR      r1,[r1,#0]
000298  ea412100          ORR      r1,r1,r0,LSL #8
00029c  6011              STR      r1,[r2,#0]
;;;474      
;;;475      /* Leave Initialisation mode for the filter */
;;;476      CAN1->FMR &= ~FMR_FINIT;
00029e  4611              MOV      r1,r2
0002a0  6809              LDR      r1,[r1,#0]
0002a2  f0210101          BIC      r1,r1,#1
0002a6  6011              STR      r1,[r2,#0]
;;;477    }
0002a8  4770              BX       lr
;;;478    
                          ENDP

                  CAN_DBGFreeze PROC
;;;487      */
;;;488    void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
0002aa  b121              CBZ      r1,|L1.694|
;;;489    {
;;;490      /* Check the parameters */
;;;491      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;492      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;493      
;;;494      if (NewState != DISABLE)
;;;495      {
;;;496        /* Enable Debug Freeze  */
;;;497        CANx->MCR |= MCR_DBF;
0002ac  6802              LDR      r2,[r0,#0]
0002ae  f4423280          ORR      r2,r2,#0x10000
0002b2  6002              STR      r2,[r0,#0]
0002b4  e003              B        |L1.702|
                  |L1.694|
;;;498      }
;;;499      else
;;;500      {
;;;501        /* Disable Debug Freeze */
;;;502        CANx->MCR &= ~MCR_DBF;
0002b6  6802              LDR      r2,[r0,#0]
0002b8  f4223280          BIC      r2,r2,#0x10000
0002bc  6002              STR      r2,[r0,#0]
                  |L1.702|
;;;503      }
;;;504    }
0002be  4770              BX       lr
;;;505    
                          ENDP

                  CAN_TTComModeCmd PROC
;;;517      */
;;;518    void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
0002c0  b1e1              CBZ      r1,|L1.764|
;;;519    {
;;;520      /* Check the parameters */
;;;521      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;522      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;523      if (NewState != DISABLE)
;;;524      {
;;;525        /* Enable the TTCM mode */
;;;526        CANx->MCR |= CAN_MCR_TTCM;
0002c2  6802              LDR      r2,[r0,#0]
0002c4  f0420280          ORR      r2,r2,#0x80
0002c8  6002              STR      r2,[r0,#0]
;;;527    
;;;528        /* Set TGT bits */
;;;529        CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
0002ca  f44f72c2          MOV      r2,#0x184
0002ce  5812              LDR      r2,[r2,r0]
0002d0  f4427380          ORR      r3,r2,#0x100
0002d4  f44f72c2          MOV      r2,#0x184
0002d8  5013              STR      r3,[r2,r0]
;;;530        CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
0002da  f44f72ca          MOV      r2,#0x194
0002de  5812              LDR      r2,[r2,r0]
0002e0  f4427380          ORR      r3,r2,#0x100
0002e4  f44f72ca          MOV      r2,#0x194
0002e8  5013              STR      r3,[r2,r0]
;;;531        CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
0002ea  f44f72d2          MOV      r2,#0x1a4
0002ee  5812              LDR      r2,[r2,r0]
0002f0  f4427380          ORR      r3,r2,#0x100
0002f4  f44f72d2          MOV      r2,#0x1a4
0002f8  5013              STR      r3,[r2,r0]
0002fa  e01b              B        |L1.820|
                  |L1.764|
;;;532      }
;;;533      else
;;;534      {
;;;535        /* Disable the TTCM mode */
;;;536        CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
0002fc  6802              LDR      r2,[r0,#0]
0002fe  f0220280          BIC      r2,r2,#0x80
000302  6002              STR      r2,[r0,#0]
;;;537    
;;;538        /* Reset TGT bits */
;;;539        CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
000304  f44f72c2          MOV      r2,#0x184
000308  5812              LDR      r2,[r2,r0]
00030a  f4227380          BIC      r3,r2,#0x100
00030e  f44f72c2          MOV      r2,#0x184
000312  5013              STR      r3,[r2,r0]
;;;540        CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
000314  f44f72ca          MOV      r2,#0x194
000318  5812              LDR      r2,[r2,r0]
00031a  f4227380          BIC      r3,r2,#0x100
00031e  f44f72ca          MOV      r2,#0x194
000322  5013              STR      r3,[r2,r0]
;;;541        CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
000324  f44f72d2          MOV      r2,#0x1a4
000328  5812              LDR      r2,[r2,r0]
00032a  f4227380          BIC      r3,r2,#0x100
00032e  f44f72d2          MOV      r2,#0x1a4
000332  5013              STR      r3,[r2,r0]
                  |L1.820|
;;;542      }
;;;543    }
000334  4770              BX       lr
;;;544    /**
                          ENDP

                  CAN_Transmit PROC
;;;571      */
;;;572    uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
000336  b510              PUSH     {r4,lr}
;;;573    {
000338  4602              MOV      r2,r0
;;;574      uint8_t transmit_mailbox = 0;
00033a  f04f0000          MOV      r0,#0
;;;575      /* Check the parameters */
;;;576      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;577      assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
;;;578      assert_param(IS_CAN_RTR(TxMessage->RTR));
;;;579      assert_param(IS_CAN_DLC(TxMessage->DLC));
;;;580    
;;;581      /* Select one empty transmit mailbox */
;;;582      if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
00033e  6893              LDR      r3,[r2,#8]
000340  f0036380          AND      r3,r3,#0x4000000
000344  f1b36f80          CMP      r3,#0x4000000
000348  d100              BNE      |L1.844|
;;;583      {
;;;584        transmit_mailbox = 0;
00034a  e013              B        |L1.884|
                  |L1.844|
;;;585      }
;;;586      else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
00034c  6893              LDR      r3,[r2,#8]
00034e  f0036300          AND      r3,r3,#0x8000000
000352  f1b36f00          CMP      r3,#0x8000000
000356  d102              BNE      |L1.862|
;;;587      {
;;;588        transmit_mailbox = 1;
000358  f04f0001          MOV      r0,#1
00035c  e00a              B        |L1.884|
                  |L1.862|
;;;589      }
;;;590      else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
00035e  6893              LDR      r3,[r2,#8]
000360  f0035380          AND      r3,r3,#0x10000000
000364  f1b35f80          CMP      r3,#0x10000000
000368  d102              BNE      |L1.880|
;;;591      {
;;;592        transmit_mailbox = 2;
00036a  f04f0002          MOV      r0,#2
00036e  e001              B        |L1.884|
                  |L1.880|
;;;593      }
;;;594      else
;;;595      {
;;;596        transmit_mailbox = CAN_TxStatus_NoMailBox;
000370  f04f0004          MOV      r0,#4
                  |L1.884|
;;;597      }
;;;598    
;;;599      if (transmit_mailbox != CAN_TxStatus_NoMailBox)
000374  2804              CMP      r0,#4
000376  d07c              BEQ      |L1.1138|
;;;600      {
;;;601        /* Set up the Id */
;;;602        CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
000378  f50273c0          ADD      r3,r2,#0x180
00037c  eb031300          ADD      r3,r3,r0,LSL #4
000380  681b              LDR      r3,[r3,#0]
000382  f0030401          AND      r4,r3,#1
000386  f50273c0          ADD      r3,r2,#0x180
00038a  eb031300          ADD      r3,r3,r0,LSL #4
00038e  601c              STR      r4,[r3,#0]
;;;603        if (TxMessage->IDE == CAN_Id_Standard)
000390  7a0b              LDRB     r3,[r1,#8]
000392  b983              CBNZ     r3,|L1.950|
;;;604        {
;;;605          assert_param(IS_CAN_STDID(TxMessage->StdId));  
;;;606          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
000394  7a4b              LDRB     r3,[r1,#9]
000396  680c              LDR      r4,[r1,#0]
000398  ea435344          ORR      r3,r3,r4,LSL #21
00039c  f50274c0          ADD      r4,r2,#0x180
0003a0  eb041400          ADD      r4,r4,r0,LSL #4
0003a4  6824              LDR      r4,[r4,#0]
0003a6  ea430304          ORR      r3,r3,r4
0003aa  f50274c0          ADD      r4,r2,#0x180
0003ae  eb041400          ADD      r4,r4,r0,LSL #4
0003b2  6023              STR      r3,[r4,#0]
0003b4  e012              B        |L1.988|
                  |L1.950|
;;;607                                                      TxMessage->RTR);
;;;608        }
;;;609        else
;;;610        {
;;;611          assert_param(IS_CAN_EXTID(TxMessage->ExtId));
;;;612          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
0003b6  7a0b              LDRB     r3,[r1,#8]
0003b8  684c              LDR      r4,[r1,#4]
0003ba  ea4303c4          ORR      r3,r3,r4,LSL #3
0003be  7a4c              LDRB     r4,[r1,#9]
0003c0  ea430304          ORR      r3,r3,r4
0003c4  f50274c0          ADD      r4,r2,#0x180
0003c8  eb041400          ADD      r4,r4,r0,LSL #4
0003cc  6824              LDR      r4,[r4,#0]
0003ce  ea430304          ORR      r3,r3,r4
0003d2  f50274c0          ADD      r4,r2,#0x180
0003d6  eb041400          ADD      r4,r4,r0,LSL #4
0003da  6023              STR      r3,[r4,#0]
                  |L1.988|
;;;613                                                      TxMessage->IDE | \
;;;614                                                      TxMessage->RTR);
;;;615        }
;;;616        
;;;617        /* Set up the DLC */
;;;618        TxMessage->DLC &= (uint8_t)0x0000000F;
0003dc  7a8b              LDRB     r3,[r1,#0xa]
0003de  f003030f          AND      r3,r3,#0xf
0003e2  728b              STRB     r3,[r1,#0xa]
;;;619        CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
0003e4  f50273c0          ADD      r3,r2,#0x180
0003e8  eb031300          ADD      r3,r3,r0,LSL #4
0003ec  685b              LDR      r3,[r3,#4]
0003ee  f023040f          BIC      r4,r3,#0xf
0003f2  f50273c0          ADD      r3,r2,#0x180
0003f6  eb031300          ADD      r3,r3,r0,LSL #4
0003fa  605c              STR      r4,[r3,#4]
;;;620        CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
0003fc  e00e              B        |L1.1052|
0003fe  0000              DCW      0x0000
                  |L1.1024|
                          DCD      0x40006400
                  |L1.1028|
                          DCD      0x40006600
                  |L1.1032|
                          DCD      0x4000661c
                  |L1.1036|
                          DCD      0x4000660c
                  |L1.1040|
                          DCD      0x40006640
                  |L1.1044|
                          DCD      0x40006604
                  |L1.1048|
                          DCD      0x40006614
                  |L1.1052|
00041c  f50273c0          ADD      r3,r2,#0x180
000420  eb031300          ADD      r3,r3,r0,LSL #4
000424  685b              LDR      r3,[r3,#4]
000426  7a8c              LDRB     r4,[r1,#0xa]
000428  ea430304          ORR      r3,r3,r4
00042c  f50274c0          ADD      r4,r2,#0x180
000430  eb041400          ADD      r4,r4,r0,LSL #4
000434  6063              STR      r3,[r4,#4]
;;;621    
;;;622        /* Set up the data field */
;;;623        CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
000436  7b8b              LDRB     r3,[r1,#0xe]
000438  ea4f6403          LSL      r4,r3,#24
00043c  7b4b              LDRB     r3,[r1,#0xd]
00043e  ea444403          ORR      r4,r4,r3,LSL #16
000442  7b0b              LDRB     r3,[r1,#0xc]
000444  ea442303          ORR      r3,r4,r3,LSL #8
000448  7acc              LDRB     r4,[r1,#0xb]
00044a  ea430304          ORR      r3,r3,r4
00044e  f50274c0          ADD      r4,r2,#0x180
000452  eb041400          ADD      r4,r4,r0,LSL #4
000456  60a3              STR      r3,[r4,#8]
;;;624                                                 ((uint32_t)TxMessage->Data[2] << 16) |
;;;625                                                 ((uint32_t)TxMessage->Data[1] << 8) | 
;;;626                                                 ((uint32_t)TxMessage->Data[0]));
;;;627        CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
000458  7c8b              LDRB     r3,[r1,#0x12]
00045a  ea4f6403          LSL      r4,r3,#24
00045e  7c4b              LDRB     r3,[r1,#0x11]
000460  ea444403          ORR      r4,r4,r3,LSL #16
000464  7c0b              LDRB     r3,[r1,#0x10]
000466  ea442303          ORR      r3,r4,r3,LSL #8
00046a  7bcc              LDRB     r4,[r1,#0xf]
00046c  ea430304          ORR      r3,r3,r4
000470  e000              B        |L1.1140|
                  |L1.1138|
000472  e010              B        |L1.1174|
                  |L1.1140|
000474  f50274c0          ADD      r4,r2,#0x180
000478  eb041400          ADD      r4,r4,r0,LSL #4
00047c  60e3              STR      r3,[r4,#0xc]
;;;628                                                 ((uint32_t)TxMessage->Data[6] << 16) |
;;;629                                                 ((uint32_t)TxMessage->Data[5] << 8) |
;;;630                                                 ((uint32_t)TxMessage->Data[4]));
;;;631        /* Request transmission */
;;;632        CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
00047e  f50273c0          ADD      r3,r2,#0x180
000482  eb031300          ADD      r3,r3,r0,LSL #4
000486  681b              LDR      r3,[r3,#0]
000488  f0430401          ORR      r4,r3,#1
00048c  f50273c0          ADD      r3,r2,#0x180
000490  eb031300          ADD      r3,r3,r0,LSL #4
000494  601c              STR      r4,[r3,#0]
                  |L1.1174|
;;;633      }
;;;634      return transmit_mailbox;
;;;635    }
000496  bd10              POP      {r4,pc}
;;;636    
                          ENDP

                  CAN_TransmitStatus PROC
;;;643      */
;;;644    uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
000498  b510              PUSH     {r4,lr}
;;;645    {
00049a  4602              MOV      r2,r0
;;;646      uint32_t state = 0;
00049c  f04f0300          MOV      r3,#0
;;;647    
;;;648      /* Check the parameters */
;;;649      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;650      assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
;;;651     
;;;652      switch (TransmitMailbox)
0004a0  b121              CBZ      r1,|L1.1196|
0004a2  2901              CMP      r1,#1
0004a4  d007              BEQ      |L1.1206|
0004a6  2902              CMP      r1,#2
0004a8  d10f              BNE      |L1.1226|
0004aa  e009              B        |L1.1216|
                  |L1.1196|
;;;653      {
;;;654        case (CAN_TXMAILBOX_0): 
;;;655          state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
0004ac  6890              LDR      r0,[r2,#8]
0004ae  4cf7              LDR      r4,|L1.2188|
0004b0  ea000304          AND      r3,r0,r4
;;;656          break;
0004b4  e00c              B        |L1.1232|
                  |L1.1206|
;;;657        case (CAN_TXMAILBOX_1): 
;;;658          state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
0004b6  6890              LDR      r0,[r2,#8]
0004b8  4cf5              LDR      r4,|L1.2192|
0004ba  ea000304          AND      r3,r0,r4
;;;659          break;
0004be  e007              B        |L1.1232|
                  |L1.1216|
;;;660        case (CAN_TXMAILBOX_2): 
;;;661          state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
0004c0  6890              LDR      r0,[r2,#8]
0004c2  4cf4              LDR      r4,|L1.2196|
0004c4  ea000304          AND      r3,r0,r4
;;;662          break;
0004c8  e002              B        |L1.1232|
                  |L1.1226|
;;;663        default:
;;;664          state = CAN_TxStatus_Failed;
0004ca  f04f0300          MOV      r3,#0
;;;665          break;
0004ce  bf00              NOP      
                  |L1.1232|
0004d0  bf00              NOP                            ;656
;;;666      }
;;;667      switch (state)
0004d2  4cf1              LDR      r4,|L1.2200|
0004d4  1b18              SUBS     r0,r3,r4
0004d6  42a3              CMP      r3,r4
0004d8  d018              BEQ      |L1.1292|
0004da  dc07              BGT      |L1.1260|
0004dc  b183              CBZ      r3,|L1.1280|
0004de  f06f6080          MVN      r0,#0x4000000
0004e2  1818              ADDS     r0,r3,r0
0004e4  d00f              BEQ      |L1.1286|
0004e6  2802              CMP      r0,#2
0004e8  d11f              BNE      |L1.1322|
0004ea  e015              B        |L1.1304|
                  |L1.1260|
0004ec  f5b07f00          CMP      r0,#0x200
0004f0  d015              BEQ      |L1.1310|
0004f2  4cea              LDR      r4,|L1.2204|
0004f4  1900              ADDS     r0,r0,r4
0004f6  d00c              BEQ      |L1.1298|
0004f8  f5b03f00          CMP      r0,#0x20000
0004fc  d115              BNE      |L1.1322|
0004fe  e011              B        |L1.1316|
                  |L1.1280|
;;;668      {
;;;669          /* transmit pending  */
;;;670        case (0x0): state = CAN_TxStatus_Pending;
000500  f04f0302          MOV      r3,#2
;;;671          break;
000504  e014              B        |L1.1328|
                  |L1.1286|
;;;672          /* transmit failed  */
;;;673         case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
000506  f04f0300          MOV      r3,#0
;;;674          break;
00050a  e011              B        |L1.1328|
                  |L1.1292|
;;;675         case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
00050c  f04f0300          MOV      r3,#0
;;;676          break;
000510  e00e              B        |L1.1328|
                  |L1.1298|
;;;677         case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
000512  f04f0300          MOV      r3,#0
;;;678          break;
000516  e00b              B        |L1.1328|
                  |L1.1304|
;;;679          /* transmit succeeded  */
;;;680        case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
000518  f04f0301          MOV      r3,#1
;;;681          break;
00051c  e008              B        |L1.1328|
                  |L1.1310|
;;;682        case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
00051e  f04f0301          MOV      r3,#1
;;;683          break;
000522  e005              B        |L1.1328|
                  |L1.1316|
;;;684        case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
000524  f04f0301          MOV      r3,#1
;;;685          break;
000528  e002              B        |L1.1328|
                  |L1.1322|
;;;686        default: state = CAN_TxStatus_Failed;
00052a  f04f0300          MOV      r3,#0
;;;687          break;
00052e  bf00              NOP      
                  |L1.1328|
000530  bf00              NOP                            ;671
;;;688      }
;;;689      return (uint8_t) state;
000532  b2d8              UXTB     r0,r3
;;;690    }
000534  bd10              POP      {r4,pc}
;;;691    
                          ENDP

                  CAN_CancelTransmit PROC
;;;697      */
;;;698    void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
000536  b121              CBZ      r1,|L1.1346|
;;;699    {
;;;700      /* Check the parameters */
;;;701      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;702      assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
;;;703      /* abort transmission */
;;;704      switch (Mailbox)
000538  2901              CMP      r1,#1
00053a  d007              BEQ      |L1.1356|
00053c  2902              CMP      r1,#2
00053e  d10f              BNE      |L1.1376|
000540  e009              B        |L1.1366|
                  |L1.1346|
;;;705      {
;;;706        case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
000542  6882              LDR      r2,[r0,#8]
000544  f0420280          ORR      r2,r2,#0x80
000548  6082              STR      r2,[r0,#8]
;;;707          break;
00054a  e00a              B        |L1.1378|
                  |L1.1356|
;;;708        case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
00054c  6882              LDR      r2,[r0,#8]
00054e  f4424200          ORR      r2,r2,#0x8000
000552  6082              STR      r2,[r0,#8]
;;;709          break;
000554  e005              B        |L1.1378|
                  |L1.1366|
;;;710        case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
000556  6882              LDR      r2,[r0,#8]
000558  f4420200          ORR      r2,r2,#0x800000
00055c  6082              STR      r2,[r0,#8]
;;;711          break;
00055e  e000              B        |L1.1378|
                  |L1.1376|
;;;712        default:
;;;713          break;
000560  bf00              NOP      
                  |L1.1378|
000562  bf00              NOP                            ;707
;;;714      }
;;;715    }
000564  4770              BX       lr
;;;716    /**
                          ENDP

                  CAN_Receive PROC
;;;744      */
;;;745    void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
000566  b510              PUSH     {r4,lr}
;;;746    {
;;;747      /* Check the parameters */
;;;748      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;749      assert_param(IS_CAN_FIFO(FIFONumber));
;;;750      /* Get the Id */
;;;751      RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
000568  f50073d8          ADD      r3,r0,#0x1b0
00056c  eb031301          ADD      r3,r3,r1,LSL #4
000570  681b              LDR      r3,[r3,#0]
000572  f0030304          AND      r3,r3,#4
000576  7213              STRB     r3,[r2,#8]
;;;752      if (RxMessage->IDE == CAN_Id_Standard)
000578  7a13              LDRB     r3,[r2,#8]
00057a  b953              CBNZ     r3,|L1.1426|
;;;753      {
;;;754        RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
00057c  f50073d8          ADD      r3,r0,#0x1b0
000580  eb031301          ADD      r3,r3,r1,LSL #4
000584  681b              LDR      r3,[r3,#0]
000586  f24074ff          MOV      r4,#0x7ff
00058a  ea045353          AND      r3,r4,r3,LSR #21
00058e  6013              STR      r3,[r2,#0]
000590  e009              B        |L1.1446|
                  |L1.1426|
;;;755      }
;;;756      else
;;;757      {
;;;758        RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
000592  f50073d8          ADD      r3,r0,#0x1b0
000596  eb031301          ADD      r3,r3,r1,LSL #4
00059a  681b              LDR      r3,[r3,#0]
00059c  f06f4460          MVN      r4,#0xe0000000
0005a0  ea0403d3          AND      r3,r4,r3,LSR #3
0005a4  6053              STR      r3,[r2,#4]
                  |L1.1446|
;;;759      }
;;;760      
;;;761      RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
0005a6  f50073d8          ADD      r3,r0,#0x1b0
0005aa  eb031301          ADD      r3,r3,r1,LSL #4
0005ae  681b              LDR      r3,[r3,#0]
0005b0  f0030302          AND      r3,r3,#2
0005b4  7253              STRB     r3,[r2,#9]
;;;762      /* Get the DLC */
;;;763      RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
0005b6  f50073d8          ADD      r3,r0,#0x1b0
0005ba  eb031301          ADD      r3,r3,r1,LSL #4
0005be  685b              LDR      r3,[r3,#4]
0005c0  f003030f          AND      r3,r3,#0xf
0005c4  7293              STRB     r3,[r2,#0xa]
;;;764      /* Get the FMI */
;;;765      RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
0005c6  f50073d8          ADD      r3,r0,#0x1b0
0005ca  eb031301          ADD      r3,r3,r1,LSL #4
0005ce  685b              LDR      r3,[r3,#4]
0005d0  ea4f2313          LSR      r3,r3,#8
0005d4  74d3              STRB     r3,[r2,#0x13]
;;;766      /* Get the data field */
;;;767      RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
0005d6  f50073d8          ADD      r3,r0,#0x1b0
0005da  eb031301          ADD      r3,r3,r1,LSL #4
0005de  689b              LDR      r3,[r3,#8]
0005e0  72d3              STRB     r3,[r2,#0xb]
;;;768      RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
0005e2  f50073d8          ADD      r3,r0,#0x1b0
0005e6  eb031301          ADD      r3,r3,r1,LSL #4
0005ea  689b              LDR      r3,[r3,#8]
0005ec  ea4f2413          LSR      r4,r3,#8
0005f0  7314              STRB     r4,[r2,#0xc]
;;;769      RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
0005f2  f50073d8          ADD      r3,r0,#0x1b0
0005f6  eb031301          ADD      r3,r3,r1,LSL #4
0005fa  689b              LDR      r3,[r3,#8]
0005fc  ea4f4413          LSR      r4,r3,#16
000600  7354              STRB     r4,[r2,#0xd]
;;;770      RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
000602  f50073d8          ADD      r3,r0,#0x1b0
000606  eb031301          ADD      r3,r3,r1,LSL #4
00060a  689b              LDR      r3,[r3,#8]
00060c  ea4f6313          LSR      r3,r3,#24
000610  7393              STRB     r3,[r2,#0xe]
;;;771      RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
000612  f50073d8          ADD      r3,r0,#0x1b0
000616  eb031301          ADD      r3,r3,r1,LSL #4
00061a  68db              LDR      r3,[r3,#0xc]
00061c  73d3              STRB     r3,[r2,#0xf]
;;;772      RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
00061e  f50073d8          ADD      r3,r0,#0x1b0
000622  eb031301          ADD      r3,r3,r1,LSL #4
000626  68db              LDR      r3,[r3,#0xc]
000628  ea4f2413          LSR      r4,r3,#8
00062c  7414              STRB     r4,[r2,#0x10]
;;;773      RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
00062e  f50073d8          ADD      r3,r0,#0x1b0
000632  eb031301          ADD      r3,r3,r1,LSL #4
000636  68db              LDR      r3,[r3,#0xc]
000638  ea4f4413          LSR      r4,r3,#16
00063c  7454              STRB     r4,[r2,#0x11]
;;;774      RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
00063e  f50073d8          ADD      r3,r0,#0x1b0
000642  eb031301          ADD      r3,r3,r1,LSL #4
000646  68db              LDR      r3,[r3,#0xc]
000648  ea4f6313          LSR      r3,r3,#24
00064c  7493              STRB     r3,[r2,#0x12]
;;;775      /* Release the FIFO */
;;;776      /* Release FIFO0 */
;;;777      if (FIFONumber == CAN_FIFO0)
00064e  b921              CBNZ     r1,|L1.1626|
;;;778      {
;;;779        CANx->RF0R |= CAN_RF0R_RFOM0;
000650  68c3              LDR      r3,[r0,#0xc]
000652  f0430320          ORR      r3,r3,#0x20
000656  60c3              STR      r3,[r0,#0xc]
000658  e003              B        |L1.1634|
                  |L1.1626|
;;;780      }
;;;781      /* Release FIFO1 */
;;;782      else /* FIFONumber == CAN_FIFO1 */
;;;783      {
;;;784        CANx->RF1R |= CAN_RF1R_RFOM1;
00065a  6903              LDR      r3,[r0,#0x10]
00065c  f0430320          ORR      r3,r3,#0x20
000660  6103              STR      r3,[r0,#0x10]
                  |L1.1634|
;;;785      }
;;;786    }
000662  bd10              POP      {r4,pc}
;;;787    
                          ENDP

                  CAN_FIFORelease PROC
;;;793      */
;;;794    void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
000664  b921              CBNZ     r1,|L1.1648|
;;;795    {
;;;796      /* Check the parameters */
;;;797      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;798      assert_param(IS_CAN_FIFO(FIFONumber));
;;;799      /* Release FIFO0 */
;;;800      if (FIFONumber == CAN_FIFO0)
;;;801      {
;;;802        CANx->RF0R |= CAN_RF0R_RFOM0;
000666  68c2              LDR      r2,[r0,#0xc]
000668  f0420220          ORR      r2,r2,#0x20
00066c  60c2              STR      r2,[r0,#0xc]
00066e  e003              B        |L1.1656|
                  |L1.1648|
;;;803      }
;;;804      /* Release FIFO1 */
;;;805      else /* FIFONumber == CAN_FIFO1 */
;;;806      {
;;;807        CANx->RF1R |= CAN_RF1R_RFOM1;
000670  6902              LDR      r2,[r0,#0x10]
000672  f0420220          ORR      r2,r2,#0x20
000676  6102              STR      r2,[r0,#0x10]
                  |L1.1656|
;;;808      }
;;;809    }
000678  4770              BX       lr
;;;810    
                          ENDP

                  CAN_MessagePending PROC
;;;816      */
;;;817    uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
00067a  4602              MOV      r2,r0
;;;818    {
;;;819      uint8_t message_pending=0;
00067c  f04f0000          MOV      r0,#0
;;;820      /* Check the parameters */
;;;821      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;822      assert_param(IS_CAN_FIFO(FIFONumber));
;;;823      if (FIFONumber == CAN_FIFO0)
000680  b919              CBNZ     r1,|L1.1674|
;;;824      {
;;;825        message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
000682  68d3              LDR      r3,[r2,#0xc]
000684  f0030003          AND      r0,r3,#3
000688  e007              B        |L1.1690|
                  |L1.1674|
;;;826      }
;;;827      else if (FIFONumber == CAN_FIFO1)
00068a  2901              CMP      r1,#1
00068c  d103              BNE      |L1.1686|
;;;828      {
;;;829        message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
00068e  6913              LDR      r3,[r2,#0x10]
000690  f0030003          AND      r0,r3,#3
000694  e001              B        |L1.1690|
                  |L1.1686|
;;;830      }
;;;831      else
;;;832      {
;;;833        message_pending = 0;
000696  f04f0000          MOV      r0,#0
                  |L1.1690|
;;;834      }
;;;835      return message_pending;
;;;836    }
00069a  4770              BX       lr
;;;837    /**
                          ENDP

                  CAN_OperatingModeRequest PROC
;;;866      */
;;;867    uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
00069c  b510              PUSH     {r4,lr}
;;;868    {
00069e  4602              MOV      r2,r0
0006a0  460b              MOV      r3,r1
;;;869      uint8_t status = CAN_ModeStatus_Failed;
0006a2  f04f0000          MOV      r0,#0
;;;870      
;;;871      /* Timeout for INAK or also for SLAK bits*/
;;;872      uint32_t timeout = INAK_TIMEOUT; 
0006a6  f64f71ff          MOV      r1,#0xffff
;;;873    
;;;874      /* Check the parameters */
;;;875      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;876      assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
;;;877    
;;;878      if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
0006aa  b9d3              CBNZ     r3,|L1.1762|
;;;879      {
;;;880        /* Request initialisation */
;;;881        CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
0006ac  6814              LDR      r4,[r2,#0]
0006ae  f0240402          BIC      r4,r4,#2
0006b2  f0440401          ORR      r4,r4,#1
0006b6  6014              STR      r4,[r2,#0]
;;;882    
;;;883        /* Wait the acknowledge */
;;;884        while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
0006b8  e001              B        |L1.1726|
                  |L1.1722|
;;;885        {
;;;886          timeout--;
0006ba  f1a10101          SUB      r1,r1,#1
                  |L1.1726|
0006be  6854              LDR      r4,[r2,#4]            ;884
0006c0  f0040403          AND      r4,r4,#3              ;884
0006c4  2c01              CMP      r4,#1                 ;884
0006c6  d001              BEQ      |L1.1740|
0006c8  2900              CMP      r1,#0                 ;884
0006ca  d1f6              BNE      |L1.1722|
                  |L1.1740|
;;;887        }
;;;888        if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
0006cc  6854              LDR      r4,[r2,#4]
0006ce  f0040403          AND      r4,r4,#3
0006d2  2c01              CMP      r4,#1
0006d4  d002              BEQ      |L1.1756|
;;;889        {
;;;890          status = CAN_ModeStatus_Failed;
0006d6  f04f0000          MOV      r0,#0
0006da  e03a              B        |L1.1874|
                  |L1.1756|
;;;891        }
;;;892        else
;;;893        {
;;;894          status = CAN_ModeStatus_Success;
0006dc  f04f0001          MOV      r0,#1
0006e0  e037              B        |L1.1874|
                  |L1.1762|
;;;895        }
;;;896      }
;;;897      else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
0006e2  2b01              CMP      r3,#1
0006e4  d116              BNE      |L1.1812|
;;;898      {
;;;899        /* Request leave initialisation and sleep mode  and enter Normal mode */
;;;900        CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
0006e6  6814              LDR      r4,[r2,#0]
0006e8  f0240403          BIC      r4,r4,#3
0006ec  6014              STR      r4,[r2,#0]
;;;901    
;;;902        /* Wait the acknowledge */
;;;903        while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
0006ee  e001              B        |L1.1780|
                  |L1.1776|
;;;904        {
;;;905          timeout--;
0006f0  f1a10101          SUB      r1,r1,#1
                  |L1.1780|
0006f4  6854              LDR      r4,[r2,#4]            ;903
0006f6  f0140f03          TST      r4,#3                 ;903
0006fa  d001              BEQ      |L1.1792|
0006fc  2900              CMP      r1,#0                 ;903
0006fe  d1f7              BNE      |L1.1776|
                  |L1.1792|
;;;906        }
;;;907        if ((CANx->MSR & CAN_MODE_MASK) != 0)
000700  6854              LDR      r4,[r2,#4]
000702  f0140f03          TST      r4,#3
000706  d002              BEQ      |L1.1806|
;;;908        {
;;;909          status = CAN_ModeStatus_Failed;
000708  f04f0000          MOV      r0,#0
00070c  e021              B        |L1.1874|
                  |L1.1806|
;;;910        }
;;;911        else
;;;912        {
;;;913          status = CAN_ModeStatus_Success;
00070e  f04f0001          MOV      r0,#1
000712  e01e              B        |L1.1874|
                  |L1.1812|
;;;914        }
;;;915      }
;;;916      else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
000714  2b02              CMP      r3,#2
000716  d11a              BNE      |L1.1870|
;;;917      {
;;;918        /* Request Sleep mode */
;;;919        CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
000718  6814              LDR      r4,[r2,#0]
00071a  f0240401          BIC      r4,r4,#1
00071e  f0440402          ORR      r4,r4,#2
000722  6014              STR      r4,[r2,#0]
;;;920    
;;;921        /* Wait the acknowledge */
;;;922        while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
000724  e001              B        |L1.1834|
                  |L1.1830|
;;;923        {
;;;924          timeout--;
000726  f1a10101          SUB      r1,r1,#1
                  |L1.1834|
00072a  6854              LDR      r4,[r2,#4]            ;922
00072c  f0040403          AND      r4,r4,#3              ;922
000730  2c02              CMP      r4,#2                 ;922
000732  d001              BEQ      |L1.1848|
000734  2900              CMP      r1,#0                 ;922
000736  d1f6              BNE      |L1.1830|
                  |L1.1848|
;;;925        }
;;;926        if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
000738  6854              LDR      r4,[r2,#4]
00073a  f0040403          AND      r4,r4,#3
00073e  2c02              CMP      r4,#2
000740  d002              BEQ      |L1.1864|
;;;927        {
;;;928          status = CAN_ModeStatus_Failed;
000742  f04f0000          MOV      r0,#0
000746  e004              B        |L1.1874|
                  |L1.1864|
;;;929        }
;;;930        else
;;;931        {
;;;932          status = CAN_ModeStatus_Success;
000748  f04f0001          MOV      r0,#1
00074c  e001              B        |L1.1874|
                  |L1.1870|
;;;933        }
;;;934      }
;;;935      else
;;;936      {
;;;937        status = CAN_ModeStatus_Failed;
00074e  f04f0000          MOV      r0,#0
                  |L1.1874|
;;;938      }
;;;939    
;;;940      return  (uint8_t) status;
;;;941    }
000752  bd10              POP      {r4,pc}
;;;942    
                          ENDP

                  CAN_Sleep PROC
;;;947      */
;;;948    uint8_t CAN_Sleep(CAN_TypeDef* CANx)
000754  4601              MOV      r1,r0
;;;949    {
;;;950      uint8_t sleepstatus = CAN_Sleep_Failed;
000756  f04f0000          MOV      r0,#0
;;;951      
;;;952      /* Check the parameters */
;;;953      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;954        
;;;955      /* Request Sleep mode */
;;;956       CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
00075a  680a              LDR      r2,[r1,#0]
00075c  f0220201          BIC      r2,r2,#1
000760  f0420202          ORR      r2,r2,#2
000764  600a              STR      r2,[r1,#0]
;;;957       
;;;958      /* Sleep mode status */
;;;959      if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
000766  684a              LDR      r2,[r1,#4]
000768  f0020203          AND      r2,r2,#3
00076c  2a02              CMP      r2,#2
00076e  d101              BNE      |L1.1908|
;;;960      {
;;;961        /* Sleep mode not entered */
;;;962        sleepstatus =  CAN_Sleep_Ok;
000770  f04f0001          MOV      r0,#1
                  |L1.1908|
;;;963      }
;;;964      /* return sleep mode status */
;;;965       return (uint8_t)sleepstatus;
;;;966    }
000774  4770              BX       lr
;;;967    
                          ENDP

                  CAN_WakeUp PROC
;;;972      */
;;;973    uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
000776  4601              MOV      r1,r0
;;;974    {
;;;975      uint32_t wait_slak = SLAK_TIMEOUT;
000778  f64f72ff          MOV      r2,#0xffff
;;;976      uint8_t wakeupstatus = CAN_WakeUp_Failed;
00077c  f04f0000          MOV      r0,#0
;;;977      
;;;978      /* Check the parameters */
;;;979      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;980        
;;;981      /* Wake up request */
;;;982      CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
000780  680b              LDR      r3,[r1,#0]
000782  f0230302          BIC      r3,r3,#2
000786  600b              STR      r3,[r1,#0]
;;;983        
;;;984      /* Sleep mode status */
;;;985      while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
000788  e001              B        |L1.1934|
                  |L1.1930|
;;;986      {
;;;987       wait_slak--;
00078a  f1a20201          SUB      r2,r2,#1
                  |L1.1934|
00078e  684b              LDR      r3,[r1,#4]            ;985
000790  f0030302          AND      r3,r3,#2              ;985
000794  2b02              CMP      r3,#2                 ;985
000796  d101              BNE      |L1.1948|
000798  2a00              CMP      r2,#0                 ;985
00079a  d1f6              BNE      |L1.1930|
                  |L1.1948|
;;;988      }
;;;989      if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
00079c  684b              LDR      r3,[r1,#4]
00079e  f0030302          AND      r3,r3,#2
0007a2  2b02              CMP      r3,#2
0007a4  d001              BEQ      |L1.1962|
;;;990      {
;;;991       /* wake up done : Sleep mode exited */
;;;992        wakeupstatus = CAN_WakeUp_Ok;
0007a6  f04f0001          MOV      r0,#1
                  |L1.1962|
;;;993      }
;;;994      /* return wakeup status */
;;;995      return (uint8_t)wakeupstatus;
;;;996    }
0007aa  4770              BX       lr
;;;997    /**
                          ENDP

                  CAN_GetLastErrorCode PROC
;;;1034     */
;;;1035   uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
0007ac  4601              MOV      r1,r0
;;;1036   {
;;;1037     uint8_t errorcode=0;
0007ae  f04f0000          MOV      r0,#0
;;;1038     
;;;1039     /* Check the parameters */
;;;1040     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1041     
;;;1042     /* Get the error code*/
;;;1043     errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
0007b2  698a              LDR      r2,[r1,#0x18]
0007b4  f0020070          AND      r0,r2,#0x70
;;;1044     
;;;1045     /* Return the error code*/
;;;1046     return errorcode;
;;;1047   }
0007b8  4770              BX       lr
;;;1048   
                          ENDP

                  CAN_GetReceiveErrorCounter PROC
;;;1059     */
;;;1060   uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
0007ba  4601              MOV      r1,r0
;;;1061   {
;;;1062     uint8_t counter=0;
0007bc  f04f0000          MOV      r0,#0
;;;1063     
;;;1064     /* Check the parameters */
;;;1065     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1066     
;;;1067     /* Get the Receive Error Counter*/
;;;1068     counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
0007c0  698a              LDR      r2,[r1,#0x18]
0007c2  ea4f6012          LSR      r0,r2,#24
;;;1069     
;;;1070     /* Return the Receive Error Counter*/
;;;1071     return counter;
;;;1072   }
0007c6  4770              BX       lr
;;;1073   
                          ENDP

                  CAN_GetLSBTransmitErrorCounter PROC
;;;1079     */
;;;1080   uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
0007c8  4601              MOV      r1,r0
;;;1081   {
;;;1082     uint8_t counter=0;
0007ca  f04f0000          MOV      r0,#0
;;;1083     
;;;1084     /* Check the parameters */
;;;1085     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1086     
;;;1087     /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
;;;1088     counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
0007ce  698a              LDR      r2,[r1,#0x18]
0007d0  f3c24007          UBFX     r0,r2,#16,#8
;;;1089     
;;;1090     /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
;;;1091     return counter;
;;;1092   }
0007d4  4770              BX       lr
;;;1093   /**
                          ENDP

                  CAN_ITConfig PROC
;;;1286     */
;;;1287   void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
0007d6  b122              CBZ      r2,|L1.2018|
;;;1288   {
;;;1289     /* Check the parameters */
;;;1290     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1291     assert_param(IS_CAN_IT(CAN_IT));
;;;1292     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1293   
;;;1294     if (NewState != DISABLE)
;;;1295     {
;;;1296       /* Enable the selected CANx interrupt */
;;;1297       CANx->IER |= CAN_IT;
0007d8  6943              LDR      r3,[r0,#0x14]
0007da  ea430301          ORR      r3,r3,r1
0007de  6143              STR      r3,[r0,#0x14]
0007e0  e003              B        |L1.2026|
                  |L1.2018|
;;;1298     }
;;;1299     else
;;;1300     {
;;;1301       /* Disable the selected CANx interrupt */
;;;1302       CANx->IER &= ~CAN_IT;
0007e2  6943              LDR      r3,[r0,#0x14]
0007e4  ea230301          BIC      r3,r3,r1
0007e8  6143              STR      r3,[r0,#0x14]
                  |L1.2026|
;;;1303     }
;;;1304   }
0007ea  4770              BX       lr
;;;1305   /**
                          ENDP

                  CAN_GetFlagStatus PROC
;;;1326     */
;;;1327   FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
0007ec  b510              PUSH     {r4,lr}
;;;1328   {
0007ee  4602              MOV      r2,r0
;;;1329     FlagStatus bitstatus = RESET;
0007f0  f04f0000          MOV      r0,#0
;;;1330     
;;;1331     /* Check the parameters */
;;;1332     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1333     assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
;;;1334     
;;;1335   
;;;1336     if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
0007f4  f4110f70          TST      r1,#0xf00000
0007f8  d00a              BEQ      |L1.2064|
;;;1337     { 
;;;1338       /* Check the status of the specified CAN flag */
;;;1339       if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
0007fa  6993              LDR      r3,[r2,#0x18]
0007fc  f3c10413          UBFX     r4,r1,#0,#20
000800  4223              TST      r3,r4
000802  d002              BEQ      |L1.2058|
;;;1340       { 
;;;1341         /* CAN_FLAG is set */
;;;1342         bitstatus = SET;
000804  f04f0001          MOV      r0,#1
000808  e036              B        |L1.2168|
                  |L1.2058|
;;;1343       }
;;;1344       else
;;;1345       { 
;;;1346         /* CAN_FLAG is reset */
;;;1347         bitstatus = RESET;
00080a  f04f0000          MOV      r0,#0
00080e  e033              B        |L1.2168|
                  |L1.2064|
;;;1348       }
;;;1349     }
;;;1350     else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
000810  f0117f80          TST      r1,#0x1000000
000814  d00a              BEQ      |L1.2092|
;;;1351     { 
;;;1352       /* Check the status of the specified CAN flag */
;;;1353       if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
000816  6853              LDR      r3,[r2,#4]
000818  f3c10413          UBFX     r4,r1,#0,#20
00081c  4223              TST      r3,r4
00081e  d002              BEQ      |L1.2086|
;;;1354       { 
;;;1355         /* CAN_FLAG is set */
;;;1356         bitstatus = SET;
000820  f04f0001          MOV      r0,#1
000824  e028              B        |L1.2168|
                  |L1.2086|
;;;1357       }
;;;1358       else
;;;1359       { 
;;;1360         /* CAN_FLAG is reset */
;;;1361         bitstatus = RESET;
000826  f04f0000          MOV      r0,#0
00082a  e025              B        |L1.2168|
                  |L1.2092|
;;;1362       }
;;;1363     }
;;;1364     else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
00082c  f0116f00          TST      r1,#0x8000000
000830  d00a              BEQ      |L1.2120|
;;;1365     { 
;;;1366       /* Check the status of the specified CAN flag */
;;;1367       if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
000832  6893              LDR      r3,[r2,#8]
000834  f3c10413          UBFX     r4,r1,#0,#20
000838  4223              TST      r3,r4
00083a  d002              BEQ      |L1.2114|
;;;1368       { 
;;;1369         /* CAN_FLAG is set */
;;;1370         bitstatus = SET;
00083c  f04f0001          MOV      r0,#1
000840  e01a              B        |L1.2168|
                  |L1.2114|
;;;1371       }
;;;1372       else
;;;1373       { 
;;;1374         /* CAN_FLAG is reset */
;;;1375         bitstatus = RESET;
000842  f04f0000          MOV      r0,#0
000846  e017              B        |L1.2168|
                  |L1.2120|
;;;1376       }
;;;1377     }
;;;1378     else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
000848  f0117f00          TST      r1,#0x2000000
00084c  d00a              BEQ      |L1.2148|
;;;1379     { 
;;;1380       /* Check the status of the specified CAN flag */
;;;1381       if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
00084e  68d3              LDR      r3,[r2,#0xc]
000850  f3c10413          UBFX     r4,r1,#0,#20
000854  4223              TST      r3,r4
000856  d002              BEQ      |L1.2142|
;;;1382       { 
;;;1383         /* CAN_FLAG is set */
;;;1384         bitstatus = SET;
000858  f04f0001          MOV      r0,#1
00085c  e00c              B        |L1.2168|
                  |L1.2142|
;;;1385       }
;;;1386       else
;;;1387       { 
;;;1388         /* CAN_FLAG is reset */
;;;1389         bitstatus = RESET;
00085e  f04f0000          MOV      r0,#0
000862  e009              B        |L1.2168|
                  |L1.2148|
;;;1390       }
;;;1391     }
;;;1392     else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
;;;1393     { 
;;;1394       /* Check the status of the specified CAN flag */
;;;1395       if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
000864  6913              LDR      r3,[r2,#0x10]
000866  f3c10413          UBFX     r4,r1,#0,#20
00086a  4223              TST      r3,r4
00086c  d002              BEQ      |L1.2164|
;;;1396       { 
;;;1397         /* CAN_FLAG is set */
;;;1398         bitstatus = SET;
00086e  f04f0001          MOV      r0,#1
000872  e001              B        |L1.2168|
                  |L1.2164|
;;;1399       }
;;;1400       else
;;;1401       { 
;;;1402         /* CAN_FLAG is reset */
;;;1403         bitstatus = RESET;
000874  f04f0000          MOV      r0,#0
                  |L1.2168|
;;;1404       }
;;;1405     }
;;;1406     /* Return the CAN_FLAG status */
;;;1407     return  bitstatus;
;;;1408   }
000878  bd10              POP      {r4,pc}
;;;1409   
                          ENDP

                  CAN_ClearFlag PROC
;;;1426     */
;;;1427   void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
00087a  f04f0200          MOV      r2,#0
;;;1428   {
;;;1429     uint32_t flagtmp=0;
;;;1430     /* Check the parameters */
;;;1431     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1432     assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
;;;1433     
;;;1434     if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
00087e  4b08              LDR      r3,|L1.2208|
000880  4299              CMP      r1,r3
000882  d10f              BNE      |L1.2212|
;;;1435     {
;;;1436       /* Clear the selected CAN flags */
;;;1437       CANx->ESR = (uint32_t)RESET;
000884  f04f0300          MOV      r3,#0
000888  6183              STR      r3,[r0,#0x18]
00088a  e01d              B        |L1.2248|
                  |L1.2188|
                          DCD      0x04000003
                  |L1.2192|
                          DCD      0x08000300
                  |L1.2196|
                          DCD      0x10030000
                  |L1.2200|
                          DCD      0x08000100
                  |L1.2204|
                          DCD      0xf7ff0100
                  |L1.2208|
                          DCD      0x30f00070
                  |L1.2212|
;;;1438     }
;;;1439     else /* MSR or TSR or RF0R or RF1R */
;;;1440     {
;;;1441       flagtmp = CAN_FLAG & 0x000FFFFF;
0008a4  f3c10213          UBFX     r2,r1,#0,#20
;;;1442   
;;;1443       if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
0008a8  f0117f00          TST      r1,#0x2000000
0008ac  d001              BEQ      |L1.2226|
;;;1444       {
;;;1445         /* Receive Flags */
;;;1446         CANx->RF0R = (uint32_t)(flagtmp);
0008ae  60c2              STR      r2,[r0,#0xc]
0008b0  e00a              B        |L1.2248|
                  |L1.2226|
;;;1447       }
;;;1448       else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
0008b2  f0116f80          TST      r1,#0x4000000
0008b6  d001              BEQ      |L1.2236|
;;;1449       {
;;;1450         /* Receive Flags */
;;;1451         CANx->RF1R = (uint32_t)(flagtmp);
0008b8  6102              STR      r2,[r0,#0x10]
0008ba  e005              B        |L1.2248|
                  |L1.2236|
;;;1452       }
;;;1453       else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
0008bc  f0116f00          TST      r1,#0x8000000
0008c0  d001              BEQ      |L1.2246|
;;;1454       {
;;;1455         /* Transmit Flags */
;;;1456         CANx->TSR = (uint32_t)(flagtmp);
0008c2  6082              STR      r2,[r0,#8]
0008c4  e000              B        |L1.2248|
                  |L1.2246|
;;;1457       }
;;;1458       else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
;;;1459       {
;;;1460         /* Operating mode Flags */
;;;1461         CANx->MSR = (uint32_t)(flagtmp);
0008c6  6042              STR      r2,[r0,#4]
                  |L1.2248|
;;;1462       }
;;;1463     }
;;;1464   }
0008c8  4770              BX       lr
;;;1465   
                          ENDP

                  CheckITStatus PROC
;;;1668     */
;;;1669   static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
0008ca  4602              MOV      r2,r0
;;;1670   {
;;;1671     ITStatus pendingbitstatus = RESET;
0008cc  f04f0000          MOV      r0,#0
;;;1672     
;;;1673     if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
0008d0  420a              TST      r2,r1
0008d2  d002              BEQ      |L1.2266|
;;;1674     {
;;;1675       /* CAN_IT is set */
;;;1676       pendingbitstatus = SET;
0008d4  f04f0001          MOV      r0,#1
0008d8  e001              B        |L1.2270|
                  |L1.2266|
;;;1677     }
;;;1678     else
;;;1679     {
;;;1680       /* CAN_IT is reset */
;;;1681       pendingbitstatus = RESET;
0008da  f04f0000          MOV      r0,#0
                  |L1.2270|
;;;1682     }
;;;1683     return pendingbitstatus;
;;;1684   }
0008de  4770              BX       lr
;;;1685   
                          ENDP

                  CAN_GetITStatus PROC
;;;1486     */
;;;1487   ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
0008e0  b570              PUSH     {r4-r6,lr}
;;;1488   {
0008e2  4604              MOV      r4,r0
0008e4  460d              MOV      r5,r1
;;;1489     ITStatus itstatus = RESET;
0008e6  f04f0600          MOV      r6,#0
;;;1490     /* Check the parameters */
;;;1491     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1492     assert_param(IS_CAN_IT(CAN_IT));
;;;1493     
;;;1494     /* check the interrupt enable bit */
;;;1495    if((CANx->IER & CAN_IT) != RESET)
0008ea  6960              LDR      r0,[r4,#0x14]
0008ec  4228              TST      r0,r5
0008ee  d071              BEQ      |L1.2516|
;;;1496    {
;;;1497      /* in case the Interrupt is enabled, .... */
;;;1498       switch (CAN_IT)
0008f0  f5b57f80          CMP      r5,#0x100
0008f4  d05c              BEQ      |L1.2480|
0008f6  dc10              BGT      |L1.2330|
0008f8  2d08              CMP      r5,#8
0008fa  d035              BEQ      |L1.2408|
0008fc  dc06              BGT      |L1.2316|
0008fe  2d01              CMP      r5,#1
000900  d020              BEQ      |L1.2372|
000902  2d02              CMP      r5,#2
000904  d024              BEQ      |L1.2384|
000906  2d04              CMP      r5,#4
000908  d172              BNE      |L1.2544|
00090a  e027              B        |L1.2396|
                  |L1.2316|
00090c  2d10              CMP      r5,#0x10
00090e  d031              BEQ      |L1.2420|
000910  2d20              CMP      r5,#0x20
000912  d035              BEQ      |L1.2432|
000914  2d40              CMP      r5,#0x40
000916  d16b              BNE      |L1.2544|
000918  e038              B        |L1.2444|
                  |L1.2330|
00091a  f5b54f00          CMP      r5,#0x8000
00091e  d060              BEQ      |L1.2530|
000920  dc09              BGT      |L1.2358|
000922  f5b57f00          CMP      r5,#0x200
000926  d049              BEQ      |L1.2492|
000928  f5b56f80          CMP      r5,#0x400
00092c  d04c              BEQ      |L1.2504|
00092e  f5b56f00          CMP      r5,#0x800
000932  d15d              BNE      |L1.2544|
000934  e04f              B        |L1.2518|
                  |L1.2358|
000936  f5b53f80          CMP      r5,#0x10000
00093a  d02d              BEQ      |L1.2456|
00093c  f5b53f00          CMP      r5,#0x20000
000940  d156              BNE      |L1.2544|
000942  e02f              B        |L1.2468|
                  |L1.2372|
;;;1499       {
;;;1500         case CAN_IT_TME:
;;;1501           /* Check CAN_TSR_RQCPx bits */
;;;1502           itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
000944  68a0              LDR      r0,[r4,#8]
000946  495d              LDR      r1,|L1.2748|
000948  f7fffffe          BL       CheckITStatus
00094c  4606              MOV      r6,r0
;;;1503           break;
00094e  e052              B        |L1.2550|
                  |L1.2384|
;;;1504         case CAN_IT_FMP0:
;;;1505           /* Check CAN_RF0R_FMP0 bit */
;;;1506           itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
000950  68e0              LDR      r0,[r4,#0xc]
000952  2103              MOVS     r1,#3
000954  f7fffffe          BL       CheckITStatus
000958  4606              MOV      r6,r0
;;;1507           break;
00095a  e04c              B        |L1.2550|
                  |L1.2396|
;;;1508         case CAN_IT_FF0:
;;;1509           /* Check CAN_RF0R_FULL0 bit */
;;;1510           itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
00095c  68e0              LDR      r0,[r4,#0xc]
00095e  2108              MOVS     r1,#8
000960  f7fffffe          BL       CheckITStatus
000964  4606              MOV      r6,r0
;;;1511           break;
000966  e046              B        |L1.2550|
                  |L1.2408|
;;;1512         case CAN_IT_FOV0:
;;;1513           /* Check CAN_RF0R_FOVR0 bit */
;;;1514           itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
000968  68e0              LDR      r0,[r4,#0xc]
00096a  2110              MOVS     r1,#0x10
00096c  f7fffffe          BL       CheckITStatus
000970  4606              MOV      r6,r0
;;;1515           break;
000972  e040              B        |L1.2550|
                  |L1.2420|
;;;1516         case CAN_IT_FMP1:
;;;1517           /* Check CAN_RF1R_FMP1 bit */
;;;1518           itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
000974  6920              LDR      r0,[r4,#0x10]
000976  2103              MOVS     r1,#3
000978  f7fffffe          BL       CheckITStatus
00097c  4606              MOV      r6,r0
;;;1519           break;
00097e  e03a              B        |L1.2550|
                  |L1.2432|
;;;1520         case CAN_IT_FF1:
;;;1521           /* Check CAN_RF1R_FULL1 bit */
;;;1522           itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
000980  6920              LDR      r0,[r4,#0x10]
000982  2108              MOVS     r1,#8
000984  f7fffffe          BL       CheckITStatus
000988  4606              MOV      r6,r0
;;;1523           break;
00098a  e034              B        |L1.2550|
                  |L1.2444|
;;;1524         case CAN_IT_FOV1:
;;;1525           /* Check CAN_RF1R_FOVR1 bit */
;;;1526           itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
00098c  6920              LDR      r0,[r4,#0x10]
00098e  2110              MOVS     r1,#0x10
000990  f7fffffe          BL       CheckITStatus
000994  4606              MOV      r6,r0
;;;1527           break;
000996  e02e              B        |L1.2550|
                  |L1.2456|
;;;1528         case CAN_IT_WKU:
;;;1529           /* Check CAN_MSR_WKUI bit */
;;;1530           itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
000998  6860              LDR      r0,[r4,#4]
00099a  2108              MOVS     r1,#8
00099c  f7fffffe          BL       CheckITStatus
0009a0  4606              MOV      r6,r0
;;;1531           break;
0009a2  e028              B        |L1.2550|
                  |L1.2468|
;;;1532         case CAN_IT_SLK:
;;;1533           /* Check CAN_MSR_SLAKI bit */
;;;1534           itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
0009a4  6860              LDR      r0,[r4,#4]
0009a6  2110              MOVS     r1,#0x10
0009a8  f7fffffe          BL       CheckITStatus
0009ac  4606              MOV      r6,r0
;;;1535           break;
0009ae  e022              B        |L1.2550|
                  |L1.2480|
;;;1536         case CAN_IT_EWG:
;;;1537           /* Check CAN_ESR_EWGF bit */
;;;1538           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
0009b0  69a0              LDR      r0,[r4,#0x18]
0009b2  2101              MOVS     r1,#1
0009b4  f7fffffe          BL       CheckITStatus
0009b8  4606              MOV      r6,r0
;;;1539           break;
0009ba  e01c              B        |L1.2550|
                  |L1.2492|
;;;1540         case CAN_IT_EPV:
;;;1541           /* Check CAN_ESR_EPVF bit */
;;;1542           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
0009bc  69a0              LDR      r0,[r4,#0x18]
0009be  2102              MOVS     r1,#2
0009c0  f7fffffe          BL       CheckITStatus
0009c4  4606              MOV      r6,r0
;;;1543           break;
0009c6  e016              B        |L1.2550|
                  |L1.2504|
;;;1544         case CAN_IT_BOF:
;;;1545           /* Check CAN_ESR_BOFF bit */
;;;1546           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
0009c8  69a0              LDR      r0,[r4,#0x18]
0009ca  2104              MOVS     r1,#4
0009cc  f7fffffe          BL       CheckITStatus
0009d0  4606              MOV      r6,r0
;;;1547           break;
0009d2  e010              B        |L1.2550|
                  |L1.2516|
0009d4  e010              B        |L1.2552|
                  |L1.2518|
;;;1548         case CAN_IT_LEC:
;;;1549           /* Check CAN_ESR_LEC bit */
;;;1550           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
0009d6  69a0              LDR      r0,[r4,#0x18]
0009d8  2170              MOVS     r1,#0x70
0009da  f7fffffe          BL       CheckITStatus
0009de  4606              MOV      r6,r0
;;;1551           break;
0009e0  e009              B        |L1.2550|
                  |L1.2530|
;;;1552         case CAN_IT_ERR:
;;;1553           /* Check CAN_MSR_ERRI bit */ 
;;;1554           itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
0009e2  6860              LDR      r0,[r4,#4]
0009e4  2104              MOVS     r1,#4
0009e6  f7fffffe          BL       CheckITStatus
0009ea  4606              MOV      r6,r0
;;;1555           break;
0009ec  e003              B        |L1.2550|
0009ee  e7ff              B        |L1.2544|
                  |L1.2544|
;;;1556         default:
;;;1557           /* in case of error, return RESET */
;;;1558           itstatus = RESET;
0009f0  f04f0600          MOV      r6,#0
;;;1559           break;
0009f4  bf00              NOP      
                  |L1.2550|
0009f6  e001              B        |L1.2556|
                  |L1.2552|
;;;1560       }
;;;1561     }
;;;1562     else
;;;1563     {
;;;1564      /* in case the Interrupt is not enabled, return RESET */
;;;1565       itstatus  = RESET;
0009f8  f04f0600          MOV      r6,#0
                  |L1.2556|
;;;1566     }
;;;1567     
;;;1568     /* Return the CAN_IT status */
;;;1569     return  itstatus;
0009fc  4630              MOV      r0,r6
;;;1570   }
0009fe  bd70              POP      {r4-r6,pc}
;;;1571   
                          ENDP

                  CAN_ClearITPendingBit PROC
;;;1590     */
;;;1591   void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
000a00  f5b17f00          CMP      r1,#0x200
;;;1592   {
;;;1593     /* Check the parameters */
;;;1594     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1595     assert_param(IS_CAN_CLEAR_IT(CAN_IT));
;;;1596   
;;;1597     switch (CAN_IT)
000a04  d041              BEQ      |L1.2698|
000a06  dc0f              BGT      |L1.2600|
000a08  2920              CMP      r1,#0x20
000a0a  d02a              BEQ      |L1.2658|
000a0c  dc06              BGT      |L1.2588|
000a0e  2901              CMP      r1,#1
000a10  d01c              BEQ      |L1.2636|
000a12  2904              CMP      r1,#4
000a14  d01d              BEQ      |L1.2642|
000a16  2908              CMP      r1,#8
000a18  d14d              BNE      |L1.2742|
000a1a  e01e              B        |L1.2650|
                  |L1.2588|
000a1c  2940              CMP      r1,#0x40
000a1e  d024              BEQ      |L1.2666|
000a20  f5b17f80          CMP      r1,#0x100
000a24  d147              BNE      |L1.2742|
000a26  e02c              B        |L1.2690|
                  |L1.2600|
000a28  f5b14f00          CMP      r1,#0x8000
000a2c  d03c              BEQ      |L1.2728|
000a2e  dc06              BGT      |L1.2622|
000a30  f5b16f80          CMP      r1,#0x400
000a34  d02d              BEQ      |L1.2706|
000a36  f5b16f00          CMP      r1,#0x800
000a3a  d13c              BNE      |L1.2742|
000a3c  e02d              B        |L1.2714|
                  |L1.2622|
000a3e  f5b13f80          CMP      r1,#0x10000
000a42  d016              BEQ      |L1.2674|
000a44  f5b13f00          CMP      r1,#0x20000
000a48  d135              BNE      |L1.2742|
000a4a  e016              B        |L1.2682|
                  |L1.2636|
;;;1598     {
;;;1599       case CAN_IT_TME:
;;;1600         /* Clear CAN_TSR_RQCPx (rc_w1)*/
;;;1601         CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
000a4c  4a1b              LDR      r2,|L1.2748|
000a4e  6082              STR      r2,[r0,#8]
;;;1602         break;
000a50  e032              B        |L1.2744|
                  |L1.2642|
;;;1603       case CAN_IT_FF0:
;;;1604         /* Clear CAN_RF0R_FULL0 (rc_w1)*/
;;;1605         CANx->RF0R = CAN_RF0R_FULL0; 
000a52  f04f0208          MOV      r2,#8
000a56  60c2              STR      r2,[r0,#0xc]
;;;1606         break;
000a58  e02e              B        |L1.2744|
                  |L1.2650|
;;;1607       case CAN_IT_FOV0:
;;;1608         /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
;;;1609         CANx->RF0R = CAN_RF0R_FOVR0; 
000a5a  f04f0210          MOV      r2,#0x10
000a5e  60c2              STR      r2,[r0,#0xc]
;;;1610         break;
000a60  e02a              B        |L1.2744|
                  |L1.2658|
;;;1611       case CAN_IT_FF1:
;;;1612         /* Clear CAN_RF1R_FULL1 (rc_w1)*/
;;;1613         CANx->RF1R = CAN_RF1R_FULL1;  
000a62  f04f0208          MOV      r2,#8
000a66  6102              STR      r2,[r0,#0x10]
;;;1614         break;
000a68  e026              B        |L1.2744|
                  |L1.2666|
;;;1615       case CAN_IT_FOV1:
;;;1616         /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
;;;1617         CANx->RF1R = CAN_RF1R_FOVR1; 
000a6a  f04f0210          MOV      r2,#0x10
000a6e  6102              STR      r2,[r0,#0x10]
;;;1618         break;
000a70  e022              B        |L1.2744|
                  |L1.2674|
;;;1619       case CAN_IT_WKU:
;;;1620         /* Clear CAN_MSR_WKUI (rc_w1)*/
;;;1621         CANx->MSR = CAN_MSR_WKUI;  
000a72  f04f0208          MOV      r2,#8
000a76  6042              STR      r2,[r0,#4]
;;;1622         break;
000a78  e01e              B        |L1.2744|
                  |L1.2682|
;;;1623       case CAN_IT_SLK:
;;;1624         /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
;;;1625         CANx->MSR = CAN_MSR_SLAKI;   
000a7a  f04f0210          MOV      r2,#0x10
000a7e  6042              STR      r2,[r0,#4]
;;;1626         break;
000a80  e01a              B        |L1.2744|
                  |L1.2690|
;;;1627       case CAN_IT_EWG:
;;;1628         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1629         CANx->MSR = CAN_MSR_ERRI;
000a82  f04f0204          MOV      r2,#4
000a86  6042              STR      r2,[r0,#4]
;;;1630          /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/ 
;;;1631         break;
000a88  e016              B        |L1.2744|
                  |L1.2698|
;;;1632       case CAN_IT_EPV:
;;;1633         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1634         CANx->MSR = CAN_MSR_ERRI; 
000a8a  f04f0204          MOV      r2,#4
000a8e  6042              STR      r2,[r0,#4]
;;;1635          /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
;;;1636         break;
000a90  e012              B        |L1.2744|
                  |L1.2706|
;;;1637       case CAN_IT_BOF:
;;;1638         /* Clear CAN_MSR_ERRI (rc_w1) */ 
;;;1639         CANx->MSR = CAN_MSR_ERRI; 
000a92  f04f0204          MOV      r2,#4
000a96  6042              STR      r2,[r0,#4]
;;;1640          /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
;;;1641          break;
000a98  e00e              B        |L1.2744|
                  |L1.2714|
;;;1642       case CAN_IT_LEC:
;;;1643         /*  Clear LEC bits */
;;;1644         CANx->ESR = RESET; 
000a9a  f04f0200          MOV      r2,#0
000a9e  6182              STR      r2,[r0,#0x18]
;;;1645         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1646         CANx->MSR = CAN_MSR_ERRI; 
000aa0  f04f0204          MOV      r2,#4
000aa4  6042              STR      r2,[r0,#4]
;;;1647         break;
000aa6  e007              B        |L1.2744|
                  |L1.2728|
;;;1648       case CAN_IT_ERR:
;;;1649         /*Clear LEC bits */
;;;1650         CANx->ESR = RESET; 
000aa8  f04f0200          MOV      r2,#0
000aac  6182              STR      r2,[r0,#0x18]
;;;1651         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1652         CANx->MSR = CAN_MSR_ERRI; 
000aae  f04f0204          MOV      r2,#4
000ab2  6042              STR      r2,[r0,#4]
;;;1653          /* @note BOFF, EPVF and EWGF Flags are cleared by hardware depending on the CAN Bus status*/
;;;1654          break;
000ab4  e000              B        |L1.2744|
                  |L1.2742|
;;;1655       default:
;;;1656          break;
000ab6  bf00              NOP      
                  |L1.2744|
000ab8  bf00              NOP                            ;1602
;;;1657      }
;;;1658   }
000aba  4770              BX       lr
;;;1659    /**
                          ENDP

                  |L1.2748|
                          DCD      0x00010101

;*** Start embedded assembler ***

#line 1 "..\\BSP\\STM32F2xx\\src\\stm32f2xx_can.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f2xx_can_c_347dae01____REV16|
#line 112 "..\\BSP\\CMSIS\\core_cmInstr.h"
|__asm___15_stm32f2xx_can_c_347dae01____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f2xx_can_c_347dae01____REVSH|
#line 130
|__asm___15_stm32f2xx_can_c_347dae01____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
