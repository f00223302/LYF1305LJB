; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Output\app_adc.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\Output\app_adc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\BSP -I..\BSP\UCOS-II -I..\BSP\STM32F2xx\inc -I..\BSP\CMSIS -I..\BSP\CMSIS\Device_Support -I..\BSP\UCOS-II -I..\..\uC-CPU -I..\..\uC-CPU\ARM-Cortex-M3 -I..\..\uC-LIB -I..\..\uC-LIB\Ports\ARM-Cortex-M3 -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3 -I..\App -I..\Prj -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DDEBUG -DLJB_CPU_MAIN -DUSE_CPU_F205RC --omf_browse=.\Output\app_adc.crf ..\App\app_adc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  GetDigitalRes PROC
;;;331    
;;;332    void GetDigitalRes(uint8_t Index)
000000  b570              PUSH     {r4-r6,lr}
;;;333    {
000002  b088              SUB      sp,sp,#0x20
000004  4605              MOV      r5,r0
;;;334        uint8_t i, _TmpVal[5];
;;;335    
;;;336        float val[5];
;;;337    
;;;338    
;;;339    #if 0
;;;340        val = AppInfo.AdcRatio[0] * _ResBuf[Index][0];
;;;341    
;;;342        UserInf.ID110V  = (uint8_t)(val/1000);
;;;343    
;;;344        val = AppInfo.AdcRatio[1] * _ResBuf[Index][1];
;;;345    
;;;346        UserInf.IID110V = (uint8_t)(val/1000);
;;;347    
;;;348        val = AppInfo.AdcRatio[2] * _ResBuf[Index][2];
;;;349    
;;;350        UserInf.CSID    = (uint8_t)(val/1000);
;;;351    
;;;352        val = AppInfo.AdcRatio[3] * _ResBuf[Index][3];
;;;353    
;;;354        UserInf.CSIID   = (uint8_t)(val/1000);
;;;355    
;;;356        val = AppInfo.AdcRatio[4] * _ResBuf[Index][4];
;;;357    
;;;358        UserInf.D110V   = (uint8_t)(val/1000);
;;;359    #endif
;;;360    
;;;361    
;;;362    
;;;363        for (i = 0; i < 5; i++)
000006  f04f0400          MOV      r4,#0
00000a  e045              B        |L1.152|
                  |L1.12|
;;;364        {
;;;365            val[i] = AppInfo.AdcRatio[i] * _ResBuf[Index][i];
00000c  eb050185          ADD      r1,r5,r5,LSL #2
000010  4ada              LDR      r2,|L1.892|
000012  eb020141          ADD      r1,r2,r1,LSL #1
000016  f8310014          LDRH     r0,[r1,r4,LSL #1]
00001a  f7fffffe          BL       __aeabi_ui2f
00001e  4606              MOV      r6,r0
000020  48d7              LDR      r0,|L1.896|
000022  f8501024          LDR      r1,[r0,r4,LSL #2]
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       __aeabi_fmul
00002c  a901              ADD      r1,sp,#4
00002e  f8410024          STR      r0,[r1,r4,LSL #2]
;;;366    
;;;367            //_TmpVal[i] = (uint8_t)(val/1000);
;;;368    
;;;369    
;;;370            if (val[i] > POW_HIGH_THRESHOLD)    /// 140V as powerover threshold(mV)
000032  f8510024          LDR      r0,[r1,r4,LSL #2]
000036  49d3              LDR      r1,|L1.900|
000038  f7fffffe          BL       __aeabi_cfrcmple
00003c  d20b              BCS      |L1.86|
;;;371            {
;;;372    
;;;373                if (_OldDigRes[i] == 1)
00003e  48d2              LDR      r0,|L1.904|
000040  5d00              LDRB     r0,[r0,r4]
000042  2801              CMP      r0,#1
000044  d102              BNE      |L1.76|
;;;374                {
;;;375                    _DigRes[i] = 1;
000046  49d1              LDR      r1,|L1.908|
000048  5508              STRB     r0,[r1,r4]
00004a  e022              B        |L1.146|
                  |L1.76|
;;;376                }
;;;377                else
;;;378                {
;;;379                    _OldDigRes[i] = 1;
00004c  f04f0001          MOV      r0,#1
000050  49cd              LDR      r1,|L1.904|
000052  5508              STRB     r0,[r1,r4]
000054  e01d              B        |L1.146|
                  |L1.86|
;;;380                }
;;;381            }
;;;382    
;;;383            else if (val[i] < POW_LOW_THRESHOLD)   /// 60V as powerover threshold(mV)
000056  a901              ADD      r1,sp,#4
000058  f8510024          LDR      r0,[r1,r4,LSL #2]
00005c  49cc              LDR      r1,|L1.912|
00005e  f7fffffe          BL       __aeabi_cfcmple
000062  d20b              BCS      |L1.124|
;;;384            {
;;;385    
;;;386                if (_OldDigRes == 0)
000064  48c8              LDR      r0,|L1.904|
000066  b920              CBNZ     r0,|L1.114|
;;;387                {
;;;388                    _DigRes[i] = 0;
000068  f04f0000          MOV      r0,#0
00006c  49c7              LDR      r1,|L1.908|
00006e  5508              STRB     r0,[r1,r4]
000070  e00f              B        |L1.146|
                  |L1.114|
;;;389                }
;;;390                else
;;;391                {
;;;392                    _OldDigRes[i] = 0;
000072  f04f0000          MOV      r0,#0
000076  49c4              LDR      r1,|L1.904|
000078  5508              STRB     r0,[r1,r4]
00007a  e00a              B        |L1.146|
                  |L1.124|
;;;393                }
;;;394            }
;;;395            else
;;;396            {
;;;397                if (_OldDigRes[i] == 1)
00007c  48c2              LDR      r0,|L1.904|
00007e  5d00              LDRB     r0,[r0,r4]
000080  2801              CMP      r0,#1
000082  d102              BNE      |L1.138|
;;;398                {
;;;399                    _DigRes[i] = 1;
000084  49c1              LDR      r1,|L1.908|
000086  5508              STRB     r0,[r1,r4]
000088  e003              B        |L1.146|
                  |L1.138|
;;;400                }
;;;401                else
;;;402                {
;;;403                    _DigRes[i] = 0;
00008a  f04f0000          MOV      r0,#0
00008e  49bf              LDR      r1,|L1.908|
000090  5508              STRB     r0,[r1,r4]
                  |L1.146|
000092  f1040001          ADD      r0,r4,#1              ;363
000096  b2c4              UXTB     r4,r0                 ;363
                  |L1.152|
000098  2c05              CMP      r4,#5                 ;363
00009a  dbb7              BLT      |L1.12|
;;;404                }
;;;405            }
;;;406    
;;;407        }
;;;408    
;;;409        for (i = 0; i < 5; i++)
00009c  f04f0400          MOV      r4,#0
0000a0  e00d              B        |L1.190|
                  |L1.162|
;;;410        {
;;;411    
;;;412            _TmpVal[i] = (uint8_t)(val[i]/100);// 由1mV改为10mV为单位
0000a2  a901              ADD      r1,sp,#4
0000a4  f8510024          LDR      r0,[r1,r4,LSL #2]
0000a8  49ba              LDR      r1,|L1.916|
0000aa  f7fffffe          BL       __aeabi_fdiv
0000ae  4606              MOV      r6,r0
0000b0  f7fffffe          BL       __aeabi_f2uiz
0000b4  a906              ADD      r1,sp,#0x18
0000b6  5508              STRB     r0,[r1,r4]
0000b8  f1040001          ADD      r0,r4,#1              ;409
0000bc  b2c4              UXTB     r4,r0                 ;409
                  |L1.190|
0000be  2c05              CMP      r4,#5                 ;409
0000c0  dbef              BLT      |L1.162|
;;;413        }
;;;414    
;;;415        UserInf.ID110V  = _TmpVal[0];
0000c2  f89d0018          LDRB     r0,[sp,#0x18]
0000c6  49b4              LDR      r1,|L1.920|
0000c8  7208              STRB     r0,[r1,#8]
;;;416    
;;;417        UserInf.IID110V = _TmpVal[1];
0000ca  f89d0019          LDRB     r0,[sp,#0x19]
0000ce  7248              STRB     r0,[r1,#9]
;;;418    
;;;419        UserInf.CSID    = _TmpVal[2];
0000d0  f89d001a          LDRB     r0,[sp,#0x1a]
0000d4  7288              STRB     r0,[r1,#0xa]
;;;420    
;;;421        UserInf.CSIID   = _TmpVal[3];
0000d6  f89d001b          LDRB     r0,[sp,#0x1b]
0000da  72c8              STRB     r0,[r1,#0xb]
;;;422    
;;;423        UserInf.D110V   = _TmpVal[4];
0000dc  f89d001c          LDRB     r0,[sp,#0x1c]
0000e0  71c8              STRB     r0,[r1,#7]
;;;424    
;;;425        if (val[4] < POW_LOW_THRESHOLD)                   // 进入掉电处理
0000e2  49ab              LDR      r1,|L1.912|
0000e4  9805              LDR      r0,[sp,#0x14]
0000e6  f7fffffe          BL       __aeabi_cfcmple
0000ea  d212              BCS      |L1.274|
;;;426        {
;;;427            UserInf.PowOffFlag |= POW_OFF_FLG;            // 置110V电源掉电标志
0000ec  48aa              LDR      r0,|L1.920|
0000ee  7b00              LDRB     r0,[r0,#0xc]  ; UserInf
0000f0  f0400001          ORR      r0,r0,#1
0000f4  49a8              LDR      r1,|L1.920|
0000f6  7308              STRB     r0,[r1,#0xc]
;;;428    
;;;429            if (g_UsartRWPowOffComplete == 1)                 //串口读写掉电数据完毕
0000f8  48a8              LDR      r0,|L1.924|
0000fa  7800              LDRB     r0,[r0,#0]  ; g_UsartRWPowOffComplete
0000fc  2801              CMP      r0,#1
0000fe  d11e              BNE      |L1.318|
;;;430            {
;;;431    ///为了调试，暂时去掉
;;;432    #if 1
;;;433                USART_CTRL_DISABLE;                        // 关断串口输出供电
000100  f44f6000          MOV      r0,#0x800
000104  49a6              LDR      r1,|L1.928|
000106  8308              STRH     r0,[r1,#0x18]
000108  f44f7000          MOV      r0,#0x200
00010c  49a5              LDR      r1,|L1.932|
00010e  8008              STRH     r0,[r1,#0]
000110  e015              B        |L1.318|
                  |L1.274|
;;;434    #endif
;;;435            }
;;;436        }
;;;437        else
;;;438        {
;;;439            UserInf.PowOffFlag &= (~POW_OFF_FLG);        // 清110V电源掉电标志
000112  48a1              LDR      r0,|L1.920|
000114  7b00              LDRB     r0,[r0,#0xc]  ; UserInf
000116  f0200001          BIC      r0,r0,#1
00011a  499f              LDR      r1,|L1.920|
00011c  7308              STRB     r0,[r1,#0xc]
;;;440    
;;;441            PosIndex = 0;
00011e  f04f0000          MOV      r0,#0
000122  49a1              LDR      r1,|L1.936|
000124  7008              STRB     r0,[r1,#0]
;;;442    
;;;443            g_changed = 1;
000126  f04f0001          MOV      r0,#1
00012a  49a0              LDR      r1,|L1.940|
00012c  7008              STRB     r0,[r1,#0]
;;;444    
;;;445            USART_CTRL_ENABLE;                           // 打开串口输出供电
00012e  f44f6000          MOV      r0,#0x800
000132  499b              LDR      r1,|L1.928|
000134  8348              STRH     r0,[r1,#0x1a]
000136  f44f7000          MOV      r0,#0x200
00013a  499d              LDR      r1,|L1.944|
00013c  8008              STRH     r0,[r1,#0]
                  |L1.318|
;;;446        }
;;;447    }
00013e  b008              ADD      sp,sp,#0x20
000140  bd70              POP      {r4-r6,pc}
;;;448    
                          ENDP

                  AdcDataHandler PROC
;;;451    
;;;452    void AdcDataHandler(void)
000142  b570              PUSH     {r4-r6,lr}
;;;453    {
;;;454        uint8_t i, j;
;;;455    
;;;456        i = _ResHandleIndex;
000144  489b              LDR      r0,|L1.948|
000146  8800              LDRH     r0,[r0,#0]  ; _ResHandleIndex
000148  b2c4              UXTB     r4,r0
;;;457    
;;;458        j = _ResIndex;
00014a  489b              LDR      r0,|L1.952|
00014c  8800              LDRH     r0,[r0,#0]  ; _ResIndex
00014e  b2c5              UXTB     r5,r0
;;;459    
;;;460        while (j != i)
000150  e007              B        |L1.354|
                  |L1.338|
;;;461        {
;;;462            GetDigitalRes(i);
000152  4620              MOV      r0,r4
000154  f7fffffe          BL       GetDigitalRes
;;;463    
;;;464            i++;
000158  f1040001          ADD      r0,r4,#1
00015c  b2c4              UXTB     r4,r0
;;;465            i &= _RES_FRAME_MASK;
00015e  f004040f          AND      r4,r4,#0xf
                  |L1.354|
000162  42a5              CMP      r5,r4                 ;460
000164  d1f5              BNE      |L1.338|
;;;466        }
;;;467    
;;;468        _ResHandleIndex = i;
000166  4893              LDR      r0,|L1.948|
000168  8004              STRH     r4,[r0,#0]
;;;469    }
00016a  bd70              POP      {r4-r6,pc}
;;;470    
                          ENDP

                  BSP_Check_RestADC1 PROC
;;;155    
;;;156    void BSP_Check_RestADC1(uint16_t *ResBuf)
00016c  b510              PUSH     {r4,lr}
;;;157    {
00016e  4604              MOV      r4,r0
;;;158        if(ADC_GetFlagStatus(ADC1, ADC_FLAG_OVR))
000170  f04f0120          MOV      r1,#0x20
000174  4891              LDR      r0,|L1.956|
000176  f7fffffe          BL       ADC_GetFlagStatus
00017a  b130              CBZ      r0,|L1.394|
;;;159        {
;;;160            ADC_ClearFlag(ADC1, ADC_FLAG_OVR);
00017c  2120              MOVS     r1,#0x20
00017e  488f              LDR      r0,|L1.956|
000180  f7fffffe          BL       ADC_ClearFlag
;;;161    
;;;162            BSP_ADC_Init(ResBuf);
000184  4620              MOV      r0,r4
000186  f7fffffe          BL       BSP_ADC_Init
                  |L1.394|
;;;163        }
;;;164    }
00018a  bd10              POP      {r4,pc}
;;;165    
                          ENDP

                  AppTaskADC PROC
;;;113    /////////////////////////////////////////////////////////////////////////////////
;;;114    void AppTaskADC(void *p_arg)
00018c  e013              B        |L1.438|
                  |L1.398|
;;;115    {
;;;116        (void)p_arg;
;;;117    
;;;118        while (DEF_TRUE)
;;;119        {
;;;120            AppInfo.TaskAdcCnt++;
00018e  488c              LDR      r0,|L1.960|
000190  f8b000ba          LDRH     r0,[r0,#0xba]  ; AppInfo
000194  f1000001          ADD      r0,r0,#1
000198  4989              LDR      r1,|L1.960|
00019a  f8a100ba          STRH     r0,[r1,#0xba]
;;;121    
;;;122            if (AppInfo.RdyFlag)
00019e  4608              MOV      r0,r1
0001a0  7f00              LDRB     r0,[r0,#0x1c]  ; AppInfo
0001a2  b128              CBZ      r0,|L1.432|
;;;123            {
;;;124                BSP_Check_RestADC1(BSP_Info.ADCBuf[0]);
0001a4  4987              LDR      r1,|L1.964|
0001a6  6848              LDR      r0,[r1,#4]  ; BSP_Info
0001a8  f7fffffe          BL       BSP_Check_RestADC1
;;;125    
;;;126                AdcDataHandler();
0001ac  f7fffffe          BL       AdcDataHandler
                  |L1.432|
;;;127            }
;;;128    
;;;129            OSTimeDly(10);
0001b0  200a              MOVS     r0,#0xa
0001b2  f7fffffe          BL       OSTimeDly
                  |L1.438|
0001b6  e7ea              B        |L1.398|
;;;130        }
;;;131    }
;;;132    
                          ENDP

                  SaveAdcData PROC
;;;238    
;;;239    void SaveAdcData(void)
0001b8  b530              PUSH     {r4,r5,lr}
;;;240    {
;;;241        uint8_t i;
;;;242        uint16_t tmp, *p16;
;;;243        uint32_t *p32;
;;;244    
;;;245    #if ADC_AVERAGE_ENABLE
;;;246    
;;;247        ///将数据存入缓冲区：
;;;248    
;;;249        p16 = (uint16_t *)&AdcBuf[0];
0001ba  4a83              LDR      r2,|L1.968|
;;;250    
;;;251        p32 = (uint32_t *)&_TotBuf[0];
0001bc  4983              LDR      r1,|L1.972|
;;;252    
;;;253        for (i = 0; i < POWER_SAMPLE_CHANNEL_COUNT; i++)
0001be  f04f0000          MOV      r0,#0
0001c2  e007              B        |L1.468|
                  |L1.452|
;;;254        {
;;;255            *p32++ += *p16++;
0001c4  f8325b02          LDRH     r5,[r2],#2
0001c8  680c              LDR      r4,[r1,#0]
0001ca  442c              ADD      r4,r4,r5
0001cc  c110              STM      r1!,{r4}
0001ce  f1000401          ADD      r4,r0,#1              ;253
0001d2  b2e0              UXTB     r0,r4                 ;253
                  |L1.468|
0001d4  2805              CMP      r0,#5                 ;253
0001d6  dbf5              BLT      |L1.452|
;;;256        }
;;;257    
;;;258        _TotCnt++;
0001d8  4c7d              LDR      r4,|L1.976|
0001da  8824              LDRH     r4,[r4,#0]  ; _TotCnt
0001dc  f1040401          ADD      r4,r4,#1
0001e0  4d7b              LDR      r5,|L1.976|
0001e2  802c              STRH     r4,[r5,#0]
;;;259    
;;;260    
;;;261        if (_TotCnt >= _TOT_CNT)
0001e4  462c              MOV      r4,r5
0001e6  8824              LDRH     r4,[r4,#0]  ; _TotCnt
0001e8  2c10              CMP      r4,#0x10
0001ea  db39              BLT      |L1.608|
;;;262        {
;;;263            _TotCnt = 0;
0001ec  f04f0400          MOV      r4,#0
0001f0  802c              STRH     r4,[r5,#0]
;;;264    
;;;265    
;;;266            p16=_ResBuf[_ResIndex];
0001f2  4c71              LDR      r4,|L1.952|
0001f4  8824              LDRH     r4,[r4,#0]  ; _ResIndex
0001f6  eb040484          ADD      r4,r4,r4,LSL #2
0001fa  4d60              LDR      r5,|L1.892|
0001fc  eb050244          ADD      r2,r5,r4,LSL #1
;;;267            p32 = (uint32_t *)&_TotBuf[0];
000200  4972              LDR      r1,|L1.972|
;;;268    
;;;269            for(i=0; i<POWER_SAMPLE_CHANNEL_COUNT; i++)
000202  f04f0000          MOV      r0,#0
000206  e01e              B        |L1.582|
                  |L1.520|
;;;270            {
;;;271                tmp=p32[i]>>_TOT_BITS;//除16
000208  f8514020          LDR      r4,[r1,r0,LSL #2]
00020c  f3c4130f          UBFX     r3,r4,#4,#16
;;;272    			p32[i]=0;
000210  f04f0400          MOV      r4,#0
000214  f8414020          STR      r4,[r1,r0,LSL #2]
;;;273    
;;;274                if (tmp > AppInfo.AdcOffset[i])
000218  4c59              LDR      r4,|L1.896|
00021a  f1a4040c          SUB      r4,r4,#0xc
00021e  f8344010          LDRH     r4,[r4,r0,LSL #1]
000222  429c              CMP      r4,r3
000224  da08              BGE      |L1.568|
;;;275                {
;;;276                    p16[i]= (tmp - AppInfo.AdcOffset[i]);
000226  4c56              LDR      r4,|L1.896|
000228  3c0c              SUBS     r4,r4,#0xc
00022a  f8344010          LDRH     r4,[r4,r0,LSL #1]
00022e  eba30404          SUB      r4,r3,r4
000232  f8224010          STRH     r4,[r2,r0,LSL #1]
000236  e003              B        |L1.576|
                  |L1.568|
;;;277                }
;;;278                else
;;;279                {
;;;280                    p16[i] = 0;
000238  f04f0400          MOV      r4,#0
00023c  f8224010          STRH     r4,[r2,r0,LSL #1]
                  |L1.576|
000240  f1000401          ADD      r4,r0,#1              ;269
000244  b2e0              UXTB     r0,r4                 ;269
                  |L1.582|
000246  2805              CMP      r0,#5                 ;269
000248  dbde              BLT      |L1.520|
;;;281                }
;;;282    
;;;283            }
;;;284         
;;;285            
;;;286    
;;;287            _ResIndex++;
00024a  4c5b              LDR      r4,|L1.952|
00024c  8824              LDRH     r4,[r4,#0]  ; _ResIndex
00024e  f1040401          ADD      r4,r4,#1
000252  4d59              LDR      r5,|L1.952|
000254  802c              STRH     r4,[r5,#0]
;;;288            _ResIndex &= _RES_FRAME_MASK;
000256  462c              MOV      r4,r5
000258  8824              LDRH     r4,[r4,#0]  ; _ResIndex
00025a  f004040f          AND      r4,r4,#0xf
00025e  802c              STRH     r4,[r5,#0]
                  |L1.608|
;;;289        }
;;;290    
;;;291    #else
;;;292    
;;;293        for (i = 0; i < POWER_SAMPLE_CHANNEL_COUNT; i++)
;;;294        {
;;;295            _ResBuf[_ResIndex][i] = AdcBuf[i];
;;;296        }
;;;297    
;;;298        _ResIndex++;
;;;299        _ResIndex &= _RES_FRAME_MASK;
;;;300    
;;;301    #endif
;;;302    
;;;303    //Deleted 2014 03 03
;;;304    #if 0
;;;305        uint8_t i;
;;;306    
;;;307        for (i = 0; i < POWER_SAMPLE_CHANNEL_COUNT; i++)
;;;308        {
;;;309            _ResBuf[_ResIndex][i] = AdcBuf[i];
;;;310    
;;;311            _TotBuf[i] += AdcBuf[i];
;;;312    
;;;313        }
;;;314    
;;;315        if (_TotCnt >= _TOT_CNT)
;;;316        {
;;;317            _TotCnt = 0;
;;;318    
;;;319            for (i = 0; i < POWER_SAMPLE_CHANNEL_COUNT; i++)
;;;320            {
;;;321                _ResBuf[_ResIndex][i] = _TotBuf[i] >> _TOT_BITS;
;;;322            }
;;;323    
;;;324            _ResIndex++;
;;;325            _ResIndex &= SAMPLE_BUF_MASK;
;;;326        }
;;;327    #endif
;;;328    
;;;329    }
000260  bd30              POP      {r4,r5,pc}
;;;330    
                          ENDP

                  Adc_Tm3CallBack PROC
;;;134    /// Tim3 中断中调用：
;;;135    uint32_t    Adc_Tm3CallBack(unsigned char Arg, void *ptr)
000262  b570              PUSH     {r4-r6,lr}
;;;136    {
000264  4604              MOV      r4,r0
000266  460d              MOV      r5,r1
;;;137        if (AppInfo.RdyFlag == 1)
000268  4855              LDR      r0,|L1.960|
00026a  7f00              LDRB     r0,[r0,#0x1c]  ; AppInfo
00026c  2801              CMP      r0,#1
00026e  d10b              BNE      |L1.648|
;;;138        {
;;;139    
;;;140            SaveAdcData();
000270  f7fffffe          BL       SaveAdcData
;;;141    
;;;142            ///重新启动 ADC 采样：
;;;143            BSP_ADC_Start();
000274  f7fffffe          BL       BSP_ADC_Start
;;;144    
;;;145            ///TIM3 监控变量
;;;146            AppInfo.IntTm3Cnt++;
000278  4851              LDR      r0,|L1.960|
00027a  f8d000e0          LDR      r0,[r0,#0xe0]  ; AppInfo
00027e  f1000001          ADD      r0,r0,#1
000282  494f              LDR      r1,|L1.960|
000284  f8c100e0          STR      r0,[r1,#0xe0]  ; AppInfo
                  |L1.648|
;;;147        }
;;;148    
;;;149        return 0;
000288  2000              MOVS     r0,#0
;;;150    }
00028a  bd70              POP      {r4-r6,pc}
;;;151    
                          ENDP

                  GetSampleOffset PROC
;;;174    ///5个通道的直流偏置
;;;175    void GetSampleOffset(uint16_t *buf)
00028c  b510              PUSH     {r4,lr}
;;;176    {
00028e  b085              SUB      sp,sp,#0x14
000290  4602              MOV      r2,r0
;;;177        uint16_t i, j;
;;;178        uint32_t tot[POWER_SAMPLE_CHANNEL_COUNT];
;;;179    
;;;180        for (i = 0; i < POWER_SAMPLE_CHANNEL_COUNT; i++)
000292  f04f0000          MOV      r0,#0
000296  e01f              B        |L1.728|
                  |L1.664|
;;;181        {
;;;182            tot[i] = 0;
000298  f04f0300          MOV      r3,#0
00029c  f84d3020          STR      r3,[sp,r0,LSL #2]
;;;183            for (j = 0; j < _RES_FRAME_SIZE; j++)
0002a0  4619              MOV      r1,r3
0002a2  e00e              B        |L1.706|
                  |L1.676|
;;;184            {
;;;185                tot[i] += _ResBuf[j][i];
0002a4  eb010381          ADD      r3,r1,r1,LSL #2
0002a8  4c34              LDR      r4,|L1.892|
0002aa  eb040343          ADD      r3,r4,r3,LSL #1
0002ae  f8333010          LDRH     r3,[r3,r0,LSL #1]
0002b2  f85d4020          LDR      r4,[sp,r0,LSL #2]
0002b6  4423              ADD      r3,r3,r4
0002b8  f84d3020          STR      r3,[sp,r0,LSL #2]
0002bc  f1010301          ADD      r3,r1,#1              ;183
0002c0  b299              UXTH     r1,r3                 ;183
                  |L1.706|
0002c2  2910              CMP      r1,#0x10              ;183
0002c4  d3ee              BCC      |L1.676|
;;;186            }
;;;187    
;;;188            buf[i] = tot[i] / _RES_FRAME_SIZE;
0002c6  f85d3020          LDR      r3,[sp,r0,LSL #2]
0002ca  f3c3130f          UBFX     r3,r3,#4,#16
0002ce  f8223010          STRH     r3,[r2,r0,LSL #1]
0002d2  f1000301          ADD      r3,r0,#1              ;180
0002d6  b298              UXTH     r0,r3                 ;180
                  |L1.728|
0002d8  2805              CMP      r0,#5                 ;180
0002da  dbdd              BLT      |L1.664|
;;;189        }
;;;190    
;;;191    }
0002dc  b005              ADD      sp,sp,#0x14
0002de  bd10              POP      {r4,pc}
;;;192    
                          ENDP

                  GetSampleValues PROC
;;;194    ///5个通道的直流电压值(mV)
;;;195    void GetSampleValues(uint16_t *buf)
0002e0  e92d43f0          PUSH     {r4-r9,lr}
;;;196    {
0002e4  b085              SUB      sp,sp,#0x14
0002e6  4606              MOV      r6,r0
;;;197        uint16_t i, j;
;;;198        uint32_t tot[POWER_SAMPLE_CHANNEL_COUNT];
;;;199        float tmp;
;;;200    
;;;201        ///禁止任务调度
;;;202        ///OSSchedLock();
;;;203    
;;;204        for (i = 0; i < POWER_SAMPLE_CHANNEL_COUNT; i++)
0002e8  f04f0400          MOV      r4,#0
0002ec  e006              B        |L1.764|
                  |L1.750|
;;;205        {
;;;206            tot[i] = 0;
0002ee  f04f0000          MOV      r0,#0
0002f2  f84d0024          STR      r0,[sp,r4,LSL #2]
0002f6  f1040001          ADD      r0,r4,#1              ;204
0002fa  b284              UXTH     r4,r0                 ;204
                  |L1.764|
0002fc  2c05              CMP      r4,#5                 ;204
0002fe  dbf6              BLT      |L1.750|
;;;207        }
;;;208    
;;;209        for (i = 0; i < _RES_FRAME_SIZE; i++)
000300  f04f0400          MOV      r4,#0
000304  e016              B        |L1.820|
                  |L1.774|
;;;210        {
;;;211            for (j = 0; j < POWER_SAMPLE_CHANNEL_COUNT; j++)
000306  f04f0500          MOV      r5,#0
00030a  e00e              B        |L1.810|
                  |L1.780|
;;;212            {
;;;213                tot[j] += _ResBuf[i][j];
00030c  eb040084          ADD      r0,r4,r4,LSL #2
000310  491a              LDR      r1,|L1.892|
000312  eb010040          ADD      r0,r1,r0,LSL #1
000316  f8300015          LDRH     r0,[r0,r5,LSL #1]
00031a  f85d1025          LDR      r1,[sp,r5,LSL #2]
00031e  4408              ADD      r0,r0,r1
000320  f84d0025          STR      r0,[sp,r5,LSL #2]
000324  f1050001          ADD      r0,r5,#1              ;211
000328  b285              UXTH     r5,r0                 ;211
                  |L1.810|
00032a  2d05              CMP      r5,#5                 ;211
00032c  dbee              BLT      |L1.780|
00032e  f1040001          ADD      r0,r4,#1              ;209
000332  b284              UXTH     r4,r0                 ;209
                  |L1.820|
000334  2c10              CMP      r4,#0x10              ;209
000336  d3e6              BCC      |L1.774|
;;;214            }
;;;215        }
;;;216    
;;;217        for (i = 0; i < POWER_SAMPLE_CHANNEL_COUNT; i++)
000338  f04f0400          MOV      r4,#0
00033c  e018              B        |L1.880|
                  |L1.830|
;;;218        {
;;;219            //tmp = AppInfo.AdcRatio[j] * tot[i] / (SAMPLE_RESULT_MAGIC * _RES_FRAME_SIZE) * 1000;///换算成 mV
;;;220    
;;;221            tmp = AppInfo.AdcRatio[i] * tot[i] / _RES_FRAME_SIZE;
00033e  f85d0024          LDR      r0,[sp,r4,LSL #2]
000342  f7fffffe          BL       __aeabi_ui2f
000346  4681              MOV      r9,r0
000348  480d              LDR      r0,|L1.896|
00034a  f8501024          LDR      r1,[r0,r4,LSL #2]
00034e  4648              MOV      r0,r9
000350  f7fffffe          BL       __aeabi_fmul
000354  4680              MOV      r8,r0
000356  f04f4183          MOV      r1,#0x41800000
00035a  f7fffffe          BL       __aeabi_fdiv
00035e  4607              MOV      r7,r0
;;;222    
;;;223            buf[i] = tmp;
000360  4638              MOV      r0,r7
000362  f7fffffe          BL       __aeabi_f2uiz
000366  f8260014          STRH     r0,[r6,r4,LSL #1]
00036a  f1040001          ADD      r0,r4,#1              ;217
00036e  b284              UXTH     r4,r0                 ;217
                  |L1.880|
000370  2c05              CMP      r4,#5                 ;217
000372  dbe4              BLT      |L1.830|
;;;224        }
;;;225    
;;;226        ///重新开放任务调度
;;;227        ///OSSchedUnlock();
;;;228    }
000374  b005              ADD      sp,sp,#0x14
000376  e8bd83f0          POP      {r4-r9,pc}
;;;229    
                          ENDP

00037a  0000              DCW      0x0000
                  |L1.892|
                          DCD      _ResBuf
                  |L1.896|
                          DCD      AppInfo+0x108
                  |L1.900|
                          DCD      0x466a6000
                  |L1.904|
                          DCD      _OldDigRes
                  |L1.908|
                          DCD      _DigRes
                  |L1.912|
                          DCD      0x45bb8000
                  |L1.916|
                          DCD      0x42c80000
                  |L1.920|
                          DCD      UserInf
                  |L1.924|
                          DCD      g_UsartRWPowOffComplete
                  |L1.928|
                          DCD      0x40020000
                  |L1.932|
                          DCD      0x40020418
                  |L1.936|
                          DCD      PosIndex
                  |L1.940|
                          DCD      g_changed
                  |L1.944|
                          DCD      0x4002041a
                  |L1.948|
                          DCD      _ResHandleIndex
                  |L1.952|
                          DCD      _ResIndex
                  |L1.956|
                          DCD      0x40012000
                  |L1.960|
                          DCD      AppInfo
                  |L1.964|
                          DCD      BSP_Info
                  |L1.968|
                          DCD      AdcBuf
                  |L1.972|
                          DCD      _TotBuf
                  |L1.976|
                          DCD      _TotCnt

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  _TotBuf
                          %        20
                  AdcBuf
                          %        10
                  _ResBuf
                          %        160

                          AREA ||.data||, DATA, ALIGN=1

                  _ResIndex
000000  0000              DCW      0x0000
                  _ResHandleIndex
000002  0000              DCW      0x0000
                  _TotCnt
000004  0000              DCW      0x0000
                  _OldDigRes
000006  0000              DCB      0x00,0x00
000008  000000            DCB      0x00,0x00,0x00
                  _DigRes
00000b  00                DCB      0x00
                          DCDU     0x00000000

;*** Start embedded assembler ***

#line 1 "..\\App\\app_adc.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_app_adc_c_8f49cd87____REV16|
#line 112 "..\\BSP\\CMSIS\\core_cmInstr.h"
|__asm___9_app_adc_c_8f49cd87____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_app_adc_c_8f49cd87____REVSH|
#line 130
|__asm___9_app_adc_c_8f49cd87____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
