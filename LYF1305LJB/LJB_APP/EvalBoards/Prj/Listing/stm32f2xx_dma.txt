; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Output\stm32f2xx_dma.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\Output\stm32f2xx_dma.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\BSP -I..\BSP\UCOS-II -I..\BSP\STM32F2xx\inc -I..\BSP\CMSIS -I..\BSP\CMSIS\Device_Support -I..\BSP\UCOS-II -I..\..\uC-CPU -I..\..\uC-CPU\ARM-Cortex-M3 -I..\..\uC-LIB -I..\..\uC-LIB\Ports\ARM-Cortex-M3 -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3 -I..\App -I..\Prj -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DDEBUG -DLJB_CPU_MAIN -DUSE_CPU_F205RC --omf_browse=.\Output\stm32f2xx_dma.crf ..\BSP\STM32F2xx\src\stm32f2xx_dma.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  DMA_DeInit PROC
;;;187      */
;;;188    void DMA_DeInit(DMA_Stream_TypeDef* DMAy_Streamx)
000000  6801              LDR      r1,[r0,#0]
;;;189    {
;;;190      /* Check the parameters */
;;;191      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;192    
;;;193      /* Disable the selected DMAy Streamx */
;;;194      DMAy_Streamx->CR &= ~((uint32_t)DMA_SxCR_EN);
000002  f0210101          BIC      r1,r1,#1
000006  6001              STR      r1,[r0,#0]
;;;195    
;;;196      /* Reset DMAy Streamx control register */
;;;197      DMAy_Streamx->CR  = 0;
000008  f04f0100          MOV      r1,#0
00000c  6001              STR      r1,[r0,#0]
;;;198      
;;;199      /* Reset DMAy Streamx Number of Data to Transfer register */
;;;200      DMAy_Streamx->NDTR = 0;
00000e  6041              STR      r1,[r0,#4]
;;;201      
;;;202      /* Reset DMAy Streamx peripheral address register */
;;;203      DMAy_Streamx->PAR  = 0;
000010  6081              STR      r1,[r0,#8]
;;;204      
;;;205      /* Reset DMAy Streamx memory 0 address register */
;;;206      DMAy_Streamx->M0AR = 0;
000012  60c1              STR      r1,[r0,#0xc]
;;;207    
;;;208      /* Reset DMAy Streamx memory 1 address register */
;;;209      DMAy_Streamx->M1AR = 0;
000014  6101              STR      r1,[r0,#0x10]
;;;210    
;;;211      /* Reset DMAy Streamx FIFO control register */
;;;212      DMAy_Streamx->FCR = (uint32_t)0x00000021; 
000016  f04f0121          MOV      r1,#0x21
00001a  6141              STR      r1,[r0,#0x14]
;;;213    
;;;214      /* Reset interrupt pending bits for the selected stream */
;;;215      if (DMAy_Streamx == DMA1_Stream0)
00001c  49e2              LDR      r1,|L1.936|
00001e  4288              CMP      r0,r1
000020  d104              BNE      |L1.44|
;;;216      {
;;;217        /* Reset interrupt pending bits for DMA1 Stream0 */
;;;218        DMA1->LIFCR = DMA_Stream0_IT_MASK;
000022  f04f013d          MOV      r1,#0x3d
000026  4ae1              LDR      r2,|L1.940|
000028  6091              STR      r1,[r2,#8]
00002a  e07e              B        |L1.298|
                  |L1.44|
;;;219      }
;;;220      else if (DMAy_Streamx == DMA1_Stream1)
00002c  49de              LDR      r1,|L1.936|
00002e  3118              ADDS     r1,r1,#0x18
000030  4288              CMP      r0,r1
000032  d104              BNE      |L1.62|
;;;221      {
;;;222        /* Reset interrupt pending bits for DMA1 Stream1 */
;;;223        DMA1->LIFCR = DMA_Stream1_IT_MASK;
000034  f44f6174          MOV      r1,#0xf40
000038  4adc              LDR      r2,|L1.940|
00003a  6091              STR      r1,[r2,#8]
00003c  e075              B        |L1.298|
                  |L1.62|
;;;224      }
;;;225      else if (DMAy_Streamx == DMA1_Stream2)
00003e  49da              LDR      r1,|L1.936|
000040  3130              ADDS     r1,r1,#0x30
000042  4288              CMP      r0,r1
000044  d104              BNE      |L1.80|
;;;226      {
;;;227        /* Reset interrupt pending bits for DMA1 Stream2 */
;;;228        DMA1->LIFCR = DMA_Stream2_IT_MASK;
000046  f44f1174          MOV      r1,#0x3d0000
00004a  4ad8              LDR      r2,|L1.940|
00004c  6091              STR      r1,[r2,#8]
00004e  e06c              B        |L1.298|
                  |L1.80|
;;;229      }
;;;230      else if (DMAy_Streamx == DMA1_Stream3)
000050  49d5              LDR      r1,|L1.936|
000052  3148              ADDS     r1,r1,#0x48
000054  4288              CMP      r0,r1
000056  d104              BNE      |L1.98|
;;;231      {
;;;232        /* Reset interrupt pending bits for DMA1 Stream3 */
;;;233        DMA1->LIFCR = DMA_Stream3_IT_MASK;
000058  f04f6174          MOV      r1,#0xf400000
00005c  4ad3              LDR      r2,|L1.940|
00005e  6091              STR      r1,[r2,#8]
000060  e063              B        |L1.298|
                  |L1.98|
;;;234      }
;;;235      else if (DMAy_Streamx == DMA1_Stream4)
000062  49d1              LDR      r1,|L1.936|
000064  3160              ADDS     r1,r1,#0x60
000066  4288              CMP      r0,r1
000068  d103              BNE      |L1.114|
;;;236      {
;;;237        /* Reset interrupt pending bits for DMA1 Stream4 */
;;;238        DMA1->HIFCR = DMA_Stream4_IT_MASK;
00006a  49d1              LDR      r1,|L1.944|
00006c  4acf              LDR      r2,|L1.940|
00006e  60d1              STR      r1,[r2,#0xc]
000070  e05b              B        |L1.298|
                  |L1.114|
;;;239      }
;;;240      else if (DMAy_Streamx == DMA1_Stream5)
000072  49cd              LDR      r1,|L1.936|
000074  3178              ADDS     r1,r1,#0x78
000076  4288              CMP      r0,r1
000078  d103              BNE      |L1.130|
;;;241      {
;;;242        /* Reset interrupt pending bits for DMA1 Stream5 */
;;;243        DMA1->HIFCR = DMA_Stream5_IT_MASK;
00007a  49ce              LDR      r1,|L1.948|
00007c  4acb              LDR      r2,|L1.940|
00007e  60d1              STR      r1,[r2,#0xc]
000080  e053              B        |L1.298|
                  |L1.130|
;;;244      }
;;;245      else if (DMAy_Streamx == DMA1_Stream6)
000082  49c9              LDR      r1,|L1.936|
000084  3190              ADDS     r1,r1,#0x90
000086  4288              CMP      r0,r1
000088  d103              BNE      |L1.146|
;;;246      {
;;;247        /* Reset interrupt pending bits for DMA1 Stream6 */
;;;248        DMA1->HIFCR = (uint32_t)DMA_Stream6_IT_MASK;
00008a  49cb              LDR      r1,|L1.952|
00008c  4ac7              LDR      r2,|L1.940|
00008e  60d1              STR      r1,[r2,#0xc]
000090  e04b              B        |L1.298|
                  |L1.146|
;;;249      }
;;;250      else if (DMAy_Streamx == DMA1_Stream7)
000092  49c5              LDR      r1,|L1.936|
000094  31a8              ADDS     r1,r1,#0xa8
000096  4288              CMP      r0,r1
000098  d104              BNE      |L1.164|
;;;251      {
;;;252        /* Reset interrupt pending bits for DMA1 Stream7 */
;;;253        DMA1->HIFCR = DMA_Stream7_IT_MASK;
00009a  f04f513d          MOV      r1,#0x2f400000
00009e  4ac3              LDR      r2,|L1.940|
0000a0  60d1              STR      r1,[r2,#0xc]
0000a2  e042              B        |L1.298|
                  |L1.164|
;;;254      }
;;;255      else if (DMAy_Streamx == DMA2_Stream0)
0000a4  49c5              LDR      r1,|L1.956|
0000a6  4288              CMP      r0,r1
0000a8  d104              BNE      |L1.180|
;;;256      {
;;;257        /* Reset interrupt pending bits for DMA2 Stream0 */
;;;258        DMA2->LIFCR = DMA_Stream0_IT_MASK;
0000aa  f04f013d          MOV      r1,#0x3d
0000ae  4ac4              LDR      r2,|L1.960|
0000b0  6011              STR      r1,[r2,#0]
0000b2  e03a              B        |L1.298|
                  |L1.180|
;;;259      }
;;;260      else if (DMAy_Streamx == DMA2_Stream1)
0000b4  49c1              LDR      r1,|L1.956|
0000b6  3118              ADDS     r1,r1,#0x18
0000b8  4288              CMP      r0,r1
0000ba  d104              BNE      |L1.198|
;;;261      {
;;;262        /* Reset interrupt pending bits for DMA2 Stream1 */
;;;263        DMA2->LIFCR = DMA_Stream1_IT_MASK;
0000bc  f44f6174          MOV      r1,#0xf40
0000c0  4abf              LDR      r2,|L1.960|
0000c2  6011              STR      r1,[r2,#0]
0000c4  e031              B        |L1.298|
                  |L1.198|
;;;264      }
;;;265      else if (DMAy_Streamx == DMA2_Stream2)
0000c6  49bd              LDR      r1,|L1.956|
0000c8  3130              ADDS     r1,r1,#0x30
0000ca  4288              CMP      r0,r1
0000cc  d104              BNE      |L1.216|
;;;266      {
;;;267        /* Reset interrupt pending bits for DMA2 Stream2 */
;;;268        DMA2->LIFCR = DMA_Stream2_IT_MASK;
0000ce  f44f1174          MOV      r1,#0x3d0000
0000d2  4abb              LDR      r2,|L1.960|
0000d4  6011              STR      r1,[r2,#0]
0000d6  e028              B        |L1.298|
                  |L1.216|
;;;269      }
;;;270      else if (DMAy_Streamx == DMA2_Stream3)
0000d8  49b8              LDR      r1,|L1.956|
0000da  3148              ADDS     r1,r1,#0x48
0000dc  4288              CMP      r0,r1
0000de  d104              BNE      |L1.234|
;;;271      {
;;;272        /* Reset interrupt pending bits for DMA2 Stream3 */
;;;273        DMA2->LIFCR = DMA_Stream3_IT_MASK;
0000e0  f04f6174          MOV      r1,#0xf400000
0000e4  4ab6              LDR      r2,|L1.960|
0000e6  6011              STR      r1,[r2,#0]
0000e8  e01f              B        |L1.298|
                  |L1.234|
;;;274      }
;;;275      else if (DMAy_Streamx == DMA2_Stream4)
0000ea  49b4              LDR      r1,|L1.956|
0000ec  3160              ADDS     r1,r1,#0x60
0000ee  4288              CMP      r0,r1
0000f0  d103              BNE      |L1.250|
;;;276      {
;;;277        /* Reset interrupt pending bits for DMA2 Stream4 */
;;;278        DMA2->HIFCR = DMA_Stream4_IT_MASK;
0000f2  49af              LDR      r1,|L1.944|
0000f4  4ab3              LDR      r2,|L1.964|
0000f6  6011              STR      r1,[r2,#0]
0000f8  e017              B        |L1.298|
                  |L1.250|
;;;279      }
;;;280      else if (DMAy_Streamx == DMA2_Stream5)
0000fa  49b0              LDR      r1,|L1.956|
0000fc  3178              ADDS     r1,r1,#0x78
0000fe  4288              CMP      r0,r1
000100  d103              BNE      |L1.266|
;;;281      {
;;;282        /* Reset interrupt pending bits for DMA2 Stream5 */
;;;283        DMA2->HIFCR = DMA_Stream5_IT_MASK;
000102  49ac              LDR      r1,|L1.948|
000104  4aaf              LDR      r2,|L1.964|
000106  6011              STR      r1,[r2,#0]
000108  e00f              B        |L1.298|
                  |L1.266|
;;;284      }
;;;285      else if (DMAy_Streamx == DMA2_Stream6)
00010a  49ac              LDR      r1,|L1.956|
00010c  3190              ADDS     r1,r1,#0x90
00010e  4288              CMP      r0,r1
000110  d103              BNE      |L1.282|
;;;286      {
;;;287        /* Reset interrupt pending bits for DMA2 Stream6 */
;;;288        DMA2->HIFCR = DMA_Stream6_IT_MASK;
000112  49a9              LDR      r1,|L1.952|
000114  4aab              LDR      r2,|L1.964|
000116  6011              STR      r1,[r2,#0]
000118  e007              B        |L1.298|
                  |L1.282|
;;;289      }
;;;290      else 
;;;291      {
;;;292        if (DMAy_Streamx == DMA2_Stream7)
00011a  49a8              LDR      r1,|L1.956|
00011c  31a8              ADDS     r1,r1,#0xa8
00011e  4288              CMP      r0,r1
000120  d103              BNE      |L1.298|
;;;293        {
;;;294          /* Reset interrupt pending bits for DMA2 Stream7 */
;;;295          DMA2->HIFCR = DMA_Stream7_IT_MASK;
000122  f04f513d          MOV      r1,#0x2f400000
000126  4aa7              LDR      r2,|L1.964|
000128  6011              STR      r1,[r2,#0]
                  |L1.298|
;;;296        }
;;;297      }
;;;298    }
00012a  4770              BX       lr
;;;299    
                          ENDP

                  DMA_Init PROC
;;;310      */
;;;311    void DMA_Init(DMA_Stream_TypeDef* DMAy_Streamx, DMA_InitTypeDef* DMA_InitStruct)
00012c  b510              PUSH     {r4,lr}
;;;312    {
;;;313      uint32_t tmpreg = 0;
00012e  f04f0200          MOV      r2,#0
;;;314    
;;;315      /* Check the parameters */
;;;316      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;317      assert_param(IS_DMA_CHANNEL(DMA_InitStruct->DMA_Channel));
;;;318      assert_param(IS_DMA_DIRECTION(DMA_InitStruct->DMA_DIR));
;;;319      assert_param(IS_DMA_BUFFER_SIZE(DMA_InitStruct->DMA_BufferSize));
;;;320      assert_param(IS_DMA_PERIPHERAL_INC_STATE(DMA_InitStruct->DMA_PeripheralInc));
;;;321      assert_param(IS_DMA_MEMORY_INC_STATE(DMA_InitStruct->DMA_MemoryInc));
;;;322      assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(DMA_InitStruct->DMA_PeripheralDataSize));
;;;323      assert_param(IS_DMA_MEMORY_DATA_SIZE(DMA_InitStruct->DMA_MemoryDataSize));
;;;324      assert_param(IS_DMA_MODE(DMA_InitStruct->DMA_Mode));
;;;325      assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
;;;326      assert_param(IS_DMA_FIFO_MODE_STATE(DMA_InitStruct->DMA_FIFOMode));
;;;327      assert_param(IS_DMA_FIFO_THRESHOLD(DMA_InitStruct->DMA_FIFOThreshold));
;;;328      assert_param(IS_DMA_MEMORY_BURST(DMA_InitStruct->DMA_MemoryBurst));
;;;329      assert_param(IS_DMA_PERIPHERAL_BURST(DMA_InitStruct->DMA_PeripheralBurst));
;;;330    
;;;331      /*------------------------- DMAy Streamx CR Configuration ------------------*/
;;;332      /* Get the DMAy_Streamx CR value */
;;;333      tmpreg = DMAy_Streamx->CR;
000132  6802              LDR      r2,[r0,#0]
;;;334    
;;;335      /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
;;;336      tmpreg &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
000134  4ba4              LDR      r3,|L1.968|
000136  ea020203          AND      r2,r2,r3
;;;337                             DMA_SxCR_PL | DMA_SxCR_MSIZE | DMA_SxCR_PSIZE | \
;;;338                             DMA_SxCR_MINC | DMA_SxCR_PINC | DMA_SxCR_CIRC | \
;;;339                             DMA_SxCR_DIR));
;;;340    
;;;341      /* Configure DMAy Streamx: */
;;;342      /* Set CHSEL bits according to DMA_CHSEL value */
;;;343      /* Set DIR bits according to DMA_DIR value */
;;;344      /* Set PINC bit according to DMA_PeripheralInc value */
;;;345      /* Set MINC bit according to DMA_MemoryInc value */
;;;346      /* Set PSIZE bits according to DMA_PeripheralDataSize value */
;;;347      /* Set MSIZE bits according to DMA_MemoryDataSize value */
;;;348      /* Set CIRC bit according to DMA_Mode value */
;;;349      /* Set PL bits according to DMA_Priority value */
;;;350      /* Set MBURST bits according to DMA_MemoryBurst value */
;;;351      /* Set PBURST bits according to DMA_PeripheralBurst value */
;;;352      tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
00013a  68cc              LDR      r4,[r1,#0xc]
00013c  680b              LDR      r3,[r1,#0]
00013e  ea430304          ORR      r3,r3,r4
000142  694c              LDR      r4,[r1,#0x14]
000144  ea430304          ORR      r3,r3,r4
000148  698c              LDR      r4,[r1,#0x18]
00014a  ea430304          ORR      r3,r3,r4
00014e  69cc              LDR      r4,[r1,#0x1c]
000150  ea430304          ORR      r3,r3,r4
000154  6a0c              LDR      r4,[r1,#0x20]
000156  ea430304          ORR      r3,r3,r4
00015a  6a4c              LDR      r4,[r1,#0x24]
00015c  ea430304          ORR      r3,r3,r4
000160  6a8c              LDR      r4,[r1,#0x28]
000162  ea430304          ORR      r3,r3,r4
000166  6b4c              LDR      r4,[r1,#0x34]
000168  ea430304          ORR      r3,r3,r4
00016c  6b8c              LDR      r4,[r1,#0x38]
00016e  ea430304          ORR      r3,r3,r4
000172  ea430202          ORR      r2,r3,r2
;;;353                DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
;;;354                DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
;;;355                DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
;;;356                DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;
;;;357    
;;;358      /* Write to DMAy Streamx CR register */
;;;359      DMAy_Streamx->CR = tmpreg;
000176  6002              STR      r2,[r0,#0]
;;;360    
;;;361      /*------------------------- DMAy Streamx FCR Configuration -----------------*/
;;;362      /* Get the DMAy_Streamx FCR value */
;;;363      tmpreg = DMAy_Streamx->FCR;
000178  6942              LDR      r2,[r0,#0x14]
;;;364    
;;;365      /* Clear DMDIS and FTH bits */
;;;366      tmpreg &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
00017a  f0220207          BIC      r2,r2,#7
;;;367    
;;;368      /* Configure DMAy Streamx FIFO: 
;;;369        Set DMDIS bits according to DMA_FIFOMode value 
;;;370        Set FTH bits according to DMA_FIFOThreshold value */
;;;371      tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
00017e  e9d1340b          LDRD     r3,r4,[r1,#0x2c]
000182  ea430304          ORR      r3,r3,r4
000186  ea430202          ORR      r2,r3,r2
;;;372    
;;;373      /* Write to DMAy Streamx CR */
;;;374      DMAy_Streamx->FCR = tmpreg;
00018a  6142              STR      r2,[r0,#0x14]
;;;375    
;;;376      /*------------------------- DMAy Streamx NDTR Configuration ----------------*/
;;;377      /* Write to DMAy Streamx NDTR register */
;;;378      DMAy_Streamx->NDTR = DMA_InitStruct->DMA_BufferSize;
00018c  690b              LDR      r3,[r1,#0x10]
00018e  6043              STR      r3,[r0,#4]
;;;379    
;;;380      /*------------------------- DMAy Streamx PAR Configuration -----------------*/
;;;381      /* Write to DMAy Streamx PAR */
;;;382      DMAy_Streamx->PAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
000190  684b              LDR      r3,[r1,#4]
000192  6083              STR      r3,[r0,#8]
;;;383    
;;;384      /*------------------------- DMAy Streamx M0AR Configuration ----------------*/
;;;385      /* Write to DMAy Streamx M0AR */
;;;386      DMAy_Streamx->M0AR = DMA_InitStruct->DMA_Memory0BaseAddr;
000194  688b              LDR      r3,[r1,#8]
000196  60c3              STR      r3,[r0,#0xc]
;;;387    }
000198  bd10              POP      {r4,pc}
;;;388    
                          ENDP

                  DMA_StructInit PROC
;;;394      */
;;;395    void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
00019a  f04f0100          MOV      r1,#0
;;;396    {
;;;397      /*-------------- Reset DMA init structure parameters values ----------------*/
;;;398      /* Initialize the DMA_Channel member */
;;;399      DMA_InitStruct->DMA_Channel = 0;
00019e  6001              STR      r1,[r0,#0]
;;;400    
;;;401      /* Initialize the DMA_PeripheralBaseAddr member */
;;;402      DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
0001a0  6041              STR      r1,[r0,#4]
;;;403    
;;;404      /* Initialize the DMA_Memory0BaseAddr member */
;;;405      DMA_InitStruct->DMA_Memory0BaseAddr = 0;
0001a2  6081              STR      r1,[r0,#8]
;;;406    
;;;407      /* Initialize the DMA_DIR member */
;;;408      DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralToMemory;
0001a4  60c1              STR      r1,[r0,#0xc]
;;;409    
;;;410      /* Initialize the DMA_BufferSize member */
;;;411      DMA_InitStruct->DMA_BufferSize = 0;
0001a6  6101              STR      r1,[r0,#0x10]
;;;412    
;;;413      /* Initialize the DMA_PeripheralInc member */
;;;414      DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
0001a8  6141              STR      r1,[r0,#0x14]
;;;415    
;;;416      /* Initialize the DMA_MemoryInc member */
;;;417      DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
0001aa  6181              STR      r1,[r0,#0x18]
;;;418    
;;;419      /* Initialize the DMA_PeripheralDataSize member */
;;;420      DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
0001ac  61c1              STR      r1,[r0,#0x1c]
;;;421    
;;;422      /* Initialize the DMA_MemoryDataSize member */
;;;423      DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
0001ae  6201              STR      r1,[r0,#0x20]
;;;424    
;;;425      /* Initialize the DMA_Mode member */
;;;426      DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
0001b0  6241              STR      r1,[r0,#0x24]
;;;427    
;;;428      /* Initialize the DMA_Priority member */
;;;429      DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
0001b2  6281              STR      r1,[r0,#0x28]
;;;430    
;;;431      /* Initialize the DMA_FIFOMode member */
;;;432      DMA_InitStruct->DMA_FIFOMode = DMA_FIFOMode_Disable;
0001b4  62c1              STR      r1,[r0,#0x2c]
;;;433    
;;;434      /* Initialize the DMA_FIFOThreshold member */
;;;435      DMA_InitStruct->DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
0001b6  6301              STR      r1,[r0,#0x30]
;;;436    
;;;437      /* Initialize the DMA_MemoryBurst member */
;;;438      DMA_InitStruct->DMA_MemoryBurst = DMA_MemoryBurst_Single;
0001b8  6341              STR      r1,[r0,#0x34]
;;;439    
;;;440      /* Initialize the DMA_PeripheralBurst member */
;;;441      DMA_InitStruct->DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
0001ba  6381              STR      r1,[r0,#0x38]
;;;442    }
0001bc  4770              BX       lr
;;;443    
                          ENDP

                  DMA_Cmd PROC
;;;469      */
;;;470    void DMA_Cmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
0001be  b121              CBZ      r1,|L1.458|
;;;471    {
;;;472      /* Check the parameters */
;;;473      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;474      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;475    
;;;476      if (NewState != DISABLE)
;;;477      {
;;;478        /* Enable the selected DMAy Streamx by setting EN bit */
;;;479        DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
0001c0  6802              LDR      r2,[r0,#0]
0001c2  f0420201          ORR      r2,r2,#1
0001c6  6002              STR      r2,[r0,#0]
0001c8  e003              B        |L1.466|
                  |L1.458|
;;;480      }
;;;481      else
;;;482      {
;;;483        /* Disable the selected DMAy Streamx by clearing EN bit */
;;;484        DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_EN;
0001ca  6802              LDR      r2,[r0,#0]
0001cc  f0220201          BIC      r2,r2,#1
0001d0  6002              STR      r2,[r0,#0]
                  |L1.466|
;;;485      }
;;;486    }
0001d2  4770              BX       lr
;;;487    
                          ENDP

                  DMA_PeriphIncOffsetSizeConfig PROC
;;;505      */
;;;506    void DMA_PeriphIncOffsetSizeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_Pincos)
0001d4  b121              CBZ      r1,|L1.480|
;;;507    {
;;;508      /* Check the parameters */
;;;509      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;510      assert_param(IS_DMA_PINCOS_SIZE(DMA_Pincos));
;;;511    
;;;512      /* Check the needed Peripheral increment offset */
;;;513      if(DMA_Pincos != DMA_PINCOS_Psize)
;;;514      {
;;;515        /* Configure DMA_SxCR_PINCOS bit with the input parameter */
;;;516        DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PINCOS;     
0001d6  6802              LDR      r2,[r0,#0]
0001d8  f4424200          ORR      r2,r2,#0x8000
0001dc  6002              STR      r2,[r0,#0]
0001de  e003              B        |L1.488|
                  |L1.480|
;;;517      }
;;;518      else
;;;519      {
;;;520        /* Clear the PINCOS bit: Peripheral address incremented according to PSIZE */
;;;521        DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PINCOS;    
0001e0  6802              LDR      r2,[r0,#0]
0001e2  f4224200          BIC      r2,r2,#0x8000
0001e6  6002              STR      r2,[r0,#0]
                  |L1.488|
;;;522      }
;;;523    }
0001e8  4770              BX       lr
;;;524    
                          ENDP

                  DMA_FlowControllerConfig PROC
;;;541      */
;;;542    void DMA_FlowControllerConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FlowCtrl)
0001ea  b121              CBZ      r1,|L1.502|
;;;543    {
;;;544      /* Check the parameters */
;;;545      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;546      assert_param(IS_DMA_FLOW_CTRL(DMA_FlowCtrl));
;;;547    
;;;548      /* Check the needed flow controller  */
;;;549      if(DMA_FlowCtrl != DMA_FlowCtrl_Memory)
;;;550      {
;;;551        /* Configure DMA_SxCR_PFCTRL bit with the input parameter */
;;;552        DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PFCTRL;   
0001ec  6802              LDR      r2,[r0,#0]
0001ee  f0420220          ORR      r2,r2,#0x20
0001f2  6002              STR      r2,[r0,#0]
0001f4  e003              B        |L1.510|
                  |L1.502|
;;;553      }
;;;554      else
;;;555      {
;;;556        /* Clear the PFCTRL bit: Memory is the flow controller */
;;;557        DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PFCTRL;    
0001f6  6802              LDR      r2,[r0,#0]
0001f8  f0220220          BIC      r2,r2,#0x20
0001fc  6002              STR      r2,[r0,#0]
                  |L1.510|
;;;558      }
;;;559    }
0001fe  4770              BX       lr
;;;560    /**
                          ENDP

                  DMA_SetCurrDataCounter PROC
;;;625      */
;;;626    void DMA_SetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx, uint16_t Counter)
000200  6041              STR      r1,[r0,#4]
;;;627    {
;;;628      /* Check the parameters */
;;;629      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;630    
;;;631      /* Write the number of data units to be transferred */
;;;632      DMAy_Streamx->NDTR = (uint16_t)Counter;
;;;633    }
000202  4770              BX       lr
;;;634    
                          ENDP

                  DMA_GetCurrDataCounter PROC
;;;640      */
;;;641    uint16_t DMA_GetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx)
000204  4601              MOV      r1,r0
;;;642    {
;;;643      /* Check the parameters */
;;;644      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;645    
;;;646      /* Return the number of remaining data units for DMAy Streamx */
;;;647      return ((uint16_t)(DMAy_Streamx->NDTR));
000206  6848              LDR      r0,[r1,#4]
000208  b280              UXTH     r0,r0
;;;648    }
00020a  4770              BX       lr
;;;649    /**
                          ENDP

                  DMA_DoubleBufferModeConfig PROC
;;;717      */
;;;718    void DMA_DoubleBufferModeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t Memory1BaseAddr,
00020c  b122              CBZ      r2,|L1.536|
;;;719                                    uint32_t DMA_CurrentMemory)
;;;720    {  
;;;721      /* Check the parameters */
;;;722      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;723      assert_param(IS_DMA_CURRENT_MEM(DMA_CurrentMemory));
;;;724    
;;;725      if (DMA_CurrentMemory != DMA_Memory_0)
;;;726      {
;;;727        /* Set Memory 1 as current memory address */
;;;728        DMAy_Streamx->CR |= (uint32_t)(DMA_SxCR_CT);    
00020e  6803              LDR      r3,[r0,#0]
000210  f4432300          ORR      r3,r3,#0x80000
000214  6003              STR      r3,[r0,#0]
000216  e003              B        |L1.544|
                  |L1.536|
;;;729      }
;;;730      else
;;;731      {
;;;732        /* Set Memory 0 as current memory address */
;;;733        DMAy_Streamx->CR &= ~(uint32_t)(DMA_SxCR_CT);    
000218  6803              LDR      r3,[r0,#0]
00021a  f4232300          BIC      r3,r3,#0x80000
00021e  6003              STR      r3,[r0,#0]
                  |L1.544|
;;;734      }
;;;735    
;;;736      /* Write to DMAy Streamx M1AR */
;;;737      DMAy_Streamx->M1AR = Memory1BaseAddr;
000220  6101              STR      r1,[r0,#0x10]
;;;738    }
000222  4770              BX       lr
;;;739    
                          ENDP

                  DMA_DoubleBufferModeCmd PROC
;;;748      */
;;;749    void DMA_DoubleBufferModeCmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
000224  b121              CBZ      r1,|L1.560|
;;;750    {  
;;;751      /* Check the parameters */
;;;752      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;753      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;754    
;;;755      /* Configure the Double Buffer mode */
;;;756      if (NewState != DISABLE)
;;;757      {
;;;758        /* Enable the Double buffer mode */
;;;759        DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_DBM;
000226  6802              LDR      r2,[r0,#0]
000228  f4422280          ORR      r2,r2,#0x40000
00022c  6002              STR      r2,[r0,#0]
00022e  e003              B        |L1.568|
                  |L1.560|
;;;760      }
;;;761      else
;;;762      {
;;;763        /* Disable the Double buffer mode */
;;;764        DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_DBM;
000230  6802              LDR      r2,[r0,#0]
000232  f4222280          BIC      r2,r2,#0x40000
000236  6002              STR      r2,[r0,#0]
                  |L1.568|
;;;765      }
;;;766    }
000238  4770              BX       lr
;;;767    
                          ENDP

                  DMA_MemoryTargetConfig PROC
;;;789      */
;;;790    void DMA_MemoryTargetConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t MemoryBaseAddr,
00023a  b10a              CBZ      r2,|L1.576|
;;;791                               uint32_t DMA_MemoryTarget)
;;;792    {
;;;793      /* Check the parameters */
;;;794      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;795      assert_param(IS_DMA_CURRENT_MEM(DMA_MemoryTarget));
;;;796        
;;;797      /* Check the Memory target to be configured */
;;;798      if (DMA_MemoryTarget != DMA_Memory_0)
;;;799      {
;;;800        /* Write to DMAy Streamx M1AR */
;;;801        DMAy_Streamx->M1AR = MemoryBaseAddr;    
00023c  6101              STR      r1,[r0,#0x10]
00023e  e000              B        |L1.578|
                  |L1.576|
;;;802      }  
;;;803      else
;;;804      {
;;;805        /* Write to DMAy Streamx M0AR */
;;;806        DMAy_Streamx->M0AR = MemoryBaseAddr;  
000240  60c1              STR      r1,[r0,#0xc]
                  |L1.578|
;;;807      }
;;;808    }
000242  4770              BX       lr
;;;809    
                          ENDP

                  DMA_GetCurrentMemoryTarget PROC
;;;815      */
;;;816    uint32_t DMA_GetCurrentMemoryTarget(DMA_Stream_TypeDef* DMAy_Streamx)
000244  4601              MOV      r1,r0
;;;817    {
;;;818      uint32_t tmp = 0;
000246  f04f0000          MOV      r0,#0
;;;819      
;;;820      /* Check the parameters */
;;;821      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;822    
;;;823      /* Get the current memory target */
;;;824      if ((DMAy_Streamx->CR & DMA_SxCR_CT) != 0)
00024a  680a              LDR      r2,[r1,#0]
00024c  f4122f00          TST      r2,#0x80000
000250  d002              BEQ      |L1.600|
;;;825      {
;;;826        /* Current memory buffer used is Memory 1 */
;;;827        tmp = 1;
000252  f04f0001          MOV      r0,#1
000256  e001              B        |L1.604|
                  |L1.600|
;;;828      }  
;;;829      else
;;;830      {
;;;831        /* Current memory buffer used is Memory 0 */
;;;832        tmp = 0;    
000258  f04f0000          MOV      r0,#0
                  |L1.604|
;;;833      }
;;;834      return tmp;
;;;835    }
00025c  4770              BX       lr
;;;836    /**
                          ENDP

                  DMA_GetCmdStatus PROC
;;;924      */
;;;925    FunctionalState DMA_GetCmdStatus(DMA_Stream_TypeDef* DMAy_Streamx)
00025e  4601              MOV      r1,r0
;;;926    {
;;;927      FunctionalState state = DISABLE;
000260  f04f0000          MOV      r0,#0
;;;928    
;;;929      /* Check the parameters */
;;;930      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;931    
;;;932      if ((DMAy_Streamx->CR & (uint32_t)DMA_SxCR_EN) != 0)
000264  680a              LDR      r2,[r1,#0]
000266  f0120f01          TST      r2,#1
00026a  d002              BEQ      |L1.626|
;;;933      {
;;;934        /* The selected DMAy Streamx EN bit is set (DMA is still transferring) */
;;;935        state = ENABLE;
00026c  f04f0001          MOV      r0,#1
000270  e001              B        |L1.630|
                  |L1.626|
;;;936      }
;;;937      else
;;;938      {
;;;939        /* The selected DMAy Streamx EN bit is cleared (DMA is disabled and 
;;;940            all transfers are complete) */
;;;941        state = DISABLE;
000272  f04f0000          MOV      r0,#0
                  |L1.630|
;;;942      }
;;;943      return state;
;;;944    }
000276  4770              BX       lr
;;;945    
                          ENDP

                  DMA_GetFIFOStatus PROC
;;;958      */
;;;959    uint32_t DMA_GetFIFOStatus(DMA_Stream_TypeDef* DMAy_Streamx)
000278  4601              MOV      r1,r0
;;;960    {
;;;961      uint32_t tmpreg = 0;
00027a  f04f0000          MOV      r0,#0
;;;962     
;;;963      /* Check the parameters */
;;;964      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;965      
;;;966      /* Get the FIFO level bits */
;;;967      tmpreg = (uint32_t)((DMAy_Streamx->FCR & DMA_SxFCR_FS));
00027e  694a              LDR      r2,[r1,#0x14]
000280  f0020038          AND      r0,r2,#0x38
;;;968      
;;;969      return tmpreg;
;;;970    }
000284  4770              BX       lr
;;;971    
                          ENDP

                  DMA_GetFlagStatus PROC
;;;985      */
;;;986    FlagStatus DMA_GetFlagStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
000286  b530              PUSH     {r4,r5,lr}
;;;987    {
000288  4603              MOV      r3,r0
00028a  460a              MOV      r2,r1
;;;988      FlagStatus bitstatus = RESET;
00028c  f04f0000          MOV      r0,#0
;;;989      DMA_TypeDef* DMAy;
;;;990      uint32_t tmpreg = 0;
000290  4604              MOV      r4,r0
;;;991    
;;;992      /* Check the parameters */
;;;993      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;994      assert_param(IS_DMA_GET_FLAG(DMA_FLAG));
;;;995    
;;;996      /* Determine the DMA to which belongs the stream */
;;;997      if (DMAy_Streamx < DMA2_Stream0)
000292  4d4a              LDR      r5,|L1.956|
000294  42ab              CMP      r3,r5
000296  d201              BCS      |L1.668|
;;;998      {
;;;999        /* DMAy_Streamx belongs to DMA1 */
;;;1000       DMAy = DMA1; 
000298  4944              LDR      r1,|L1.940|
00029a  e000              B        |L1.670|
                  |L1.668|
;;;1001     } 
;;;1002     else 
;;;1003     {
;;;1004       /* DMAy_Streamx belongs to DMA2 */
;;;1005       DMAy = DMA2; 
00029c  494b              LDR      r1,|L1.972|
                  |L1.670|
;;;1006     }
;;;1007   
;;;1008     /* Check if the flag is in HISR or LISR */
;;;1009     if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
00029e  f0125f00          TST      r2,#0x20000000
0002a2  d001              BEQ      |L1.680|
;;;1010     {
;;;1011       /* Get DMAy HISR register value */
;;;1012       tmpreg = DMAy->HISR;
0002a4  684c              LDR      r4,[r1,#4]
0002a6  e000              B        |L1.682|
                  |L1.680|
;;;1013     }
;;;1014     else
;;;1015     {
;;;1016       /* Get DMAy LISR register value */
;;;1017       tmpreg = DMAy->LISR;
0002a8  680c              LDR      r4,[r1,#0]
                  |L1.682|
;;;1018     }   
;;;1019    
;;;1020     /* Mask the reserved bits */
;;;1021     tmpreg &= (uint32_t)RESERVED_MASK;
0002aa  4d49              LDR      r5,|L1.976|
0002ac  ea040405          AND      r4,r4,r5
;;;1022   
;;;1023     /* Check the status of the specified DMA flag */
;;;1024     if ((tmpreg & DMA_FLAG) != (uint32_t)RESET)
0002b0  4214              TST      r4,r2
0002b2  d002              BEQ      |L1.698|
;;;1025     {
;;;1026       /* DMA_FLAG is set */
;;;1027       bitstatus = SET;
0002b4  f04f0001          MOV      r0,#1
0002b8  e001              B        |L1.702|
                  |L1.698|
;;;1028     }
;;;1029     else
;;;1030     {
;;;1031       /* DMA_FLAG is reset */
;;;1032       bitstatus = RESET;
0002ba  f04f0000          MOV      r0,#0
                  |L1.702|
;;;1033     }
;;;1034   
;;;1035     /* Return the DMA_FLAG status */
;;;1036     return  bitstatus;
;;;1037   }
0002be  bd30              POP      {r4,r5,pc}
;;;1038   
                          ENDP

                  DMA_ClearFlag PROC
;;;1052     */
;;;1053   void DMA_ClearFlag(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
0002c0  4602              MOV      r2,r0
;;;1054   {
;;;1055     DMA_TypeDef* DMAy;
;;;1056   
;;;1057     /* Check the parameters */
;;;1058     assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;1059     assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));
;;;1060   
;;;1061     /* Determine the DMA to which belongs the stream */
;;;1062     if (DMAy_Streamx < DMA2_Stream0)
0002c2  4b3e              LDR      r3,|L1.956|
0002c4  429a              CMP      r2,r3
0002c6  d201              BCS      |L1.716|
;;;1063     {
;;;1064       /* DMAy_Streamx belongs to DMA1 */
;;;1065       DMAy = DMA1; 
0002c8  4838              LDR      r0,|L1.940|
0002ca  e000              B        |L1.718|
                  |L1.716|
;;;1066     } 
;;;1067     else 
;;;1068     {
;;;1069       /* DMAy_Streamx belongs to DMA2 */
;;;1070       DMAy = DMA2; 
0002cc  483f              LDR      r0,|L1.972|
                  |L1.718|
;;;1071     }
;;;1072   
;;;1073     /* Check if LIFCR or HIFCR register is targeted */
;;;1074     if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
0002ce  f0115f00          TST      r1,#0x20000000
0002d2  d004              BEQ      |L1.734|
;;;1075     {
;;;1076       /* Set DMAy HIFCR register clear flag bits */
;;;1077       DMAy->HIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
0002d4  4b3e              LDR      r3,|L1.976|
0002d6  ea010303          AND      r3,r1,r3
0002da  60c3              STR      r3,[r0,#0xc]
0002dc  e003              B        |L1.742|
                  |L1.734|
;;;1078     }
;;;1079     else 
;;;1080     {
;;;1081       /* Set DMAy LIFCR register clear flag bits */
;;;1082       DMAy->LIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
0002de  4b3c              LDR      r3,|L1.976|
0002e0  ea010303          AND      r3,r1,r3
0002e4  6083              STR      r3,[r0,#8]
                  |L1.742|
;;;1083     }    
;;;1084   }
0002e6  4770              BX       lr
;;;1085   
                          ENDP

                  DMA_ITConfig PROC
;;;1099     */
;;;1100   void DMA_ITConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT, FunctionalState NewState)
0002e8  b510              PUSH     {r4,lr}
;;;1101   {
;;;1102     /* Check the parameters */
;;;1103     assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;1104     assert_param(IS_DMA_CONFIG_IT(DMA_IT));
;;;1105     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1106   
;;;1107     /* Check if the DMA_IT parameter contains a FIFO interrupt */
;;;1108     if ((DMA_IT & DMA_IT_FE) != 0)
0002ea  f0110f80          TST      r1,#0x80
0002ee  d009              BEQ      |L1.772|
;;;1109     {
;;;1110       if (NewState != DISABLE)
0002f0  b122              CBZ      r2,|L1.764|
;;;1111       {
;;;1112         /* Enable the selected DMA FIFO interrupts */
;;;1113         DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
0002f2  6943              LDR      r3,[r0,#0x14]
0002f4  f0430380          ORR      r3,r3,#0x80
0002f8  6143              STR      r3,[r0,#0x14]
0002fa  e003              B        |L1.772|
                  |L1.764|
;;;1114       }    
;;;1115       else 
;;;1116       {
;;;1117         /* Disable the selected DMA FIFO interrupts */
;;;1118         DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
0002fc  6943              LDR      r3,[r0,#0x14]
0002fe  f0230380          BIC      r3,r3,#0x80
000302  6143              STR      r3,[r0,#0x14]
                  |L1.772|
;;;1119       }
;;;1120     }
;;;1121   
;;;1122     /* Check if the DMA_IT parameter contains a Transfer interrupt */
;;;1123     if (DMA_IT != DMA_IT_FE)
000304  2980              CMP      r1,#0x80
000306  d00d              BEQ      |L1.804|
;;;1124     {
;;;1125       if (NewState != DISABLE)
000308  b132              CBZ      r2,|L1.792|
;;;1126       {
;;;1127         /* Enable the selected DMA transfer interrupts */
;;;1128         DMAy_Streamx->CR |= (uint32_t)(DMA_IT  & TRANSFER_IT_ENABLE_MASK);
00030a  6803              LDR      r3,[r0,#0]
00030c  f001041e          AND      r4,r1,#0x1e
000310  ea430304          ORR      r3,r3,r4
000314  6003              STR      r3,[r0,#0]
000316  e005              B        |L1.804|
                  |L1.792|
;;;1129       }
;;;1130       else
;;;1131       {
;;;1132         /* Disable the selected DMA transfer interrupts */
;;;1133         DMAy_Streamx->CR &= ~(uint32_t)(DMA_IT & TRANSFER_IT_ENABLE_MASK);
000318  6803              LDR      r3,[r0,#0]
00031a  f001041e          AND      r4,r1,#0x1e
00031e  ea230304          BIC      r3,r3,r4
000322  6003              STR      r3,[r0,#0]
                  |L1.804|
;;;1134       }    
;;;1135     }
;;;1136   }
000324  bd10              POP      {r4,pc}
;;;1137   
                          ENDP

                  DMA_GetITStatus PROC
;;;1151     */
;;;1152   ITStatus DMA_GetITStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
000326  b570              PUSH     {r4-r6,lr}
;;;1153   {
000328  4602              MOV      r2,r0
;;;1154     ITStatus bitstatus = RESET;
00032a  f04f0000          MOV      r0,#0
;;;1155     DMA_TypeDef* DMAy;
;;;1156     uint32_t tmpreg = 0, enablestatus = 0;
00032e  4604              MOV      r4,r0
000330  4605              MOV      r5,r0
;;;1157   
;;;1158     /* Check the parameters */
;;;1159     assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;1160     assert_param(IS_DMA_GET_IT(DMA_IT));
;;;1161    
;;;1162     /* Determine the DMA to which belongs the stream */
;;;1163     if (DMAy_Streamx < DMA2_Stream0)
000332  4e22              LDR      r6,|L1.956|
000334  42b2              CMP      r2,r6
000336  d201              BCS      |L1.828|
;;;1164     {
;;;1165       /* DMAy_Streamx belongs to DMA1 */
;;;1166       DMAy = DMA1; 
000338  4b1c              LDR      r3,|L1.940|
00033a  e000              B        |L1.830|
                  |L1.828|
;;;1167     } 
;;;1168     else 
;;;1169     {
;;;1170       /* DMAy_Streamx belongs to DMA2 */
;;;1171       DMAy = DMA2; 
00033c  4b23              LDR      r3,|L1.972|
                  |L1.830|
;;;1172     }
;;;1173   
;;;1174     /* Check if the interrupt enable bit is in the CR or FCR register */
;;;1175     if ((DMA_IT & TRANSFER_IT_MASK) != (uint32_t)RESET)
00033e  4e25              LDR      r6,|L1.980|
000340  4231              TST      r1,r6
000342  d007              BEQ      |L1.852|
;;;1176     {
;;;1177       /* Get the interrupt enable position mask in CR register */
;;;1178       tmpreg = (uint32_t)((DMA_IT >> 11) & TRANSFER_IT_ENABLE_MASK);   
000344  f04f061e          MOV      r6,#0x1e
000348  ea0624d1          AND      r4,r6,r1,LSR #11
;;;1179       
;;;1180       /* Check the enable bit in CR register */
;;;1181       enablestatus = (uint32_t)(DMAy_Streamx->CR & tmpreg);
00034c  6816              LDR      r6,[r2,#0]
00034e  ea060504          AND      r5,r6,r4
000352  e002              B        |L1.858|
                  |L1.852|
;;;1182     }
;;;1183     else 
;;;1184     {
;;;1185       /* Check the enable bit in FCR register */
;;;1186       enablestatus = (uint32_t)(DMAy_Streamx->FCR & DMA_IT_FE); 
000354  6956              LDR      r6,[r2,#0x14]
000356  f0060580          AND      r5,r6,#0x80
                  |L1.858|
;;;1187     }
;;;1188    
;;;1189     /* Check if the interrupt pending flag is in LISR or HISR */
;;;1190     if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
00035a  f0115f00          TST      r1,#0x20000000
00035e  d001              BEQ      |L1.868|
;;;1191     {
;;;1192       /* Get DMAy HISR register value */
;;;1193       tmpreg = DMAy->HISR ;
000360  685c              LDR      r4,[r3,#4]
000362  e000              B        |L1.870|
                  |L1.868|
;;;1194     }
;;;1195     else
;;;1196     {
;;;1197       /* Get DMAy LISR register value */
;;;1198       tmpreg = DMAy->LISR ;
000364  681c              LDR      r4,[r3,#0]
                  |L1.870|
;;;1199     } 
;;;1200   
;;;1201     /* mask all reserved bits */
;;;1202     tmpreg &= (uint32_t)RESERVED_MASK;
000366  4e1a              LDR      r6,|L1.976|
000368  ea040406          AND      r4,r4,r6
;;;1203   
;;;1204     /* Check the status of the specified DMA interrupt */
;;;1205     if (((tmpreg & DMA_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
00036c  420c              TST      r4,r1
00036e  d003              BEQ      |L1.888|
000370  b115              CBZ      r5,|L1.888|
;;;1206     {
;;;1207       /* DMA_IT is set */
;;;1208       bitstatus = SET;
000372  f04f0001          MOV      r0,#1
000376  e001              B        |L1.892|
                  |L1.888|
;;;1209     }
;;;1210     else
;;;1211     {
;;;1212       /* DMA_IT is reset */
;;;1213       bitstatus = RESET;
000378  f04f0000          MOV      r0,#0
                  |L1.892|
;;;1214     }
;;;1215   
;;;1216     /* Return the DMA_IT status */
;;;1217     return  bitstatus;
;;;1218   }
00037c  bd70              POP      {r4-r6,pc}
;;;1219   
                          ENDP

                  DMA_ClearITPendingBit PROC
;;;1233     */
;;;1234   void DMA_ClearITPendingBit(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
00037e  4602              MOV      r2,r0
;;;1235   {
;;;1236     DMA_TypeDef* DMAy;
;;;1237   
;;;1238     /* Check the parameters */
;;;1239     assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;1240     assert_param(IS_DMA_CLEAR_IT(DMA_IT));
;;;1241   
;;;1242     /* Determine the DMA to which belongs the stream */
;;;1243     if (DMAy_Streamx < DMA2_Stream0)
000380  4b0e              LDR      r3,|L1.956|
000382  429a              CMP      r2,r3
000384  d201              BCS      |L1.906|
;;;1244     {
;;;1245       /* DMAy_Streamx belongs to DMA1 */
;;;1246       DMAy = DMA1; 
000386  4809              LDR      r0,|L1.940|
000388  e000              B        |L1.908|
                  |L1.906|
;;;1247     } 
;;;1248     else 
;;;1249     {
;;;1250       /* DMAy_Streamx belongs to DMA2 */
;;;1251       DMAy = DMA2; 
00038a  4810              LDR      r0,|L1.972|
                  |L1.908|
;;;1252     }
;;;1253   
;;;1254     /* Check if LIFCR or HIFCR register is targeted */
;;;1255     if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
00038c  f0115f00          TST      r1,#0x20000000
000390  d004              BEQ      |L1.924|
;;;1256     {
;;;1257       /* Set DMAy HIFCR register clear interrupt bits */
;;;1258       DMAy->HIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
000392  4b0f              LDR      r3,|L1.976|
000394  ea010303          AND      r3,r1,r3
000398  60c3              STR      r3,[r0,#0xc]
00039a  e003              B        |L1.932|
                  |L1.924|
;;;1259     }
;;;1260     else 
;;;1261     {
;;;1262       /* Set DMAy LIFCR register clear interrupt bits */
;;;1263       DMAy->LIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
00039c  4b0c              LDR      r3,|L1.976|
00039e  ea010303          AND      r3,r1,r3
0003a2  6083              STR      r3,[r0,#8]
                  |L1.932|
;;;1264     }   
;;;1265   }
0003a4  4770              BX       lr
;;;1266   
                          ENDP

0003a6  0000              DCW      0x0000
                  |L1.936|
                          DCD      0x40026010
                  |L1.940|
                          DCD      0x40026000
                  |L1.944|
                          DCD      0x2000003d
                  |L1.948|
                          DCD      0x20000f40
                  |L1.952|
                          DCD      0x203d0000
                  |L1.956|
                          DCD      0x40026410
                  |L1.960|
                          DCD      0x40026408
                  |L1.964|
                          DCD      0x4002640c
                  |L1.968|
                          DCD      0xf01c803f
                  |L1.972|
                          DCD      0x40026400
                  |L1.976|
                          DCD      0x0f7d0f7d
                  |L1.980|
                          DCD      0x0f3c0f3c

;*** Start embedded assembler ***

#line 1 "..\\BSP\\STM32F2xx\\src\\stm32f2xx_dma.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f2xx_dma_c_e9b554c0____REV16|
#line 112 "..\\BSP\\CMSIS\\core_cmInstr.h"
|__asm___15_stm32f2xx_dma_c_e9b554c0____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f2xx_dma_c_e9b554c0____REVSH|
#line 130
|__asm___15_stm32f2xx_dma_c_e9b554c0____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
