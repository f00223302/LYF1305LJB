; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Output\os_tmr.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\Output\os_tmr.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\BSP -I..\BSP\UCOS-II -I..\BSP\STM32F2xx\inc -I..\BSP\CMSIS -I..\BSP\CMSIS\Device_Support -I..\BSP\UCOS-II -I..\..\uC-CPU -I..\..\uC-CPU\ARM-Cortex-M3 -I..\..\uC-LIB -I..\..\uC-LIB\Ports\ARM-Cortex-M3 -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3 -I..\App -I..\Prj -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DDEBUG -DLJB_CPU_MAIN -DUSE_CPU_F205RC --omf_browse=.\Output\os_tmr.crf ..\..\uCOS-II\Source\os_tmr.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  OSTmr_Alloc PROC
;;;757    #if OS_TMR_EN > 0u
;;;758    static  OS_TMR  *OSTmr_Alloc (void)
000000  48f7              LDR      r0,|L1.992|
;;;759    {
;;;760        OS_TMR *ptmr;
;;;761    
;;;762    
;;;763        if (OSTmrFreeList == (OS_TMR *)0) {
000002  6800              LDR      r0,[r0,#0]  ; OSTmrFreeList
000004  b908              CBNZ     r0,|L1.10|
;;;764            return ((OS_TMR *)0);
000006  2000              MOVS     r0,#0
                  |L1.8|
;;;765        }
;;;766        ptmr            = (OS_TMR *)OSTmrFreeList;
;;;767        OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
;;;768        ptmr->OSTmrNext = (OS_TCB *)0;
;;;769        ptmr->OSTmrPrev = (OS_TCB *)0;
;;;770        OSTmrUsed++;
;;;771        OSTmrFree--;
;;;772        return (ptmr);
;;;773    }
000008  4770              BX       lr
                  |L1.10|
00000a  48f5              LDR      r0,|L1.992|
00000c  6801              LDR      r1,[r0,#0]            ;766  ; OSTmrFreeList
00000e  4af4              LDR      r2,|L1.992|
000010  68c8              LDR      r0,[r1,#0xc]          ;767
000012  6010              STR      r0,[r2,#0]            ;767  ; OSTmrFreeList
000014  f04f0000          MOV      r0,#0                 ;768
000018  60c8              STR      r0,[r1,#0xc]          ;768
00001a  6108              STR      r0,[r1,#0x10]         ;769
00001c  48f1              LDR      r0,|L1.996|
00001e  8800              LDRH     r0,[r0,#0]            ;770  ; OSTmrUsed
000020  f1000001          ADD      r0,r0,#1              ;770
000024  4aef              LDR      r2,|L1.996|
000026  8010              STRH     r0,[r2,#0]            ;770
000028  48ef              LDR      r0,|L1.1000|
00002a  8800              LDRH     r0,[r0,#0]            ;771  ; OSTmrFree
00002c  f1a00001          SUB      r0,r0,#1              ;771
000030  4aed              LDR      r2,|L1.1000|
000032  8010              STRH     r0,[r2,#0]            ;771
000034  4608              MOV      r0,r1                 ;772
000036  e7e7              B        |L1.8|
;;;774    #endif
                          ENDP

                  OSTmrCreate PROC
;;;111    #if OS_TMR_EN > 0u
;;;112    OS_TMR  *OSTmrCreate (INT32U           dly,
000038  e92d5ff0          PUSH     {r4-r12,lr}
;;;113                          INT32U           period,
;;;114                          INT8U            opt,
;;;115                          OS_TMR_CALLBACK  callback,
;;;116                          void            *callback_arg,
;;;117                          INT8U           *pname,
;;;118                          INT8U           *perr)
;;;119    {
00003c  4606              MOV      r6,r0
00003e  460f              MOV      r7,r1
000040  4690              MOV      r8,r2
000042  4699              MOV      r9,r3
000044  e9ddba0a          LDRD     r11,r10,[sp,#0x28]
000048  9d0c              LDR      r5,[sp,#0x30]
;;;120        OS_TMR   *ptmr;
;;;121    
;;;122    
;;;123    #ifdef OS_SAFETY_CRITICAL
;;;124        if (perr == (INT8U *)0) {
;;;125            OS_SAFETY_CRITICAL_EXCEPTION();
;;;126            return ((OS_TMR *)0);
;;;127        }
;;;128    #endif
;;;129    
;;;130    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;131        if (OSSafetyCriticalStartFlag == OS_TRUE) {
;;;132            OS_SAFETY_CRITICAL_EXCEPTION();
;;;133            return ((OS_TMR *)0);
;;;134        }
;;;135    #endif
;;;136    
;;;137    #if OS_ARG_CHK_EN > 0u
;;;138        switch (opt) {                                          /* Validate arguments                                     */
;;;139            case OS_TMR_OPT_PERIODIC:
;;;140                 if (period == 0u) {
;;;141                     *perr = OS_ERR_TMR_INVALID_PERIOD;
;;;142                     return ((OS_TMR *)0);
;;;143                 }
;;;144                 break;
;;;145    
;;;146            case OS_TMR_OPT_ONE_SHOT:
;;;147                 if (dly == 0u) {
;;;148                     *perr = OS_ERR_TMR_INVALID_DLY;
;;;149                     return ((OS_TMR *)0);
;;;150                 }
;;;151                 break;
;;;152    
;;;153            default:
;;;154                 *perr = OS_ERR_TMR_INVALID_OPT;
;;;155                 return ((OS_TMR *)0);
;;;156        }
;;;157    #endif
;;;158        if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
00004a  48e8              LDR      r0,|L1.1004|
00004c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00004e  b130              CBZ      r0,|L1.94|
;;;159            *perr  = OS_ERR_TMR_ISR;
000050  f04f008b          MOV      r0,#0x8b
000054  7028              STRB     r0,[r5,#0]
;;;160            return ((OS_TMR *)0);
000056  f04f0000          MOV      r0,#0
                  |L1.90|
;;;161        }
;;;162        OSSchedLock();
;;;163        ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
;;;164        if (ptmr == (OS_TMR *)0) {
;;;165            OSSchedUnlock();
;;;166            *perr = OS_ERR_TMR_NON_AVAIL;
;;;167            return ((OS_TMR *)0);
;;;168        }
;;;169        ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
;;;170        ptmr->OSTmrDly         = dly;
;;;171        ptmr->OSTmrPeriod      = period;
;;;172        ptmr->OSTmrOpt         = opt;
;;;173        ptmr->OSTmrCallback    = callback;
;;;174        ptmr->OSTmrCallbackArg = callback_arg;
;;;175    #if OS_TMR_CFG_NAME_EN > 0u
;;;176        if (pname == (INT8U *)0) {                              /* Is 'pname' a NULL pointer?                             */
;;;177            ptmr->OSTmrName    = (INT8U *)(void *)"?";
;;;178        } else {
;;;179            ptmr->OSTmrName    = pname;
;;;180        }
;;;181    #endif
;;;182        OSSchedUnlock();
;;;183        *perr = OS_ERR_NONE;
;;;184        return (ptmr);
;;;185    }
00005a  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.94|
00005e  f7fffffe          BL       OSSchedLock
000062  f7fffffe          BL       OSTmr_Alloc
000066  4604              MOV      r4,r0                 ;163
000068  b93c              CBNZ     r4,|L1.122|
00006a  f7fffffe          BL       OSSchedUnlock
00006e  f04f0086          MOV      r0,#0x86              ;166
000072  7028              STRB     r0,[r5,#0]            ;166
000074  f04f0000          MOV      r0,#0                 ;167
000078  e7ef              B        |L1.90|
                  |L1.122|
00007a  f04f0001          MOV      r0,#1                 ;169
00007e  f8840025          STRB     r0,[r4,#0x25]         ;169
000082  61a6              STR      r6,[r4,#0x18]         ;170
000084  61e7              STR      r7,[r4,#0x1c]         ;171
000086  f8848024          STRB     r8,[r4,#0x24]         ;172
00008a  f8c49004          STR      r9,[r4,#4]            ;173
00008e  f8c4b008          STR      r11,[r4,#8]           ;174
000092  f1ba0f00          CMP      r10,#0                ;176
000096  d102              BNE      |L1.158|
000098  a0d5              ADR      r0,|L1.1008|
00009a  6220              STR      r0,[r4,#0x20]         ;177
00009c  e001              B        |L1.162|
                  |L1.158|
00009e  f8c4a020          STR      r10,[r4,#0x20]        ;179
                  |L1.162|
0000a2  f7fffffe          BL       OSSchedUnlock
0000a6  f04f0000          MOV      r0,#0                 ;183
0000aa  7028              STRB     r0,[r5,#0]            ;183
0000ac  4620              MOV      r0,r4                 ;184
0000ae  e7d4              B        |L1.90|
;;;186    #endif
                          ENDP

                  OSTmr_Free PROC
;;;789    #if OS_TMR_EN > 0u
;;;790    static  void  OSTmr_Free (OS_TMR *ptmr)
0000b0  f04f0100          MOV      r1,#0
;;;791    {
;;;792        ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
0000b4  f8801025          STRB     r1,[r0,#0x25]
;;;793        ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
0000b8  f8801024          STRB     r1,[r0,#0x24]
;;;794        ptmr->OSTmrPeriod      = 0u;
0000bc  61c1              STR      r1,[r0,#0x1c]
;;;795        ptmr->OSTmrMatch       = 0u;
0000be  6141              STR      r1,[r0,#0x14]
;;;796        ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
0000c0  6041              STR      r1,[r0,#4]
;;;797        ptmr->OSTmrCallbackArg = (void *)0;
0000c2  6081              STR      r1,[r0,#8]
;;;798    #if OS_TMR_CFG_NAME_EN > 0u
;;;799        ptmr->OSTmrName        = (INT8U *)(void *)"?";
0000c4  a1ca              ADR      r1,|L1.1008|
0000c6  6201              STR      r1,[r0,#0x20]
;;;800    #endif
;;;801    
;;;802        ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
0000c8  f04f0100          MOV      r1,#0
0000cc  6101              STR      r1,[r0,#0x10]
;;;803        ptmr->OSTmrNext        = OSTmrFreeList;
0000ce  49c4              LDR      r1,|L1.992|
0000d0  6809              LDR      r1,[r1,#0]  ; OSTmrFreeList
0000d2  60c1              STR      r1,[r0,#0xc]
;;;804        OSTmrFreeList          = ptmr;
0000d4  49c2              LDR      r1,|L1.992|
0000d6  6008              STR      r0,[r1,#0]  ; OSTmrFreeList
;;;805    
;;;806        OSTmrUsed--;                                       /* Update timer object statistics                              */
0000d8  49c2              LDR      r1,|L1.996|
0000da  8809              LDRH     r1,[r1,#0]  ; OSTmrUsed
0000dc  f1a10101          SUB      r1,r1,#1
0000e0  4ac0              LDR      r2,|L1.996|
0000e2  8011              STRH     r1,[r2,#0]
;;;807        OSTmrFree++;
0000e4  49c0              LDR      r1,|L1.1000|
0000e6  8809              LDRH     r1,[r1,#0]  ; OSTmrFree
0000e8  f1010101          ADD      r1,r1,#1
0000ec  4abe              LDR      r2,|L1.1000|
0000ee  8011              STRH     r1,[r2,#0]
;;;808    }
0000f0  4770              BX       lr
;;;809    #endif
                          ENDP

                  OSTmr_Unlink PROC
;;;1004   #if OS_TMR_EN > 0u
;;;1005   static  void  OSTmr_Unlink (OS_TMR *ptmr)
0000f2  b530              PUSH     {r4,r5,lr}
;;;1006   {
;;;1007       OS_TMR        *ptmr1;
;;;1008       OS_TMR        *ptmr2;
;;;1009       OS_TMR_WHEEL  *pspoke;
;;;1010       INT16U         spoke;
;;;1011   
;;;1012   
;;;1013       spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
0000f4  6945              LDR      r5,[r0,#0x14]
0000f6  f0050407          AND      r4,r5,#7
;;;1014       pspoke = &OSTmrWheelTbl[spoke];
0000fa  4dbe              LDR      r5,|L1.1012|
0000fc  eb0503c4          ADD      r3,r5,r4,LSL #3
;;;1015   
;;;1016       if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
000100  681d              LDR      r5,[r3,#0]
000102  4285              CMP      r5,r0
000104  d106              BNE      |L1.276|
;;;1017           ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
000106  68c1              LDR      r1,[r0,#0xc]
;;;1018           pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
000108  6019              STR      r1,[r3,#0]
;;;1019           if (ptmr1 != (OS_TMR *)0) {
00010a  b141              CBZ      r1,|L1.286|
;;;1020               ptmr1->OSTmrPrev = (void *)0;
00010c  f04f0500          MOV      r5,#0
000110  610d              STR      r5,[r1,#0x10]
000112  e004              B        |L1.286|
                  |L1.276|
;;;1021           }
;;;1022       } else {
;;;1023           ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
000114  6901              LDR      r1,[r0,#0x10]
;;;1024           ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
000116  68c2              LDR      r2,[r0,#0xc]
;;;1025           ptmr1->OSTmrNext = ptmr2;
000118  60ca              STR      r2,[r1,#0xc]
;;;1026           if (ptmr2 != (OS_TMR *)0) {
00011a  b102              CBZ      r2,|L1.286|
;;;1027               ptmr2->OSTmrPrev = (void *)ptmr1;
00011c  6111              STR      r1,[r2,#0x10]
                  |L1.286|
;;;1028           }
;;;1029       }
;;;1030       ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
00011e  f04f0501          MOV      r5,#1
000122  f8805025          STRB     r5,[r0,#0x25]
;;;1031       ptmr->OSTmrNext  = (void *)0;
000126  f04f0500          MOV      r5,#0
00012a  60c5              STR      r5,[r0,#0xc]
;;;1032       ptmr->OSTmrPrev  = (void *)0;
00012c  6105              STR      r5,[r0,#0x10]
;;;1033       pspoke->OSTmrEntries--;
00012e  889d              LDRH     r5,[r3,#4]
000130  f1a50501          SUB      r5,r5,#1
000134  809d              STRH     r5,[r3,#4]
;;;1034   }
000136  bd30              POP      {r4,r5,pc}
;;;1035   #endif
                          ENDP

                  OSTmrDel PROC
;;;210    #if OS_TMR_EN > 0u
;;;211    BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
000138  b570              PUSH     {r4-r6,lr}
;;;212                       INT8U   *perr)
;;;213    {
00013a  4605              MOV      r5,r0
00013c  460c              MOV      r4,r1
;;;214    #ifdef OS_SAFETY_CRITICAL
;;;215        if (perr == (INT8U *)0) {
;;;216            OS_SAFETY_CRITICAL_EXCEPTION();
;;;217            return (OS_FALSE);
;;;218        }
;;;219    #endif
;;;220    
;;;221    #if OS_ARG_CHK_EN > 0u
;;;222        if (ptmr == (OS_TMR *)0) {
;;;223            *perr = OS_ERR_TMR_INVALID;
;;;224            return (OS_FALSE);
;;;225        }
;;;226    #endif
;;;227        if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
00013e  7828              LDRB     r0,[r5,#0]
000140  2864              CMP      r0,#0x64
000142  d005              BEQ      |L1.336|
;;;228            *perr = OS_ERR_TMR_INVALID_TYPE;
000144  f04f0089          MOV      r0,#0x89
000148  7020              STRB     r0,[r4,#0]
;;;229            return (OS_FALSE);
00014a  f04f0000          MOV      r0,#0
                  |L1.334|
;;;230        }
;;;231        if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
;;;232            *perr  = OS_ERR_TMR_ISR;
;;;233            return (OS_FALSE);
;;;234        }
;;;235        OSSchedLock();
;;;236        switch (ptmr->OSTmrState) {
;;;237            case OS_TMR_STATE_RUNNING:
;;;238                 OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
;;;239                 OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
;;;240                 OSSchedUnlock();
;;;241                 *perr = OS_ERR_NONE;
;;;242                 return (OS_TRUE);
;;;243    
;;;244            case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
;;;245            case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
;;;246                 OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
;;;247                 OSSchedUnlock();
;;;248                 *perr = OS_ERR_NONE;
;;;249                 return (OS_TRUE);
;;;250    
;;;251            case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
;;;252                 OSSchedUnlock();
;;;253                 *perr = OS_ERR_TMR_INACTIVE;
;;;254                 return (OS_FALSE);
;;;255    
;;;256            default:
;;;257                 OSSchedUnlock();
;;;258                 *perr = OS_ERR_TMR_INVALID_STATE;
;;;259                 return (OS_FALSE);
;;;260        }
;;;261    }
00014e  bd70              POP      {r4-r6,pc}
                  |L1.336|
000150  48a6              LDR      r0,|L1.1004|
000152  7800              LDRB     r0,[r0,#0]            ;231  ; OSIntNesting
000154  b128              CBZ      r0,|L1.354|
000156  f04f008b          MOV      r0,#0x8b              ;232
00015a  7020              STRB     r0,[r4,#0]            ;232
00015c  f04f0000          MOV      r0,#0                 ;233
000160  e7f5              B        |L1.334|
                  |L1.354|
000162  f7fffffe          BL       OSSchedLock
000166  f8950025          LDRB     r0,[r5,#0x25]         ;236
00016a  b1f8              CBZ      r0,|L1.428|
00016c  2801              CMP      r0,#1                 ;236
00016e  d011              BEQ      |L1.404|
000170  2802              CMP      r0,#2                 ;236
000172  d010              BEQ      |L1.406|
000174  2803              CMP      r0,#3                 ;236
000176  d121              BNE      |L1.444|
000178  4628              MOV      r0,r5                 ;238
00017a  f7fffffe          BL       OSTmr_Unlink
00017e  4628              MOV      r0,r5                 ;239
000180  f7fffffe          BL       OSTmr_Free
000184  f7fffffe          BL       OSSchedUnlock
000188  f04f0000          MOV      r0,#0                 ;241
00018c  7020              STRB     r0,[r4,#0]            ;241
00018e  f04f0001          MOV      r0,#1                 ;242
000192  e7dc              B        |L1.334|
                  |L1.404|
000194  bf00              NOP                            ;245
                  |L1.406|
000196  4628              MOV      r0,r5                 ;246
000198  f7fffffe          BL       OSTmr_Free
00019c  f7fffffe          BL       OSSchedUnlock
0001a0  f04f0000          MOV      r0,#0                 ;248
0001a4  7020              STRB     r0,[r4,#0]            ;248
0001a6  f04f0001          MOV      r0,#1                 ;249
0001aa  e7d0              B        |L1.334|
                  |L1.428|
0001ac  f7fffffe          BL       OSSchedUnlock
0001b0  f04f0087          MOV      r0,#0x87              ;253
0001b4  7020              STRB     r0,[r4,#0]            ;253
0001b6  f04f0000          MOV      r0,#0                 ;254
0001ba  e7c8              B        |L1.334|
                  |L1.444|
0001bc  f7fffffe          BL       OSSchedUnlock
0001c0  f04f008d          MOV      r0,#0x8d              ;258
0001c4  7020              STRB     r0,[r4,#0]            ;258
0001c6  f04f0000          MOV      r0,#0                 ;259
0001ca  e7c0              B        |L1.334|
;;;262    #endif
                          ENDP

                  OSTmrNameGet PROC
;;;288    #if OS_TMR_EN > 0u && OS_TMR_CFG_NAME_EN > 0u
;;;289    INT8U  OSTmrNameGet (OS_TMR   *ptmr,
0001cc  e92d41f0          PUSH     {r4-r8,lr}
;;;290                         INT8U   **pdest,
;;;291                         INT8U    *perr)
;;;292    {
0001d0  4605              MOV      r5,r0
0001d2  460e              MOV      r6,r1
0001d4  4614              MOV      r4,r2
;;;293        INT8U  len;
;;;294    
;;;295    
;;;296    #ifdef OS_SAFETY_CRITICAL
;;;297        if (perr == (INT8U *)0) {
;;;298            OS_SAFETY_CRITICAL_EXCEPTION();
;;;299            return (0u);
;;;300        }
;;;301    #endif
;;;302    
;;;303    #if OS_ARG_CHK_EN > 0u
;;;304        if (pdest == (INT8U **)0) {
;;;305            *perr = OS_ERR_TMR_INVALID_DEST;
;;;306            return (0u);
;;;307        }
;;;308        if (ptmr == (OS_TMR *)0) {
;;;309            *perr = OS_ERR_TMR_INVALID;
;;;310            return (0u);
;;;311        }
;;;312    #endif
;;;313        if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
0001d6  7828              LDRB     r0,[r5,#0]
0001d8  2864              CMP      r0,#0x64
0001da  d006              BEQ      |L1.490|
;;;314            *perr = OS_ERR_TMR_INVALID_TYPE;
0001dc  f04f0089          MOV      r0,#0x89
0001e0  7020              STRB     r0,[r4,#0]
;;;315            return (0u);
0001e2  f04f0000          MOV      r0,#0
                  |L1.486|
;;;316        }
;;;317        if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
;;;318            *perr = OS_ERR_NAME_GET_ISR;
;;;319            return (0u);
;;;320        }
;;;321        OSSchedLock();
;;;322        switch (ptmr->OSTmrState) {
;;;323            case OS_TMR_STATE_RUNNING:
;;;324            case OS_TMR_STATE_STOPPED:
;;;325            case OS_TMR_STATE_COMPLETED:
;;;326                 *pdest = ptmr->OSTmrName;
;;;327                 len    = OS_StrLen(*pdest);
;;;328                 OSSchedUnlock();
;;;329                 *perr = OS_ERR_NONE;
;;;330                 return (len);
;;;331    
;;;332            case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
;;;333                 OSSchedUnlock();
;;;334                 *perr = OS_ERR_TMR_INACTIVE;
;;;335                 return (0u);
;;;336    
;;;337            default:
;;;338                 OSSchedUnlock();
;;;339                 *perr = OS_ERR_TMR_INVALID_STATE;
;;;340                 return (0u);
;;;341        }
;;;342    }
0001e6  e8bd81f0          POP      {r4-r8,pc}
                  |L1.490|
0001ea  4880              LDR      r0,|L1.1004|
0001ec  7800              LDRB     r0,[r0,#0]            ;317  ; OSIntNesting
0001ee  b128              CBZ      r0,|L1.508|
0001f0  f04f0011          MOV      r0,#0x11              ;318
0001f4  7020              STRB     r0,[r4,#0]            ;318
0001f6  f04f0000          MOV      r0,#0                 ;319
0001fa  e7f4              B        |L1.486|
                  |L1.508|
0001fc  f7fffffe          BL       OSSchedLock
000200  f8950025          LDRB     r0,[r5,#0x25]         ;322
000204  b1a0              CBZ      r0,|L1.560|
000206  2801              CMP      r0,#1                 ;322
000208  d004              BEQ      |L1.532|
00020a  2802              CMP      r0,#2                 ;322
00020c  d003              BEQ      |L1.534|
00020e  2803              CMP      r0,#3                 ;322
000210  d116              BNE      |L1.576|
000212  bf00              NOP                            ;324
                  |L1.532|
000214  bf00              NOP                            ;325
                  |L1.534|
000216  6a28              LDR      r0,[r5,#0x20]         ;326
000218  6030              STR      r0,[r6,#0]            ;326
00021a  6830              LDR      r0,[r6,#0]            ;327
00021c  f7fffffe          BL       OS_StrLen
000220  4607              MOV      r7,r0                 ;327
000222  f7fffffe          BL       OSSchedUnlock
000226  f04f0000          MOV      r0,#0                 ;329
00022a  7020              STRB     r0,[r4,#0]            ;329
00022c  4638              MOV      r0,r7                 ;330
00022e  e7da              B        |L1.486|
                  |L1.560|
000230  f7fffffe          BL       OSSchedUnlock
000234  f04f0087          MOV      r0,#0x87              ;334
000238  7020              STRB     r0,[r4,#0]            ;334
00023a  f04f0000          MOV      r0,#0                 ;335
00023e  e7d2              B        |L1.486|
                  |L1.576|
000240  f7fffffe          BL       OSSchedUnlock
000244  f04f008d          MOV      r0,#0x8d              ;339
000248  7020              STRB     r0,[r4,#0]            ;339
00024a  f04f0000          MOV      r0,#0                 ;340
00024e  e7ca              B        |L1.486|
;;;343    #endif
                          ENDP

                  OSTmrRemainGet PROC
;;;368    #if OS_TMR_EN > 0u
;;;369    INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
000250  b570              PUSH     {r4-r6,lr}
;;;370                            INT8U   *perr)
;;;371    {
000252  4604              MOV      r4,r0
000254  460d              MOV      r5,r1
;;;372        INT32U  remain;
;;;373    
;;;374    
;;;375    #ifdef OS_SAFETY_CRITICAL
;;;376        if (perr == (INT8U *)0) {
;;;377            OS_SAFETY_CRITICAL_EXCEPTION();
;;;378            return (0u);
;;;379        }
;;;380    #endif
;;;381    
;;;382    #if OS_ARG_CHK_EN > 0u
;;;383        if (ptmr == (OS_TMR *)0) {
;;;384            *perr = OS_ERR_TMR_INVALID;
;;;385            return (0u);
;;;386        }
;;;387    #endif
;;;388        if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
000256  7820              LDRB     r0,[r4,#0]
000258  2864              CMP      r0,#0x64
00025a  d005              BEQ      |L1.616|
;;;389            *perr = OS_ERR_TMR_INVALID_TYPE;
00025c  f04f0089          MOV      r0,#0x89
000260  7028              STRB     r0,[r5,#0]
;;;390            return (0u);
000262  f04f0000          MOV      r0,#0
                  |L1.614|
;;;391        }
;;;392        if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
;;;393            *perr = OS_ERR_TMR_ISR;
;;;394            return (0u);
;;;395        }
;;;396        OSSchedLock();
;;;397        switch (ptmr->OSTmrState) {
;;;398            case OS_TMR_STATE_RUNNING:
;;;399                 remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
;;;400                 OSSchedUnlock();
;;;401                 *perr  = OS_ERR_NONE;
;;;402                 return (remain);
;;;403    
;;;404            case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
;;;405                 switch (ptmr->OSTmrOpt) {
;;;406                     case OS_TMR_OPT_PERIODIC:
;;;407                          if (ptmr->OSTmrDly == 0u) {
;;;408                              remain = ptmr->OSTmrPeriod;
;;;409                          } else {
;;;410                              remain = ptmr->OSTmrDly;
;;;411                          }
;;;412                          OSSchedUnlock();
;;;413                          *perr  = OS_ERR_NONE;
;;;414                          break;
;;;415    
;;;416                     case OS_TMR_OPT_ONE_SHOT:
;;;417                     default:
;;;418                          remain = ptmr->OSTmrDly;
;;;419                          OSSchedUnlock();
;;;420                          *perr  = OS_ERR_NONE;
;;;421                          break;
;;;422                 }
;;;423                 return (remain);
;;;424    
;;;425            case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
;;;426                 OSSchedUnlock();
;;;427                 *perr = OS_ERR_NONE;
;;;428                 return (0u);
;;;429    
;;;430            case OS_TMR_STATE_UNUSED:
;;;431                 OSSchedUnlock();
;;;432                 *perr = OS_ERR_TMR_INACTIVE;
;;;433                 return (0u);
;;;434    
;;;435            default:
;;;436                 OSSchedUnlock();
;;;437                 *perr = OS_ERR_TMR_INVALID_STATE;
;;;438                 return (0u);
;;;439        }
;;;440    }
000266  bd70              POP      {r4-r6,pc}
                  |L1.616|
000268  4860              LDR      r0,|L1.1004|
00026a  7800              LDRB     r0,[r0,#0]            ;392  ; OSIntNesting
00026c  b128              CBZ      r0,|L1.634|
00026e  f04f008b          MOV      r0,#0x8b              ;393
000272  7028              STRB     r0,[r5,#0]            ;393
000274  f04f0000          MOV      r0,#0                 ;394
000278  e7f5              B        |L1.614|
                  |L1.634|
00027a  f7fffffe          BL       OSSchedLock
00027e  f8940025          LDRB     r0,[r4,#0x25]         ;397
000282  b398              CBZ      r0,|L1.748|
000284  2801              CMP      r0,#1                 ;397
000286  d00f              BEQ      |L1.680|
000288  2802              CMP      r0,#2                 ;397
00028a  d029              BEQ      |L1.736|
00028c  2803              CMP      r0,#3                 ;397
00028e  d136              BNE      |L1.766|
000290  4959              LDR      r1,|L1.1016|
000292  6960              LDR      r0,[r4,#0x14]         ;399
000294  6809              LDR      r1,[r1,#0]            ;399  ; OSTmrTime
000296  eba00601          SUB      r6,r0,r1              ;399
00029a  f7fffffe          BL       OSSchedUnlock
00029e  f04f0000          MOV      r0,#0                 ;401
0002a2  7028              STRB     r0,[r5,#0]            ;401
0002a4  4630              MOV      r0,r6                 ;402
0002a6  e7de              B        |L1.614|
                  |L1.680|
0002a8  f8940024          LDRB     r0,[r4,#0x24]         ;405
0002ac  2801              CMP      r0,#1                 ;405
0002ae  d00d              BEQ      |L1.716|
0002b0  2802              CMP      r0,#2                 ;405
0002b2  d10a              BNE      |L1.714|
0002b4  69a0              LDR      r0,[r4,#0x18]         ;407
0002b6  b908              CBNZ     r0,|L1.700|
0002b8  69e6              LDR      r6,[r4,#0x1c]         ;408
0002ba  e000              B        |L1.702|
                  |L1.700|
0002bc  69a6              LDR      r6,[r4,#0x18]         ;410
                  |L1.702|
0002be  f7fffffe          BL       OSSchedUnlock
0002c2  f04f0000          MOV      r0,#0                 ;413
0002c6  7028              STRB     r0,[r5,#0]            ;413
0002c8  e007              B        |L1.730|
                  |L1.714|
0002ca  bf00              NOP                            ;416
                  |L1.716|
0002cc  69a6              LDR      r6,[r4,#0x18]         ;418
0002ce  f7fffffe          BL       OSSchedUnlock
0002d2  f04f0000          MOV      r0,#0                 ;420
0002d6  7028              STRB     r0,[r5,#0]            ;420
0002d8  bf00              NOP                            ;421
                  |L1.730|
0002da  bf00              NOP                            ;414
0002dc  4630              MOV      r0,r6                 ;423
0002de  e7c2              B        |L1.614|
                  |L1.736|
0002e0  f7fffffe          BL       OSSchedUnlock
0002e4  f04f0000          MOV      r0,#0                 ;427
0002e8  7028              STRB     r0,[r5,#0]            ;427
0002ea  e7bc              B        |L1.614|
                  |L1.748|
0002ec  e7ff              B        |L1.750|
                  |L1.750|
0002ee  f7fffffe          BL       OSSchedUnlock
0002f2  f04f0087          MOV      r0,#0x87              ;432
0002f6  7028              STRB     r0,[r5,#0]            ;432
0002f8  f04f0000          MOV      r0,#0                 ;433
0002fc  e7b3              B        |L1.614|
                  |L1.766|
0002fe  f7fffffe          BL       OSSchedUnlock
000302  f04f008d          MOV      r0,#0x8d              ;437
000306  7028              STRB     r0,[r5,#0]            ;437
000308  f04f0000          MOV      r0,#0                 ;438
00030c  e7ab              B        |L1.614|
;;;441    #endif
                          ENDP

                  OSTmrStateGet PROC
;;;469    #if OS_TMR_EN > 0u
;;;470    INT8U  OSTmrStateGet (OS_TMR  *ptmr,
00030e  b570              PUSH     {r4-r6,lr}
;;;471                          INT8U   *perr)
;;;472    {
000310  4605              MOV      r5,r0
000312  460c              MOV      r4,r1
;;;473        INT8U  state;
;;;474    
;;;475    
;;;476    #ifdef OS_SAFETY_CRITICAL
;;;477        if (perr == (INT8U *)0) {
;;;478            OS_SAFETY_CRITICAL_EXCEPTION();
;;;479            return (0u);
;;;480        }
;;;481    #endif
;;;482    
;;;483    #if OS_ARG_CHK_EN > 0u
;;;484        if (ptmr == (OS_TMR *)0) {
;;;485            *perr = OS_ERR_TMR_INVALID;
;;;486            return (0u);
;;;487        }
;;;488    #endif
;;;489        if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
000314  7828              LDRB     r0,[r5,#0]
000316  2864              CMP      r0,#0x64
000318  d005              BEQ      |L1.806|
;;;490            *perr = OS_ERR_TMR_INVALID_TYPE;
00031a  f04f0089          MOV      r0,#0x89
00031e  7020              STRB     r0,[r4,#0]
;;;491            return (0u);
000320  f04f0000          MOV      r0,#0
                  |L1.804|
;;;492        }
;;;493        if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
;;;494            *perr = OS_ERR_TMR_ISR;
;;;495            return (0u);
;;;496        }
;;;497        OSSchedLock();
;;;498        state = ptmr->OSTmrState;
;;;499        switch (state) {
;;;500            case OS_TMR_STATE_UNUSED:
;;;501            case OS_TMR_STATE_STOPPED:
;;;502            case OS_TMR_STATE_COMPLETED:
;;;503            case OS_TMR_STATE_RUNNING:
;;;504                 *perr = OS_ERR_NONE;
;;;505                 break;
;;;506    
;;;507            default:
;;;508                 *perr = OS_ERR_TMR_INVALID_STATE;
;;;509                 break;
;;;510        }
;;;511        OSSchedUnlock();
;;;512        return (state);
;;;513    }
000324  bd70              POP      {r4-r6,pc}
                  |L1.806|
000326  4831              LDR      r0,|L1.1004|
000328  7800              LDRB     r0,[r0,#0]            ;493  ; OSIntNesting
00032a  b128              CBZ      r0,|L1.824|
00032c  f04f008b          MOV      r0,#0x8b              ;494
000330  7020              STRB     r0,[r4,#0]            ;494
000332  f04f0000          MOV      r0,#0                 ;495
000336  e7f5              B        |L1.804|
                  |L1.824|
000338  f7fffffe          BL       OSSchedLock
00033c  f8956025          LDRB     r6,[r5,#0x25]         ;498
000340  b136              CBZ      r6,|L1.848|
000342  2e01              CMP      r6,#1                 ;499
000344  d005              BEQ      |L1.850|
000346  2e02              CMP      r6,#2                 ;499
000348  d004              BEQ      |L1.852|
00034a  2e03              CMP      r6,#3                 ;499
00034c  d107              BNE      |L1.862|
00034e  e002              B        |L1.854|
                  |L1.848|
000350  bf00              NOP                            ;501
                  |L1.850|
000352  bf00              NOP                            ;502
                  |L1.852|
000354  bf00              NOP                            ;503
                  |L1.854|
000356  f04f0000          MOV      r0,#0                 ;504
00035a  7020              STRB     r0,[r4,#0]            ;504
00035c  e003              B        |L1.870|
                  |L1.862|
00035e  f04f008d          MOV      r0,#0x8d              ;508
000362  7020              STRB     r0,[r4,#0]            ;508
000364  bf00              NOP                            ;509
                  |L1.870|
000366  bf00              NOP                            ;505
000368  f7fffffe          BL       OSSchedUnlock
00036c  4630              MOV      r0,r6                 ;512
00036e  e7d9              B        |L1.804|
;;;514    #endif
                          ENDP

                  OSTmr_Link PROC
;;;954    #if OS_TMR_EN > 0u
;;;955    static  void  OSTmr_Link (OS_TMR  *ptmr,
000370  b570              PUSH     {r4-r6,lr}
;;;956                              INT8U    type)
;;;957    {
000372  460b              MOV      r3,r1
;;;958        OS_TMR       *ptmr1;
;;;959        OS_TMR_WHEEL *pspoke;
;;;960        INT16U        spoke;
;;;961    
;;;962    
;;;963        ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
000374  f04f0503          MOV      r5,#3
000378  f8805025          STRB     r5,[r0,#0x25]
;;;964        if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
00037c  2b01              CMP      r3,#1
00037e  d105              BNE      |L1.908|
;;;965            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
000380  4e1d              LDR      r6,|L1.1016|
000382  69c5              LDR      r5,[r0,#0x1c]
000384  6836              LDR      r6,[r6,#0]  ; OSTmrTime
000386  4435              ADD      r5,r5,r6
000388  6145              STR      r5,[r0,#0x14]
00038a  e00c              B        |L1.934|
                  |L1.908|
;;;966        } else {
;;;967            if (ptmr->OSTmrDly == 0u) {
00038c  6985              LDR      r5,[r0,#0x18]
00038e  b92d              CBNZ     r5,|L1.924|
;;;968                ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
000390  4e19              LDR      r6,|L1.1016|
000392  69c5              LDR      r5,[r0,#0x1c]
000394  6836              LDR      r6,[r6,#0]  ; OSTmrTime
000396  4435              ADD      r5,r5,r6
000398  6145              STR      r5,[r0,#0x14]
00039a  e004              B        |L1.934|
                  |L1.924|
;;;969            } else {
;;;970                ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
00039c  4e16              LDR      r6,|L1.1016|
00039e  6985              LDR      r5,[r0,#0x18]
0003a0  6836              LDR      r6,[r6,#0]  ; OSTmrTime
0003a2  4435              ADD      r5,r5,r6
0003a4  6145              STR      r5,[r0,#0x14]
                  |L1.934|
;;;971            }
;;;972        }
;;;973        spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
0003a6  6945              LDR      r5,[r0,#0x14]
0003a8  f0050407          AND      r4,r5,#7
;;;974        pspoke = &OSTmrWheelTbl[spoke];
0003ac  4d11              LDR      r5,|L1.1012|
0003ae  eb0501c4          ADD      r1,r5,r4,LSL #3
;;;975    
;;;976        if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
0003b2  680d              LDR      r5,[r1,#0]
0003b4  b93d              CBNZ     r5,|L1.966|
;;;977            pspoke->OSTmrFirst   = ptmr;
0003b6  6008              STR      r0,[r1,#0]
;;;978            ptmr->OSTmrNext      = (OS_TMR *)0;
0003b8  f04f0500          MOV      r5,#0
0003bc  60c5              STR      r5,[r0,#0xc]
;;;979            pspoke->OSTmrEntries = 1u;
0003be  f04f0501          MOV      r5,#1
0003c2  808d              STRH     r5,[r1,#4]
0003c4  e007              B        |L1.982|
                  |L1.966|
;;;980        } else {
;;;981            ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
0003c6  680a              LDR      r2,[r1,#0]
;;;982            pspoke->OSTmrFirst   = ptmr;
0003c8  6008              STR      r0,[r1,#0]
;;;983            ptmr->OSTmrNext      = (void *)ptmr1;
0003ca  60c2              STR      r2,[r0,#0xc]
;;;984            ptmr1->OSTmrPrev     = (void *)ptmr;
0003cc  6110              STR      r0,[r2,#0x10]
;;;985            pspoke->OSTmrEntries++;
0003ce  888d              LDRH     r5,[r1,#4]
0003d0  f1050501          ADD      r5,r5,#1
0003d4  808d              STRH     r5,[r1,#4]
                  |L1.982|
;;;986        }
;;;987        ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
0003d6  f04f0500          MOV      r5,#0
0003da  6105              STR      r5,[r0,#0x10]
;;;988    }
0003dc  bd70              POP      {r4-r6,pc}
0003de  0000              DCW      0x0000
                  |L1.992|
                          DCD      OSTmrFreeList
                  |L1.996|
                          DCD      OSTmrUsed
                  |L1.1000|
                          DCD      OSTmrFree
                  |L1.1004|
                          DCD      OSIntNesting
                  |L1.1008|
0003f0  3f00              DCB      "?",0
0003f2  00                DCB      0
0003f3  00                DCB      0
                  |L1.1012|
                          DCD      OSTmrWheelTbl
                  |L1.1016|
                          DCD      OSTmrTime
                          ENDP

                  OSTmrStart PROC
;;;538    #if OS_TMR_EN > 0u
;;;539    BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
0003fc  b570              PUSH     {r4-r6,lr}
;;;540                         INT8U    *perr)
;;;541    {
0003fe  4605              MOV      r5,r0
000400  460c              MOV      r4,r1
;;;542    #ifdef OS_SAFETY_CRITICAL
;;;543        if (perr == (INT8U *)0) {
;;;544            OS_SAFETY_CRITICAL_EXCEPTION();
;;;545            return (OS_FALSE);
;;;546        }
;;;547    #endif
;;;548    
;;;549    #if OS_ARG_CHK_EN > 0u
;;;550        if (ptmr == (OS_TMR *)0) {
;;;551            *perr = OS_ERR_TMR_INVALID;
;;;552            return (OS_FALSE);
;;;553        }
;;;554    #endif
;;;555        if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
000402  7828              LDRB     r0,[r5,#0]
000404  2864              CMP      r0,#0x64
000406  d005              BEQ      |L1.1044|
;;;556            *perr = OS_ERR_TMR_INVALID_TYPE;
000408  f04f0089          MOV      r0,#0x89
00040c  7020              STRB     r0,[r4,#0]
;;;557            return (OS_FALSE);
00040e  f04f0000          MOV      r0,#0
                  |L1.1042|
;;;558        }
;;;559        if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
;;;560            *perr  = OS_ERR_TMR_ISR;
;;;561            return (OS_FALSE);
;;;562        }
;;;563        OSSchedLock();
;;;564        switch (ptmr->OSTmrState) {
;;;565            case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
;;;566                 OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
;;;567                 OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
;;;568                 OSSchedUnlock();
;;;569                 *perr = OS_ERR_NONE;
;;;570                 return (OS_TRUE);
;;;571    
;;;572            case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
;;;573            case OS_TMR_STATE_COMPLETED:
;;;574                 OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
;;;575                 OSSchedUnlock();
;;;576                 *perr = OS_ERR_NONE;
;;;577                 return (OS_TRUE);
;;;578    
;;;579            case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
;;;580                 OSSchedUnlock();
;;;581                 *perr = OS_ERR_TMR_INACTIVE;
;;;582                 return (OS_FALSE);
;;;583    
;;;584            default:
;;;585                 OSSchedUnlock();
;;;586                 *perr = OS_ERR_TMR_INVALID_STATE;
;;;587                 return (OS_FALSE);
;;;588        }
;;;589    }
000412  bd70              POP      {r4-r6,pc}
                  |L1.1044|
000414  48b1              LDR      r0,|L1.1756|
000416  7800              LDRB     r0,[r0,#0]            ;559  ; OSIntNesting
000418  b128              CBZ      r0,|L1.1062|
00041a  f04f008b          MOV      r0,#0x8b              ;560
00041e  7020              STRB     r0,[r4,#0]            ;560
000420  f04f0000          MOV      r0,#0                 ;561
000424  e7f5              B        |L1.1042|
                  |L1.1062|
000426  f7fffffe          BL       OSSchedLock
00042a  f8950025          LDRB     r0,[r5,#0x25]         ;564
00042e  b308              CBZ      r0,|L1.1140|
000430  2801              CMP      r0,#1                 ;564
000432  d012              BEQ      |L1.1114|
000434  2802              CMP      r0,#2                 ;564
000436  d011              BEQ      |L1.1116|
000438  2803              CMP      r0,#3                 ;564
00043a  d123              BNE      |L1.1156|
00043c  4628              MOV      r0,r5                 ;566
00043e  f7fffffe          BL       OSTmr_Unlink
000442  2100              MOVS     r1,#0                 ;567
000444  4628              MOV      r0,r5                 ;567
000446  f7fffffe          BL       OSTmr_Link
00044a  f7fffffe          BL       OSSchedUnlock
00044e  f04f0000          MOV      r0,#0                 ;569
000452  7020              STRB     r0,[r4,#0]            ;569
000454  f04f0001          MOV      r0,#1                 ;570
000458  e7db              B        |L1.1042|
                  |L1.1114|
00045a  bf00              NOP                            ;573
                  |L1.1116|
00045c  2100              MOVS     r1,#0                 ;574
00045e  4628              MOV      r0,r5                 ;574
000460  f7fffffe          BL       OSTmr_Link
000464  f7fffffe          BL       OSSchedUnlock
000468  f04f0000          MOV      r0,#0                 ;576
00046c  7020              STRB     r0,[r4,#0]            ;576
00046e  f04f0001          MOV      r0,#1                 ;577
000472  e7ce              B        |L1.1042|
                  |L1.1140|
000474  f7fffffe          BL       OSSchedUnlock
000478  f04f0087          MOV      r0,#0x87              ;581
00047c  7020              STRB     r0,[r4,#0]            ;581
00047e  f04f0000          MOV      r0,#0                 ;582
000482  e7c6              B        |L1.1042|
                  |L1.1156|
000484  f7fffffe          BL       OSSchedUnlock
000488  f04f008d          MOV      r0,#0x8d              ;586
00048c  7020              STRB     r0,[r4,#0]            ;586
00048e  f04f0000          MOV      r0,#0                 ;587
000492  e7be              B        |L1.1042|
;;;590    #endif
                          ENDP

                  OSTmrStop PROC
;;;630    #if OS_TMR_EN > 0u
;;;631    BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
000494  e92d41f0          PUSH     {r4-r8,lr}
;;;632                        INT8U    opt,
;;;633                        void    *callback_arg,
;;;634                        INT8U   *perr)
;;;635    {
000498  4605              MOV      r5,r0
00049a  460f              MOV      r7,r1
00049c  4690              MOV      r8,r2
00049e  461c              MOV      r4,r3
;;;636        OS_TMR_CALLBACK  pfnct;
;;;637    
;;;638    
;;;639    #ifdef OS_SAFETY_CRITICAL
;;;640        if (perr == (INT8U *)0) {
;;;641            OS_SAFETY_CRITICAL_EXCEPTION();
;;;642            return (OS_FALSE);
;;;643        }
;;;644    #endif
;;;645    
;;;646    #if OS_ARG_CHK_EN > 0u
;;;647        if (ptmr == (OS_TMR *)0) {
;;;648            *perr = OS_ERR_TMR_INVALID;
;;;649            return (OS_FALSE);
;;;650        }
;;;651    #endif
;;;652        if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
0004a0  7828              LDRB     r0,[r5,#0]
0004a2  2864              CMP      r0,#0x64
0004a4  d006              BEQ      |L1.1204|
;;;653            *perr = OS_ERR_TMR_INVALID_TYPE;
0004a6  f04f0089          MOV      r0,#0x89
0004aa  7020              STRB     r0,[r4,#0]
;;;654            return (OS_FALSE);
0004ac  f04f0000          MOV      r0,#0
                  |L1.1200|
;;;655        }
;;;656        if (OSIntNesting > 0u) {                                      /* See if trying to call from an ISR                */
;;;657            *perr  = OS_ERR_TMR_ISR;
;;;658            return (OS_FALSE);
;;;659        }
;;;660        OSSchedLock();
;;;661        switch (ptmr->OSTmrState) {
;;;662            case OS_TMR_STATE_RUNNING:
;;;663                 OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
;;;664                 *perr = OS_ERR_NONE;
;;;665                 switch (opt) {
;;;666                     case OS_TMR_OPT_CALLBACK:
;;;667                          pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
;;;668                          if (pfnct != (OS_TMR_CALLBACK)0) {
;;;669                              (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
;;;670                          } else {
;;;671                              *perr = OS_ERR_TMR_NO_CALLBACK;
;;;672                          }
;;;673                          break;
;;;674    
;;;675                     case OS_TMR_OPT_CALLBACK_ARG:
;;;676                          pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
;;;677                          if (pfnct != (OS_TMR_CALLBACK)0) {
;;;678                              (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
;;;679                          } else {
;;;680                              *perr = OS_ERR_TMR_NO_CALLBACK;
;;;681                          }
;;;682                          break;
;;;683    
;;;684                     case OS_TMR_OPT_NONE:
;;;685                          break;
;;;686    
;;;687                     default:
;;;688                         *perr = OS_ERR_TMR_INVALID_OPT;
;;;689                         break;
;;;690                 }
;;;691                 OSSchedUnlock();
;;;692                 return (OS_TRUE);
;;;693    
;;;694            case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
;;;695            case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
;;;696                 OSSchedUnlock();
;;;697                 *perr = OS_ERR_TMR_STOPPED;
;;;698                 return (OS_TRUE);
;;;699    
;;;700            case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
;;;701                 OSSchedUnlock();
;;;702                 *perr = OS_ERR_TMR_INACTIVE;
;;;703                 return (OS_FALSE);
;;;704    
;;;705            default:
;;;706                 OSSchedUnlock();
;;;707                 *perr = OS_ERR_TMR_INVALID_STATE;
;;;708                 return (OS_FALSE);
;;;709        }
;;;710    }
0004b0  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1204|
0004b4  4889              LDR      r0,|L1.1756|
0004b6  7800              LDRB     r0,[r0,#0]            ;656  ; OSIntNesting
0004b8  b128              CBZ      r0,|L1.1222|
0004ba  f04f008b          MOV      r0,#0x8b              ;657
0004be  7020              STRB     r0,[r4,#0]            ;657
0004c0  f04f0000          MOV      r0,#0                 ;658
0004c4  e7f4              B        |L1.1200|
                  |L1.1222|
0004c6  f7fffffe          BL       OSSchedLock
0004ca  f8950025          LDRB     r0,[r5,#0x25]         ;661
0004ce  2800              CMP      r0,#0                 ;661
0004d0  d038              BEQ      |L1.1348|
0004d2  2801              CMP      r0,#1                 ;661
0004d4  d02e              BEQ      |L1.1332|
0004d6  2802              CMP      r0,#2                 ;661
0004d8  d02b              BEQ      |L1.1330|
0004da  2803              CMP      r0,#3                 ;661
0004dc  d13a              BNE      |L1.1364|
0004de  4628              MOV      r0,r5                 ;663
0004e0  f7fffffe          BL       OSTmr_Unlink
0004e4  f04f0000          MOV      r0,#0                 ;664
0004e8  7020              STRB     r0,[r4,#0]            ;664
0004ea  b1c7              CBZ      r7,|L1.1310|
0004ec  2f03              CMP      r7,#3                 ;665
0004ee  d002              BEQ      |L1.1270|
0004f0  2f04              CMP      r7,#4                 ;665
0004f2  d115              BNE      |L1.1312|
0004f4  e009              B        |L1.1290|
                  |L1.1270|
0004f6  686e              LDR      r6,[r5,#4]            ;667
0004f8  b11e              CBZ      r6,|L1.1282|
0004fa  4628              MOV      r0,r5                 ;669
0004fc  68a9              LDR      r1,[r5,#8]            ;669
0004fe  47b0              BLX      r6                    ;669
000500  e002              B        |L1.1288|
                  |L1.1282|
000502  f04f008f          MOV      r0,#0x8f              ;671
000506  7020              STRB     r0,[r4,#0]            ;671
                  |L1.1288|
000508  e00e              B        |L1.1320|
                  |L1.1290|
00050a  686e              LDR      r6,[r5,#4]            ;676
00050c  b11e              CBZ      r6,|L1.1302|
00050e  4641              MOV      r1,r8                 ;678
000510  4628              MOV      r0,r5                 ;678
000512  47b0              BLX      r6                    ;678
000514  e002              B        |L1.1308|
                  |L1.1302|
000516  f04f008f          MOV      r0,#0x8f              ;680
00051a  7020              STRB     r0,[r4,#0]            ;680
                  |L1.1308|
00051c  e004              B        |L1.1320|
                  |L1.1310|
00051e  e003              B        |L1.1320|
                  |L1.1312|
000520  f04f0084          MOV      r0,#0x84              ;688
000524  7020              STRB     r0,[r4,#0]            ;688
000526  bf00              NOP                            ;689
                  |L1.1320|
000528  bf00              NOP                            ;673
00052a  f7fffffe          BL       OSSchedUnlock
00052e  2001              MOVS     r0,#1                 ;692
000530  e7be              B        |L1.1200|
                  |L1.1330|
000532  bf00              NOP                            ;695
                  |L1.1332|
000534  f7fffffe          BL       OSSchedUnlock
000538  f04f008e          MOV      r0,#0x8e              ;697
00053c  7020              STRB     r0,[r4,#0]            ;697
00053e  f04f0001          MOV      r0,#1                 ;698
000542  e7b5              B        |L1.1200|
                  |L1.1348|
000544  f7fffffe          BL       OSSchedUnlock
000548  f04f0087          MOV      r0,#0x87              ;702
00054c  7020              STRB     r0,[r4,#0]            ;702
00054e  f04f0000          MOV      r0,#0                 ;703
000552  e7ad              B        |L1.1200|
                  |L1.1364|
000554  f7fffffe          BL       OSSchedUnlock
000558  f04f008d          MOV      r0,#0x8d              ;707
00055c  7020              STRB     r0,[r4,#0]            ;707
00055e  f04f0000          MOV      r0,#0                 ;708
000562  e7a5              B        |L1.1200|
;;;711    #endif
                          ENDP

                  OSTmrSignal PROC
;;;733    #if OS_TMR_EN > 0u
;;;734    INT8U  OSTmrSignal (void)
000564  b510              PUSH     {r4,lr}
;;;735    {
;;;736        INT8U  err;
;;;737    
;;;738    
;;;739        err = OSSemPost(OSTmrSemSignal);
000566  485e              LDR      r0,|L1.1760|
000568  6800              LDR      r0,[r0,#0]  ; OSTmrSemSignal
00056a  f7fffffe          BL       OSSemPost
00056e  4604              MOV      r4,r0
;;;740        return (err);
000570  4620              MOV      r0,r4
;;;741    }
000572  bd10              POP      {r4,pc}
;;;742    #endif
                          ENDP

                  OSTmr_Task PROC
;;;1050   #if OS_TMR_EN > 0u
;;;1051   static  void  OSTmr_Task (void *p_arg)
000574  b508              PUSH     {r3,lr}
;;;1052   {
;;;1053       INT8U            err;
;;;1054       OS_TMR          *ptmr;
;;;1055       OS_TMR          *ptmr_next;
;;;1056       OS_TMR_CALLBACK  pfnct;
;;;1057       OS_TMR_WHEEL    *pspoke;
;;;1058       INT16U           spoke;
;;;1059   
;;;1060   
;;;1061       p_arg = p_arg;                                               /* Prevent compiler warning for not using 'p_arg'    */
000576  bf00              NOP      
;;;1062       for (;;) {
000578  bf00              NOP      
                  |L1.1402|
;;;1063           OSSemPend(OSTmrSemSignal, 0u, &err);                     /* Wait for signal indicating time to update timers  */
00057a  466a              MOV      r2,sp
00057c  2100              MOVS     r1,#0
00057e  4858              LDR      r0,|L1.1760|
000580  6800              LDR      r0,[r0,#0]  ; OSTmrSemSignal
000582  f7fffffe          BL       OSSemPend
;;;1064           OSSchedLock();
000586  f7fffffe          BL       OSSchedLock
;;;1065           OSTmrTime++;                                             /* Increment the current time                        */
00058a  4856              LDR      r0,|L1.1764|
00058c  6800              LDR      r0,[r0,#0]  ; OSTmrTime
00058e  f1000001          ADD      r0,r0,#1
000592  4954              LDR      r1,|L1.1764|
000594  6008              STR      r0,[r1,#0]  ; OSTmrTime
;;;1066           spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
000596  4608              MOV      r0,r1
000598  6800              LDR      r0,[r0,#0]  ; OSTmrTime
00059a  f0000807          AND      r8,r0,#7
;;;1067           pspoke = &OSTmrWheelTbl[spoke];
00059e  4852              LDR      r0,|L1.1768|
0005a0  eb0007c8          ADD      r7,r0,r8,LSL #3
;;;1068           ptmr   = pspoke->OSTmrFirst;
0005a4  683c              LDR      r4,[r7,#0]
;;;1069           while (ptmr != (OS_TMR *)0) {
0005a6  e01b              B        |L1.1504|
                  |L1.1448|
;;;1070               ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
0005a8  68e6              LDR      r6,[r4,#0xc]
;;;1071                                                                    /* ... timer could get unlinked from the wheel.      */
;;;1072               if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
0005aa  494e              LDR      r1,|L1.1764|
0005ac  6960              LDR      r0,[r4,#0x14]
0005ae  6809              LDR      r1,[r1,#0]  ; OSTmrTime
0005b0  4288              CMP      r0,r1
0005b2  d114              BNE      |L1.1502|
;;;1073                   OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
0005b4  4620              MOV      r0,r4
0005b6  f7fffffe          BL       OSTmr_Unlink
;;;1074                   if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
0005ba  f8940024          LDRB     r0,[r4,#0x24]
0005be  2802              CMP      r0,#2
0005c0  d104              BNE      |L1.1484|
;;;1075                       OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
0005c2  2101              MOVS     r1,#1
0005c4  4620              MOV      r0,r4
0005c6  f7fffffe          BL       OSTmr_Link
0005ca  e003              B        |L1.1492|
                  |L1.1484|
;;;1076                   } else {
;;;1077                       ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
0005cc  f04f0002          MOV      r0,#2
0005d0  f8840025          STRB     r0,[r4,#0x25]
                  |L1.1492|
;;;1078                   }
;;;1079                   pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
0005d4  6865              LDR      r5,[r4,#4]
;;;1080                   if (pfnct != (OS_TMR_CALLBACK)0) {
0005d6  b115              CBZ      r5,|L1.1502|
;;;1081                       (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
0005d8  4620              MOV      r0,r4
0005da  68a1              LDR      r1,[r4,#8]
0005dc  47a8              BLX      r5
                  |L1.1502|
;;;1082                   }
;;;1083               }
;;;1084               ptmr = ptmr_next;
0005de  4634              MOV      r4,r6
                  |L1.1504|
0005e0  2c00              CMP      r4,#0                 ;1069
0005e2  d1e1              BNE      |L1.1448|
;;;1085           }
;;;1086           OSSchedUnlock();
0005e4  f7fffffe          BL       OSSchedUnlock
0005e8  e7c7              B        |L1.1402|
;;;1087       }
;;;1088   }
;;;1089   #endif
                          ENDP

                  OSTmr_InitTask PROC
;;;886    #if OS_TMR_EN > 0u
;;;887    static  void  OSTmr_InitTask (void)
0005ea  b500              PUSH     {lr}
;;;888    {
0005ec  b087              SUB      sp,sp,#0x1c
;;;889    #if OS_TASK_NAME_EN > 0u
;;;890        INT8U  err;
;;;891    #endif
;;;892    
;;;893    
;;;894    #if OS_TASK_CREATE_EXT_EN > 0u
;;;895        #if OS_STK_GROWTH == 1u
;;;896        (void)OSTaskCreateExt(OSTmr_Task,
0005ee  2003              MOVS     r0,#3
0005f0  2100              MOVS     r1,#0
0005f2  2280              MOVS     r2,#0x80
0005f4  4b3d              LDR      r3,|L1.1772|
0005f6  e9cd3201          STRD     r3,r2,[sp,#4]
0005fa  e9cd1003          STRD     r1,r0,[sp,#0xc]
0005fe  f64f70fd          MOV      r0,#0xfffd
000602  233d              MOVS     r3,#0x3d
000604  4a3a              LDR      r2,|L1.1776|
000606  9000              STR      r0,[sp,#0]
000608  483a              LDR      r0,|L1.1780|
00060a  f7fffffe          BL       OSTaskCreateExt
;;;897                              (void *)0,                                       /* No arguments passed to OSTmrTask()      */
;;;898                              &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Top-Of-Stack                        */
;;;899                              OS_TASK_TMR_PRIO,
;;;900                              OS_TASK_TMR_ID,
;;;901                              &OSTmrTaskStk[0],                                /* Set Bottom-Of-Stack                     */
;;;902                              OS_TASK_TMR_STK_SIZE,
;;;903                              (void *)0,                                       /* No TCB extension                        */
;;;904                              OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
;;;905        #else
;;;906        (void)OSTaskCreateExt(OSTmr_Task,
;;;907                              (void *)0,                                       /* No arguments passed to OSTmrTask()      */
;;;908                              &OSTmrTaskStk[0],                                /* Set Top-Of-Stack                        */
;;;909                              OS_TASK_TMR_PRIO,
;;;910                              OS_TASK_TMR_ID,
;;;911                              &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Bottom-Of-Stack                     */
;;;912                              OS_TASK_TMR_STK_SIZE,
;;;913                              (void *)0,                                       /* No TCB extension                        */
;;;914                              OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
;;;915        #endif
;;;916    #else
;;;917        #if OS_STK_GROWTH == 1u
;;;918        (void)OSTaskCreate(OSTmr_Task,
;;;919                           (void *)0,
;;;920                           &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],
;;;921                           OS_TASK_TMR_PRIO);
;;;922        #else
;;;923        (void)OSTaskCreate(OSTmr_Task,
;;;924                           (void *)0,
;;;925                           &OSTmrTaskStk[0],
;;;926                           OS_TASK_TMR_PRIO);
;;;927        #endif
;;;928    #endif
;;;929    
;;;930    #if OS_TASK_NAME_EN > 0u
;;;931        OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)(void *)"uC/OS-II Tmr", &err);
00060e  aa06              ADD      r2,sp,#0x18
000610  a139              ADR      r1,|L1.1784|
000612  203d              MOVS     r0,#0x3d
000614  f7fffffe          BL       OSTaskNameSet
;;;932    #endif
;;;933    }
000618  b007              ADD      sp,sp,#0x1c
00061a  bd00              POP      {pc}
;;;934    #endif
                          ENDP

                  OSTmr_Init PROC
;;;825    #if OS_TMR_EN > 0u
;;;826    void  OSTmr_Init (void)
00061c  b5f8              PUSH     {r3-r7,lr}
;;;827    {
;;;828    #if OS_EVENT_NAME_EN > 0u
;;;829        INT8U    err;
;;;830    #endif
;;;831        INT16U   ix;
;;;832        INT16U   ix_next;
;;;833        OS_TMR  *ptmr1;
;;;834        OS_TMR  *ptmr2;
;;;835    
;;;836    
;;;837        OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
00061e  f44f7120          MOV      r1,#0x280
000622  4839              LDR      r0,|L1.1800|
000624  f7fffffe          BL       OS_MemClr
;;;838        OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
000628  2140              MOVS     r1,#0x40
00062a  482f              LDR      r0,|L1.1768|
00062c  f7fffffe          BL       OS_MemClr
;;;839    
;;;840        for (ix = 0u; ix < (OS_TMR_CFG_MAX - 1u); ix++) {                   /* Init. list of free TMRs                    */
000630  f04f0500          MOV      r5,#0
000634  e019              B        |L1.1642|
                  |L1.1590|
;;;841            ix_next = ix + 1u;
000636  f1050001          ADD      r0,r5,#1
00063a  b286              UXTH     r6,r0
;;;842            ptmr1 = &OSTmrTbl[ix];
00063c  eb050085          ADD      r0,r5,r5,LSL #2
000640  4931              LDR      r1,|L1.1800|
000642  eb0104c0          ADD      r4,r1,r0,LSL #3
;;;843            ptmr2 = &OSTmrTbl[ix_next];
000646  eb060086          ADD      r0,r6,r6,LSL #2
00064a  eb0107c0          ADD      r7,r1,r0,LSL #3
;;;844            ptmr1->OSTmrType    = OS_TMR_TYPE;
00064e  f04f0064          MOV      r0,#0x64
000652  7020              STRB     r0,[r4,#0]
;;;845            ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
000654  f04f0000          MOV      r0,#0
000658  f8840025          STRB     r0,[r4,#0x25]
;;;846            ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
00065c  60e7              STR      r7,[r4,#0xc]
;;;847    #if OS_TMR_CFG_NAME_EN > 0u
;;;848            ptmr1->OSTmrName    = (INT8U *)(void *)"?";
00065e  f2af2070          ADR      r0,|L1.1008|
000662  6220              STR      r0,[r4,#0x20]
000664  f1050001          ADD      r0,r5,#1              ;840
000668  b285              UXTH     r5,r0                 ;840
                  |L1.1642|
00066a  2d0f              CMP      r5,#0xf               ;840
00066c  d3e3              BCC      |L1.1590|
;;;849    #endif
;;;850        }
;;;851        ptmr1               = &OSTmrTbl[ix];
00066e  eb050085          ADD      r0,r5,r5,LSL #2
000672  4925              LDR      r1,|L1.1800|
000674  eb0104c0          ADD      r4,r1,r0,LSL #3
;;;852        ptmr1->OSTmrType    = OS_TMR_TYPE;
000678  f04f0064          MOV      r0,#0x64
00067c  7020              STRB     r0,[r4,#0]
;;;853        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
00067e  f04f0000          MOV      r0,#0
000682  f8840025          STRB     r0,[r4,#0x25]
;;;854        ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
000686  60e0              STR      r0,[r4,#0xc]
;;;855    #if OS_TMR_CFG_NAME_EN > 0u
;;;856        ptmr1->OSTmrName    = (INT8U *)(void *)"?";
000688  f2af209c          ADR      r0,|L1.1008|
00068c  6220              STR      r0,[r4,#0x20]
;;;857    #endif
;;;858        OSTmrTime           = 0u;
00068e  f04f0000          MOV      r0,#0
000692  4914              LDR      r1,|L1.1764|
000694  6008              STR      r0,[r1,#0]  ; OSTmrTime
;;;859        OSTmrUsed           = 0u;
000696  491d              LDR      r1,|L1.1804|
000698  8008              STRH     r0,[r1,#0]
;;;860        OSTmrFree           = OS_TMR_CFG_MAX;
00069a  f04f0010          MOV      r0,#0x10
00069e  491c              LDR      r1,|L1.1808|
0006a0  8008              STRH     r0,[r1,#0]
;;;861        OSTmrFreeList       = &OSTmrTbl[0];
0006a2  4819              LDR      r0,|L1.1800|
0006a4  491b              LDR      r1,|L1.1812|
0006a6  6008              STR      r0,[r1,#0]  ; OSTmrFreeList
;;;862        OSTmrSem            = OSSemCreate(1u);
0006a8  f04f0001          MOV      r0,#1
0006ac  f7fffffe          BL       OSSemCreate
0006b0  4919              LDR      r1,|L1.1816|
0006b2  6008              STR      r0,[r1,#0]  ; OSTmrSem
;;;863        OSTmrSemSignal      = OSSemCreate(0u);
0006b4  2000              MOVS     r0,#0
0006b6  f7fffffe          BL       OSSemCreate
0006ba  4909              LDR      r1,|L1.1760|
0006bc  6008              STR      r0,[r1,#0]  ; OSTmrSemSignal
;;;864    
;;;865    #if OS_EVENT_NAME_EN > 0u                                               /* Assign names to semaphores                 */
;;;866        OSEventNameSet(OSTmrSem,       (INT8U *)(void *)"uC/OS-II TmrLock",   &err);
0006be  466a              MOV      r2,sp
0006c0  a116              ADR      r1,|L1.1820|
0006c2  4815              LDR      r0,|L1.1816|
0006c4  6800              LDR      r0,[r0,#0]  ; OSTmrSem
0006c6  f7fffffe          BL       OSEventNameSet
;;;867        OSEventNameSet(OSTmrSemSignal, (INT8U *)(void *)"uC/OS-II TmrSignal", &err);
0006ca  466a              MOV      r2,sp
0006cc  a118              ADR      r1,|L1.1840|
0006ce  4804              LDR      r0,|L1.1760|
0006d0  6800              LDR      r0,[r0,#0]  ; OSTmrSemSignal
0006d2  f7fffffe          BL       OSEventNameSet
;;;868    #endif
;;;869    
;;;870        OSTmr_InitTask();
0006d6  f7fffffe          BL       OSTmr_InitTask
;;;871    }
0006da  bdf8              POP      {r3-r7,pc}
;;;872    #endif
                          ENDP

                  |L1.1756|
                          DCD      OSIntNesting
                  |L1.1760|
                          DCD      OSTmrSemSignal
                  |L1.1764|
                          DCD      OSTmrTime
                  |L1.1768|
                          DCD      OSTmrWheelTbl
                  |L1.1772|
                          DCD      OSTmrTaskStk
                  |L1.1776|
                          DCD      OSTmrTaskStk+0x1fc
                  |L1.1780|
                          DCD      OSTmr_Task
                  |L1.1784|
0006f8  75432f4f          DCB      "uC/OS-II Tmr",0
0006fc  532d4949
000700  20546d72
000704  00      
000705  00                DCB      0
000706  00                DCB      0
000707  00                DCB      0
                  |L1.1800|
                          DCD      OSTmrTbl
                  |L1.1804|
                          DCD      OSTmrUsed
                  |L1.1808|
                          DCD      OSTmrFree
                  |L1.1812|
                          DCD      OSTmrFreeList
                  |L1.1816|
                          DCD      OSTmrSem
                  |L1.1820|
00071c  75432f4f          DCB      "uC/OS-II TmrLock",0
000720  532d4949
000724  20546d72
000728  4c6f636b
00072c  00      
00072d  00                DCB      0
00072e  00                DCB      0
00072f  00                DCB      0
                  |L1.1840|
000730  75432f4f          DCB      "uC/OS-II TmrSignal",0
000734  532d4949
000738  20546d72
00073c  5369676e
000740  616c00  
000743  00                DCB      0
