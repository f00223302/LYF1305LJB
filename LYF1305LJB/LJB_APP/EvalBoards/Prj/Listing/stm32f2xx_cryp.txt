; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Output\stm32f2xx_cryp.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\Output\stm32f2xx_cryp.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\BSP -I..\BSP\UCOS-II -I..\BSP\STM32F2xx\inc -I..\BSP\CMSIS -I..\BSP\CMSIS\Device_Support -I..\BSP\UCOS-II -I..\..\uC-CPU -I..\..\uC-CPU\ARM-Cortex-M3 -I..\..\uC-LIB -I..\..\uC-LIB\Ports\ARM-Cortex-M3 -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3 -I..\App -I..\Prj -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DDEBUG -DLJB_CPU_MAIN -DUSE_CPU_F205RC --omf_browse=.\Output\stm32f2xx_cryp.crf ..\BSP\STM32F2xx\src\stm32f2xx_cryp.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  CRYP_DeInit PROC
;;;214      */
;;;215    void CRYP_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;216    {
;;;217      /* Enable CRYP reset state */
;;;218      RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, ENABLE);
000002  2101              MOVS     r1,#1
000004  2010              MOVS     r0,#0x10
000006  f7fffffe          BL       RCC_AHB2PeriphResetCmd
;;;219    
;;;220      /* Release CRYP from reset state */
;;;221      RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  2010              MOVS     r0,#0x10
00000e  f7fffffe          BL       RCC_AHB2PeriphResetCmd
;;;222    }
000012  bd10              POP      {r4,pc}
;;;223    
                          ENDP

                  CRYP_Init PROC
;;;230      */
;;;231    void CRYP_Init(CRYP_InitTypeDef* CRYP_InitStruct)
000014  49a8              LDR      r1,|L1.696|
;;;232    {
;;;233      /* Check the parameters */
;;;234      assert_param(IS_CRYP_ALGOMODE(CRYP_InitStruct->CRYP_AlgoMode));
;;;235      assert_param(IS_CRYP_DATATYPE(CRYP_InitStruct->CRYP_DataType));
;;;236      assert_param(IS_CRYP_ALGODIR(CRYP_InitStruct->CRYP_AlgoDir));
;;;237    
;;;238      /* Select Algorithm mode*/  
;;;239      CRYP->CR &= ~CRYP_CR_ALGOMODE;
000016  6809              LDR      r1,[r1,#0]
000018  f0210138          BIC      r1,r1,#0x38
00001c  4aa6              LDR      r2,|L1.696|
00001e  6011              STR      r1,[r2,#0]
;;;240      CRYP->CR |= CRYP_InitStruct->CRYP_AlgoMode;
000020  4611              MOV      r1,r2
000022  6809              LDR      r1,[r1,#0]
000024  8842              LDRH     r2,[r0,#2]
000026  ea410102          ORR      r1,r1,r2
00002a  4aa3              LDR      r2,|L1.696|
00002c  6011              STR      r1,[r2,#0]
;;;241    
;;;242      /* Select dataType */ 
;;;243      CRYP->CR &= ~CRYP_CR_DATATYPE;
00002e  4611              MOV      r1,r2
000030  6809              LDR      r1,[r1,#0]
000032  f02101c0          BIC      r1,r1,#0xc0
000036  6011              STR      r1,[r2,#0]
;;;244      CRYP->CR |= CRYP_InitStruct->CRYP_DataType;
000038  4611              MOV      r1,r2
00003a  6809              LDR      r1,[r1,#0]
00003c  8882              LDRH     r2,[r0,#4]
00003e  ea410102          ORR      r1,r1,r2
000042  4a9d              LDR      r2,|L1.696|
000044  6011              STR      r1,[r2,#0]
;;;245    
;;;246      /* select Key size (used only with AES algorithm) */
;;;247      if ((CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_ECB) ||
000046  8841              LDRH     r1,[r0,#2]
000048  2920              CMP      r1,#0x20
00004a  d008              BEQ      |L1.94|
;;;248          (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_CBC) ||
00004c  8841              LDRH     r1,[r0,#2]
00004e  2928              CMP      r1,#0x28
000050  d005              BEQ      |L1.94|
;;;249          (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_CTR) ||
000052  8841              LDRH     r1,[r0,#2]
000054  2930              CMP      r1,#0x30
000056  d002              BEQ      |L1.94|
;;;250          (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_Key))
000058  8841              LDRH     r1,[r0,#2]
00005a  2938              CMP      r1,#0x38
00005c  d10c              BNE      |L1.120|
                  |L1.94|
;;;251      {
;;;252        assert_param(IS_CRYP_KEYSIZE(CRYP_InitStruct->CRYP_KeySize));
;;;253        CRYP->CR &= ~CRYP_CR_KEYSIZE;
00005e  4996              LDR      r1,|L1.696|
000060  6809              LDR      r1,[r1,#0]
000062  f4217140          BIC      r1,r1,#0x300
000066  4a94              LDR      r2,|L1.696|
000068  6011              STR      r1,[r2,#0]
;;;254        CRYP->CR |= CRYP_InitStruct->CRYP_KeySize; /* Key size and value must be 
00006a  4611              MOV      r1,r2
00006c  6809              LDR      r1,[r1,#0]
00006e  88c2              LDRH     r2,[r0,#6]
000070  ea410102          ORR      r1,r1,r2
000074  4a90              LDR      r2,|L1.696|
000076  6011              STR      r1,[r2,#0]
                  |L1.120|
;;;255                                                      configured once the key has 
;;;256                                                      been prepared */
;;;257      }
;;;258    
;;;259      /* Select data Direction */ 
;;;260      CRYP->CR &= ~CRYP_CR_ALGODIR;
000078  498f              LDR      r1,|L1.696|
00007a  6809              LDR      r1,[r1,#0]
00007c  f0210104          BIC      r1,r1,#4
000080  4a8d              LDR      r2,|L1.696|
000082  6011              STR      r1,[r2,#0]
;;;261      CRYP->CR |= CRYP_InitStruct->CRYP_AlgoDir;
000084  4611              MOV      r1,r2
000086  6809              LDR      r1,[r1,#0]
000088  8802              LDRH     r2,[r0,#0]
00008a  ea410102          ORR      r1,r1,r2
00008e  4a8a              LDR      r2,|L1.696|
000090  6011              STR      r1,[r2,#0]
;;;262    }
000092  4770              BX       lr
;;;263    
                          ENDP

                  CRYP_StructInit PROC
;;;269      */
;;;270    void CRYP_StructInit(CRYP_InitTypeDef* CRYP_InitStruct)
000094  f04f0100          MOV      r1,#0
;;;271    {
;;;272      /* Initialize the CRYP_AlgoDir member */
;;;273      CRYP_InitStruct->CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
000098  8001              STRH     r1,[r0,#0]
;;;274    
;;;275      /* initialize the CRYP_AlgoMode member */
;;;276      CRYP_InitStruct->CRYP_AlgoMode = CRYP_AlgoMode_TDES_ECB;
00009a  8041              STRH     r1,[r0,#2]
;;;277    
;;;278      /* initialize the CRYP_DataType member */
;;;279      CRYP_InitStruct->CRYP_DataType = CRYP_DataType_32b;
00009c  8081              STRH     r1,[r0,#4]
;;;280      
;;;281      /* Initialize the CRYP_KeySize member */
;;;282      CRYP_InitStruct->CRYP_KeySize = CRYP_KeySize_128b;
00009e  80c1              STRH     r1,[r0,#6]
;;;283    }
0000a0  4770              BX       lr
;;;284    
                          ENDP

                  CRYP_KeyInit PROC
;;;291      */
;;;292    void CRYP_KeyInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
0000a2  4a85              LDR      r2,|L1.696|
;;;293    {
;;;294      /* Key Initialisation */
;;;295      CRYP->K0LR = CRYP_KeyInitStruct->CRYP_Key0Left;
0000a4  6801              LDR      r1,[r0,#0]
0000a6  6211              STR      r1,[r2,#0x20]
;;;296      CRYP->K0RR = CRYP_KeyInitStruct->CRYP_Key0Right;
0000a8  6841              LDR      r1,[r0,#4]
0000aa  6251              STR      r1,[r2,#0x24]
;;;297      CRYP->K1LR = CRYP_KeyInitStruct->CRYP_Key1Left;
0000ac  6881              LDR      r1,[r0,#8]
0000ae  6291              STR      r1,[r2,#0x28]
;;;298      CRYP->K1RR = CRYP_KeyInitStruct->CRYP_Key1Right;
0000b0  68c1              LDR      r1,[r0,#0xc]
0000b2  62d1              STR      r1,[r2,#0x2c]
;;;299      CRYP->K2LR = CRYP_KeyInitStruct->CRYP_Key2Left;
0000b4  6901              LDR      r1,[r0,#0x10]
0000b6  6311              STR      r1,[r2,#0x30]
;;;300      CRYP->K2RR = CRYP_KeyInitStruct->CRYP_Key2Right;
0000b8  6941              LDR      r1,[r0,#0x14]
0000ba  6351              STR      r1,[r2,#0x34]
;;;301      CRYP->K3LR = CRYP_KeyInitStruct->CRYP_Key3Left;
0000bc  6981              LDR      r1,[r0,#0x18]
0000be  6391              STR      r1,[r2,#0x38]
;;;302      CRYP->K3RR = CRYP_KeyInitStruct->CRYP_Key3Right;
0000c0  69c1              LDR      r1,[r0,#0x1c]
0000c2  63d1              STR      r1,[r2,#0x3c]
;;;303    }
0000c4  4770              BX       lr
;;;304    
                          ENDP

                  CRYP_KeyStructInit PROC
;;;310      */
;;;311    void CRYP_KeyStructInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
0000c6  f04f0100          MOV      r1,#0
;;;312    {
;;;313      CRYP_KeyInitStruct->CRYP_Key0Left  = 0;
0000ca  6001              STR      r1,[r0,#0]
;;;314      CRYP_KeyInitStruct->CRYP_Key0Right = 0;
0000cc  6041              STR      r1,[r0,#4]
;;;315      CRYP_KeyInitStruct->CRYP_Key1Left  = 0;
0000ce  6081              STR      r1,[r0,#8]
;;;316      CRYP_KeyInitStruct->CRYP_Key1Right = 0;
0000d0  60c1              STR      r1,[r0,#0xc]
;;;317      CRYP_KeyInitStruct->CRYP_Key2Left  = 0;
0000d2  6101              STR      r1,[r0,#0x10]
;;;318      CRYP_KeyInitStruct->CRYP_Key2Right = 0;
0000d4  6141              STR      r1,[r0,#0x14]
;;;319      CRYP_KeyInitStruct->CRYP_Key3Left  = 0;
0000d6  6181              STR      r1,[r0,#0x18]
;;;320      CRYP_KeyInitStruct->CRYP_Key3Right = 0;
0000d8  61c1              STR      r1,[r0,#0x1c]
;;;321    }
0000da  4770              BX       lr
;;;322    /**
                          ENDP

                  CRYP_IVInit PROC
;;;328      */
;;;329    void CRYP_IVInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)
0000dc  4a76              LDR      r2,|L1.696|
;;;330    {
;;;331      CRYP->IV0LR = CRYP_IVInitStruct->CRYP_IV0Left;
0000de  6801              LDR      r1,[r0,#0]
0000e0  6411              STR      r1,[r2,#0x40]
;;;332      CRYP->IV0RR = CRYP_IVInitStruct->CRYP_IV0Right;
0000e2  6841              LDR      r1,[r0,#4]
0000e4  6451              STR      r1,[r2,#0x44]
;;;333      CRYP->IV1LR = CRYP_IVInitStruct->CRYP_IV1Left;
0000e6  6881              LDR      r1,[r0,#8]
0000e8  6491              STR      r1,[r2,#0x48]
;;;334      CRYP->IV1RR = CRYP_IVInitStruct->CRYP_IV1Right;
0000ea  68c1              LDR      r1,[r0,#0xc]
0000ec  64d1              STR      r1,[r2,#0x4c]
;;;335    }
0000ee  4770              BX       lr
;;;336    
                          ENDP

                  CRYP_IVStructInit PROC
;;;342      */
;;;343    void CRYP_IVStructInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)
0000f0  f04f0100          MOV      r1,#0
;;;344    {
;;;345      CRYP_IVInitStruct->CRYP_IV0Left  = 0;
0000f4  6001              STR      r1,[r0,#0]
;;;346      CRYP_IVInitStruct->CRYP_IV0Right = 0;
0000f6  6041              STR      r1,[r0,#4]
;;;347      CRYP_IVInitStruct->CRYP_IV1Left  = 0;
0000f8  6081              STR      r1,[r0,#8]
;;;348      CRYP_IVInitStruct->CRYP_IV1Right = 0;
0000fa  60c1              STR      r1,[r0,#0xc]
;;;349    }
0000fc  4770              BX       lr
;;;350    
                          ENDP

                  CRYP_FIFOFlush PROC
;;;357      */
;;;358    void CRYP_FIFOFlush(void)
0000fe  486e              LDR      r0,|L1.696|
;;;359    {
;;;360      /* Reset the read and write pointers of the FIFOs */
;;;361      CRYP->CR |= CRYP_CR_FFLUSH;
000100  6800              LDR      r0,[r0,#0]
000102  f4404080          ORR      r0,r0,#0x4000
000106  496c              LDR      r1,|L1.696|
000108  6008              STR      r0,[r1,#0]
;;;362    }
00010a  4770              BX       lr
;;;363    
                          ENDP

                  CRYP_Cmd PROC
;;;369      */
;;;370    void CRYP_Cmd(FunctionalState NewState)
00010c  b130              CBZ      r0,|L1.284|
;;;371    {
;;;372      /* Check the parameters */
;;;373      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;374    
;;;375      if (NewState != DISABLE)
;;;376      {
;;;377        /* Enable the Cryptographic processor */
;;;378        CRYP->CR |= CRYP_CR_CRYPEN;
00010e  496a              LDR      r1,|L1.696|
000110  6809              LDR      r1,[r1,#0]
000112  f4414100          ORR      r1,r1,#0x8000
000116  4a68              LDR      r2,|L1.696|
000118  6011              STR      r1,[r2,#0]
00011a  e005              B        |L1.296|
                  |L1.284|
;;;379      }
;;;380      else
;;;381      {
;;;382        /* Disable the Cryptographic processor */
;;;383        CRYP->CR &= ~CRYP_CR_CRYPEN;
00011c  4966              LDR      r1,|L1.696|
00011e  6809              LDR      r1,[r1,#0]
000120  f4214100          BIC      r1,r1,#0x8000
000124  4a64              LDR      r2,|L1.696|
000126  6011              STR      r1,[r2,#0]
                  |L1.296|
;;;384      }
;;;385    }
000128  4770              BX       lr
;;;386    /**
                          ENDP

                  CRYP_DataIn PROC
;;;412      */
;;;413    void CRYP_DataIn(uint32_t Data)
00012a  4963              LDR      r1,|L1.696|
;;;414    {
;;;415      CRYP->DR = Data;
00012c  6088              STR      r0,[r1,#8]
;;;416    }
00012e  4770              BX       lr
;;;417    
                          ENDP

                  CRYP_DataOut PROC
;;;422      */
;;;423    uint32_t CRYP_DataOut(void)
000130  4861              LDR      r0,|L1.696|
;;;424    {
;;;425      return CRYP->DOUT;
000132  68c0              LDR      r0,[r0,#0xc]
;;;426    }
000134  4770              BX       lr
;;;427    /**
                          ENDP

                  CRYP_SaveContext PROC
;;;465      */
;;;466    ErrorStatus CRYP_SaveContext(CRYP_Context* CRYP_ContextSave,
000136  b5f0              PUSH     {r4-r7,lr}
;;;467                                 CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
;;;468    {
000138  4602              MOV      r2,r0
;;;469      __IO uint32_t timeout = 0;
00013a  f04f0300          MOV      r3,#0
;;;470      uint32_t ckeckmask = 0, bitstatus;    
00013e  461c              MOV      r4,r3
;;;471      ErrorStatus status = ERROR;
000140  4618              MOV      r0,r3
;;;472    
;;;473      /* Stop DMA transfers on the IN FIFO by clearing the DIEN bit in the CRYP_DMACR */
;;;474      CRYP->DMACR &= ~(uint32_t)CRYP_DMACR_DIEN;
000142  4e5d              LDR      r6,|L1.696|
000144  6936              LDR      r6,[r6,#0x10]
000146  f0260601          BIC      r6,r6,#1
00014a  4f5b              LDR      r7,|L1.696|
00014c  613e              STR      r6,[r7,#0x10]
;;;475        
;;;476      /* Wait until both the IN and OUT FIFOs are empty  
;;;477        (IFEM=1 and OFNE=0 in the CRYP_SR register) and the 
;;;478         BUSY bit is cleared. */
;;;479    
;;;480      if ((CRYP->CR & (uint32_t)(CRYP_CR_ALGOMODE_TDES_ECB | CRYP_CR_ALGOMODE_TDES_CBC)) != (uint32_t)0 )/* TDES */
00014e  463e              MOV      r6,r7
000150  6836              LDR      r6,[r6,#0]
000152  f0160f08          TST      r6,#8
000156  d002              BEQ      |L1.350|
;;;481      { 
;;;482        ckeckmask =  CRYP_SR_IFEM | CRYP_SR_BUSY ;
000158  f04f0411          MOV      r4,#0x11
00015c  e001              B        |L1.354|
                  |L1.350|
;;;483      }
;;;484      else /* AES or DES */
;;;485      {
;;;486        ckeckmask =  CRYP_SR_IFEM | CRYP_SR_BUSY | CRYP_SR_OFNE;
00015e  f04f0415          MOV      r4,#0x15
                  |L1.354|
;;;487      }           
;;;488       
;;;489      do 
000162  bf00              NOP      
                  |L1.356|
;;;490      {
;;;491        bitstatus = CRYP->SR & ckeckmask;
000164  4e54              LDR      r6,|L1.696|
000166  6876              LDR      r6,[r6,#4]
000168  ea060504          AND      r5,r6,r4
;;;492        timeout++;
00016c  f1030301          ADD      r3,r3,#1
;;;493      }
;;;494      while ((timeout != MAX_TIMEOUT) && (bitstatus != CRYP_SR_IFEM));
000170  f5a3467f          SUB      r6,r3,#0xff00
000174  3eff              SUBS     r6,r6,#0xff
000176  d001              BEQ      |L1.380|
000178  2d01              CMP      r5,#1
00017a  d1f3              BNE      |L1.356|
                  |L1.380|
;;;495         
;;;496      if ((CRYP->SR & ckeckmask) != CRYP_SR_IFEM)
00017c  4e4e              LDR      r6,|L1.696|
00017e  6876              LDR      r6,[r6,#4]
000180  4026              ANDS     r6,r6,r4
000182  2e01              CMP      r6,#1
000184  d002              BEQ      |L1.396|
;;;497      {
;;;498        status = ERROR;
000186  f04f0000          MOV      r0,#0
00018a  e02d              B        |L1.488|
                  |L1.396|
;;;499      }
;;;500      else
;;;501      {      
;;;502        /* Stop DMA transfers on the OUT FIFO by 
;;;503           - writing the DOEN bit to 0 in the CRYP_DMACR register 
;;;504           - and clear the CRYPEN bit. */
;;;505    
;;;506        CRYP->DMACR &= ~(uint32_t)CRYP_DMACR_DOEN;
00018c  4e4a              LDR      r6,|L1.696|
00018e  6936              LDR      r6,[r6,#0x10]
000190  f0260602          BIC      r6,r6,#2
000194  4f48              LDR      r7,|L1.696|
000196  613e              STR      r6,[r7,#0x10]
;;;507        CRYP->CR &= ~(uint32_t)CRYP_CR_CRYPEN;
000198  463e              MOV      r6,r7
00019a  6836              LDR      r6,[r6,#0]
00019c  f4264600          BIC      r6,r6,#0x8000
0001a0  603e              STR      r6,[r7,#0]
;;;508    
;;;509        /* Save the current configuration (bits [9:2] in the CRYP_CR register) */
;;;510        CRYP_ContextSave->CR_bits9to2  = CRYP->CR & (CRYP_CR_KEYSIZE  | 
0001a2  463e              MOV      r6,r7
0001a4  6836              LDR      r6,[r6,#0]
0001a6  f406767f          AND      r6,r6,#0x3fc
0001aa  6016              STR      r6,[r2,#0]
;;;511                                                     CRYP_CR_DATATYPE | 
;;;512                                                     CRYP_CR_ALGOMODE |
;;;513                                                     CRYP_CR_ALGODIR); 
;;;514    
;;;515        /* and, if not in ECB mode, the initialization vectors. */
;;;516        CRYP_ContextSave->CRYP_IV0LR = CRYP->IV0LR;
0001ac  463e              MOV      r6,r7
0001ae  6c36              LDR      r6,[r6,#0x40]
0001b0  6056              STR      r6,[r2,#4]
;;;517        CRYP_ContextSave->CRYP_IV0RR = CRYP->IV0RR;
0001b2  463e              MOV      r6,r7
0001b4  6c76              LDR      r6,[r6,#0x44]
0001b6  6096              STR      r6,[r2,#8]
;;;518        CRYP_ContextSave->CRYP_IV1LR = CRYP->IV1LR;
0001b8  463e              MOV      r6,r7
0001ba  6cb6              LDR      r6,[r6,#0x48]
0001bc  60d6              STR      r6,[r2,#0xc]
;;;519        CRYP_ContextSave->CRYP_IV1RR = CRYP->IV1RR;
0001be  463e              MOV      r6,r7
0001c0  6cf6              LDR      r6,[r6,#0x4c]
0001c2  6116              STR      r6,[r2,#0x10]
;;;520    
;;;521        /* save The key value */
;;;522        CRYP_ContextSave->CRYP_K0LR = CRYP_KeyInitStruct->CRYP_Key0Left; 
0001c4  680e              LDR      r6,[r1,#0]
0001c6  6156              STR      r6,[r2,#0x14]
;;;523        CRYP_ContextSave->CRYP_K0RR = CRYP_KeyInitStruct->CRYP_Key0Right; 
0001c8  684e              LDR      r6,[r1,#4]
0001ca  6196              STR      r6,[r2,#0x18]
;;;524        CRYP_ContextSave->CRYP_K1LR = CRYP_KeyInitStruct->CRYP_Key1Left; 
0001cc  688e              LDR      r6,[r1,#8]
0001ce  61d6              STR      r6,[r2,#0x1c]
;;;525        CRYP_ContextSave->CRYP_K1RR = CRYP_KeyInitStruct->CRYP_Key1Right; 
0001d0  68ce              LDR      r6,[r1,#0xc]
0001d2  6216              STR      r6,[r2,#0x20]
;;;526        CRYP_ContextSave->CRYP_K2LR = CRYP_KeyInitStruct->CRYP_Key2Left; 
0001d4  690e              LDR      r6,[r1,#0x10]
0001d6  6256              STR      r6,[r2,#0x24]
;;;527        CRYP_ContextSave->CRYP_K2RR = CRYP_KeyInitStruct->CRYP_Key2Right; 
0001d8  694e              LDR      r6,[r1,#0x14]
0001da  6296              STR      r6,[r2,#0x28]
;;;528        CRYP_ContextSave->CRYP_K3LR = CRYP_KeyInitStruct->CRYP_Key3Left; 
0001dc  698e              LDR      r6,[r1,#0x18]
0001de  62d6              STR      r6,[r2,#0x2c]
;;;529        CRYP_ContextSave->CRYP_K3RR = CRYP_KeyInitStruct->CRYP_Key3Right; 
0001e0  69ce              LDR      r6,[r1,#0x1c]
0001e2  6316              STR      r6,[r2,#0x30]
;;;530    
;;;531       /* When needed, save the DMA status (pointers for IN and OUT messages, 
;;;532          number of remaining bytes, etc.) */
;;;533         
;;;534        status = SUCCESS;
0001e4  f04f0001          MOV      r0,#1
                  |L1.488|
;;;535      }
;;;536    
;;;537       return status;
;;;538    }
0001e8  bdf0              POP      {r4-r7,pc}
;;;539    
                          ENDP

                  CRYP_RestoreContext PROC
;;;550      */
;;;551    void CRYP_RestoreContext(CRYP_Context* CRYP_ContextRestore)  
0001ea  4a33              LDR      r2,|L1.696|
;;;552    {
;;;553    
;;;554      /* Configure the processor with the saved configuration */
;;;555      CRYP->CR = CRYP_ContextRestore->CR_bits9to2;
0001ec  6801              LDR      r1,[r0,#0]
0001ee  6011              STR      r1,[r2,#0]
;;;556    
;;;557      /* restore The key value */
;;;558      CRYP->K0LR = CRYP_ContextRestore->CRYP_K0LR; 
0001f0  6941              LDR      r1,[r0,#0x14]
0001f2  6211              STR      r1,[r2,#0x20]
;;;559      CRYP->K0RR = CRYP_ContextRestore->CRYP_K0RR;
0001f4  6981              LDR      r1,[r0,#0x18]
0001f6  6251              STR      r1,[r2,#0x24]
;;;560      CRYP->K1LR = CRYP_ContextRestore->CRYP_K1LR;
0001f8  69c1              LDR      r1,[r0,#0x1c]
0001fa  6291              STR      r1,[r2,#0x28]
;;;561      CRYP->K1RR = CRYP_ContextRestore->CRYP_K1RR;
0001fc  6a01              LDR      r1,[r0,#0x20]
0001fe  62d1              STR      r1,[r2,#0x2c]
;;;562      CRYP->K2LR = CRYP_ContextRestore->CRYP_K2LR;
000200  6a41              LDR      r1,[r0,#0x24]
000202  6311              STR      r1,[r2,#0x30]
;;;563      CRYP->K2RR = CRYP_ContextRestore->CRYP_K2RR;
000204  6a81              LDR      r1,[r0,#0x28]
000206  6351              STR      r1,[r2,#0x34]
;;;564      CRYP->K3LR = CRYP_ContextRestore->CRYP_K3LR;
000208  6ac1              LDR      r1,[r0,#0x2c]
00020a  6391              STR      r1,[r2,#0x38]
;;;565      CRYP->K3RR = CRYP_ContextRestore->CRYP_K3RR;
00020c  6b01              LDR      r1,[r0,#0x30]
00020e  63d1              STR      r1,[r2,#0x3c]
;;;566    
;;;567      /* and the initialization vectors. */
;;;568      CRYP->IV0LR = CRYP_ContextRestore->CRYP_IV0LR;
000210  6841              LDR      r1,[r0,#4]
000212  6411              STR      r1,[r2,#0x40]
;;;569      CRYP->IV0RR = CRYP_ContextRestore->CRYP_IV0RR;
000214  6881              LDR      r1,[r0,#8]
000216  6451              STR      r1,[r2,#0x44]
;;;570      CRYP->IV1LR = CRYP_ContextRestore->CRYP_IV1LR;
000218  68c1              LDR      r1,[r0,#0xc]
00021a  6491              STR      r1,[r2,#0x48]
;;;571      CRYP->IV1RR = CRYP_ContextRestore->CRYP_IV1RR;
00021c  6901              LDR      r1,[r0,#0x10]
00021e  64d1              STR      r1,[r2,#0x4c]
;;;572    
;;;573      /* Enable the cryptographic processor */
;;;574      CRYP->CR |= CRYP_CR_CRYPEN;
000220  4611              MOV      r1,r2
000222  6809              LDR      r1,[r1,#0]
000224  f4414100          ORR      r1,r1,#0x8000
000228  6011              STR      r1,[r2,#0]
;;;575    }
00022a  4770              BX       lr
;;;576    /**
                          ENDP

                  CRYP_DMACmd PROC
;;;611      */
;;;612    void CRYP_DMACmd(uint8_t CRYP_DMAReq, FunctionalState NewState)
00022c  b131              CBZ      r1,|L1.572|
;;;613    {
;;;614      /* Check the parameters */
;;;615      assert_param(IS_CRYP_DMAREQ(CRYP_DMAReq));
;;;616      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;617    
;;;618      if (NewState != DISABLE)
;;;619      {
;;;620        /* Enable the selected CRYP DMA request */
;;;621        CRYP->DMACR |= CRYP_DMAReq;
00022e  4a22              LDR      r2,|L1.696|
000230  6912              LDR      r2,[r2,#0x10]
000232  ea420200          ORR      r2,r2,r0
000236  4b20              LDR      r3,|L1.696|
000238  611a              STR      r2,[r3,#0x10]
00023a  e008              B        |L1.590|
                  |L1.572|
;;;622      }
;;;623      else
;;;624      {
;;;625        /* Disable the selected CRYP DMA request */
;;;626        CRYP->DMACR &= (uint8_t)~CRYP_DMAReq;
00023c  4a1e              LDR      r2,|L1.696|
00023e  6912              LDR      r2,[r2,#0x10]
000240  ea6f0300          MVN      r3,r0
000244  b2db              UXTB     r3,r3
000246  ea020203          AND      r2,r2,r3
00024a  4b1b              LDR      r3,|L1.696|
00024c  611a              STR      r2,[r3,#0x10]
                  |L1.590|
;;;627      }
;;;628    }
00024e  4770              BX       lr
;;;629    /**
                          ENDP

                  CRYP_ITConfig PROC
;;;736      */
;;;737    void CRYP_ITConfig(uint8_t CRYP_IT, FunctionalState NewState)
000250  b131              CBZ      r1,|L1.608|
;;;738    {
;;;739      /* Check the parameters */
;;;740      assert_param(IS_CRYP_CONFIG_IT(CRYP_IT));
;;;741      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;742    
;;;743      if (NewState != DISABLE)
;;;744      {
;;;745        /* Enable the selected CRYP interrupt */
;;;746        CRYP->IMSCR |= CRYP_IT;
000252  4a19              LDR      r2,|L1.696|
000254  6952              LDR      r2,[r2,#0x14]
000256  ea420200          ORR      r2,r2,r0
00025a  4b17              LDR      r3,|L1.696|
00025c  615a              STR      r2,[r3,#0x14]
00025e  e008              B        |L1.626|
                  |L1.608|
;;;747      }
;;;748      else
;;;749      {
;;;750        /* Disable the selected CRYP interrupt */
;;;751        CRYP->IMSCR &= (uint8_t)~CRYP_IT;
000260  4a15              LDR      r2,|L1.696|
000262  6952              LDR      r2,[r2,#0x14]
000264  ea6f0300          MVN      r3,r0
000268  b2db              UXTB     r3,r3
00026a  ea020203          AND      r2,r2,r3
00026e  4b12              LDR      r3,|L1.696|
000270  615a              STR      r2,[r3,#0x14]
                  |L1.626|
;;;752      }
;;;753    }
000272  4770              BX       lr
;;;754    
                          ENDP

                  CRYP_GetITStatus PROC
;;;764      */
;;;765    ITStatus CRYP_GetITStatus(uint8_t CRYP_IT)
000274  4601              MOV      r1,r0
;;;766    {
;;;767      ITStatus bitstatus = RESET;
000276  f04f0000          MOV      r0,#0
;;;768      /* Check the parameters */
;;;769      assert_param(IS_CRYP_GET_IT(CRYP_IT));
;;;770    
;;;771      /* Check the status of the specified CRYP interrupt */
;;;772      if ((CRYP->MISR &  CRYP_IT) != (uint8_t)RESET)
00027a  4a0f              LDR      r2,|L1.696|
00027c  69d2              LDR      r2,[r2,#0x1c]
00027e  420a              TST      r2,r1
000280  d002              BEQ      |L1.648|
;;;773      {
;;;774        /* CRYP_IT is set */
;;;775        bitstatus = SET;
000282  f04f0001          MOV      r0,#1
000286  e001              B        |L1.652|
                  |L1.648|
;;;776      }
;;;777      else
;;;778      {
;;;779        /* CRYP_IT is reset */
;;;780        bitstatus = RESET;
000288  f04f0000          MOV      r0,#0
                  |L1.652|
;;;781      }
;;;782      /* Return the CRYP_IT status */
;;;783      return bitstatus;
;;;784    }
00028c  4770              BX       lr
;;;785    
                          ENDP

                  CRYP_GetFlagStatus PROC
;;;798      */
;;;799    FlagStatus CRYP_GetFlagStatus(uint8_t CRYP_FLAG)
00028e  4601              MOV      r1,r0
;;;800    {
;;;801      FlagStatus bitstatus = RESET;
000290  f04f0000          MOV      r0,#0
;;;802      uint32_t tempreg = 0;
000294  4602              MOV      r2,r0
;;;803    
;;;804      /* Check the parameters */
;;;805      assert_param(IS_CRYP_GET_FLAG(CRYP_FLAG));
;;;806    
;;;807      /* check if the FLAG is in RISR register */
;;;808      if ((CRYP_FLAG & FLAG_MASK) != 0x00) 
000296  f0110f20          TST      r1,#0x20
00029a  d002              BEQ      |L1.674|
;;;809      {
;;;810        tempreg = CRYP->RISR;
00029c  4b06              LDR      r3,|L1.696|
00029e  699a              LDR      r2,[r3,#0x18]
0002a0  e001              B        |L1.678|
                  |L1.674|
;;;811      }
;;;812      else  /* The FLAG is in SR register */
;;;813      {
;;;814        tempreg = CRYP->SR;
0002a2  4b05              LDR      r3,|L1.696|
0002a4  685a              LDR      r2,[r3,#4]
                  |L1.678|
;;;815      }
;;;816    
;;;817    
;;;818      /* Check the status of the specified CRYP flag */
;;;819      if ((tempreg & CRYP_FLAG ) != (uint8_t)RESET)
0002a6  420a              TST      r2,r1
0002a8  d002              BEQ      |L1.688|
;;;820      {
;;;821        /* CRYP_FLAG is set */
;;;822        bitstatus = SET;
0002aa  f04f0001          MOV      r0,#1
0002ae  e001              B        |L1.692|
                  |L1.688|
;;;823      }
;;;824      else
;;;825      {
;;;826        /* CRYP_FLAG is reset */
;;;827        bitstatus = RESET;
0002b0  f04f0000          MOV      r0,#0
                  |L1.692|
;;;828      }
;;;829    
;;;830      /* Return the CRYP_FLAG status */
;;;831      return  bitstatus;
;;;832    }
0002b4  4770              BX       lr
;;;833    
                          ENDP

0002b6  0000              DCW      0x0000
                  |L1.696|
                          DCD      0x50060000

;*** Start embedded assembler ***

#line 1 "..\\BSP\\STM32F2xx\\src\\stm32f2xx_cryp.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_stm32f2xx_cryp_c_459f21d3____REV16|
#line 112 "..\\BSP\\CMSIS\\core_cmInstr.h"
|__asm___16_stm32f2xx_cryp_c_459f21d3____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_stm32f2xx_cryp_c_459f21d3____REVSH|
#line 130
|__asm___16_stm32f2xx_cryp_c_459f21d3____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
