; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Output\os_flag.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\Output\os_flag.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\BSP -I..\BSP\UCOS-II -I..\BSP\STM32F2xx\inc -I..\BSP\CMSIS -I..\BSP\CMSIS\Device_Support -I..\BSP\UCOS-II -I..\..\uC-CPU -I..\..\uC-CPU\ARM-Cortex-M3 -I..\..\uC-LIB -I..\..\uC-LIB\Ports\ARM-Cortex-M3 -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3 -I..\App -I..\Prj -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DDEBUG -DLJB_CPU_MAIN -DUSE_CPU_F205RC --omf_browse=.\Output\os_flag.crf ..\..\uCOS-II\Source\os_flag.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  OSFlagAccept PROC
;;;93     #if OS_FLAG_ACCEPT_EN > 0u
;;;94     OS_FLAGS  OSFlagAccept (OS_FLAG_GRP  *pgrp,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;95                             OS_FLAGS      flags,
;;;96                             INT8U         wait_type,
;;;97                             INT8U        *perr)
;;;98     {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4691              MOV      r9,r2
00000a  461e              MOV      r6,r3
;;;99         OS_FLAGS      flags_rdy;
;;;100        INT8U         result;
;;;101        BOOLEAN       consume;
;;;102    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;103        OS_CPU_SR     cpu_sr = 0u;
00000c  f04f0b00          MOV      r11,#0
;;;104    #endif
;;;105    
;;;106    
;;;107    
;;;108    #ifdef OS_SAFETY_CRITICAL
;;;109        if (perr == (INT8U *)0) {
;;;110            OS_SAFETY_CRITICAL_EXCEPTION();
;;;111            return ((OS_FLAGS)0);
;;;112        }
;;;113    #endif
;;;114    
;;;115    #if OS_ARG_CHK_EN > 0u
;;;116        if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
;;;117            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;118            return ((OS_FLAGS)0);
;;;119        }
;;;120    #endif
;;;121        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
000010  7820              LDRB     r0,[r4,#0]
000012  2805              CMP      r0,#5
000014  d006              BEQ      |L1.36|
;;;122            *perr = OS_ERR_EVENT_TYPE;
000016  f04f0001          MOV      r0,#1
00001a  7030              STRB     r0,[r6,#0]
;;;123            return ((OS_FLAGS)0);
00001c  f04f0000          MOV      r0,#0
                  |L1.32|
;;;124        }
;;;125        result = (INT8U)(wait_type & OS_FLAG_CONSUME);
;;;126        if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
;;;127            wait_type &= ~OS_FLAG_CONSUME;
;;;128            consume    = OS_TRUE;
;;;129        } else {
;;;130            consume    = OS_FALSE;
;;;131        }
;;;132    /*$PAGE*/
;;;133        *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
;;;134        OS_ENTER_CRITICAL();
;;;135        switch (wait_type) {
;;;136            case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
;;;137                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
;;;138                 if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;139                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;140                         pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we wanted  */
;;;141                     }
;;;142                 } else {
;;;143                     *perr = OS_ERR_FLAG_NOT_RDY;
;;;144                 }
;;;145                 OS_EXIT_CRITICAL();
;;;146                 break;
;;;147    
;;;148            case OS_FLAG_WAIT_SET_ANY:
;;;149                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
;;;150                 if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
;;;151                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;152                         pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we got     */
;;;153                     }
;;;154                 } else {
;;;155                     *perr = OS_ERR_FLAG_NOT_RDY;
;;;156                 }
;;;157                 OS_EXIT_CRITICAL();
;;;158                 break;
;;;159    
;;;160    #if OS_FLAG_WAIT_CLR_EN > 0u
;;;161            case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
;;;162                 flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
;;;163                 if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;164                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;165                         pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
;;;166                     }
;;;167                 } else {
;;;168                     *perr = OS_ERR_FLAG_NOT_RDY;
;;;169                 }
;;;170                 OS_EXIT_CRITICAL();
;;;171                 break;
;;;172    
;;;173            case OS_FLAG_WAIT_CLR_ANY:
;;;174                 flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
;;;175                 if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
;;;176                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;177                         pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
;;;178                     }
;;;179                 } else {
;;;180                     *perr = OS_ERR_FLAG_NOT_RDY;
;;;181                 }
;;;182                 OS_EXIT_CRITICAL();
;;;183                 break;
;;;184    #endif
;;;185    
;;;186            default:
;;;187                 OS_EXIT_CRITICAL();
;;;188                 flags_rdy = (OS_FLAGS)0;
;;;189                 *perr     = OS_ERR_FLAG_WAIT_TYPE;
;;;190                 break;
;;;191        }
;;;192        return (flags_rdy);
;;;193    }
000020  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.36|
000024  f0090a80          AND      r10,r9,#0x80          ;125
000028  f1ba0f00          CMP      r10,#0                ;126
00002c  d004              BEQ      |L1.56|
00002e  f0290980          BIC      r9,r9,#0x80           ;127
000032  f04f0801          MOV      r8,#1                 ;128
000036  e001              B        |L1.60|
                  |L1.56|
000038  f04f0800          MOV      r8,#0                 ;130
                  |L1.60|
00003c  f04f0000          MOV      r0,#0                 ;133
000040  7030              STRB     r0,[r6,#0]            ;133
000042  f7fffffe          BL       OS_CPU_SR_Save
000046  4683              MOV      r11,r0                ;134
000048  f1b90f00          CMP      r9,#0                 ;135
00004c  d036              BEQ      |L1.188|
00004e  f1b90f01          CMP      r9,#1                 ;135
000052  d04a              BEQ      |L1.234|
000054  f1b90f02          CMP      r9,#2                 ;135
000058  d003              BEQ      |L1.98|
00005a  f1b90f03          CMP      r9,#3                 ;135
00005e  d15a              BNE      |L1.278|
000060  e016              B        |L1.144|
                  |L1.98|
000062  8920              LDRH     r0,[r4,#8]            ;137
000064  ea000507          AND      r5,r0,r7              ;137
000068  42bd              CMP      r5,r7                 ;138
00006a  d10a              BNE      |L1.130|
00006c  f1b80f01          CMP      r8,#1                 ;139
000070  d10a              BNE      |L1.136|
000072  8920              LDRH     r0,[r4,#8]            ;140
000074  ea6f0105          MVN      r1,r5                 ;140
000078  b289              UXTH     r1,r1                 ;140
00007a  ea000001          AND      r0,r0,r1              ;140
00007e  8120              STRH     r0,[r4,#8]            ;140
000080  e002              B        |L1.136|
                  |L1.130|
000082  f04f0070          MOV      r0,#0x70              ;143
000086  7030              STRB     r0,[r6,#0]            ;143
                  |L1.136|
000088  4658              MOV      r0,r11                ;145
00008a  f7fffffe          BL       OS_CPU_SR_Restore
00008e  e04b              B        |L1.296|
                  |L1.144|
000090  8920              LDRH     r0,[r4,#8]            ;149
000092  ea000507          AND      r5,r0,r7              ;149
000096  b155              CBZ      r5,|L1.174|
000098  f1b80f01          CMP      r8,#1                 ;151
00009c  d10a              BNE      |L1.180|
00009e  8920              LDRH     r0,[r4,#8]            ;152
0000a0  ea6f0105          MVN      r1,r5                 ;152
0000a4  b289              UXTH     r1,r1                 ;152
0000a6  ea000001          AND      r0,r0,r1              ;152
0000aa  8120              STRH     r0,[r4,#8]            ;152
0000ac  e002              B        |L1.180|
                  |L1.174|
0000ae  f04f0070          MOV      r0,#0x70              ;155
0000b2  7030              STRB     r0,[r6,#0]            ;155
                  |L1.180|
0000b4  4658              MOV      r0,r11                ;157
0000b6  f7fffffe          BL       OS_CPU_SR_Restore
0000ba  e035              B        |L1.296|
                  |L1.188|
0000bc  8920              LDRH     r0,[r4,#8]            ;162
0000be  ea6f0000          MVN      r0,r0                 ;162
0000c2  b280              UXTH     r0,r0                 ;162
0000c4  ea000507          AND      r5,r0,r7              ;162
0000c8  42bd              CMP      r5,r7                 ;163
0000ca  d107              BNE      |L1.220|
0000cc  f1b80f01          CMP      r8,#1                 ;164
0000d0  d107              BNE      |L1.226|
0000d2  8920              LDRH     r0,[r4,#8]            ;165
0000d4  ea400005          ORR      r0,r0,r5              ;165
0000d8  8120              STRH     r0,[r4,#8]            ;165
0000da  e002              B        |L1.226|
                  |L1.220|
0000dc  f04f0070          MOV      r0,#0x70              ;168
0000e0  7030              STRB     r0,[r6,#0]            ;168
                  |L1.226|
0000e2  4658              MOV      r0,r11                ;170
0000e4  f7fffffe          BL       OS_CPU_SR_Restore
0000e8  e01e              B        |L1.296|
                  |L1.234|
0000ea  8920              LDRH     r0,[r4,#8]            ;174
0000ec  ea6f0000          MVN      r0,r0                 ;174
0000f0  b280              UXTH     r0,r0                 ;174
0000f2  ea000507          AND      r5,r0,r7              ;174
0000f6  b13d              CBZ      r5,|L1.264|
0000f8  f1b80f01          CMP      r8,#1                 ;176
0000fc  d107              BNE      |L1.270|
0000fe  8920              LDRH     r0,[r4,#8]            ;177
000100  ea400005          ORR      r0,r0,r5              ;177
000104  8120              STRH     r0,[r4,#8]            ;177
000106  e002              B        |L1.270|
                  |L1.264|
000108  f04f0070          MOV      r0,#0x70              ;180
00010c  7030              STRB     r0,[r6,#0]            ;180
                  |L1.270|
00010e  4658              MOV      r0,r11                ;182
000110  f7fffffe          BL       OS_CPU_SR_Restore
000114  e008              B        |L1.296|
                  |L1.278|
000116  4658              MOV      r0,r11                ;187
000118  f7fffffe          BL       OS_CPU_SR_Restore
00011c  f04f0500          MOV      r5,#0                 ;188
000120  f04f006f          MOV      r0,#0x6f              ;189
000124  7030              STRB     r0,[r6,#0]            ;189
000126  bf00              NOP                            ;190
                  |L1.296|
000128  bf00              NOP                            ;146
00012a  4628              MOV      r0,r5                 ;192
00012c  e778              B        |L1.32|
;;;194    #endif
                          ENDP

                  OSFlagCreate PROC
;;;216    
;;;217    OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS  flags,
00012e  e92d41f0          PUSH     {r4-r8,lr}
;;;218                                INT8U    *perr)
;;;219    {
000132  4606              MOV      r6,r0
000134  460d              MOV      r5,r1
;;;220        OS_FLAG_GRP *pgrp;
;;;221    #if OS_CRITICAL_METHOD == 3u                        /* Allocate storage for CPU status register        */
;;;222        OS_CPU_SR    cpu_sr = 0u;
000136  f04f0700          MOV      r7,#0
;;;223    #endif
;;;224    
;;;225    
;;;226    
;;;227    #ifdef OS_SAFETY_CRITICAL
;;;228        if (perr == (INT8U *)0) {
;;;229            OS_SAFETY_CRITICAL_EXCEPTION();
;;;230            return ((OS_FLAG_GRP *)0);
;;;231        }
;;;232    #endif
;;;233    
;;;234    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;235        if (OSSafetyCriticalStartFlag == OS_TRUE) {
;;;236            OS_SAFETY_CRITICAL_EXCEPTION();
;;;237            return ((OS_FLAG_GRP *)0);
;;;238        }
;;;239    #endif
;;;240    
;;;241        if (OSIntNesting > 0u) {                        /* See if called from ISR ...                      */
00013a  48f9              LDR      r0,|L1.1312|
00013c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00013e  b130              CBZ      r0,|L1.334|
;;;242            *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
000140  f04f0010          MOV      r0,#0x10
000144  7028              STRB     r0,[r5,#0]
;;;243            return ((OS_FLAG_GRP *)0);
000146  f04f0000          MOV      r0,#0
                  |L1.330|
;;;244        }
;;;245        OS_ENTER_CRITICAL();
;;;246        pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
;;;247        if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
;;;248                                                        /* Adjust free list                                */
;;;249            OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
;;;250            pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
;;;251            pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
;;;252            pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
;;;253    #if OS_FLAG_NAME_EN > 0u
;;;254            pgrp->OSFlagName     = (INT8U *)(void *)"?";
;;;255    #endif
;;;256            OS_EXIT_CRITICAL();
;;;257            *perr                = OS_ERR_NONE;
;;;258        } else {
;;;259            OS_EXIT_CRITICAL();
;;;260            *perr                = OS_ERR_FLAG_GRP_DEPLETED;
;;;261        }
;;;262        return (pgrp);                                  /* Return pointer to event flag group              */
;;;263    }
00014a  e8bd81f0          POP      {r4-r8,pc}
                  |L1.334|
00014e  f7fffffe          BL       OS_CPU_SR_Save
000152  4607              MOV      r7,r0                 ;245
000154  48f3              LDR      r0,|L1.1316|
000156  6804              LDR      r4,[r0,#0]            ;246  ; OSFlagFreeList
000158  b19c              CBZ      r4,|L1.386|
00015a  6800              LDR      r0,[r0,#0]            ;249  ; OSFlagFreeList
00015c  6840              LDR      r0,[r0,#4]            ;249
00015e  49f1              LDR      r1,|L1.1316|
000160  6008              STR      r0,[r1,#0]            ;249  ; OSFlagFreeList
000162  f04f0005          MOV      r0,#5                 ;250
000166  7020              STRB     r0,[r4,#0]            ;250
000168  8126              STRH     r6,[r4,#8]            ;251
00016a  f04f0000          MOV      r0,#0                 ;252
00016e  6060              STR      r0,[r4,#4]            ;252
000170  a0ed              ADR      r0,|L1.1320|
000172  60e0              STR      r0,[r4,#0xc]          ;254
000174  4638              MOV      r0,r7                 ;256
000176  f7fffffe          BL       OS_CPU_SR_Restore
00017a  f04f0000          MOV      r0,#0                 ;257
00017e  7028              STRB     r0,[r5,#0]            ;257
000180  e005              B        |L1.398|
                  |L1.386|
000182  4638              MOV      r0,r7                 ;259
000184  f7fffffe          BL       OS_CPU_SR_Restore
000188  f04f0072          MOV      r0,#0x72              ;260
00018c  7028              STRB     r0,[r5,#0]            ;260
                  |L1.398|
00018e  4620              MOV      r0,r4                 ;262
000190  e7db              B        |L1.330|
;;;264    
                          ENDP

                  OS_FlagUnlink PROC
;;;1201   
;;;1202   void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
000192  b530              PUSH     {r4,r5,lr}
;;;1203   {
000194  4601              MOV      r1,r0
;;;1204   #if OS_TASK_DEL_EN > 0u
;;;1205       OS_TCB       *ptcb;
;;;1206   #endif
;;;1207       OS_FLAG_GRP  *pgrp;
;;;1208       OS_FLAG_NODE *pnode_prev;
;;;1209       OS_FLAG_NODE *pnode_next;
;;;1210   
;;;1211   
;;;1212       pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
000196  684a              LDR      r2,[r1,#4]
;;;1213       pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
000198  6808              LDR      r0,[r1,#0]
;;;1214       if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
00019a  b932              CBNZ     r2,|L1.426|
;;;1215           pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
00019c  68cc              LDR      r4,[r1,#0xc]
;;;1216           pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
00019e  6060              STR      r0,[r4,#4]
;;;1217           if (pnode_next != (OS_FLAG_NODE *)0) {
0001a0  b130              CBZ      r0,|L1.432|
;;;1218               pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
0001a2  f04f0500          MOV      r5,#0
0001a6  6045              STR      r5,[r0,#4]
0001a8  e002              B        |L1.432|
                  |L1.426|
;;;1219           }
;;;1220       } else {                                                    /* No,  A node somewhere in the list   */
;;;1221           pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
0001aa  6010              STR      r0,[r2,#0]
;;;1222           if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
0001ac  b100              CBZ      r0,|L1.432|
;;;1223               pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
0001ae  6042              STR      r2,[r0,#4]
                  |L1.432|
;;;1224           }
;;;1225       }
;;;1226   #if OS_TASK_DEL_EN > 0u
;;;1227       ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
0001b0  688b              LDR      r3,[r1,#8]
;;;1228       ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
0001b2  f04f0500          MOV      r5,#0
0001b6  629d              STR      r5,[r3,#0x28]
;;;1229   #endif
;;;1230   }
0001b8  bd30              POP      {r4,r5,pc}
;;;1231   #endif
                          ENDP

                  OS_FlagTaskRdy PROC
;;;1155   
;;;1156   static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode,
0001ba  e92d41f0          PUSH     {r4-r8,lr}
;;;1157                                    OS_FLAGS      flags_rdy,
;;;1158                                    INT8U         pend_stat)
;;;1159   {
0001be  4606              MOV      r6,r0
0001c0  4688              MOV      r8,r1
0001c2  4617              MOV      r7,r2
;;;1160       OS_TCB   *ptcb;
;;;1161       BOOLEAN   sched;
;;;1162   
;;;1163   
;;;1164       ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
0001c4  68b4              LDR      r4,[r6,#8]
;;;1165       ptcb->OSTCBDly       = 0u;
0001c6  f04f0000          MOV      r0,#0
0001ca  f8440f30          STR      r0,[r4,#0x30]!
;;;1166       ptcb->OSTCBFlagsRdy  = flags_rdy;
0001ce  f8248c04          STRH     r8,[r4,#-4]
;;;1167       ptcb->OSTCBStat     &= (INT8U)~(INT8U)OS_STAT_FLAG;
0001d2  7920              LDRB     r0,[r4,#4]
0001d4  f00000df          AND      r0,r0,#0xdf
0001d8  7120              STRB     r0,[r4,#4]
;;;1168       ptcb->OSTCBStatPend  = pend_stat;
0001da  7167              STRB     r7,[r4,#5]
;;;1169       if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
0001dc  7920              LDRB     r0,[r4,#4]
0001de  f1a40430          SUB      r4,r4,#0x30
0001e2  b9a8              CBNZ     r0,|L1.528|
;;;1170           OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
0001e4  f1040438          ADD      r4,r4,#0x38
0001e8  78a0              LDRB     r0,[r4,#2]
0001ea  49d0              LDR      r1,|L1.1324|
0001ec  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
0001ee  ea400001          ORR      r0,r0,r1
0001f2  49ce              LDR      r1,|L1.1324|
0001f4  7008              STRB     r0,[r1,#0]
;;;1171           OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
0001f6  7820              LDRB     r0,[r4,#0]
0001f8  49cd              LDR      r1,|L1.1328|
0001fa  5c08              LDRB     r0,[r1,r0]
0001fc  7861              LDRB     r1,[r4,#1]
0001fe  ea400001          ORR      r0,r0,r1
000202  f8141938          LDRB     r1,[r4],#-0x38
000206  4aca              LDR      r2,|L1.1328|
000208  5450              STRB     r0,[r2,r1]
;;;1172           sched                   = OS_TRUE;
00020a  f04f0501          MOV      r5,#1
00020e  e001              B        |L1.532|
                  |L1.528|
;;;1173       } else {
;;;1174           sched                   = OS_FALSE;
000210  f04f0500          MOV      r5,#0
                  |L1.532|
;;;1175       }
;;;1176       OS_FlagUnlink(pnode);
000214  4630              MOV      r0,r6
000216  f7fffffe          BL       OS_FlagUnlink
;;;1177       return (sched);
00021a  4628              MOV      r0,r5
;;;1178   }
00021c  e8bd81f0          POP      {r4-r8,pc}
;;;1179   
                          ENDP

                  OSFlagDel PROC
;;;304    #if OS_FLAG_DEL_EN > 0u
;;;305    OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP  *pgrp,
000220  e92d47f0          PUSH     {r4-r10,lr}
;;;306                             INT8U         opt,
;;;307                             INT8U        *perr)
;;;308    {
000224  4604              MOV      r4,r0
000226  4689              MOV      r9,r1
000228  4615              MOV      r5,r2
;;;309        BOOLEAN       tasks_waiting;
;;;310        OS_FLAG_NODE *pnode;
;;;311        OS_FLAG_GRP  *pgrp_return;
;;;312    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;313        OS_CPU_SR     cpu_sr = 0u;
00022a  f04f0a00          MOV      r10,#0
;;;314    #endif
;;;315    
;;;316    
;;;317    
;;;318    #ifdef OS_SAFETY_CRITICAL
;;;319        if (perr == (INT8U *)0) {
;;;320            OS_SAFETY_CRITICAL_EXCEPTION();
;;;321            return ((OS_FLAG_GRP *)0);
;;;322        }
;;;323    #endif
;;;324    
;;;325    #if OS_ARG_CHK_EN > 0u
;;;326        if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
;;;327            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;328            return (pgrp);
;;;329        }
;;;330    #endif
;;;331        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00022e  48bc              LDR      r0,|L1.1312|
000230  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000232  b128              CBZ      r0,|L1.576|
;;;332            *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
000234  f04f000f          MOV      r0,#0xf
000238  7028              STRB     r0,[r5,#0]
;;;333            return (pgrp);
00023a  4620              MOV      r0,r4
                  |L1.572|
;;;334        }
;;;335        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
;;;336            *perr = OS_ERR_EVENT_TYPE;
;;;337            return (pgrp);
;;;338        }
;;;339        OS_ENTER_CRITICAL();
;;;340        if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
;;;341            tasks_waiting = OS_TRUE;                           /* Yes                                      */
;;;342        } else {
;;;343            tasks_waiting = OS_FALSE;                          /* No                                       */
;;;344        }
;;;345        switch (opt) {
;;;346            case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
;;;347                 if (tasks_waiting == OS_FALSE) {
;;;348    #if OS_FLAG_NAME_EN > 0u
;;;349                     pgrp->OSFlagName     = (INT8U *)(void *)"?";
;;;350    #endif
;;;351                     pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
;;;352                     pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
;;;353                     pgrp->OSFlagFlags    = (OS_FLAGS)0;
;;;354                     OSFlagFreeList       = pgrp;
;;;355                     OS_EXIT_CRITICAL();
;;;356                     *perr                = OS_ERR_NONE;
;;;357                     pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
;;;358                 } else {
;;;359                     OS_EXIT_CRITICAL();
;;;360                     *perr                = OS_ERR_TASK_WAITING;
;;;361                     pgrp_return          = pgrp;
;;;362                 }
;;;363                 break;
;;;364    
;;;365            case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
;;;366                 pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
;;;367                 while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
;;;368                     (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0, OS_STAT_PEND_ABORT);
;;;369                     pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
;;;370                 }
;;;371    #if OS_FLAG_NAME_EN > 0u
;;;372                 pgrp->OSFlagName     = (INT8U *)(void *)"?";
;;;373    #endif
;;;374                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
;;;375                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
;;;376                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
;;;377                 OSFlagFreeList       = pgrp;
;;;378                 OS_EXIT_CRITICAL();
;;;379                 if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
;;;380                     OS_Sched();                               /* Find highest priority task ready to run  */
;;;381                 }
;;;382                 *perr = OS_ERR_NONE;
;;;383                 pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
;;;384                 break;
;;;385    
;;;386            default:
;;;387                 OS_EXIT_CRITICAL();
;;;388                 *perr                = OS_ERR_INVALID_OPT;
;;;389                 pgrp_return          = pgrp;
;;;390                 break;
;;;391        }
;;;392        return (pgrp_return);
;;;393    }
00023c  e8bd87f0          POP      {r4-r10,pc}
                  |L1.576|
000240  7820              LDRB     r0,[r4,#0]            ;335
000242  2805              CMP      r0,#5                 ;335
000244  d004              BEQ      |L1.592|
000246  f04f0001          MOV      r0,#1                 ;336
00024a  7028              STRB     r0,[r5,#0]            ;336
00024c  4620              MOV      r0,r4                 ;337
00024e  e7f5              B        |L1.572|
                  |L1.592|
000250  f7fffffe          BL       OS_CPU_SR_Save
000254  4682              MOV      r10,r0                ;339
000256  6860              LDR      r0,[r4,#4]            ;340
000258  b110              CBZ      r0,|L1.608|
00025a  f04f0701          MOV      r7,#1                 ;341
00025e  e001              B        |L1.612|
                  |L1.608|
000260  f04f0700          MOV      r7,#0                 ;343
                  |L1.612|
000264  f1b90f00          CMP      r9,#0                 ;345
000268  d003              BEQ      |L1.626|
00026a  f1b90f01          CMP      r9,#1                 ;345
00026e  d144              BNE      |L1.762|
000270  e01d              B        |L1.686|
                  |L1.626|
000272  b9a7              CBNZ     r7,|L1.670|
000274  a0ac              ADR      r0,|L1.1320|
000276  60e0              STR      r0,[r4,#0xc]          ;349
000278  f04f0000          MOV      r0,#0                 ;351
00027c  7020              STRB     r0,[r4,#0]            ;351
00027e  48a9              LDR      r0,|L1.1316|
000280  6800              LDR      r0,[r0,#0]            ;352  ; OSFlagFreeList
000282  6060              STR      r0,[r4,#4]            ;352
000284  f04f0000          MOV      r0,#0                 ;353
000288  8120              STRH     r0,[r4,#8]            ;353
00028a  48a6              LDR      r0,|L1.1316|
00028c  6004              STR      r4,[r0,#0]            ;354  ; OSFlagFreeList
00028e  4650              MOV      r0,r10                ;355
000290  f7fffffe          BL       OS_CPU_SR_Restore
000294  f04f0000          MOV      r0,#0                 ;356
000298  7028              STRB     r0,[r5,#0]            ;356
00029a  4606              MOV      r6,r0                 ;357
00029c  e006              B        |L1.684|
                  |L1.670|
00029e  4650              MOV      r0,r10                ;359
0002a0  f7fffffe          BL       OS_CPU_SR_Restore
0002a4  f04f0049          MOV      r0,#0x49              ;360
0002a8  7028              STRB     r0,[r5,#0]            ;360
0002aa  4626              MOV      r6,r4                 ;361
                  |L1.684|
0002ac  e02d              B        |L1.778|
                  |L1.686|
0002ae  f8d48004          LDR      r8,[r4,#4]            ;366
0002b2  e006              B        |L1.706|
                  |L1.692|
0002b4  2202              MOVS     r2,#2                 ;368
0002b6  2100              MOVS     r1,#0                 ;368
0002b8  4640              MOV      r0,r8                 ;368
0002ba  f7fffffe          BL       OS_FlagTaskRdy
0002be  f8d88000          LDR      r8,[r8,#0]            ;369
                  |L1.706|
0002c2  f1b80f00          CMP      r8,#0                 ;367
0002c6  d1f5              BNE      |L1.692|
0002c8  a097              ADR      r0,|L1.1320|
0002ca  60e0              STR      r0,[r4,#0xc]          ;372
0002cc  f04f0000          MOV      r0,#0                 ;374
0002d0  7020              STRB     r0,[r4,#0]            ;374
0002d2  4894              LDR      r0,|L1.1316|
0002d4  6800              LDR      r0,[r0,#0]            ;375  ; OSFlagFreeList
0002d6  6060              STR      r0,[r4,#4]            ;375
0002d8  f04f0000          MOV      r0,#0                 ;376
0002dc  8120              STRH     r0,[r4,#8]            ;376
0002de  4891              LDR      r0,|L1.1316|
0002e0  6004              STR      r4,[r0,#0]            ;377  ; OSFlagFreeList
0002e2  4650              MOV      r0,r10                ;378
0002e4  f7fffffe          BL       OS_CPU_SR_Restore
0002e8  2f01              CMP      r7,#1                 ;379
0002ea  d101              BNE      |L1.752|
0002ec  f7fffffe          BL       OS_Sched
                  |L1.752|
0002f0  f04f0000          MOV      r0,#0                 ;382
0002f4  7028              STRB     r0,[r5,#0]            ;382
0002f6  4606              MOV      r6,r0                 ;383
0002f8  e007              B        |L1.778|
                  |L1.762|
0002fa  4650              MOV      r0,r10                ;387
0002fc  f7fffffe          BL       OS_CPU_SR_Restore
000300  f04f0007          MOV      r0,#7                 ;388
000304  7028              STRB     r0,[r5,#0]            ;388
000306  4626              MOV      r6,r4                 ;389
000308  bf00              NOP                            ;390
                  |L1.778|
00030a  bf00              NOP                            ;363
00030c  4630              MOV      r0,r6                 ;392
00030e  e795              B        |L1.572|
;;;394    #endif
                          ENDP

                  OSFlagNameGet PROC
;;;419    #if OS_FLAG_NAME_EN > 0u
;;;420    INT8U  OSFlagNameGet (OS_FLAG_GRP   *pgrp,
000310  e92d41f0          PUSH     {r4-r8,lr}
;;;421                          INT8U        **pname,
;;;422                          INT8U         *perr)
;;;423    {
000314  4605              MOV      r5,r0
000316  460e              MOV      r6,r1
000318  4614              MOV      r4,r2
;;;424        INT8U      len;
;;;425    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;426        OS_CPU_SR  cpu_sr = 0u;
00031a  f04f0700          MOV      r7,#0
;;;427    #endif
;;;428    
;;;429    
;;;430    
;;;431    #ifdef OS_SAFETY_CRITICAL
;;;432        if (perr == (INT8U *)0) {
;;;433            OS_SAFETY_CRITICAL_EXCEPTION();
;;;434            return (0u);
;;;435        }
;;;436    #endif
;;;437    
;;;438    #if OS_ARG_CHK_EN > 0u
;;;439        if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
;;;440            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;441            return (0u);
;;;442        }
;;;443        if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;444            *perr = OS_ERR_PNAME_NULL;
;;;445            return (0u);
;;;446        }
;;;447    #endif
;;;448        if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00031e  4880              LDR      r0,|L1.1312|
000320  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000322  b130              CBZ      r0,|L1.818|
;;;449            *perr = OS_ERR_NAME_GET_ISR;
000324  f04f0011          MOV      r0,#0x11
000328  7020              STRB     r0,[r4,#0]
;;;450            return (0u);
00032a  f04f0000          MOV      r0,#0
                  |L1.814|
;;;451        }
;;;452        OS_ENTER_CRITICAL();
;;;453        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
;;;454            OS_EXIT_CRITICAL();
;;;455            *perr = OS_ERR_EVENT_TYPE;
;;;456            return (0u);
;;;457        }
;;;458        *pname = pgrp->OSFlagName;
;;;459        len    = OS_StrLen(*pname);
;;;460        OS_EXIT_CRITICAL();
;;;461        *perr  = OS_ERR_NONE;
;;;462        return (len);
;;;463    }
00032e  e8bd81f0          POP      {r4-r8,pc}
                  |L1.818|
000332  f7fffffe          BL       OS_CPU_SR_Save
000336  4607              MOV      r7,r0                 ;452
000338  7828              LDRB     r0,[r5,#0]            ;453
00033a  2805              CMP      r0,#5                 ;453
00033c  d008              BEQ      |L1.848|
00033e  4638              MOV      r0,r7                 ;454
000340  f7fffffe          BL       OS_CPU_SR_Restore
000344  f04f0001          MOV      r0,#1                 ;455
000348  7020              STRB     r0,[r4,#0]            ;455
00034a  f04f0000          MOV      r0,#0                 ;456
00034e  e7ee              B        |L1.814|
                  |L1.848|
000350  68e8              LDR      r0,[r5,#0xc]          ;458
000352  6030              STR      r0,[r6,#0]            ;458
000354  6830              LDR      r0,[r6,#0]            ;459
000356  f7fffffe          BL       OS_StrLen
00035a  4680              MOV      r8,r0                 ;459
00035c  4638              MOV      r0,r7                 ;460
00035e  f7fffffe          BL       OS_CPU_SR_Restore
000362  f04f0000          MOV      r0,#0                 ;461
000366  7020              STRB     r0,[r4,#0]            ;461
000368  4640              MOV      r0,r8                 ;462
00036a  e7e0              B        |L1.814|
;;;464    #endif
                          ENDP

                  OSFlagNameSet PROC
;;;490    #if OS_FLAG_NAME_EN > 0u
;;;491    void  OSFlagNameSet (OS_FLAG_GRP  *pgrp,
00036c  e92d41f0          PUSH     {r4-r8,lr}
;;;492                         INT8U        *pname,
;;;493                         INT8U        *perr)
;;;494    {
000370  4605              MOV      r5,r0
000372  460e              MOV      r6,r1
000374  4614              MOV      r4,r2
;;;495    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;496        OS_CPU_SR  cpu_sr = 0u;
000376  f04f0700          MOV      r7,#0
;;;497    #endif
;;;498    
;;;499    
;;;500    
;;;501    #ifdef OS_SAFETY_CRITICAL
;;;502        if (perr == (INT8U *)0) {
;;;503            OS_SAFETY_CRITICAL_EXCEPTION();
;;;504            return;
;;;505        }
;;;506    #endif
;;;507    
;;;508    #if OS_ARG_CHK_EN > 0u
;;;509        if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
;;;510            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;511            return;
;;;512        }
;;;513        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;514            *perr = OS_ERR_PNAME_NULL;
;;;515            return;
;;;516        }
;;;517    #endif
;;;518        if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00037a  4869              LDR      r0,|L1.1312|
00037c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00037e  b120              CBZ      r0,|L1.906|
;;;519            *perr = OS_ERR_NAME_SET_ISR;
000380  f04f0012          MOV      r0,#0x12
000384  7020              STRB     r0,[r4,#0]
                  |L1.902|
;;;520            return;
;;;521        }
;;;522        OS_ENTER_CRITICAL();
;;;523        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
;;;524            OS_EXIT_CRITICAL();
;;;525            *perr = OS_ERR_EVENT_TYPE;
;;;526            return;
;;;527        }
;;;528        pgrp->OSFlagName = pname;
;;;529        OS_EXIT_CRITICAL();
;;;530        *perr            = OS_ERR_NONE;
;;;531        return;
;;;532    }
000386  e8bd81f0          POP      {r4-r8,pc}
                  |L1.906|
00038a  f7fffffe          BL       OS_CPU_SR_Save
00038e  4607              MOV      r7,r0                 ;522
000390  7828              LDRB     r0,[r5,#0]            ;523
000392  2805              CMP      r0,#5                 ;523
000394  d006              BEQ      |L1.932|
000396  4638              MOV      r0,r7                 ;524
000398  f7fffffe          BL       OS_CPU_SR_Restore
00039c  f04f0001          MOV      r0,#1                 ;525
0003a0  7020              STRB     r0,[r4,#0]            ;525
0003a2  e7f0              B        |L1.902|
                  |L1.932|
0003a4  60ee              STR      r6,[r5,#0xc]          ;528
0003a6  4638              MOV      r0,r7                 ;529
0003a8  f7fffffe          BL       OS_CPU_SR_Restore
0003ac  f04f0000          MOV      r0,#0                 ;530
0003b0  7020              STRB     r0,[r4,#0]            ;530
0003b2  bf00              NOP                            ;531
0003b4  e7e7              B        |L1.902|
;;;533    #endif
                          ENDP

                  OS_FlagBlock PROC
;;;1037   
;;;1038   static  void  OS_FlagBlock (OS_FLAG_GRP  *pgrp,
0003b6  b5f0              PUSH     {r4-r7,lr}
;;;1039                               OS_FLAG_NODE *pnode,
;;;1040                               OS_FLAGS      flags,
;;;1041                               INT8U         wait_type,
;;;1042                               INT32U        timeout)
;;;1043   {
0003b8  4614              MOV      r4,r2
0003ba  9e05              LDR      r6,[sp,#0x14]
;;;1044       OS_FLAG_NODE  *pnode_next;
;;;1045       INT8U          y;
;;;1046   
;;;1047   
;;;1048       OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
0003bc  4f5d              LDR      r7,|L1.1332|
0003be  683f              LDR      r7,[r7,#0]  ; OSTCBCur
0003c0  f8977034          LDRB     r7,[r7,#0x34]
0003c4  f0470720          ORR      r7,r7,#0x20
0003c8  f8dfc168          LDR      r12,|L1.1332|
0003cc  f8dcc000          LDR      r12,[r12,#0]  ; OSTCBCur
0003d0  f88c7034          STRB     r7,[r12,#0x34]
;;;1049       OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
0003d4  f04f0700          MOV      r7,#0
0003d8  f8dfc158          LDR      r12,|L1.1332|
0003dc  f8dcc000          LDR      r12,[r12,#0]  ; OSTCBCur
0003e0  f88c7035          STRB     r7,[r12,#0x35]
;;;1050       OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
0003e4  4f53              LDR      r7,|L1.1332|
0003e6  683f              LDR      r7,[r7,#0]  ; OSTCBCur
0003e8  633e              STR      r6,[r7,#0x30]
;;;1051   #if OS_TASK_DEL_EN > 0u
;;;1052       OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
0003ea  4f52              LDR      r7,|L1.1332|
0003ec  683f              LDR      r7,[r7,#0]  ; OSTCBCur
0003ee  62b9              STR      r1,[r7,#0x28]
;;;1053   #endif
;;;1054       pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
0003f0  820c              STRH     r4,[r1,#0x10]
;;;1055       pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
0003f2  748b              STRB     r3,[r1,#0x12]
;;;1056       pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
0003f4  4f4f              LDR      r7,|L1.1332|
0003f6  683f              LDR      r7,[r7,#0]  ; OSTCBCur
0003f8  608f              STR      r7,[r1,#8]
;;;1057       pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
0003fa  6847              LDR      r7,[r0,#4]
0003fc  600f              STR      r7,[r1,#0]
;;;1058       pnode->OSFlagNodePrev     = (void *)0;
0003fe  f04f0700          MOV      r7,#0
000402  604f              STR      r7,[r1,#4]
;;;1059       pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
000404  60c8              STR      r0,[r1,#0xc]
;;;1060       pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
000406  6845              LDR      r5,[r0,#4]
;;;1061       if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
000408  b105              CBZ      r5,|L1.1036|
;;;1062           pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
00040a  6069              STR      r1,[r5,#4]
                  |L1.1036|
;;;1063       }
;;;1064       pgrp->OSFlagWaitList = (void *)pnode;
00040c  6041              STR      r1,[r0,#4]
;;;1065   
;;;1066       y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
00040e  4f49              LDR      r7,|L1.1332|
000410  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000412  f8972038          LDRB     r2,[r7,#0x38]
;;;1067       OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
000416  4f46              LDR      r7,|L1.1328|
000418  5cbf              LDRB     r7,[r7,r2]
00041a  f8dfc118          LDR      r12,|L1.1332|
00041e  f8dcc000          LDR      r12,[r12,#0]  ; OSTCBCur
000422  f89cc039          LDRB     r12,[r12,#0x39]
000426  ea6f0c0c          MVN      r12,r12
00042a  f00c0cff          AND      r12,r12,#0xff
00042e  ea07070c          AND      r7,r7,r12
000432  f8dfc0fc          LDR      r12,|L1.1328|
000436  f80c7002          STRB     r7,[r12,r2]
;;;1068       if (OSRdyTbl[y] == 0x00u) {
00043a  4667              MOV      r7,r12
00043c  5cbf              LDRB     r7,[r7,r2]
00043e  b987              CBNZ     r7,|L1.1122|
;;;1069           OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
000440  4f3c              LDR      r7,|L1.1332|
000442  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000444  f897703a          LDRB     r7,[r7,#0x3a]
000448  ea6f0707          MVN      r7,r7
00044c  b2ff              UXTB     r7,r7
00044e  f8dfc0dc          LDR      r12,|L1.1324|
000452  f89cc000          LDRB     r12,[r12,#0]  ; OSRdyGrp
000456  ea07070c          AND      r7,r7,r12
00045a  f8dfc0d0          LDR      r12,|L1.1324|
00045e  f88c7000          STRB     r7,[r12,#0]
                  |L1.1122|
;;;1070       }
;;;1071   }
000462  bdf0              POP      {r4-r7,pc}
;;;1072   
                          ENDP

                  OSFlagPend PROC
;;;589    
;;;590    OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *pgrp,
000464  e92d4ff0          PUSH     {r4-r11,lr}
;;;591                          OS_FLAGS      flags,
;;;592                          INT8U         wait_type,
;;;593                          INT32U        timeout,
;;;594                          INT8U        *perr)
;;;595    {
000468  b089              SUB      sp,sp,#0x24
00046a  4605              MOV      r5,r0
00046c  460f              MOV      r7,r1
00046e  4691              MOV      r9,r2
000470  469a              MOV      r10,r3
000472  9e12              LDR      r6,[sp,#0x48]
;;;596        OS_FLAG_NODE  node;
;;;597        OS_FLAGS      flags_rdy;
;;;598        INT8U         result;
;;;599        INT8U         pend_stat;
;;;600        BOOLEAN       consume;
;;;601    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;602        OS_CPU_SR     cpu_sr = 0u;
000474  f04f0000          MOV      r0,#0
000478  9002              STR      r0,[sp,#8]
;;;603    #endif
;;;604    
;;;605    
;;;606    
;;;607    #ifdef OS_SAFETY_CRITICAL
;;;608        if (perr == (INT8U *)0) {
;;;609            OS_SAFETY_CRITICAL_EXCEPTION();
;;;610            return ((OS_FLAGS)0);
;;;611        }
;;;612    #endif
;;;613    
;;;614    #if OS_ARG_CHK_EN > 0u
;;;615        if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
;;;616            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;617            return ((OS_FLAGS)0);
;;;618        }
;;;619    #endif
;;;620        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00047a  4829              LDR      r0,|L1.1312|
00047c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00047e  b138              CBZ      r0,|L1.1168|
;;;621            *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
000480  f04f0002          MOV      r0,#2
000484  7030              STRB     r0,[r6,#0]
;;;622            return ((OS_FLAGS)0);
000486  f04f0000          MOV      r0,#0
                  |L1.1162|
;;;623        }
;;;624        if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
;;;625            *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
;;;626            return ((OS_FLAGS)0);
;;;627        }
;;;628        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
;;;629            *perr = OS_ERR_EVENT_TYPE;
;;;630            return ((OS_FLAGS)0);
;;;631        }
;;;632        result = (INT8U)(wait_type & OS_FLAG_CONSUME);
;;;633        if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
;;;634            wait_type &= (INT8U)~(INT8U)OS_FLAG_CONSUME;
;;;635            consume    = OS_TRUE;
;;;636        } else {
;;;637            consume    = OS_FALSE;
;;;638        }
;;;639    /*$PAGE*/
;;;640        OS_ENTER_CRITICAL();
;;;641        switch (wait_type) {
;;;642            case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
;;;643                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
;;;644                 if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;645                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;646                         pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;   /* Clear ONLY the flags we wanted    */
;;;647                     }
;;;648                     OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;649                     OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;650                     *perr                   = OS_ERR_NONE;
;;;651                     return (flags_rdy);
;;;652                 } else {                                      /* Block task until events occur or timeout */
;;;653                     OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;654                     OS_EXIT_CRITICAL();
;;;655                 }
;;;656                 break;
;;;657    
;;;658            case OS_FLAG_WAIT_SET_ANY:
;;;659                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
;;;660                 if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
;;;661                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;662                         pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;    /* Clear ONLY the flags that we got */
;;;663                     }
;;;664                     OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;665                     OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;666                     *perr                   = OS_ERR_NONE;
;;;667                     return (flags_rdy);
;;;668                 } else {                                      /* Block task until events occur or timeout */
;;;669                     OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;670                     OS_EXIT_CRITICAL();
;;;671                 }
;;;672                 break;
;;;673    
;;;674    #if OS_FLAG_WAIT_CLR_EN > 0u
;;;675            case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
;;;676                 flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
;;;677                 if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;678                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;679                         pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
;;;680                     }
;;;681                     OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;682                     OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;683                     *perr                   = OS_ERR_NONE;
;;;684                     return (flags_rdy);
;;;685                 } else {                                      /* Block task until events occur or timeout */
;;;686                     OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;687                     OS_EXIT_CRITICAL();
;;;688                 }
;;;689                 break;
;;;690    
;;;691            case OS_FLAG_WAIT_CLR_ANY:
;;;692                 flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
;;;693                 if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
;;;694                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;695                         pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
;;;696                     }
;;;697                     OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;698                     OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;699                     *perr                   = OS_ERR_NONE;
;;;700                     return (flags_rdy);
;;;701                 } else {                                      /* Block task until events occur or timeout */
;;;702                     OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;703                     OS_EXIT_CRITICAL();
;;;704                 }
;;;705                 break;
;;;706    #endif
;;;707    
;;;708            default:
;;;709                 OS_EXIT_CRITICAL();
;;;710                 flags_rdy = (OS_FLAGS)0;
;;;711                 *perr      = OS_ERR_FLAG_WAIT_TYPE;
;;;712                 return (flags_rdy);
;;;713        }
;;;714    /*$PAGE*/
;;;715        OS_Sched();                                            /* Find next HPT ready to run               */
;;;716        OS_ENTER_CRITICAL();
;;;717        if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
;;;718            pend_stat                = OSTCBCur->OSTCBStatPend;
;;;719            OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;720            OS_FlagUnlink(&node);
;;;721            OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
;;;722            OS_EXIT_CRITICAL();
;;;723            flags_rdy                = (OS_FLAGS)0;
;;;724            switch (pend_stat) {
;;;725                case OS_STAT_PEND_ABORT:
;;;726                     *perr = OS_ERR_PEND_ABORT;                /* Indicate that we aborted   waiting       */
;;;727                     break;
;;;728    
;;;729                case OS_STAT_PEND_TO:
;;;730                default:
;;;731                     *perr = OS_ERR_TIMEOUT;                   /* Indicate that we timed-out waiting       */
;;;732                     break;
;;;733            }
;;;734            return (flags_rdy);
;;;735        }
;;;736        flags_rdy = OSTCBCur->OSTCBFlagsRdy;
;;;737        if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
;;;738            switch (wait_type) {
;;;739                case OS_FLAG_WAIT_SET_ALL:
;;;740                case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
;;;741                     pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;
;;;742                     break;
;;;743    
;;;744    #if OS_FLAG_WAIT_CLR_EN > 0u
;;;745                case OS_FLAG_WAIT_CLR_ALL:
;;;746                case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
;;;747                     pgrp->OSFlagFlags |=  flags_rdy;
;;;748                     break;
;;;749    #endif
;;;750                default:
;;;751                     OS_EXIT_CRITICAL();
;;;752                     *perr = OS_ERR_FLAG_WAIT_TYPE;
;;;753                     return ((OS_FLAGS)0);
;;;754            }
;;;755        }
;;;756        OS_EXIT_CRITICAL();
;;;757        *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
;;;758        return (flags_rdy);
;;;759    }
00048a  b009              ADD      sp,sp,#0x24
00048c  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.1168|
000490  4829              LDR      r0,|L1.1336|
000492  7800              LDRB     r0,[r0,#0]            ;624  ; OSLockNesting
000494  b128              CBZ      r0,|L1.1186|
000496  f04f000d          MOV      r0,#0xd               ;625
00049a  7030              STRB     r0,[r6,#0]            ;625
00049c  f04f0000          MOV      r0,#0                 ;626
0004a0  e7f3              B        |L1.1162|
                  |L1.1186|
0004a2  7828              LDRB     r0,[r5,#0]            ;628
0004a4  2805              CMP      r0,#5                 ;628
0004a6  d005              BEQ      |L1.1204|
0004a8  f04f0001          MOV      r0,#1                 ;629
0004ac  7030              STRB     r0,[r6,#0]            ;629
0004ae  f04f0000          MOV      r0,#0                 ;630
0004b2  e7ea              B        |L1.1162|
                  |L1.1204|
0004b4  f0090b80          AND      r11,r9,#0x80          ;632
0004b8  f1bb0f00          CMP      r11,#0                ;633
0004bc  d004              BEQ      |L1.1224|
0004be  f009097f          AND      r9,r9,#0x7f           ;634
0004c2  f04f0801          MOV      r8,#1                 ;635
0004c6  e001              B        |L1.1228|
                  |L1.1224|
0004c8  f04f0800          MOV      r8,#0                 ;637
                  |L1.1228|
0004cc  f7fffffe          BL       OS_CPU_SR_Save
0004d0  9002              STR      r0,[sp,#8]            ;640
0004d2  f1b90f00          CMP      r9,#0                 ;641
0004d6  d062              BEQ      |L1.1438|
0004d8  f1b90f01          CMP      r9,#1                 ;641
0004dc  d079              BEQ      |L1.1490|
0004de  f1b90f02          CMP      r9,#2                 ;641
0004e2  d003              BEQ      |L1.1260|
0004e4  f1b90f03          CMP      r9,#3                 ;641
0004e8  d174              BNE      |L1.1492|
0004ea  e033              B        |L1.1364|
                  |L1.1260|
0004ec  8928              LDRH     r0,[r5,#8]            ;643
0004ee  ea000407          AND      r4,r0,r7              ;643
0004f2  42bc              CMP      r4,r7                 ;644
0004f4  d122              BNE      |L1.1340|
0004f6  f1b80f01          CMP      r8,#1                 ;645
0004fa  d106              BNE      |L1.1290|
0004fc  8928              LDRH     r0,[r5,#8]            ;646
0004fe  ea6f0104          MVN      r1,r4                 ;646
000502  b289              UXTH     r1,r1                 ;646
000504  ea000001          AND      r0,r0,r1              ;646
000508  8128              STRH     r0,[r5,#8]            ;646
                  |L1.1290|
00050a  480a              LDR      r0,|L1.1332|
00050c  6800              LDR      r0,[r0,#0]            ;648  ; OSTCBCur
00050e  8584              STRH     r4,[r0,#0x2c]         ;648
000510  9802              LDR      r0,[sp,#8]            ;649
000512  f7fffffe          BL       OS_CPU_SR_Restore
000516  f04f0000          MOV      r0,#0                 ;650
00051a  7030              STRB     r0,[r6,#0]            ;650
00051c  4620              MOV      r0,r4                 ;651
00051e  e7b4              B        |L1.1162|
                  |L1.1312|
                          DCD      OSIntNesting
                  |L1.1316|
                          DCD      OSFlagFreeList
                  |L1.1320|
000528  3f00              DCB      "?",0
00052a  00                DCB      0
00052b  00                DCB      0
                  |L1.1324|
                          DCD      OSRdyGrp
                  |L1.1328|
                          DCD      OSRdyTbl
                  |L1.1332|
                          DCD      OSTCBCur
                  |L1.1336|
                          DCD      OSLockNesting
                  |L1.1340|
00053c  464b              MOV      r3,r9                 ;653
00053e  463a              MOV      r2,r7                 ;653
000540  a904              ADD      r1,sp,#0x10           ;653
000542  4628              MOV      r0,r5                 ;653
000544  f8cda000          STR      r10,[sp,#0]           ;653
000548  f7fffffe          BL       OS_FlagBlock
00054c  9802              LDR      r0,[sp,#8]            ;654
00054e  f7fffffe          BL       OS_CPU_SR_Restore
000552  e07b              B        |L1.1612|
                  |L1.1364|
000554  8928              LDRH     r0,[r5,#8]            ;659
000556  ea000407          AND      r4,r0,r7              ;659
00055a  b1a4              CBZ      r4,|L1.1414|
00055c  f1b80f01          CMP      r8,#1                 ;661
000560  d106              BNE      |L1.1392|
000562  8928              LDRH     r0,[r5,#8]            ;662
000564  ea6f0104          MVN      r1,r4                 ;662
000568  b289              UXTH     r1,r1                 ;662
00056a  ea000001          AND      r0,r0,r1              ;662
00056e  8128              STRH     r0,[r5,#8]            ;662
                  |L1.1392|
000570  48ee              LDR      r0,|L1.2348|
000572  6800              LDR      r0,[r0,#0]            ;664  ; OSTCBCur
000574  8584              STRH     r4,[r0,#0x2c]         ;664
000576  9802              LDR      r0,[sp,#8]            ;665
000578  f7fffffe          BL       OS_CPU_SR_Restore
00057c  f04f0000          MOV      r0,#0                 ;666
000580  7030              STRB     r0,[r6,#0]            ;666
000582  4620              MOV      r0,r4                 ;667
000584  e781              B        |L1.1162|
                  |L1.1414|
000586  464b              MOV      r3,r9                 ;669
000588  463a              MOV      r2,r7                 ;669
00058a  a904              ADD      r1,sp,#0x10           ;669
00058c  4628              MOV      r0,r5                 ;669
00058e  f8cda000          STR      r10,[sp,#0]           ;669
000592  f7fffffe          BL       OS_FlagBlock
000596  9802              LDR      r0,[sp,#8]            ;670
000598  f7fffffe          BL       OS_CPU_SR_Restore
00059c  e056              B        |L1.1612|
                  |L1.1438|
00059e  8928              LDRH     r0,[r5,#8]            ;676
0005a0  ea6f0000          MVN      r0,r0                 ;676
0005a4  b280              UXTH     r0,r0                 ;676
0005a6  ea000407          AND      r4,r0,r7              ;676
0005aa  42bc              CMP      r4,r7                 ;677
0005ac  d113              BNE      |L1.1494|
0005ae  f1b80f01          CMP      r8,#1                 ;678
0005b2  d103              BNE      |L1.1468|
0005b4  8928              LDRH     r0,[r5,#8]            ;679
0005b6  ea400004          ORR      r0,r0,r4              ;679
0005ba  8128              STRH     r0,[r5,#8]            ;679
                  |L1.1468|
0005bc  48db              LDR      r0,|L1.2348|
0005be  6800              LDR      r0,[r0,#0]            ;681  ; OSTCBCur
0005c0  8584              STRH     r4,[r0,#0x2c]         ;681
0005c2  9802              LDR      r0,[sp,#8]            ;682
0005c4  f7fffffe          BL       OS_CPU_SR_Restore
0005c8  f04f0000          MOV      r0,#0                 ;683
0005cc  7030              STRB     r0,[r6,#0]            ;683
0005ce  4620              MOV      r0,r4                 ;684
0005d0  e75b              B        |L1.1162|
                  |L1.1490|
0005d2  e00c              B        |L1.1518|
                  |L1.1492|
0005d4  e030              B        |L1.1592|
                  |L1.1494|
0005d6  464b              MOV      r3,r9                 ;686
0005d8  463a              MOV      r2,r7                 ;686
0005da  a904              ADD      r1,sp,#0x10           ;686
0005dc  4628              MOV      r0,r5                 ;686
0005de  f8cda000          STR      r10,[sp,#0]           ;686
0005e2  f7fffffe          BL       OS_FlagBlock
0005e6  9802              LDR      r0,[sp,#8]            ;687
0005e8  f7fffffe          BL       OS_CPU_SR_Restore
0005ec  e02e              B        |L1.1612|
                  |L1.1518|
0005ee  8928              LDRH     r0,[r5,#8]            ;692
0005f0  ea6f0000          MVN      r0,r0                 ;692
0005f4  b280              UXTH     r0,r0                 ;692
0005f6  ea000407          AND      r4,r0,r7              ;692
0005fa  b18c              CBZ      r4,|L1.1568|
0005fc  f1b80f01          CMP      r8,#1                 ;694
000600  d103              BNE      |L1.1546|
000602  8928              LDRH     r0,[r5,#8]            ;695
000604  ea400004          ORR      r0,r0,r4              ;695
000608  8128              STRH     r0,[r5,#8]            ;695
                  |L1.1546|
00060a  48c8              LDR      r0,|L1.2348|
00060c  6800              LDR      r0,[r0,#0]            ;697  ; OSTCBCur
00060e  8584              STRH     r4,[r0,#0x2c]         ;697
000610  9802              LDR      r0,[sp,#8]            ;698
000612  f7fffffe          BL       OS_CPU_SR_Restore
000616  f04f0000          MOV      r0,#0                 ;699
00061a  7030              STRB     r0,[r6,#0]            ;699
00061c  4620              MOV      r0,r4                 ;700
00061e  e734              B        |L1.1162|
                  |L1.1568|
000620  464b              MOV      r3,r9                 ;702
000622  463a              MOV      r2,r7                 ;702
000624  a904              ADD      r1,sp,#0x10           ;702
000626  4628              MOV      r0,r5                 ;702
000628  f8cda000          STR      r10,[sp,#0]           ;702
00062c  f7fffffe          BL       OS_FlagBlock
000630  9802              LDR      r0,[sp,#8]            ;703
000632  f7fffffe          BL       OS_CPU_SR_Restore
000636  e009              B        |L1.1612|
                  |L1.1592|
000638  9802              LDR      r0,[sp,#8]            ;709
00063a  f7fffffe          BL       OS_CPU_SR_Restore
00063e  f04f0400          MOV      r4,#0                 ;710
000642  f04f006f          MOV      r0,#0x6f              ;711
000646  7030              STRB     r0,[r6,#0]            ;711
000648  4620              MOV      r0,r4                 ;712
00064a  e71e              B        |L1.1162|
                  |L1.1612|
00064c  bf00              NOP                            ;656
00064e  f7fffffe          BL       OS_Sched
000652  f7fffffe          BL       OS_CPU_SR_Save
000656  9002              STR      r0,[sp,#8]            ;716
000658  48b4              LDR      r0,|L1.2348|
00065a  6800              LDR      r0,[r0,#0]            ;717  ; OSTCBCur
00065c  f8900035          LDRB     r0,[r0,#0x35]         ;717
000660  b348              CBZ      r0,|L1.1718|
000662  48b2              LDR      r0,|L1.2348|
000664  6800              LDR      r0,[r0,#0]            ;718  ; OSTCBCur
000666  f8900035          LDRB     r0,[r0,#0x35]         ;718
00066a  9003              STR      r0,[sp,#0xc]          ;718
00066c  f04f0000          MOV      r0,#0                 ;719
000670  49ae              LDR      r1,|L1.2348|
000672  6809              LDR      r1,[r1,#0]            ;719  ; OSTCBCur
000674  f8810035          STRB     r0,[r1,#0x35]         ;719
000678  a804              ADD      r0,sp,#0x10           ;720
00067a  f7fffffe          BL       OS_FlagUnlink
00067e  f04f0000          MOV      r0,#0                 ;721
000682  49aa              LDR      r1,|L1.2348|
000684  6809              LDR      r1,[r1,#0]            ;721  ; OSTCBCur
000686  f8810034          STRB     r0,[r1,#0x34]         ;721
00068a  9802              LDR      r0,[sp,#8]            ;722
00068c  f7fffffe          BL       OS_CPU_SR_Restore
000690  f04f0400          MOV      r4,#0                 ;723
000694  9803              LDR      r0,[sp,#0xc]          ;724
000696  2801              CMP      r0,#1                 ;724
000698  d006              BEQ      |L1.1704|
00069a  2802              CMP      r0,#2                 ;724
00069c  d103              BNE      |L1.1702|
00069e  f04f000e          MOV      r0,#0xe               ;726
0006a2  7030              STRB     r0,[r6,#0]            ;726
0006a4  e004              B        |L1.1712|
                  |L1.1702|
0006a6  bf00              NOP                            ;729
                  |L1.1704|
0006a8  f04f000a          MOV      r0,#0xa               ;731
0006ac  7030              STRB     r0,[r6,#0]            ;731
0006ae  bf00              NOP                            ;732
                  |L1.1712|
0006b0  bf00              NOP                            ;727
0006b2  4620              MOV      r0,r4                 ;734
0006b4  e6e9              B        |L1.1162|
                  |L1.1718|
0006b6  489d              LDR      r0,|L1.2348|
0006b8  6800              LDR      r0,[r0,#0]            ;736  ; OSTCBCur
0006ba  8d84              LDRH     r4,[r0,#0x2c]         ;736
0006bc  f1b80f01          CMP      r8,#1                 ;737
0006c0  d125              BNE      |L1.1806|
0006c2  f1b90f00          CMP      r9,#0                 ;738
0006c6  d012              BEQ      |L1.1774|
0006c8  f1b90f01          CMP      r9,#1                 ;738
0006cc  d010              BEQ      |L1.1776|
0006ce  f1b90f02          CMP      r9,#2                 ;738
0006d2  d003              BEQ      |L1.1756|
0006d4  f1b90f03          CMP      r9,#3                 ;738
0006d8  d10f              BNE      |L1.1786|
0006da  e000              B        |L1.1758|
                  |L1.1756|
0006dc  bf00              NOP                            ;740
                  |L1.1758|
0006de  8928              LDRH     r0,[r5,#8]            ;741
0006e0  ea6f0104          MVN      r1,r4                 ;741
0006e4  b289              UXTH     r1,r1                 ;741
0006e6  ea000001          AND      r0,r0,r1              ;741
0006ea  8128              STRH     r0,[r5,#8]            ;741
0006ec  e00e              B        |L1.1804|
                  |L1.1774|
0006ee  bf00              NOP                            ;746
                  |L1.1776|
0006f0  8928              LDRH     r0,[r5,#8]            ;747
0006f2  ea400004          ORR      r0,r0,r4              ;747
0006f6  8128              STRH     r0,[r5,#8]            ;747
0006f8  e008              B        |L1.1804|
                  |L1.1786|
0006fa  9802              LDR      r0,[sp,#8]            ;751
0006fc  f7fffffe          BL       OS_CPU_SR_Restore
000700  f04f006f          MOV      r0,#0x6f              ;752
000704  7030              STRB     r0,[r6,#0]            ;752
000706  f04f0000          MOV      r0,#0                 ;753
00070a  e6be              B        |L1.1162|
                  |L1.1804|
00070c  bf00              NOP                            ;742
                  |L1.1806|
00070e  9802              LDR      r0,[sp,#8]            ;756
000710  f7fffffe          BL       OS_CPU_SR_Restore
000714  f04f0000          MOV      r0,#0                 ;757
000718  7030              STRB     r0,[r6,#0]            ;757
00071a  4620              MOV      r0,r4                 ;758
00071c  e6b5              B        |L1.1162|
;;;760    /*$PAGE*/
                          ENDP

                  OSFlagPendGetFlagsRdy PROC
;;;775    
;;;776    OS_FLAGS  OSFlagPendGetFlagsRdy (void)
00071e  b570              PUSH     {r4-r6,lr}
;;;777    {
;;;778        OS_FLAGS      flags;
;;;779    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;780        OS_CPU_SR     cpu_sr = 0u;
000720  f04f0500          MOV      r5,#0
;;;781    #endif
;;;782    
;;;783    
;;;784    
;;;785        OS_ENTER_CRITICAL();
000724  f7fffffe          BL       OS_CPU_SR_Save
000728  4605              MOV      r5,r0
;;;786        flags = OSTCBCur->OSTCBFlagsRdy;
00072a  4880              LDR      r0,|L1.2348|
00072c  6800              LDR      r0,[r0,#0]  ; OSTCBCur
00072e  8d84              LDRH     r4,[r0,#0x2c]
;;;787        OS_EXIT_CRITICAL();
000730  4628              MOV      r0,r5
000732  f7fffffe          BL       OS_CPU_SR_Restore
;;;788        return (flags);
000736  4620              MOV      r0,r4
;;;789    }
000738  bd70              POP      {r4-r6,pc}
;;;790    
                          ENDP

                  OSFlagPost PROC
;;;832    */
;;;833    OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *pgrp,
00073a  e92d5ffc          PUSH     {r2-r12,lr}
;;;834                          OS_FLAGS      flags,
;;;835                          INT8U         opt,
;;;836                          INT8U        *perr)
;;;837    {
00073e  4604              MOV      r4,r0
000740  4689              MOV      r9,r1
000742  4692              MOV      r10,r2
000744  461e              MOV      r6,r3
;;;838        OS_FLAG_NODE *pnode;
;;;839        BOOLEAN       sched;
;;;840        OS_FLAGS      flags_cur;
;;;841        OS_FLAGS      flags_rdy;
;;;842        BOOLEAN       rdy;
;;;843    #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
;;;844        OS_CPU_SR     cpu_sr = 0u;
000746  f04f0000          MOV      r0,#0
00074a  9000              STR      r0,[sp,#0]
;;;845    #endif
;;;846    
;;;847    
;;;848    
;;;849    #ifdef OS_SAFETY_CRITICAL
;;;850        if (perr == (INT8U *)0) {
;;;851            OS_SAFETY_CRITICAL_EXCEPTION();
;;;852            return ((OS_FLAGS)0);
;;;853        }
;;;854    #endif
;;;855    
;;;856    #if OS_ARG_CHK_EN > 0u
;;;857        if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
;;;858            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;859            return ((OS_FLAGS)0);
;;;860        }
;;;861    #endif
;;;862        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
00074c  7820              LDRB     r0,[r4,#0]
00074e  2805              CMP      r0,#5
000750  d006              BEQ      |L1.1888|
;;;863            *perr = OS_ERR_EVENT_TYPE;
000752  f04f0001          MOV      r0,#1
000756  7030              STRB     r0,[r6,#0]
;;;864            return ((OS_FLAGS)0);
000758  f04f0000          MOV      r0,#0
                  |L1.1884|
;;;865        }
;;;866    /*$PAGE*/
;;;867        OS_ENTER_CRITICAL();
;;;868        switch (opt) {
;;;869            case OS_FLAG_CLR:
;;;870                 pgrp->OSFlagFlags &= (OS_FLAGS)~flags;  /* Clear the flags specified in the group         */
;;;871                 break;
;;;872    
;;;873            case OS_FLAG_SET:
;;;874                 pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
;;;875                 break;
;;;876    
;;;877            default:
;;;878                 OS_EXIT_CRITICAL();                     /* INVALID option                                 */
;;;879                 *perr = OS_ERR_FLAG_INVALID_OPT;
;;;880                 return ((OS_FLAGS)0);
;;;881        }
;;;882        sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
;;;883        pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
;;;884        while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
;;;885            switch (pnode->OSFlagNodeWaitType) {
;;;886                case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
;;;887                     flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
;;;888                     if (flags_rdy == pnode->OSFlagNodeFlags) {   /* Make task RTR, event(s) Rx'd          */
;;;889                         rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);  
;;;890                         if (rdy == OS_TRUE) {
;;;891                             sched = OS_TRUE;                     /* When done we will reschedule          */
;;;892                         }
;;;893                     }
;;;894                     break;
;;;895    
;;;896                case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
;;;897                     flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
;;;898                     if (flags_rdy != (OS_FLAGS)0) {              /* Make task RTR, event(s) Rx'd          */
;;;899                         rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);  
;;;900                         if (rdy == OS_TRUE) {
;;;901                             sched = OS_TRUE;                     /* When done we will reschedule          */
;;;902                         }
;;;903                     }
;;;904                     break;
;;;905    
;;;906    #if OS_FLAG_WAIT_CLR_EN > 0u
;;;907                case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
;;;908                     flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
;;;909                     if (flags_rdy == pnode->OSFlagNodeFlags) {   /* Make task RTR, event(s) Rx'd          */
;;;910                         rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);  
;;;911                         if (rdy == OS_TRUE) {
;;;912                             sched = OS_TRUE;                     /* When done we will reschedule          */
;;;913                         }
;;;914                     }
;;;915                     break;
;;;916    
;;;917                case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
;;;918                     flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
;;;919                     if (flags_rdy != (OS_FLAGS)0) {              /* Make task RTR, event(s) Rx'd          */
;;;920                         rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);  
;;;921                         if (rdy == OS_TRUE) {
;;;922                             sched = OS_TRUE;                     /* When done we will reschedule          */
;;;923                         }
;;;924                     }
;;;925                     break;
;;;926    #endif
;;;927                default:
;;;928                     OS_EXIT_CRITICAL();
;;;929                     *perr = OS_ERR_FLAG_WAIT_TYPE;
;;;930                     return ((OS_FLAGS)0);
;;;931            }
;;;932            pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
;;;933        }
;;;934        OS_EXIT_CRITICAL();
;;;935        if (sched == OS_TRUE) {
;;;936            OS_Sched();
;;;937        }
;;;938        OS_ENTER_CRITICAL();
;;;939        flags_cur = pgrp->OSFlagFlags;
;;;940        OS_EXIT_CRITICAL();
;;;941        *perr     = OS_ERR_NONE;
;;;942        return (flags_cur);
;;;943    }
00075c  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.1888|
000760  f7fffffe          BL       OS_CPU_SR_Save
000764  9000              STR      r0,[sp,#0]            ;867
000766  f1ba0f00          CMP      r10,#0                ;868
00076a  d003              BEQ      |L1.1908|
00076c  f1ba0f01          CMP      r10,#1                ;868
000770  d10d              BNE      |L1.1934|
000772  e007              B        |L1.1924|
                  |L1.1908|
000774  8920              LDRH     r0,[r4,#8]            ;870
000776  ea6f0109          MVN      r1,r9                 ;870
00077a  b289              UXTH     r1,r1                 ;870
00077c  ea000001          AND      r0,r0,r1              ;870
000780  8120              STRH     r0,[r4,#8]            ;870
000782  e00d              B        |L1.1952|
                  |L1.1924|
000784  8920              LDRH     r0,[r4,#8]            ;874
000786  ea400009          ORR      r0,r0,r9              ;874
00078a  8120              STRH     r0,[r4,#8]            ;874
00078c  e008              B        |L1.1952|
                  |L1.1934|
00078e  9800              LDR      r0,[sp,#0]            ;878
000790  f7fffffe          BL       OS_CPU_SR_Restore
000794  f04f0071          MOV      r0,#0x71              ;879
000798  7030              STRB     r0,[r6,#0]            ;879
00079a  f04f0000          MOV      r0,#0                 ;880
00079e  e7dd              B        |L1.1884|
                  |L1.1952|
0007a0  bf00              NOP                            ;871
0007a2  f04f0b00          MOV      r11,#0                ;882
0007a6  6865              LDR      r5,[r4,#4]            ;883
0007a8  e061              B        |L1.2158|
                  |L1.1962|
0007aa  7ca8              LDRB     r0,[r5,#0x12]         ;885
0007ac  b350              CBZ      r0,|L1.2052|
0007ae  2801              CMP      r0,#1                 ;885
0007b0  d03e              BEQ      |L1.2096|
0007b2  2802              CMP      r0,#2                 ;885
0007b4  d002              BEQ      |L1.1980|
0007b6  2803              CMP      r0,#3                 ;885
0007b8  d14e              BNE      |L1.2136|
0007ba  e012              B        |L1.2018|
                  |L1.1980|
0007bc  8920              LDRH     r0,[r4,#8]            ;887
0007be  8a29              LDRH     r1,[r5,#0x10]         ;887
0007c0  ea000701          AND      r7,r0,r1              ;887
0007c4  8a28              LDRH     r0,[r5,#0x10]         ;888
0007c6  42b8              CMP      r0,r7                 ;888
0007c8  d10a              BNE      |L1.2016|
0007ca  2200              MOVS     r2,#0                 ;889
0007cc  4639              MOV      r1,r7                 ;889
0007ce  4628              MOV      r0,r5                 ;889
0007d0  f7fffffe          BL       OS_FlagTaskRdy
0007d4  4680              MOV      r8,r0                 ;889
0007d6  f1b80f01          CMP      r8,#1                 ;890
0007da  d101              BNE      |L1.2016|
0007dc  f04f0b01          MOV      r11,#1                ;891
                  |L1.2016|
0007e0  e043              B        |L1.2154|
                  |L1.2018|
0007e2  8920              LDRH     r0,[r4,#8]            ;897
0007e4  8a29              LDRH     r1,[r5,#0x10]         ;897
0007e6  ea000701          AND      r7,r0,r1              ;897
0007ea  b157              CBZ      r7,|L1.2050|
0007ec  2200              MOVS     r2,#0                 ;899
0007ee  4639              MOV      r1,r7                 ;899
0007f0  4628              MOV      r0,r5                 ;899
0007f2  f7fffffe          BL       OS_FlagTaskRdy
0007f6  4680              MOV      r8,r0                 ;899
0007f8  f1b80f01          CMP      r8,#1                 ;900
0007fc  d101              BNE      |L1.2050|
0007fe  f04f0b01          MOV      r11,#1                ;901
                  |L1.2050|
000802  e032              B        |L1.2154|
                  |L1.2052|
000804  8920              LDRH     r0,[r4,#8]            ;908
000806  ea6f0000          MVN      r0,r0                 ;908
00080a  b280              UXTH     r0,r0                 ;908
00080c  8a29              LDRH     r1,[r5,#0x10]         ;908
00080e  ea000701          AND      r7,r0,r1              ;908
000812  8a28              LDRH     r0,[r5,#0x10]         ;909
000814  42b8              CMP      r0,r7                 ;909
000816  d10a              BNE      |L1.2094|
000818  2200              MOVS     r2,#0                 ;910
00081a  4639              MOV      r1,r7                 ;910
00081c  4628              MOV      r0,r5                 ;910
00081e  f7fffffe          BL       OS_FlagTaskRdy
000822  4680              MOV      r8,r0                 ;910
000824  f1b80f01          CMP      r8,#1                 ;911
000828  d101              BNE      |L1.2094|
00082a  f04f0b01          MOV      r11,#1                ;912
                  |L1.2094|
00082e  e01c              B        |L1.2154|
                  |L1.2096|
000830  8920              LDRH     r0,[r4,#8]            ;918
000832  ea6f0000          MVN      r0,r0                 ;918
000836  b280              UXTH     r0,r0                 ;918
000838  8a29              LDRH     r1,[r5,#0x10]         ;918
00083a  ea000701          AND      r7,r0,r1              ;918
00083e  b157              CBZ      r7,|L1.2134|
000840  2200              MOVS     r2,#0                 ;920
000842  4639              MOV      r1,r7                 ;920
000844  4628              MOV      r0,r5                 ;920
000846  f7fffffe          BL       OS_FlagTaskRdy
00084a  4680              MOV      r8,r0                 ;920
00084c  f1b80f01          CMP      r8,#1                 ;921
000850  d101              BNE      |L1.2134|
000852  f04f0b01          MOV      r11,#1                ;922
                  |L1.2134|
000856  e008              B        |L1.2154|
                  |L1.2136|
000858  9800              LDR      r0,[sp,#0]            ;928
00085a  f7fffffe          BL       OS_CPU_SR_Restore
00085e  f04f006f          MOV      r0,#0x6f              ;929
000862  7030              STRB     r0,[r6,#0]            ;929
000864  f04f0000          MOV      r0,#0                 ;930
000868  e778              B        |L1.1884|
                  |L1.2154|
00086a  bf00              NOP                            ;894
00086c  682d              LDR      r5,[r5,#0]            ;932
                  |L1.2158|
00086e  2d00              CMP      r5,#0                 ;884
000870  d19b              BNE      |L1.1962|
000872  9800              LDR      r0,[sp,#0]            ;934
000874  f7fffffe          BL       OS_CPU_SR_Restore
000878  f1bb0f01          CMP      r11,#1                ;935
00087c  d101              BNE      |L1.2178|
00087e  f7fffffe          BL       OS_Sched
                  |L1.2178|
000882  f7fffffe          BL       OS_CPU_SR_Save
000886  9000              STR      r0,[sp,#0]            ;938
000888  8920              LDRH     r0,[r4,#8]            ;939
00088a  9001              STR      r0,[sp,#4]            ;939
00088c  9800              LDR      r0,[sp,#0]            ;940
00088e  f7fffffe          BL       OS_CPU_SR_Restore
000892  f04f0000          MOV      r0,#0                 ;941
000896  7030              STRB     r0,[r6,#0]            ;941
000898  9801              LDR      r0,[sp,#4]            ;942
00089a  e75f              B        |L1.1884|
;;;944    /*$PAGE*/
                          ENDP

                  OSFlagQuery PROC
;;;964    #if OS_FLAG_QUERY_EN > 0u
;;;965    OS_FLAGS  OSFlagQuery (OS_FLAG_GRP  *pgrp,
00089c  e92d41f0          PUSH     {r4-r8,lr}
;;;966                           INT8U        *perr)
;;;967    {
0008a0  4604              MOV      r4,r0
0008a2  460d              MOV      r5,r1
;;;968        OS_FLAGS   flags;
;;;969    #if OS_CRITICAL_METHOD == 3u                      /* Allocate storage for CPU status register          */
;;;970        OS_CPU_SR  cpu_sr = 0u;
0008a4  f04f0700          MOV      r7,#0
;;;971    #endif
;;;972    
;;;973    
;;;974    
;;;975    #ifdef OS_SAFETY_CRITICAL
;;;976        if (perr == (INT8U *)0) {
;;;977            OS_SAFETY_CRITICAL_EXCEPTION();
;;;978            return ((OS_FLAGS)0);
;;;979        }
;;;980    #endif
;;;981    
;;;982    #if OS_ARG_CHK_EN > 0u
;;;983        if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
;;;984            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;985            return ((OS_FLAGS)0);
;;;986        }
;;;987    #endif
;;;988        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
0008a8  7820              LDRB     r0,[r4,#0]
0008aa  2805              CMP      r0,#5
0008ac  d006              BEQ      |L1.2236|
;;;989            *perr = OS_ERR_EVENT_TYPE;
0008ae  f04f0001          MOV      r0,#1
0008b2  7028              STRB     r0,[r5,#0]
;;;990            return ((OS_FLAGS)0);
0008b4  f04f0000          MOV      r0,#0
                  |L1.2232|
;;;991        }
;;;992        OS_ENTER_CRITICAL();
;;;993        flags = pgrp->OSFlagFlags;
;;;994        OS_EXIT_CRITICAL();
;;;995        *perr = OS_ERR_NONE;
;;;996        return (flags);                               /* Return the current value of the event flags       */
;;;997    }
0008b8  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2236|
0008bc  f7fffffe          BL       OS_CPU_SR_Save
0008c0  4607              MOV      r7,r0                 ;992
0008c2  8926              LDRH     r6,[r4,#8]            ;993
0008c4  4638              MOV      r0,r7                 ;994
0008c6  f7fffffe          BL       OS_CPU_SR_Restore
0008ca  f04f0000          MOV      r0,#0                 ;995
0008ce  7028              STRB     r0,[r5,#0]            ;995
0008d0  4630              MOV      r0,r6                 ;996
0008d2  e7f1              B        |L1.2232|
;;;998    #endif
                          ENDP

                  OS_FlagInit PROC
;;;1088   
;;;1089   void  OS_FlagInit (void)
0008d4  e92d41f0          PUSH     {r4-r8,lr}
;;;1090   {
;;;1091   #if OS_MAX_FLAGS == 1u
;;;1092       OSFlagFreeList                 = (OS_FLAG_GRP *)&OSFlagTbl[0];  /* Only ONE event flag group!      */
;;;1093       OSFlagFreeList->OSFlagType     = OS_EVENT_TYPE_UNUSED;
;;;1094       OSFlagFreeList->OSFlagWaitList = (void *)0;
;;;1095       OSFlagFreeList->OSFlagFlags    = (OS_FLAGS)0;
;;;1096   #if OS_FLAG_NAME_EN > 0u
;;;1097       OSFlagFreeList->OSFlagName     = (INT8U *)"?";
;;;1098   #endif
;;;1099   #endif
;;;1100   
;;;1101   #if OS_MAX_FLAGS >= 2u
;;;1102       INT16U        ix;
;;;1103       INT16U        ix_next;
;;;1104       OS_FLAG_GRP  *pgrp1;
;;;1105       OS_FLAG_GRP  *pgrp2;
;;;1106   
;;;1107   
;;;1108       OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
0008d8  2150              MOVS     r1,#0x50
0008da  4815              LDR      r0,|L1.2352|
0008dc  f7fffffe          BL       OS_MemClr
;;;1109       for (ix = 0u; ix < (OS_MAX_FLAGS - 1u); ix++) {                 /* Init. list of free EVENT FLAGS  */
0008e0  f04f0500          MOV      r5,#0
0008e4  e011              B        |L1.2314|
                  |L1.2278|
;;;1110           ix_next = ix + 1u;
0008e6  f1050001          ADD      r0,r5,#1
0008ea  b286              UXTH     r6,r0
;;;1111           pgrp1 = &OSFlagTbl[ix];
0008ec  4810              LDR      r0,|L1.2352|
0008ee  eb001405          ADD      r4,r0,r5,LSL #4
;;;1112           pgrp2 = &OSFlagTbl[ix_next];
0008f2  eb001706          ADD      r7,r0,r6,LSL #4
;;;1113           pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
0008f6  f04f0000          MOV      r0,#0
0008fa  7020              STRB     r0,[r4,#0]
;;;1114           pgrp1->OSFlagWaitList = (void *)pgrp2;
0008fc  6067              STR      r7,[r4,#4]
;;;1115   #if OS_FLAG_NAME_EN > 0u
;;;1116           pgrp1->OSFlagName     = (INT8U *)(void *)"?";               /* Unknown name                    */
0008fe  f2af30d8          ADR      r0,|L1.1320|
000902  60e0              STR      r0,[r4,#0xc]
000904  f1050001          ADD      r0,r5,#1              ;1109
000908  b285              UXTH     r5,r0                 ;1109
                  |L1.2314|
00090a  2d04              CMP      r5,#4                 ;1109
00090c  d3eb              BCC      |L1.2278|
;;;1117   #endif
;;;1118       }
;;;1119       pgrp1                 = &OSFlagTbl[ix];
00090e  4808              LDR      r0,|L1.2352|
000910  eb001405          ADD      r4,r0,r5,LSL #4
;;;1120       pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
000914  f04f0000          MOV      r0,#0
000918  7020              STRB     r0,[r4,#0]
;;;1121       pgrp1->OSFlagWaitList = (void *)0;
00091a  6060              STR      r0,[r4,#4]
;;;1122   #if OS_FLAG_NAME_EN > 0u
;;;1123       pgrp1->OSFlagName     = (INT8U *)(void *)"?";                   /* Unknown name                    */
00091c  f2af30f8          ADR      r0,|L1.1320|
000920  60e0              STR      r0,[r4,#0xc]
;;;1124   #endif
;;;1125       OSFlagFreeList        = &OSFlagTbl[0];
000922  4803              LDR      r0,|L1.2352|
000924  4903              LDR      r1,|L1.2356|
000926  6008              STR      r0,[r1,#0]  ; OSFlagFreeList
;;;1126   #endif
;;;1127   }
000928  e8bd81f0          POP      {r4-r8,pc}
;;;1128   
                          ENDP

                  |L1.2348|
                          DCD      OSTCBCur
                  |L1.2352|
                          DCD      OSFlagTbl
                  |L1.2356|
                          DCD      OSFlagFreeList
