; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Output\stm32f2xx_tim.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\Output\stm32f2xx_tim.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\BSP -I..\BSP\UCOS-II -I..\BSP\STM32F2xx\inc -I..\BSP\CMSIS -I..\BSP\CMSIS\Device_Support -I..\BSP\UCOS-II -I..\..\uC-CPU -I..\..\uC-CPU\ARM-Cortex-M3 -I..\..\uC-LIB -I..\..\uC-LIB\Ports\ARM-Cortex-M3 -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3 -I..\App -I..\Prj -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DDEBUG -DLJB_CPU_MAIN -DUSE_CPU_F205RC --omf_browse=.\Output\stm32f2xx_tim.crf ..\BSP\STM32F2xx\src\stm32f2xx_tim.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;193      */
;;;194    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  b510              PUSH     {r4,lr}
;;;195    {
000002  4604              MOV      r4,r0
;;;196      /* Check the parameters */
;;;197      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;198     
;;;199      if (TIMx == TIM1)
000004  48fa              LDR      r0,|L1.1008|
000006  4284              CMP      r4,r0
000008  d108              BNE      |L1.28|
;;;200      {
;;;201        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;202        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
000012  2100              MOVS     r1,#0
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       RCC_APB2PeriphResetCmd
00001a  e09d              B        |L1.344|
                  |L1.28|
;;;203      } 
;;;204      else if (TIMx == TIM2) 
00001c  f1b44f80          CMP      r4,#0x40000000
000020  d108              BNE      |L1.52|
;;;205      {     
;;;206        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
000022  2101              MOVS     r1,#1
000024  4608              MOV      r0,r1
000026  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;207        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
00002a  2100              MOVS     r1,#0
00002c  2001              MOVS     r0,#1
00002e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000032  e091              B        |L1.344|
                  |L1.52|
;;;208      }  
;;;209      else if (TIMx == TIM3)
000034  48ef              LDR      r0,|L1.1012|
000036  4284              CMP      r4,r0
000038  d108              BNE      |L1.76|
;;;210      { 
;;;211        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
00003a  2101              MOVS     r1,#1
00003c  2002              MOVS     r0,#2
00003e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;212        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
000042  2100              MOVS     r1,#0
000044  2002              MOVS     r0,#2
000046  f7fffffe          BL       RCC_APB1PeriphResetCmd
00004a  e085              B        |L1.344|
                  |L1.76|
;;;213      }  
;;;214      else if (TIMx == TIM4)
00004c  48ea              LDR      r0,|L1.1016|
00004e  4284              CMP      r4,r0
000050  d108              BNE      |L1.100|
;;;215      { 
;;;216        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
000052  2101              MOVS     r1,#1
000054  2004              MOVS     r0,#4
000056  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;217        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
00005a  2100              MOVS     r1,#0
00005c  2004              MOVS     r0,#4
00005e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000062  e079              B        |L1.344|
                  |L1.100|
;;;218      }  
;;;219      else if (TIMx == TIM5)
000064  48e5              LDR      r0,|L1.1020|
000066  4284              CMP      r4,r0
000068  d108              BNE      |L1.124|
;;;220      {      
;;;221        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
00006a  2101              MOVS     r1,#1
00006c  2008              MOVS     r0,#8
00006e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;222        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
000072  2100              MOVS     r1,#0
000074  2008              MOVS     r0,#8
000076  f7fffffe          BL       RCC_APB1PeriphResetCmd
00007a  e06d              B        |L1.344|
                  |L1.124|
;;;223      }  
;;;224      else if (TIMx == TIM6)  
00007c  48e0              LDR      r0,|L1.1024|
00007e  4284              CMP      r4,r0
000080  d108              BNE      |L1.148|
;;;225      {    
;;;226        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
000082  2101              MOVS     r1,#1
000084  2010              MOVS     r0,#0x10
000086  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;227        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
00008a  2100              MOVS     r1,#0
00008c  2010              MOVS     r0,#0x10
00008e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000092  e061              B        |L1.344|
                  |L1.148|
;;;228      }  
;;;229      else if (TIMx == TIM7)
000094  48db              LDR      r0,|L1.1028|
000096  4284              CMP      r4,r0
000098  d108              BNE      |L1.172|
;;;230      {      
;;;231        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
00009a  2101              MOVS     r1,#1
00009c  2020              MOVS     r0,#0x20
00009e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;232        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
0000a2  2100              MOVS     r1,#0
0000a4  2020              MOVS     r0,#0x20
0000a6  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000aa  e055              B        |L1.344|
                  |L1.172|
;;;233      }  
;;;234      else if (TIMx == TIM8)
0000ac  48d6              LDR      r0,|L1.1032|
0000ae  4284              CMP      r4,r0
0000b0  d108              BNE      |L1.196|
;;;235      {      
;;;236        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
0000b2  2101              MOVS     r1,#1
0000b4  2002              MOVS     r0,#2
0000b6  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;237        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
0000ba  2100              MOVS     r1,#0
0000bc  2002              MOVS     r0,#2
0000be  f7fffffe          BL       RCC_APB2PeriphResetCmd
0000c2  e049              B        |L1.344|
                  |L1.196|
;;;238      }  
;;;239      else if (TIMx == TIM9)
0000c4  48d1              LDR      r0,|L1.1036|
0000c6  4284              CMP      r4,r0
0000c8  d109              BNE      |L1.222|
;;;240      {      
;;;241        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
0000ca  2101              MOVS     r1,#1
0000cc  0408              LSLS     r0,r1,#16
0000ce  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;242        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
0000d2  2100              MOVS     r1,#0
0000d4  f44f3080          MOV      r0,#0x10000
0000d8  f7fffffe          BL       RCC_APB2PeriphResetCmd
0000dc  e03c              B        |L1.344|
                  |L1.222|
;;;243       }  
;;;244      else if (TIMx == TIM10)
0000de  48cc              LDR      r0,|L1.1040|
0000e0  4284              CMP      r4,r0
0000e2  d109              BNE      |L1.248|
;;;245      {      
;;;246        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
0000e4  2101              MOVS     r1,#1
0000e6  0448              LSLS     r0,r1,#17
0000e8  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;247        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
0000ec  2100              MOVS     r1,#0
0000ee  f44f3000          MOV      r0,#0x20000
0000f2  f7fffffe          BL       RCC_APB2PeriphResetCmd
0000f6  e02f              B        |L1.344|
                  |L1.248|
;;;248      }  
;;;249      else if (TIMx == TIM11) 
0000f8  48c6              LDR      r0,|L1.1044|
0000fa  4284              CMP      r4,r0
0000fc  d109              BNE      |L1.274|
;;;250      {     
;;;251        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
0000fe  2101              MOVS     r1,#1
000100  0488              LSLS     r0,r1,#18
000102  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;252        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
000106  2100              MOVS     r1,#0
000108  f44f2080          MOV      r0,#0x40000
00010c  f7fffffe          BL       RCC_APB2PeriphResetCmd
000110  e022              B        |L1.344|
                  |L1.274|
;;;253      }  
;;;254      else if (TIMx == TIM12)
000112  48c1              LDR      r0,|L1.1048|
000114  4284              CMP      r4,r0
000116  d108              BNE      |L1.298|
;;;255      {      
;;;256        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
000118  2101              MOVS     r1,#1
00011a  2040              MOVS     r0,#0x40
00011c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;257        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
000120  2100              MOVS     r1,#0
000122  2040              MOVS     r0,#0x40
000124  f7fffffe          BL       RCC_APB1PeriphResetCmd
000128  e016              B        |L1.344|
                  |L1.298|
;;;258      }  
;;;259      else if (TIMx == TIM13) 
00012a  48bc              LDR      r0,|L1.1052|
00012c  4284              CMP      r4,r0
00012e  d108              BNE      |L1.322|
;;;260      {       
;;;261        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
000130  2101              MOVS     r1,#1
000132  2080              MOVS     r0,#0x80
000134  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;262        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
000138  2100              MOVS     r1,#0
00013a  2080              MOVS     r0,#0x80
00013c  f7fffffe          BL       RCC_APB1PeriphResetCmd
000140  e00a              B        |L1.344|
                  |L1.322|
;;;263      }  
;;;264      else
;;;265      { 
;;;266        if (TIMx == TIM14) 
000142  48b7              LDR      r0,|L1.1056|
000144  4284              CMP      r4,r0
000146  d107              BNE      |L1.344|
;;;267        {     
;;;268          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
000148  2101              MOVS     r1,#1
00014a  1580              ASRS     r0,r0,#22
00014c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;269          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
000150  2100              MOVS     r1,#0
000152  15a0              ASRS     r0,r4,#22
000154  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L1.344|
;;;270        }   
;;;271      }
;;;272    }
000158  bd10              POP      {r4,pc}
;;;273    
                          ENDP

                  TIM_TimeBaseInit PROC
;;;281      */
;;;282    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
00015a  f04f0200          MOV      r2,#0
;;;283    {
;;;284      uint16_t tmpcr1 = 0;
;;;285    
;;;286      /* Check the parameters */
;;;287      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;288      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;289      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;290    
;;;291      tmpcr1 = TIMx->CR1;  
00015e  8802              LDRH     r2,[r0,#0]
;;;292    
;;;293      if((TIMx == TIM1) || (TIMx == TIM8)||
000160  4ba3              LDR      r3,|L1.1008|
000162  4298              CMP      r0,r3
000164  d00e              BEQ      |L1.388|
000166  4ba8              LDR      r3,|L1.1032|
000168  4298              CMP      r0,r3
00016a  d00b              BEQ      |L1.388|
;;;294         (TIMx == TIM2) || (TIMx == TIM3)||
00016c  f1b04f80          CMP      r0,#0x40000000
000170  d008              BEQ      |L1.388|
000172  4ba0              LDR      r3,|L1.1012|
000174  4298              CMP      r0,r3
000176  d005              BEQ      |L1.388|
;;;295         (TIMx == TIM4) || (TIMx == TIM5)) 
000178  4b9f              LDR      r3,|L1.1016|
00017a  4298              CMP      r0,r3
00017c  d002              BEQ      |L1.388|
00017e  4b9f              LDR      r3,|L1.1020|
000180  4298              CMP      r0,r3
000182  d106              BNE      |L1.402|
                  |L1.388|
;;;296      {
;;;297        /* Select the Counter Mode */
;;;298        tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
000184  f64f738f          MOV      r3,#0xff8f
000188  ea020203          AND      r2,r2,r3
;;;299        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
00018c  884b              LDRH     r3,[r1,#2]
00018e  ea430202          ORR      r2,r3,r2
                  |L1.402|
;;;300      }
;;;301     
;;;302      if((TIMx != TIM6) && (TIMx != TIM7))
000192  4b9b              LDR      r3,|L1.1024|
000194  4298              CMP      r0,r3
000196  d009              BEQ      |L1.428|
000198  4b9a              LDR      r3,|L1.1028|
00019a  4298              CMP      r0,r3
00019c  d006              BEQ      |L1.428|
;;;303      {
;;;304        /* Set the clock division */
;;;305        tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
00019e  f64f43ff          MOV      r3,#0xfcff
0001a2  ea020203          AND      r2,r2,r3
;;;306        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
0001a6  890b              LDRH     r3,[r1,#8]
0001a8  ea430202          ORR      r2,r3,r2
                  |L1.428|
;;;307      }
;;;308    
;;;309      TIMx->CR1 = tmpcr1;
0001ac  8002              STRH     r2,[r0,#0]
;;;310    
;;;311      /* Set the Autoreload value */
;;;312      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
0001ae  684b              LDR      r3,[r1,#4]
0001b0  62c3              STR      r3,[r0,#0x2c]
;;;313     
;;;314      /* Set the Prescaler value */
;;;315      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
0001b2  880b              LDRH     r3,[r1,#0]
0001b4  8503              STRH     r3,[r0,#0x28]
;;;316        
;;;317      if ((TIMx == TIM1) || (TIMx == TIM8))  
0001b6  4b8e              LDR      r3,|L1.1008|
0001b8  4298              CMP      r0,r3
0001ba  d002              BEQ      |L1.450|
0001bc  4b92              LDR      r3,|L1.1032|
0001be  4298              CMP      r0,r3
0001c0  d101              BNE      |L1.454|
                  |L1.450|
;;;318      {
;;;319        /* Set the Repetition Counter value */
;;;320        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
0001c2  7a8b              LDRB     r3,[r1,#0xa]
0001c4  8603              STRH     r3,[r0,#0x30]
                  |L1.454|
;;;321      }
;;;322    
;;;323      /* Generate an update event to reload the Prescaler 
;;;324         and the repetition counter(only for TIM1 and TIM8) value immediatly */
;;;325      TIMx->EGR = TIM_PSCReloadMode_Immediate;          
0001c6  f04f0301          MOV      r3,#1
0001ca  8283              STRH     r3,[r0,#0x14]
;;;326    }
0001cc  4770              BX       lr
;;;327    
                          ENDP

                  TIM_TimeBaseStructInit PROC
;;;333      */
;;;334    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
0001ce  f04f31ff          MOV      r1,#0xffffffff
;;;335    {
;;;336      /* Set the default configuration */
;;;337      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
0001d2  6041              STR      r1,[r0,#4]
;;;338      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
0001d4  f04f0100          MOV      r1,#0
0001d8  8001              STRH     r1,[r0,#0]
;;;339      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
0001da  8101              STRH     r1,[r0,#8]
;;;340      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
0001dc  8041              STRH     r1,[r0,#2]
;;;341      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
0001de  7281              STRB     r1,[r0,#0xa]
;;;342    }
0001e0  4770              BX       lr
;;;343    
                          ENDP

                  TIM_PrescalerConfig PROC
;;;353      */
;;;354    void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
0001e2  8501              STRH     r1,[r0,#0x28]
;;;355    {
;;;356      /* Check the parameters */
;;;357      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;358      assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;359      /* Set the Prescaler value */
;;;360      TIMx->PSC = Prescaler;
;;;361      /* Set or reset the UG Bit */
;;;362      TIMx->EGR = TIM_PSCReloadMode;
0001e4  8282              STRH     r2,[r0,#0x14]
;;;363    }
0001e6  4770              BX       lr
;;;364    
                          ENDP

                  TIM_CounterModeConfig PROC
;;;376      */
;;;377    void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
0001e8  460a              MOV      r2,r1
;;;378    {
;;;379      uint16_t tmpcr1 = 0;
0001ea  f04f0100          MOV      r1,#0
;;;380    
;;;381      /* Check the parameters */
;;;382      assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;383      assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;384    
;;;385      tmpcr1 = TIMx->CR1;
0001ee  8801              LDRH     r1,[r0,#0]
;;;386    
;;;387      /* Reset the CMS and DIR Bits */
;;;388      tmpcr1 &= (uint16_t)~(TIM_CR1_DIR | TIM_CR1_CMS);
0001f0  f64f738f          MOV      r3,#0xff8f
0001f4  ea010103          AND      r1,r1,r3
;;;389    
;;;390      /* Set the Counter Mode */
;;;391      tmpcr1 |= TIM_CounterMode;
0001f8  ea410102          ORR      r1,r1,r2
;;;392    
;;;393      /* Write to TIMx CR1 register */
;;;394      TIMx->CR1 = tmpcr1;
0001fc  8001              STRH     r1,[r0,#0]
;;;395    }
0001fe  4770              BX       lr
;;;396    
                          ENDP

                  TIM_SetCounter PROC
;;;402      */
;;;403    void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
000200  6241              STR      r1,[r0,#0x24]
;;;404    {
;;;405      /* Check the parameters */
;;;406       assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;407    
;;;408      /* Set the Counter Register value */
;;;409      TIMx->CNT = Counter;
;;;410    }
000202  4770              BX       lr
;;;411    
                          ENDP

                  TIM_SetAutoreload PROC
;;;417      */
;;;418    void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
000204  62c1              STR      r1,[r0,#0x2c]
;;;419    {
;;;420      /* Check the parameters */
;;;421      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;422      
;;;423      /* Set the Autoreload Register value */
;;;424      TIMx->ARR = Autoreload;
;;;425    }
000206  4770              BX       lr
;;;426    
                          ENDP

                  TIM_GetCounter PROC
;;;431      */
;;;432    uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
000208  4601              MOV      r1,r0
;;;433    {
;;;434      /* Check the parameters */
;;;435      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;436    
;;;437      /* Get the Counter Register value */
;;;438      return TIMx->CNT;
00020a  6a48              LDR      r0,[r1,#0x24]
;;;439    }
00020c  4770              BX       lr
;;;440    
                          ENDP

                  TIM_GetPrescaler PROC
;;;445      */
;;;446    uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
00020e  4601              MOV      r1,r0
;;;447    {
;;;448      /* Check the parameters */
;;;449      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;450    
;;;451      /* Get the Prescaler Register value */
;;;452      return TIMx->PSC;
000210  8d08              LDRH     r0,[r1,#0x28]
;;;453    }
000212  4770              BX       lr
;;;454    
                          ENDP

                  TIM_UpdateDisableConfig PROC
;;;461      */
;;;462    void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000214  b121              CBZ      r1,|L1.544|
;;;463    {
;;;464      /* Check the parameters */
;;;465      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;466      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;467    
;;;468      if (NewState != DISABLE)
;;;469      {
;;;470        /* Set the Update Disable Bit */
;;;471        TIMx->CR1 |= TIM_CR1_UDIS;
000216  8802              LDRH     r2,[r0,#0]
000218  f0420202          ORR      r2,r2,#2
00021c  8002              STRH     r2,[r0,#0]
00021e  e005              B        |L1.556|
                  |L1.544|
;;;472      }
;;;473      else
;;;474      {
;;;475        /* Reset the Update Disable Bit */
;;;476        TIMx->CR1 &= (uint16_t)~TIM_CR1_UDIS;
000220  8802              LDRH     r2,[r0,#0]
000222  f64f73fd          MOV      r3,#0xfffd
000226  ea020203          AND      r2,r2,r3
00022a  8002              STRH     r2,[r0,#0]
                  |L1.556|
;;;477      }
;;;478    }
00022c  4770              BX       lr
;;;479    
                          ENDP

                  TIM_UpdateRequestConfig PROC
;;;490      */
;;;491    void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
00022e  b121              CBZ      r1,|L1.570|
;;;492    {
;;;493      /* Check the parameters */
;;;494      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;495      assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;496    
;;;497      if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;498      {
;;;499        /* Set the URS Bit */
;;;500        TIMx->CR1 |= TIM_CR1_URS;
000230  8802              LDRH     r2,[r0,#0]
000232  f0420204          ORR      r2,r2,#4
000236  8002              STRH     r2,[r0,#0]
000238  e005              B        |L1.582|
                  |L1.570|
;;;501      }
;;;502      else
;;;503      {
;;;504        /* Reset the URS Bit */
;;;505        TIMx->CR1 &= (uint16_t)~TIM_CR1_URS;
00023a  8802              LDRH     r2,[r0,#0]
00023c  f64f73fb          MOV      r3,#0xfffb
000240  ea020203          AND      r2,r2,r3
000244  8002              STRH     r2,[r0,#0]
                  |L1.582|
;;;506      }
;;;507    }
000246  4770              BX       lr
;;;508    
                          ENDP

                  TIM_ARRPreloadConfig PROC
;;;515      */
;;;516    void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000248  b121              CBZ      r1,|L1.596|
;;;517    {
;;;518      /* Check the parameters */
;;;519      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;520      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;521    
;;;522      if (NewState != DISABLE)
;;;523      {
;;;524        /* Set the ARR Preload Bit */
;;;525        TIMx->CR1 |= TIM_CR1_ARPE;
00024a  8802              LDRH     r2,[r0,#0]
00024c  f0420280          ORR      r2,r2,#0x80
000250  8002              STRH     r2,[r0,#0]
000252  e005              B        |L1.608|
                  |L1.596|
;;;526      }
;;;527      else
;;;528      {
;;;529        /* Reset the ARR Preload Bit */
;;;530        TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
000254  8802              LDRH     r2,[r0,#0]
000256  f64f737f          MOV      r3,#0xff7f
00025a  ea020203          AND      r2,r2,r3
00025e  8002              STRH     r2,[r0,#0]
                  |L1.608|
;;;531      }
;;;532    }
000260  4770              BX       lr
;;;533    
                          ENDP

                  TIM_SelectOnePulseMode PROC
;;;542      */
;;;543    void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
000262  8802              LDRH     r2,[r0,#0]
;;;544    {
;;;545      /* Check the parameters */
;;;546      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;547      assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;548    
;;;549      /* Reset the OPM Bit */
;;;550      TIMx->CR1 &= (uint16_t)~TIM_CR1_OPM;
000264  f64f73f7          MOV      r3,#0xfff7
000268  ea020203          AND      r2,r2,r3
00026c  8002              STRH     r2,[r0,#0]
;;;551    
;;;552      /* Configure the OPM Mode */
;;;553      TIMx->CR1 |= TIM_OPMode;
00026e  8802              LDRH     r2,[r0,#0]
000270  ea420201          ORR      r2,r2,r1
000274  8002              STRH     r2,[r0,#0]
;;;554    }
000276  4770              BX       lr
;;;555    
                          ENDP

                  TIM_SetClockDivision PROC
;;;565      */
;;;566    void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
000278  8802              LDRH     r2,[r0,#0]
;;;567    {
;;;568      /* Check the parameters */
;;;569      assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;570      assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;571    
;;;572      /* Reset the CKD Bits */
;;;573      TIMx->CR1 &= (uint16_t)(~TIM_CR1_CKD);
00027a  f64f43ff          MOV      r3,#0xfcff
00027e  ea020203          AND      r2,r2,r3
000282  8002              STRH     r2,[r0,#0]
;;;574    
;;;575      /* Set the CKD value */
;;;576      TIMx->CR1 |= TIM_CKD;
000284  8802              LDRH     r2,[r0,#0]
000286  ea420201          ORR      r2,r2,r1
00028a  8002              STRH     r2,[r0,#0]
;;;577    }
00028c  4770              BX       lr
;;;578    
                          ENDP

                  TIM_Cmd PROC
;;;585      */
;;;586    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
00028e  b121              CBZ      r1,|L1.666|
;;;587    {
;;;588      /* Check the parameters */
;;;589      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;590      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;591      
;;;592      if (NewState != DISABLE)
;;;593      {
;;;594        /* Enable the TIM Counter */
;;;595        TIMx->CR1 |= TIM_CR1_CEN;
000290  8802              LDRH     r2,[r0,#0]
000292  f0420201          ORR      r2,r2,#1
000296  8002              STRH     r2,[r0,#0]
000298  e005              B        |L1.678|
                  |L1.666|
;;;596      }
;;;597      else
;;;598      {
;;;599        /* Disable the TIM Counter */
;;;600        TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
00029a  8802              LDRH     r2,[r0,#0]
00029c  f64f73fe          MOV      r3,#0xfffe
0002a0  ea020203          AND      r2,r2,r3
0002a4  8002              STRH     r2,[r0,#0]
                  |L1.678|
;;;601      }
;;;602    }
0002a6  4770              BX       lr
;;;603    /**
                          ENDP

                  TIM_OC1Init PROC
;;;664      */
;;;665    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
0002a8  b570              PUSH     {r4-r6,lr}
;;;666    {
;;;667      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
0002aa  f04f0400          MOV      r4,#0
0002ae  4622              MOV      r2,r4
0002b0  4613              MOV      r3,r2
;;;668       
;;;669      /* Check the parameters */
;;;670      assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;671      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;672      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;673      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;674    
;;;675      /* Disable the Channel 1: Reset the CC1E Bit */
;;;676      TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
0002b2  8c05              LDRH     r5,[r0,#0x20]
0002b4  f64f76fe          MOV      r6,#0xfffe
0002b8  ea050506          AND      r5,r5,r6
0002bc  8405              STRH     r5,[r0,#0x20]
;;;677      
;;;678      /* Get the TIMx CCER register value */
;;;679      tmpccer = TIMx->CCER;
0002be  8c02              LDRH     r2,[r0,#0x20]
;;;680      /* Get the TIMx CR2 register value */
;;;681      tmpcr2 =  TIMx->CR2;
0002c0  8883              LDRH     r3,[r0,#4]
;;;682      
;;;683      /* Get the TIMx CCMR1 register value */
;;;684      tmpccmrx = TIMx->CCMR1;
0002c2  8b04              LDRH     r4,[r0,#0x18]
;;;685        
;;;686      /* Reset the Output Compare Mode Bits */
;;;687      tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
0002c4  f64f758f          MOV      r5,#0xff8f
0002c8  ea040405          AND      r4,r4,r5
;;;688      tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
0002cc  f64f75fc          MOV      r5,#0xfffc
0002d0  ea040405          AND      r4,r4,r5
;;;689      /* Select the Output Compare Mode */
;;;690      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
0002d4  880d              LDRH     r5,[r1,#0]
0002d6  ea450404          ORR      r4,r5,r4
;;;691      
;;;692      /* Reset the Output Polarity level */
;;;693      tmpccer &= (uint16_t)~TIM_CCER_CC1P;
0002da  f64f75fd          MOV      r5,#0xfffd
0002de  ea020205          AND      r2,r2,r5
;;;694      /* Set the Output Compare Polarity */
;;;695      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
0002e2  898d              LDRH     r5,[r1,#0xc]
0002e4  ea450202          ORR      r2,r5,r2
;;;696      
;;;697      /* Set the Output State */
;;;698      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
0002e8  884d              LDRH     r5,[r1,#2]
0002ea  ea450202          ORR      r2,r5,r2
;;;699        
;;;700      if((TIMx == TIM1) || (TIMx == TIM8))
0002ee  4d40              LDR      r5,|L1.1008|
0002f0  42a8              CMP      r0,r5
0002f2  d002              BEQ      |L1.762|
0002f4  4d44              LDR      r5,|L1.1032|
0002f6  42a8              CMP      r0,r5
0002f8  d11b              BNE      |L1.818|
                  |L1.762|
;;;701      {
;;;702        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;703        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;704        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;705        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;706        
;;;707        /* Reset the Output N Polarity level */
;;;708        tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
0002fa  f64f75f7          MOV      r5,#0xfff7
0002fe  ea020205          AND      r2,r2,r5
;;;709        /* Set the Output N Polarity */
;;;710        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
000302  89cd              LDRH     r5,[r1,#0xe]
000304  ea450202          ORR      r2,r5,r2
;;;711        /* Reset the Output N State */
;;;712        tmpccer &= (uint16_t)~TIM_CCER_CC1NE;
000308  f64f75fb          MOV      r5,#0xfffb
00030c  ea020205          AND      r2,r2,r5
;;;713        
;;;714        /* Set the Output N State */
;;;715        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
000310  888d              LDRH     r5,[r1,#4]
000312  ea450202          ORR      r2,r5,r2
;;;716        /* Reset the Output Compare and Output Compare N IDLE State */
;;;717        tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
000316  f64f65ff          MOV      r5,#0xfeff
00031a  ea030305          AND      r3,r3,r5
;;;718        tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
00031e  f64f55ff          MOV      r5,#0xfdff
000322  ea030305          AND      r3,r3,r5
;;;719        /* Set the Output Idle state */
;;;720        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
000326  8a0d              LDRH     r5,[r1,#0x10]
000328  ea450303          ORR      r3,r5,r3
;;;721        /* Set the Output N Idle state */
;;;722        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
00032c  8a4d              LDRH     r5,[r1,#0x12]
00032e  ea450303          ORR      r3,r5,r3
                  |L1.818|
;;;723      }
;;;724      /* Write to TIMx CR2 */
;;;725      TIMx->CR2 = tmpcr2;
000332  8083              STRH     r3,[r0,#4]
;;;726      
;;;727      /* Write to TIMx CCMR1 */
;;;728      TIMx->CCMR1 = tmpccmrx;
000334  8304              STRH     r4,[r0,#0x18]
;;;729      
;;;730      /* Set the Capture Compare Register value */
;;;731      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
000336  688d              LDR      r5,[r1,#8]
000338  6345              STR      r5,[r0,#0x34]
;;;732      
;;;733      /* Write to TIMx CCER */
;;;734      TIMx->CCER = tmpccer;
00033a  8402              STRH     r2,[r0,#0x20]
;;;735    }
00033c  bd70              POP      {r4-r6,pc}
;;;736    
                          ENDP

                  TIM_OC2Init PROC
;;;745      */
;;;746    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
00033e  b570              PUSH     {r4-r6,lr}
;;;747    {
;;;748      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000340  f04f0400          MOV      r4,#0
000344  4622              MOV      r2,r4
000346  4613              MOV      r3,r2
;;;749       
;;;750      /* Check the parameters */
;;;751      assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
;;;752      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;753      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;754      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;755    
;;;756      /* Disable the Channel 2: Reset the CC2E Bit */
;;;757      TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
000348  8c05              LDRH     r5,[r0,#0x20]
00034a  f64f76ef          MOV      r6,#0xffef
00034e  ea050506          AND      r5,r5,r6
000352  8405              STRH     r5,[r0,#0x20]
;;;758      
;;;759      /* Get the TIMx CCER register value */  
;;;760      tmpccer = TIMx->CCER;
000354  8c02              LDRH     r2,[r0,#0x20]
;;;761      /* Get the TIMx CR2 register value */
;;;762      tmpcr2 =  TIMx->CR2;
000356  8883              LDRH     r3,[r0,#4]
;;;763      
;;;764      /* Get the TIMx CCMR1 register value */
;;;765      tmpccmrx = TIMx->CCMR1;
000358  8b04              LDRH     r4,[r0,#0x18]
;;;766        
;;;767      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;768      tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
00035a  f64875ff          MOV      r5,#0x8fff
00035e  ea040405          AND      r4,r4,r5
;;;769      tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
000362  f64f45ff          MOV      r5,#0xfcff
000366  ea040405          AND      r4,r4,r5
;;;770      
;;;771      /* Select the Output Compare Mode */
;;;772      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
00036a  880d              LDRH     r5,[r1,#0]
00036c  ea4f6505          LSL      r5,r5,#24
000370  ea444415          ORR      r4,r4,r5,LSR #16
;;;773      
;;;774      /* Reset the Output Polarity level */
;;;775      tmpccer &= (uint16_t)~TIM_CCER_CC2P;
000374  f64f75df          MOV      r5,#0xffdf
000378  ea020205          AND      r2,r2,r5
;;;776      /* Set the Output Compare Polarity */
;;;777      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
00037c  898d              LDRH     r5,[r1,#0xc]
00037e  ea4f5505          LSL      r5,r5,#20
000382  ea424215          ORR      r2,r2,r5,LSR #16
;;;778      
;;;779      /* Set the Output State */
;;;780      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
000386  884d              LDRH     r5,[r1,#2]
000388  ea4f5505          LSL      r5,r5,#20
00038c  ea424215          ORR      r2,r2,r5,LSR #16
;;;781        
;;;782      if((TIMx == TIM1) || (TIMx == TIM8))
000390  4d17              LDR      r5,|L1.1008|
000392  42a8              CMP      r0,r5
000394  d002              BEQ      |L1.924|
000396  4d1c              LDR      r5,|L1.1032|
000398  42a8              CMP      r0,r5
00039a  d123              BNE      |L1.996|
                  |L1.924|
;;;783      {
;;;784        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;785        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;786        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;787        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;788        
;;;789        /* Reset the Output N Polarity level */
;;;790        tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
00039c  f64f757f          MOV      r5,#0xff7f
0003a0  ea020205          AND      r2,r2,r5
;;;791        /* Set the Output N Polarity */
;;;792        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
0003a4  89cd              LDRH     r5,[r1,#0xe]
0003a6  ea4f5505          LSL      r5,r5,#20
0003aa  ea424215          ORR      r2,r2,r5,LSR #16
;;;793        /* Reset the Output N State */
;;;794        tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
0003ae  f64f75bf          MOV      r5,#0xffbf
0003b2  ea020205          AND      r2,r2,r5
;;;795        
;;;796        /* Set the Output N State */
;;;797        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
0003b6  888d              LDRH     r5,[r1,#4]
0003b8  ea4f5505          LSL      r5,r5,#20
0003bc  ea424215          ORR      r2,r2,r5,LSR #16
;;;798        /* Reset the Output Compare and Output Compare N IDLE State */
;;;799        tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
0003c0  f64f35ff          MOV      r5,#0xfbff
0003c4  ea030305          AND      r3,r3,r5
;;;800        tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
0003c8  f24f75ff          MOV      r5,#0xf7ff
0003cc  ea030305          AND      r3,r3,r5
;;;801        /* Set the Output Idle state */
;;;802        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
0003d0  8a0d              LDRH     r5,[r1,#0x10]
0003d2  ea4f4585          LSL      r5,r5,#18
0003d6  ea434315          ORR      r3,r3,r5,LSR #16
;;;803        /* Set the Output N Idle state */
;;;804        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
0003da  8a4d              LDRH     r5,[r1,#0x12]
0003dc  ea4f4585          LSL      r5,r5,#18
0003e0  ea434315          ORR      r3,r3,r5,LSR #16
                  |L1.996|
;;;805      }
;;;806      /* Write to TIMx CR2 */
;;;807      TIMx->CR2 = tmpcr2;
0003e4  8083              STRH     r3,[r0,#4]
;;;808      
;;;809      /* Write to TIMx CCMR1 */
;;;810      TIMx->CCMR1 = tmpccmrx;
0003e6  8304              STRH     r4,[r0,#0x18]
;;;811      
;;;812      /* Set the Capture Compare Register value */
;;;813      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
0003e8  688d              LDR      r5,[r1,#8]
0003ea  6385              STR      r5,[r0,#0x38]
;;;814      
;;;815      /* Write to TIMx CCER */
;;;816      TIMx->CCER = tmpccer;
0003ec  8402              STRH     r2,[r0,#0x20]
;;;817    }
0003ee  bd70              POP      {r4-r6,pc}
                  |L1.1008|
                          DCD      0x40010000
                  |L1.1012|
                          DCD      0x40000400
                  |L1.1016|
                          DCD      0x40000800
                  |L1.1020|
                          DCD      0x40000c00
                  |L1.1024|
                          DCD      0x40001000
                  |L1.1028|
                          DCD      0x40001400
                  |L1.1032|
                          DCD      0x40010400
                  |L1.1036|
                          DCD      0x40014000
                  |L1.1040|
                          DCD      0x40014400
                  |L1.1044|
                          DCD      0x40014800
                  |L1.1048|
                          DCD      0x40001800
                  |L1.1052|
                          DCD      0x40001c00
                  |L1.1056|
                          DCD      0x40002000
                          ENDP

                  TIM_OC3Init PROC
;;;826      */
;;;827    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000424  b570              PUSH     {r4-r6,lr}
;;;828    {
;;;829      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000426  f04f0400          MOV      r4,#0
00042a  4622              MOV      r2,r4
00042c  4613              MOV      r3,r2
;;;830       
;;;831      /* Check the parameters */
;;;832      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;833      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;834      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;835      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;836    
;;;837      /* Disable the Channel 3: Reset the CC2E Bit */
;;;838      TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
00042e  8c05              LDRH     r5,[r0,#0x20]
000430  f64f66ff          MOV      r6,#0xfeff
000434  ea050506          AND      r5,r5,r6
000438  8405              STRH     r5,[r0,#0x20]
;;;839      
;;;840      /* Get the TIMx CCER register value */
;;;841      tmpccer = TIMx->CCER;
00043a  8c02              LDRH     r2,[r0,#0x20]
;;;842      /* Get the TIMx CR2 register value */
;;;843      tmpcr2 =  TIMx->CR2;
00043c  8883              LDRH     r3,[r0,#4]
;;;844      
;;;845      /* Get the TIMx CCMR2 register value */
;;;846      tmpccmrx = TIMx->CCMR2;
00043e  8b84              LDRH     r4,[r0,#0x1c]
;;;847        
;;;848      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;849      tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
000440  f64f758f          MOV      r5,#0xff8f
000444  ea040405          AND      r4,r4,r5
;;;850      tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
000448  f64f75fc          MOV      r5,#0xfffc
00044c  ea040405          AND      r4,r4,r5
;;;851      /* Select the Output Compare Mode */
;;;852      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000450  880d              LDRH     r5,[r1,#0]
000452  ea450404          ORR      r4,r5,r4
;;;853      
;;;854      /* Reset the Output Polarity level */
;;;855      tmpccer &= (uint16_t)~TIM_CCER_CC3P;
000456  f64f55ff          MOV      r5,#0xfdff
00045a  ea020205          AND      r2,r2,r5
;;;856      /* Set the Output Compare Polarity */
;;;857      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
00045e  898d              LDRH     r5,[r1,#0xc]
000460  ea4f6505          LSL      r5,r5,#24
000464  ea424215          ORR      r2,r2,r5,LSR #16
;;;858      
;;;859      /* Set the Output State */
;;;860      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
000468  884d              LDRH     r5,[r1,#2]
00046a  ea4f6505          LSL      r5,r5,#24
00046e  ea424215          ORR      r2,r2,r5,LSR #16
;;;861        
;;;862      if((TIMx == TIM1) || (TIMx == TIM8))
000472  4dfc              LDR      r5,|L1.2148|
000474  42a8              CMP      r0,r5
000476  d002              BEQ      |L1.1150|
000478  4dfb              LDR      r5,|L1.2152|
00047a  42a8              CMP      r0,r5
00047c  d123              BNE      |L1.1222|
                  |L1.1150|
;;;863      {
;;;864        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;865        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;866        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;867        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;868        
;;;869        /* Reset the Output N Polarity level */
;;;870        tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
00047e  f24f75ff          MOV      r5,#0xf7ff
000482  ea020205          AND      r2,r2,r5
;;;871        /* Set the Output N Polarity */
;;;872        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
000486  89cd              LDRH     r5,[r1,#0xe]
000488  ea4f6505          LSL      r5,r5,#24
00048c  ea424215          ORR      r2,r2,r5,LSR #16
;;;873        /* Reset the Output N State */
;;;874        tmpccer &= (uint16_t)~TIM_CCER_CC3NE;
000490  f64f35ff          MOV      r5,#0xfbff
000494  ea020205          AND      r2,r2,r5
;;;875        
;;;876        /* Set the Output N State */
;;;877        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
000498  888d              LDRH     r5,[r1,#4]
00049a  ea4f6505          LSL      r5,r5,#24
00049e  ea424215          ORR      r2,r2,r5,LSR #16
;;;878        /* Reset the Output Compare and Output Compare N IDLE State */
;;;879        tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
0004a2  f64e75ff          MOV      r5,#0xefff
0004a6  ea030305          AND      r3,r3,r5
;;;880        tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
0004aa  f64d75ff          MOV      r5,#0xdfff
0004ae  ea030305          AND      r3,r3,r5
;;;881        /* Set the Output Idle state */
;;;882        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
0004b2  8a0d              LDRH     r5,[r1,#0x10]
0004b4  ea4f5505          LSL      r5,r5,#20
0004b8  ea434315          ORR      r3,r3,r5,LSR #16
;;;883        /* Set the Output N Idle state */
;;;884        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
0004bc  8a4d              LDRH     r5,[r1,#0x12]
0004be  ea4f5505          LSL      r5,r5,#20
0004c2  ea434315          ORR      r3,r3,r5,LSR #16
                  |L1.1222|
;;;885      }
;;;886      /* Write to TIMx CR2 */
;;;887      TIMx->CR2 = tmpcr2;
0004c6  8083              STRH     r3,[r0,#4]
;;;888      
;;;889      /* Write to TIMx CCMR2 */
;;;890      TIMx->CCMR2 = tmpccmrx;
0004c8  8384              STRH     r4,[r0,#0x1c]
;;;891      
;;;892      /* Set the Capture Compare Register value */
;;;893      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
0004ca  688d              LDR      r5,[r1,#8]
0004cc  63c5              STR      r5,[r0,#0x3c]
;;;894      
;;;895      /* Write to TIMx CCER */
;;;896      TIMx->CCER = tmpccer;
0004ce  8402              STRH     r2,[r0,#0x20]
;;;897    }
0004d0  bd70              POP      {r4-r6,pc}
;;;898    
                          ENDP

                  TIM_OC4Init PROC
;;;906      */
;;;907    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
0004d2  b570              PUSH     {r4-r6,lr}
;;;908    {
;;;909      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
0004d4  f04f0200          MOV      r2,#0
0004d8  4613              MOV      r3,r2
0004da  4614              MOV      r4,r2
;;;910       
;;;911      /* Check the parameters */
;;;912      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;913      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;914      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;915      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;916    
;;;917      /* Disable the Channel 4: Reset the CC4E Bit */
;;;918      TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
0004dc  8c05              LDRH     r5,[r0,#0x20]
0004de  f64e76ff          MOV      r6,#0xefff
0004e2  ea050506          AND      r5,r5,r6
0004e6  8405              STRH     r5,[r0,#0x20]
;;;919      
;;;920      /* Get the TIMx CCER register value */
;;;921      tmpccer = TIMx->CCER;
0004e8  8c03              LDRH     r3,[r0,#0x20]
;;;922      /* Get the TIMx CR2 register value */
;;;923      tmpcr2 =  TIMx->CR2;
0004ea  8884              LDRH     r4,[r0,#4]
;;;924      
;;;925      /* Get the TIMx CCMR2 register value */
;;;926      tmpccmrx = TIMx->CCMR2;
0004ec  8b82              LDRH     r2,[r0,#0x1c]
;;;927        
;;;928      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;929      tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
0004ee  f64875ff          MOV      r5,#0x8fff
0004f2  ea020205          AND      r2,r2,r5
;;;930      tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
0004f6  f64f45ff          MOV      r5,#0xfcff
0004fa  ea020205          AND      r2,r2,r5
;;;931      
;;;932      /* Select the Output Compare Mode */
;;;933      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
0004fe  880d              LDRH     r5,[r1,#0]
000500  ea4f6505          LSL      r5,r5,#24
000504  ea424215          ORR      r2,r2,r5,LSR #16
;;;934      
;;;935      /* Reset the Output Polarity level */
;;;936      tmpccer &= (uint16_t)~TIM_CCER_CC4P;
000508  f64d75ff          MOV      r5,#0xdfff
00050c  ea030305          AND      r3,r3,r5
;;;937      /* Set the Output Compare Polarity */
;;;938      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
000510  898d              LDRH     r5,[r1,#0xc]
000512  ea4f7505          LSL      r5,r5,#28
000516  ea434315          ORR      r3,r3,r5,LSR #16
;;;939      
;;;940      /* Set the Output State */
;;;941      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
00051a  884d              LDRH     r5,[r1,#2]
00051c  ea4f7505          LSL      r5,r5,#28
000520  ea434315          ORR      r3,r3,r5,LSR #16
;;;942      
;;;943      if((TIMx == TIM1) || (TIMx == TIM8))
000524  4dcf              LDR      r5,|L1.2148|
000526  42a8              CMP      r0,r5
000528  d002              BEQ      |L1.1328|
00052a  4dcf              LDR      r5,|L1.2152|
00052c  42a8              CMP      r0,r5
00052e  d108              BNE      |L1.1346|
                  |L1.1328|
;;;944      {
;;;945        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;946        /* Reset the Output Compare IDLE State */
;;;947        tmpcr2 &=(uint16_t) ~TIM_CR2_OIS4;
000530  f64b75ff          MOV      r5,#0xbfff
000534  ea040405          AND      r4,r4,r5
;;;948        /* Set the Output Idle state */
;;;949        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
000538  8a0d              LDRH     r5,[r1,#0x10]
00053a  ea4f5585          LSL      r5,r5,#22
00053e  ea444415          ORR      r4,r4,r5,LSR #16
                  |L1.1346|
;;;950      }
;;;951      /* Write to TIMx CR2 */
;;;952      TIMx->CR2 = tmpcr2;
000542  8084              STRH     r4,[r0,#4]
;;;953      
;;;954      /* Write to TIMx CCMR2 */  
;;;955      TIMx->CCMR2 = tmpccmrx;
000544  8382              STRH     r2,[r0,#0x1c]
;;;956        
;;;957      /* Set the Capture Compare Register value */
;;;958      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
000546  688d              LDR      r5,[r1,#8]
000548  6405              STR      r5,[r0,#0x40]
;;;959      
;;;960      /* Write to TIMx CCER */
;;;961      TIMx->CCER = tmpccer;
00054a  8403              STRH     r3,[r0,#0x20]
;;;962    }
00054c  bd70              POP      {r4-r6,pc}
;;;963    
                          ENDP

                  TIM_OCStructInit PROC
;;;969      */
;;;970    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
00054e  f04f0100          MOV      r1,#0
;;;971    {
;;;972      /* Set the default configuration */
;;;973      TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
000552  8001              STRH     r1,[r0,#0]
;;;974      TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
000554  8041              STRH     r1,[r0,#2]
;;;975      TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
000556  8081              STRH     r1,[r0,#4]
;;;976      TIM_OCInitStruct->TIM_Pulse = 0x00000000;
000558  6081              STR      r1,[r0,#8]
;;;977      TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
00055a  8181              STRH     r1,[r0,#0xc]
;;;978      TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
00055c  81c1              STRH     r1,[r0,#0xe]
;;;979      TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
00055e  8201              STRH     r1,[r0,#0x10]
;;;980      TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
000560  8241              STRH     r1,[r0,#0x12]
;;;981    }
000562  4770              BX       lr
;;;982    
                          ENDP

                  TIM_SelectOCxM PROC
;;;1005     */
;;;1006   void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
000564  b570              PUSH     {r4-r6,lr}
;;;1007   {
000566  4603              MOV      r3,r0
;;;1008     uint32_t tmp = 0;
000568  f04f0000          MOV      r0,#0
;;;1009     uint16_t tmp1 = 0;
00056c  4604              MOV      r4,r0
;;;1010   
;;;1011     /* Check the parameters */
;;;1012     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1013     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;1014     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;1015   
;;;1016     tmp = (uint32_t) TIMx;
00056e  4618              MOV      r0,r3
;;;1017     tmp += CCMR_OFFSET;
000570  f1000018          ADD      r0,r0,#0x18
;;;1018   
;;;1019     tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
000574  f04f0501          MOV      r5,#1
000578  fa05f501          LSL      r5,r5,r1
00057c  b2ac              UXTH     r4,r5
;;;1020   
;;;1021     /* Disable the Channel: Reset the CCxE Bit */
;;;1022     TIMx->CCER &= (uint16_t) ~tmp1;
00057e  8c1d              LDRH     r5,[r3,#0x20]
000580  ea6f0604          MVN      r6,r4
000584  b2b6              UXTH     r6,r6
000586  ea050506          AND      r5,r5,r6
00058a  841d              STRH     r5,[r3,#0x20]
;;;1023   
;;;1024     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
00058c  b109              CBZ      r1,|L1.1426|
00058e  2908              CMP      r1,#8
000590  d10c              BNE      |L1.1452|
                  |L1.1426|
;;;1025     {
;;;1026       tmp += (TIM_Channel>>1);
000592  eb000061          ADD      r0,r0,r1,ASR #1
;;;1027   
;;;1028       /* Reset the OCxM bits in the CCMRx register */
;;;1029       *(__IO uint32_t *) tmp &= CCMR_OC13M_MASK;
000596  6805              LDR      r5,[r0,#0]
000598  f64f768f          MOV      r6,#0xff8f
00059c  ea050506          AND      r5,r5,r6
0005a0  6005              STR      r5,[r0,#0]
;;;1030      
;;;1031       /* Configure the OCxM bits in the CCMRx register */
;;;1032       *(__IO uint32_t *) tmp |= TIM_OCMode;
0005a2  6805              LDR      r5,[r0,#0]
0005a4  ea450502          ORR      r5,r5,r2
0005a8  6005              STR      r5,[r0,#0]
0005aa  e010              B        |L1.1486|
                  |L1.1452|
;;;1033     }
;;;1034     else
;;;1035     {
;;;1036       tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
0005ac  f1a10504          SUB      r5,r1,#4
0005b0  b2ad              UXTH     r5,r5
0005b2  eb000065          ADD      r0,r0,r5,ASR #1
;;;1037   
;;;1038       /* Reset the OCxM bits in the CCMRx register */
;;;1039       *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
0005b6  6805              LDR      r5,[r0,#0]
0005b8  f64876ff          MOV      r6,#0x8fff
0005bc  ea050506          AND      r5,r5,r6
0005c0  6005              STR      r5,[r0,#0]
;;;1040       
;;;1041       /* Configure the OCxM bits in the CCMRx register */
;;;1042       *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
0005c2  6805              LDR      r5,[r0,#0]
0005c4  ea4f6602          LSL      r6,r2,#24
0005c8  ea454516          ORR      r5,r5,r6,LSR #16
0005cc  6005              STR      r5,[r0,#0]
                  |L1.1486|
;;;1043     }
;;;1044   }
0005ce  bd70              POP      {r4-r6,pc}
;;;1045   
                          ENDP

                  TIM_SetCompare1 PROC
;;;1051     */
;;;1052   void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
0005d0  6341              STR      r1,[r0,#0x34]
;;;1053   {
;;;1054     /* Check the parameters */
;;;1055     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1056   
;;;1057     /* Set the Capture Compare1 Register value */
;;;1058     TIMx->CCR1 = Compare1;
;;;1059   }
0005d2  4770              BX       lr
;;;1060   
                          ENDP

                  TIM_SetCompare2 PROC
;;;1067     */
;;;1068   void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
0005d4  6381              STR      r1,[r0,#0x38]
;;;1069   {
;;;1070     /* Check the parameters */
;;;1071     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1072   
;;;1073     /* Set the Capture Compare2 Register value */
;;;1074     TIMx->CCR2 = Compare2;
;;;1075   }
0005d6  4770              BX       lr
;;;1076   
                          ENDP

                  TIM_SetCompare3 PROC
;;;1082     */
;;;1083   void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
0005d8  63c1              STR      r1,[r0,#0x3c]
;;;1084   {
;;;1085     /* Check the parameters */
;;;1086     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1087   
;;;1088     /* Set the Capture Compare3 Register value */
;;;1089     TIMx->CCR3 = Compare3;
;;;1090   }
0005da  4770              BX       lr
;;;1091   
                          ENDP

                  TIM_SetCompare4 PROC
;;;1097     */
;;;1098   void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
0005dc  6401              STR      r1,[r0,#0x40]
;;;1099   {
;;;1100     /* Check the parameters */
;;;1101     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1102   
;;;1103     /* Set the Capture Compare4 Register value */
;;;1104     TIMx->CCR4 = Compare4;
;;;1105   }
0005de  4770              BX       lr
;;;1106   
                          ENDP

                  TIM_ForcedOC1Config PROC
;;;1115     */
;;;1116   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
0005e0  460a              MOV      r2,r1
;;;1117   {
;;;1118     uint16_t tmpccmr1 = 0;
0005e2  f04f0100          MOV      r1,#0
;;;1119   
;;;1120     /* Check the parameters */
;;;1121     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1122     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1123     tmpccmr1 = TIMx->CCMR1;
0005e6  8b01              LDRH     r1,[r0,#0x18]
;;;1124   
;;;1125     /* Reset the OC1M Bits */
;;;1126     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1M;
0005e8  f64f738f          MOV      r3,#0xff8f
0005ec  ea010103          AND      r1,r1,r3
;;;1127   
;;;1128     /* Configure The Forced output Mode */
;;;1129     tmpccmr1 |= TIM_ForcedAction;
0005f0  ea410102          ORR      r1,r1,r2
;;;1130   
;;;1131     /* Write to TIMx CCMR1 register */
;;;1132     TIMx->CCMR1 = tmpccmr1;
0005f4  8301              STRH     r1,[r0,#0x18]
;;;1133   }
0005f6  4770              BX       lr
;;;1134   
                          ENDP

                  TIM_ForcedOC2Config PROC
;;;1144     */
;;;1145   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
0005f8  460a              MOV      r2,r1
;;;1146   {
;;;1147     uint16_t tmpccmr1 = 0;
0005fa  f04f0100          MOV      r1,#0
;;;1148   
;;;1149     /* Check the parameters */
;;;1150     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1151     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1152     tmpccmr1 = TIMx->CCMR1;
0005fe  8b01              LDRH     r1,[r0,#0x18]
;;;1153   
;;;1154     /* Reset the OC2M Bits */
;;;1155     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2M;
000600  f64873ff          MOV      r3,#0x8fff
000604  ea010103          AND      r1,r1,r3
;;;1156   
;;;1157     /* Configure The Forced output Mode */
;;;1158     tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
000608  ea4f6302          LSL      r3,r2,#24
00060c  ea414113          ORR      r1,r1,r3,LSR #16
;;;1159   
;;;1160     /* Write to TIMx CCMR1 register */
;;;1161     TIMx->CCMR1 = tmpccmr1;
000610  8301              STRH     r1,[r0,#0x18]
;;;1162   }
000612  4770              BX       lr
;;;1163   
                          ENDP

                  TIM_ForcedOC3Config PROC
;;;1172     */
;;;1173   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000614  460a              MOV      r2,r1
;;;1174   {
;;;1175     uint16_t tmpccmr2 = 0;
000616  f04f0100          MOV      r1,#0
;;;1176   
;;;1177     /* Check the parameters */
;;;1178     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1179     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1180   
;;;1181     tmpccmr2 = TIMx->CCMR2;
00061a  8b81              LDRH     r1,[r0,#0x1c]
;;;1182   
;;;1183     /* Reset the OC1M Bits */
;;;1184     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3M;
00061c  f64f738f          MOV      r3,#0xff8f
000620  ea010103          AND      r1,r1,r3
;;;1185   
;;;1186     /* Configure The Forced output Mode */
;;;1187     tmpccmr2 |= TIM_ForcedAction;
000624  ea410102          ORR      r1,r1,r2
;;;1188   
;;;1189     /* Write to TIMx CCMR2 register */
;;;1190     TIMx->CCMR2 = tmpccmr2;
000628  8381              STRH     r1,[r0,#0x1c]
;;;1191   }
00062a  4770              BX       lr
;;;1192   
                          ENDP

                  TIM_ForcedOC4Config PROC
;;;1201     */
;;;1202   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
00062c  460a              MOV      r2,r1
;;;1203   {
;;;1204     uint16_t tmpccmr2 = 0;
00062e  f04f0100          MOV      r1,#0
;;;1205   
;;;1206     /* Check the parameters */
;;;1207     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1208     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1209     tmpccmr2 = TIMx->CCMR2;
000632  8b81              LDRH     r1,[r0,#0x1c]
;;;1210   
;;;1211     /* Reset the OC2M Bits */
;;;1212     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4M;
000634  f64873ff          MOV      r3,#0x8fff
000638  ea010103          AND      r1,r1,r3
;;;1213   
;;;1214     /* Configure The Forced output Mode */
;;;1215     tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
00063c  ea4f6302          LSL      r3,r2,#24
000640  ea414113          ORR      r1,r1,r3,LSR #16
;;;1216   
;;;1217     /* Write to TIMx CCMR2 register */
;;;1218     TIMx->CCMR2 = tmpccmr2;
000644  8381              STRH     r1,[r0,#0x1c]
;;;1219   }
000646  4770              BX       lr
;;;1220   
                          ENDP

                  TIM_OC1PreloadConfig PROC
;;;1229     */
;;;1230   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000648  460a              MOV      r2,r1
;;;1231   {
;;;1232     uint16_t tmpccmr1 = 0;
00064a  f04f0100          MOV      r1,#0
;;;1233   
;;;1234     /* Check the parameters */
;;;1235     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1236     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1237   
;;;1238     tmpccmr1 = TIMx->CCMR1;
00064e  8b01              LDRH     r1,[r0,#0x18]
;;;1239   
;;;1240     /* Reset the OC1PE Bit */
;;;1241     tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC1PE);
000650  f64f73f7          MOV      r3,#0xfff7
000654  ea010103          AND      r1,r1,r3
;;;1242   
;;;1243     /* Enable or Disable the Output Compare Preload feature */
;;;1244     tmpccmr1 |= TIM_OCPreload;
000658  ea410102          ORR      r1,r1,r2
;;;1245   
;;;1246     /* Write to TIMx CCMR1 register */
;;;1247     TIMx->CCMR1 = tmpccmr1;
00065c  8301              STRH     r1,[r0,#0x18]
;;;1248   }
00065e  4770              BX       lr
;;;1249   
                          ENDP

                  TIM_OC2PreloadConfig PROC
;;;1259     */
;;;1260   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000660  460a              MOV      r2,r1
;;;1261   {
;;;1262     uint16_t tmpccmr1 = 0;
000662  f04f0100          MOV      r1,#0
;;;1263   
;;;1264     /* Check the parameters */
;;;1265     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1266     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1267   
;;;1268     tmpccmr1 = TIMx->CCMR1;
000666  8b01              LDRH     r1,[r0,#0x18]
;;;1269   
;;;1270     /* Reset the OC2PE Bit */
;;;1271     tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2PE);
000668  f24f73ff          MOV      r3,#0xf7ff
00066c  ea010103          AND      r1,r1,r3
;;;1272   
;;;1273     /* Enable or Disable the Output Compare Preload feature */
;;;1274     tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
000670  ea4f6302          LSL      r3,r2,#24
000674  ea414113          ORR      r1,r1,r3,LSR #16
;;;1275   
;;;1276     /* Write to TIMx CCMR1 register */
;;;1277     TIMx->CCMR1 = tmpccmr1;
000678  8301              STRH     r1,[r0,#0x18]
;;;1278   }
00067a  4770              BX       lr
;;;1279   
                          ENDP

                  TIM_OC3PreloadConfig PROC
;;;1288     */
;;;1289   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
00067c  460a              MOV      r2,r1
;;;1290   {
;;;1291     uint16_t tmpccmr2 = 0;
00067e  f04f0100          MOV      r1,#0
;;;1292   
;;;1293     /* Check the parameters */
;;;1294     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1295     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1296   
;;;1297     tmpccmr2 = TIMx->CCMR2;
000682  8b81              LDRH     r1,[r0,#0x1c]
;;;1298   
;;;1299     /* Reset the OC3PE Bit */
;;;1300     tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC3PE);
000684  f64f73f7          MOV      r3,#0xfff7
000688  ea010103          AND      r1,r1,r3
;;;1301   
;;;1302     /* Enable or Disable the Output Compare Preload feature */
;;;1303     tmpccmr2 |= TIM_OCPreload;
00068c  ea410102          ORR      r1,r1,r2
;;;1304   
;;;1305     /* Write to TIMx CCMR2 register */
;;;1306     TIMx->CCMR2 = tmpccmr2;
000690  8381              STRH     r1,[r0,#0x1c]
;;;1307   }
000692  4770              BX       lr
;;;1308   
                          ENDP

                  TIM_OC4PreloadConfig PROC
;;;1317     */
;;;1318   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000694  460a              MOV      r2,r1
;;;1319   {
;;;1320     uint16_t tmpccmr2 = 0;
000696  f04f0100          MOV      r1,#0
;;;1321   
;;;1322     /* Check the parameters */
;;;1323     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1324     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1325   
;;;1326     tmpccmr2 = TIMx->CCMR2;
00069a  8b81              LDRH     r1,[r0,#0x1c]
;;;1327   
;;;1328     /* Reset the OC4PE Bit */
;;;1329     tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4PE);
00069c  f24f73ff          MOV      r3,#0xf7ff
0006a0  ea010103          AND      r1,r1,r3
;;;1330   
;;;1331     /* Enable or Disable the Output Compare Preload feature */
;;;1332     tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
0006a4  ea4f6302          LSL      r3,r2,#24
0006a8  ea414113          ORR      r1,r1,r3,LSR #16
;;;1333   
;;;1334     /* Write to TIMx CCMR2 register */
;;;1335     TIMx->CCMR2 = tmpccmr2;
0006ac  8381              STRH     r1,[r0,#0x1c]
;;;1336   }
0006ae  4770              BX       lr
;;;1337   
                          ENDP

                  TIM_OC1FastConfig PROC
;;;1346     */
;;;1347   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
0006b0  460a              MOV      r2,r1
;;;1348   {
;;;1349     uint16_t tmpccmr1 = 0;
0006b2  f04f0100          MOV      r1,#0
;;;1350   
;;;1351     /* Check the parameters */
;;;1352     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1353     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1354   
;;;1355     /* Get the TIMx CCMR1 register value */
;;;1356     tmpccmr1 = TIMx->CCMR1;
0006b6  8b01              LDRH     r1,[r0,#0x18]
;;;1357   
;;;1358     /* Reset the OC1FE Bit */
;;;1359     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1FE;
0006b8  f64f73fb          MOV      r3,#0xfffb
0006bc  ea010103          AND      r1,r1,r3
;;;1360   
;;;1361     /* Enable or Disable the Output Compare Fast Bit */
;;;1362     tmpccmr1 |= TIM_OCFast;
0006c0  ea410102          ORR      r1,r1,r2
;;;1363   
;;;1364     /* Write to TIMx CCMR1 */
;;;1365     TIMx->CCMR1 = tmpccmr1;
0006c4  8301              STRH     r1,[r0,#0x18]
;;;1366   }
0006c6  4770              BX       lr
;;;1367   
                          ENDP

                  TIM_OC2FastConfig PROC
;;;1377     */
;;;1378   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
0006c8  460a              MOV      r2,r1
;;;1379   {
;;;1380     uint16_t tmpccmr1 = 0;
0006ca  f04f0100          MOV      r1,#0
;;;1381   
;;;1382     /* Check the parameters */
;;;1383     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1384     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1385   
;;;1386     /* Get the TIMx CCMR1 register value */
;;;1387     tmpccmr1 = TIMx->CCMR1;
0006ce  8b01              LDRH     r1,[r0,#0x18]
;;;1388   
;;;1389     /* Reset the OC2FE Bit */
;;;1390     tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2FE);
0006d0  f64f33ff          MOV      r3,#0xfbff
0006d4  ea010103          AND      r1,r1,r3
;;;1391   
;;;1392     /* Enable or Disable the Output Compare Fast Bit */
;;;1393     tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
0006d8  ea4f6302          LSL      r3,r2,#24
0006dc  ea414113          ORR      r1,r1,r3,LSR #16
;;;1394   
;;;1395     /* Write to TIMx CCMR1 */
;;;1396     TIMx->CCMR1 = tmpccmr1;
0006e0  8301              STRH     r1,[r0,#0x18]
;;;1397   }
0006e2  4770              BX       lr
;;;1398   
                          ENDP

                  TIM_OC3FastConfig PROC
;;;1407     */
;;;1408   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
0006e4  460a              MOV      r2,r1
;;;1409   {
;;;1410     uint16_t tmpccmr2 = 0;
0006e6  f04f0100          MOV      r1,#0
;;;1411     
;;;1412     /* Check the parameters */
;;;1413     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1414     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1415   
;;;1416     /* Get the TIMx CCMR2 register value */
;;;1417     tmpccmr2 = TIMx->CCMR2;
0006ea  8b81              LDRH     r1,[r0,#0x1c]
;;;1418   
;;;1419     /* Reset the OC3FE Bit */
;;;1420     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3FE;
0006ec  f64f73fb          MOV      r3,#0xfffb
0006f0  ea010103          AND      r1,r1,r3
;;;1421   
;;;1422     /* Enable or Disable the Output Compare Fast Bit */
;;;1423     tmpccmr2 |= TIM_OCFast;
0006f4  ea410102          ORR      r1,r1,r2
;;;1424   
;;;1425     /* Write to TIMx CCMR2 */
;;;1426     TIMx->CCMR2 = tmpccmr2;
0006f8  8381              STRH     r1,[r0,#0x1c]
;;;1427   }
0006fa  4770              BX       lr
;;;1428   
                          ENDP

                  TIM_OC4FastConfig PROC
;;;1437     */
;;;1438   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
0006fc  460a              MOV      r2,r1
;;;1439   {
;;;1440     uint16_t tmpccmr2 = 0;
0006fe  f04f0100          MOV      r1,#0
;;;1441   
;;;1442     /* Check the parameters */
;;;1443     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1444     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1445   
;;;1446     /* Get the TIMx CCMR2 register value */
;;;1447     tmpccmr2 = TIMx->CCMR2;
000702  8b81              LDRH     r1,[r0,#0x1c]
;;;1448   
;;;1449     /* Reset the OC4FE Bit */
;;;1450     tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4FE);
000704  f64f33ff          MOV      r3,#0xfbff
000708  ea010103          AND      r1,r1,r3
;;;1451   
;;;1452     /* Enable or Disable the Output Compare Fast Bit */
;;;1453     tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
00070c  ea4f6302          LSL      r3,r2,#24
000710  ea414113          ORR      r1,r1,r3,LSR #16
;;;1454   
;;;1455     /* Write to TIMx CCMR2 */
;;;1456     TIMx->CCMR2 = tmpccmr2;
000714  8381              STRH     r1,[r0,#0x1c]
;;;1457   }
000716  4770              BX       lr
;;;1458   
                          ENDP

                  TIM_ClearOC1Ref PROC
;;;1467     */
;;;1468   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000718  460a              MOV      r2,r1
;;;1469   {
;;;1470     uint16_t tmpccmr1 = 0;
00071a  f04f0100          MOV      r1,#0
;;;1471   
;;;1472     /* Check the parameters */
;;;1473     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1474     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1475   
;;;1476     tmpccmr1 = TIMx->CCMR1;
00071e  8b01              LDRH     r1,[r0,#0x18]
;;;1477   
;;;1478     /* Reset the OC1CE Bit */
;;;1479     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1CE;
000720  f64f737f          MOV      r3,#0xff7f
000724  ea010103          AND      r1,r1,r3
;;;1480   
;;;1481     /* Enable or Disable the Output Compare Clear Bit */
;;;1482     tmpccmr1 |= TIM_OCClear;
000728  ea410102          ORR      r1,r1,r2
;;;1483   
;;;1484     /* Write to TIMx CCMR1 register */
;;;1485     TIMx->CCMR1 = tmpccmr1;
00072c  8301              STRH     r1,[r0,#0x18]
;;;1486   }
00072e  4770              BX       lr
;;;1487   
                          ENDP

                  TIM_ClearOC2Ref PROC
;;;1497     */
;;;1498   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000730  460a              MOV      r2,r1
;;;1499   {
;;;1500     uint16_t tmpccmr1 = 0;
000732  f04f0100          MOV      r1,#0
;;;1501   
;;;1502     /* Check the parameters */
;;;1503     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1504     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1505   
;;;1506     tmpccmr1 = TIMx->CCMR1;
000736  8b01              LDRH     r1,[r0,#0x18]
;;;1507   
;;;1508     /* Reset the OC2CE Bit */
;;;1509     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2CE;
000738  f3c1010e          UBFX     r1,r1,#0,#15
;;;1510   
;;;1511     /* Enable or Disable the Output Compare Clear Bit */
;;;1512     tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
00073c  ea4f6302          LSL      r3,r2,#24
000740  ea414113          ORR      r1,r1,r3,LSR #16
;;;1513   
;;;1514     /* Write to TIMx CCMR1 register */
;;;1515     TIMx->CCMR1 = tmpccmr1;
000744  8301              STRH     r1,[r0,#0x18]
;;;1516   }
000746  4770              BX       lr
;;;1517   
                          ENDP

                  TIM_ClearOC3Ref PROC
;;;1526     */
;;;1527   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000748  460a              MOV      r2,r1
;;;1528   {
;;;1529     uint16_t tmpccmr2 = 0;
00074a  f04f0100          MOV      r1,#0
;;;1530   
;;;1531     /* Check the parameters */
;;;1532     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1533     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1534   
;;;1535     tmpccmr2 = TIMx->CCMR2;
00074e  8b81              LDRH     r1,[r0,#0x1c]
;;;1536   
;;;1537     /* Reset the OC3CE Bit */
;;;1538     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3CE;
000750  f64f737f          MOV      r3,#0xff7f
000754  ea010103          AND      r1,r1,r3
;;;1539   
;;;1540     /* Enable or Disable the Output Compare Clear Bit */
;;;1541     tmpccmr2 |= TIM_OCClear;
000758  ea410102          ORR      r1,r1,r2
;;;1542   
;;;1543     /* Write to TIMx CCMR2 register */
;;;1544     TIMx->CCMR2 = tmpccmr2;
00075c  8381              STRH     r1,[r0,#0x1c]
;;;1545   }
00075e  4770              BX       lr
;;;1546   
                          ENDP

                  TIM_ClearOC4Ref PROC
;;;1555     */
;;;1556   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000760  460a              MOV      r2,r1
;;;1557   {
;;;1558     uint16_t tmpccmr2 = 0;
000762  f04f0100          MOV      r1,#0
;;;1559   
;;;1560     /* Check the parameters */
;;;1561     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1562     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1563   
;;;1564     tmpccmr2 = TIMx->CCMR2;
000766  8b81              LDRH     r1,[r0,#0x1c]
;;;1565   
;;;1566     /* Reset the OC4CE Bit */
;;;1567     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4CE;
000768  f3c1010e          UBFX     r1,r1,#0,#15
;;;1568   
;;;1569     /* Enable or Disable the Output Compare Clear Bit */
;;;1570     tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
00076c  ea4f6302          LSL      r3,r2,#24
000770  ea414113          ORR      r1,r1,r3,LSR #16
;;;1571   
;;;1572     /* Write to TIMx CCMR2 register */
;;;1573     TIMx->CCMR2 = tmpccmr2;
000774  8381              STRH     r1,[r0,#0x1c]
;;;1574   }
000776  4770              BX       lr
;;;1575   
                          ENDP

                  TIM_OC1PolarityConfig PROC
;;;1584     */
;;;1585   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000778  460a              MOV      r2,r1
;;;1586   {
;;;1587     uint16_t tmpccer = 0;
00077a  f04f0100          MOV      r1,#0
;;;1588   
;;;1589     /* Check the parameters */
;;;1590     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1591     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1592   
;;;1593     tmpccer = TIMx->CCER;
00077e  8c01              LDRH     r1,[r0,#0x20]
;;;1594   
;;;1595     /* Set or Reset the CC1P Bit */
;;;1596     tmpccer &= (uint16_t)(~TIM_CCER_CC1P);
000780  f64f73fd          MOV      r3,#0xfffd
000784  ea010103          AND      r1,r1,r3
;;;1597     tmpccer |= TIM_OCPolarity;
000788  ea410102          ORR      r1,r1,r2
;;;1598   
;;;1599     /* Write to TIMx CCER register */
;;;1600     TIMx->CCER = tmpccer;
00078c  8401              STRH     r1,[r0,#0x20]
;;;1601   }
00078e  4770              BX       lr
;;;1602   
                          ENDP

                  TIM_OC1NPolarityConfig PROC
;;;1611     */
;;;1612   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000790  460a              MOV      r2,r1
;;;1613   {
;;;1614     uint16_t tmpccer = 0;
000792  f04f0100          MOV      r1,#0
;;;1615     /* Check the parameters */
;;;1616     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1617     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1618      
;;;1619     tmpccer = TIMx->CCER;
000796  8c01              LDRH     r1,[r0,#0x20]
;;;1620   
;;;1621     /* Set or Reset the CC1NP Bit */
;;;1622     tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
000798  f64f73f7          MOV      r3,#0xfff7
00079c  ea010103          AND      r1,r1,r3
;;;1623     tmpccer |= TIM_OCNPolarity;
0007a0  ea410102          ORR      r1,r1,r2
;;;1624   
;;;1625     /* Write to TIMx CCER register */
;;;1626     TIMx->CCER = tmpccer;
0007a4  8401              STRH     r1,[r0,#0x20]
;;;1627   }
0007a6  4770              BX       lr
;;;1628   
                          ENDP

                  TIM_OC2PolarityConfig PROC
;;;1638     */
;;;1639   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
0007a8  460a              MOV      r2,r1
;;;1640   {
;;;1641     uint16_t tmpccer = 0;
0007aa  f04f0100          MOV      r1,#0
;;;1642   
;;;1643     /* Check the parameters */
;;;1644     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1645     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1646   
;;;1647     tmpccer = TIMx->CCER;
0007ae  8c01              LDRH     r1,[r0,#0x20]
;;;1648   
;;;1649     /* Set or Reset the CC2P Bit */
;;;1650     tmpccer &= (uint16_t)(~TIM_CCER_CC2P);
0007b0  f64f73df          MOV      r3,#0xffdf
0007b4  ea010103          AND      r1,r1,r3
;;;1651     tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
0007b8  ea4f5302          LSL      r3,r2,#20
0007bc  ea414113          ORR      r1,r1,r3,LSR #16
;;;1652   
;;;1653     /* Write to TIMx CCER register */
;;;1654     TIMx->CCER = tmpccer;
0007c0  8401              STRH     r1,[r0,#0x20]
;;;1655   }
0007c2  4770              BX       lr
;;;1656   
                          ENDP

                  TIM_OC2NPolarityConfig PROC
;;;1665     */
;;;1666   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
0007c4  460a              MOV      r2,r1
;;;1667   {
;;;1668     uint16_t tmpccer = 0;
0007c6  f04f0100          MOV      r1,#0
;;;1669   
;;;1670     /* Check the parameters */
;;;1671     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1672     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1673     
;;;1674     tmpccer = TIMx->CCER;
0007ca  8c01              LDRH     r1,[r0,#0x20]
;;;1675   
;;;1676     /* Set or Reset the CC2NP Bit */
;;;1677     tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
0007cc  f64f737f          MOV      r3,#0xff7f
0007d0  ea010103          AND      r1,r1,r3
;;;1678     tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
0007d4  ea4f5302          LSL      r3,r2,#20
0007d8  ea414113          ORR      r1,r1,r3,LSR #16
;;;1679   
;;;1680     /* Write to TIMx CCER register */
;;;1681     TIMx->CCER = tmpccer;
0007dc  8401              STRH     r1,[r0,#0x20]
;;;1682   }
0007de  4770              BX       lr
;;;1683   
                          ENDP

                  TIM_OC3PolarityConfig PROC
;;;1692     */
;;;1693   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
0007e0  460a              MOV      r2,r1
;;;1694   {
;;;1695     uint16_t tmpccer = 0;
0007e2  f04f0100          MOV      r1,#0
;;;1696   
;;;1697     /* Check the parameters */
;;;1698     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1699     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1700   
;;;1701     tmpccer = TIMx->CCER;
0007e6  8c01              LDRH     r1,[r0,#0x20]
;;;1702   
;;;1703     /* Set or Reset the CC3P Bit */
;;;1704     tmpccer &= (uint16_t)~TIM_CCER_CC3P;
0007e8  f64f53ff          MOV      r3,#0xfdff
0007ec  ea010103          AND      r1,r1,r3
;;;1705     tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
0007f0  ea4f6302          LSL      r3,r2,#24
0007f4  ea414113          ORR      r1,r1,r3,LSR #16
;;;1706   
;;;1707     /* Write to TIMx CCER register */
;;;1708     TIMx->CCER = tmpccer;
0007f8  8401              STRH     r1,[r0,#0x20]
;;;1709   }
0007fa  4770              BX       lr
;;;1710   
                          ENDP

                  TIM_OC3NPolarityConfig PROC
;;;1719     */
;;;1720   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
0007fc  460a              MOV      r2,r1
;;;1721   {
;;;1722     uint16_t tmpccer = 0;
0007fe  f04f0100          MOV      r1,#0
;;;1723    
;;;1724     /* Check the parameters */
;;;1725     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1726     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1727       
;;;1728     tmpccer = TIMx->CCER;
000802  8c01              LDRH     r1,[r0,#0x20]
;;;1729   
;;;1730     /* Set or Reset the CC3NP Bit */
;;;1731     tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
000804  f24f73ff          MOV      r3,#0xf7ff
000808  ea010103          AND      r1,r1,r3
;;;1732     tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
00080c  ea4f6302          LSL      r3,r2,#24
000810  ea414113          ORR      r1,r1,r3,LSR #16
;;;1733   
;;;1734     /* Write to TIMx CCER register */
;;;1735     TIMx->CCER = tmpccer;
000814  8401              STRH     r1,[r0,#0x20]
;;;1736   }
000816  4770              BX       lr
;;;1737   
                          ENDP

                  TIM_OC4PolarityConfig PROC
;;;1746     */
;;;1747   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000818  460a              MOV      r2,r1
;;;1748   {
;;;1749     uint16_t tmpccer = 0;
00081a  f04f0100          MOV      r1,#0
;;;1750   
;;;1751     /* Check the parameters */
;;;1752     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1753     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1754   
;;;1755     tmpccer = TIMx->CCER;
00081e  8c01              LDRH     r1,[r0,#0x20]
;;;1756   
;;;1757     /* Set or Reset the CC4P Bit */
;;;1758     tmpccer &= (uint16_t)~TIM_CCER_CC4P;
000820  f64d73ff          MOV      r3,#0xdfff
000824  ea010103          AND      r1,r1,r3
;;;1759     tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
000828  ea4f7302          LSL      r3,r2,#28
00082c  ea414113          ORR      r1,r1,r3,LSR #16
;;;1760   
;;;1761     /* Write to TIMx CCER register */
;;;1762     TIMx->CCER = tmpccer;
000830  8401              STRH     r1,[r0,#0x20]
;;;1763   }
000832  4770              BX       lr
;;;1764   
                          ENDP

                  TIM_CCxCmd PROC
;;;1777     */
;;;1778   void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
000834  b530              PUSH     {r4,r5,lr}
;;;1779   {
;;;1780     uint16_t tmp = 0;
000836  f04f0300          MOV      r3,#0
;;;1781   
;;;1782     /* Check the parameters */
;;;1783     assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;1784     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;1785     assert_param(IS_TIM_CCX(TIM_CCx));
;;;1786   
;;;1787     tmp = CCER_CCE_SET << TIM_Channel;
00083a  f04f0401          MOV      r4,#1
00083e  fa04f401          LSL      r4,r4,r1
000842  b2a3              UXTH     r3,r4
;;;1788   
;;;1789     /* Reset the CCxE Bit */
;;;1790     TIMx->CCER &= (uint16_t)~ tmp;
000844  8c04              LDRH     r4,[r0,#0x20]
000846  ea6f0503          MVN      r5,r3
00084a  b2ad              UXTH     r5,r5
00084c  ea040405          AND      r4,r4,r5
000850  8404              STRH     r4,[r0,#0x20]
;;;1791   
;;;1792     /* Set or reset the CCxE Bit */ 
;;;1793     TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
000852  8c04              LDRH     r4,[r0,#0x20]
000854  fa02f501          LSL      r5,r2,r1
000858  b2ad              UXTH     r5,r5
00085a  ea440405          ORR      r4,r4,r5
00085e  8404              STRH     r4,[r0,#0x20]
;;;1794   }
000860  bd30              POP      {r4,r5,pc}
000862  0000              DCW      0x0000
                  |L1.2148|
                          DCD      0x40010000
                  |L1.2152|
                          DCD      0x40010400
                          ENDP

                  TIM_CCxNCmd PROC
;;;1807     */
;;;1808   void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
00086c  b530              PUSH     {r4,r5,lr}
;;;1809   {
;;;1810     uint16_t tmp = 0;
00086e  f04f0300          MOV      r3,#0
;;;1811   
;;;1812     /* Check the parameters */
;;;1813     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1814     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;1815     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;1816   
;;;1817     tmp = CCER_CCNE_SET << TIM_Channel;
000872  f04f0404          MOV      r4,#4
000876  fa04f401          LSL      r4,r4,r1
00087a  b2a3              UXTH     r3,r4
;;;1818   
;;;1819     /* Reset the CCxNE Bit */
;;;1820     TIMx->CCER &= (uint16_t) ~tmp;
00087c  8c04              LDRH     r4,[r0,#0x20]
00087e  ea6f0503          MVN      r5,r3
000882  b2ad              UXTH     r5,r5
000884  ea040405          AND      r4,r4,r5
000888  8404              STRH     r4,[r0,#0x20]
;;;1821   
;;;1822     /* Set or reset the CCxNE Bit */ 
;;;1823     TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
00088a  8c04              LDRH     r4,[r0,#0x20]
00088c  fa02f501          LSL      r5,r2,r1
000890  b2ad              UXTH     r5,r5
000892  ea440405          ORR      r4,r4,r5
000896  8404              STRH     r4,[r0,#0x20]
;;;1824   }
000898  bd30              POP      {r4,r5,pc}
;;;1825   /**
                          ENDP

                  TIM_SetIC4Prescaler PROC
;;;2154     */
;;;2155   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
00089a  8b82              LDRH     r2,[r0,#0x1c]
;;;2156   {  
;;;2157     /* Check the parameters */
;;;2158     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2159     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2160   
;;;2161     /* Reset the IC4PSC Bits */
;;;2162     TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC;
00089c  f24f33ff          MOV      r3,#0xf3ff
0008a0  ea020203          AND      r2,r2,r3
0008a4  8382              STRH     r2,[r0,#0x1c]
;;;2163   
;;;2164     /* Set the IC4PSC value */
;;;2165     TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
0008a6  8b82              LDRH     r2,[r0,#0x1c]
0008a8  ea4f6301          LSL      r3,r1,#24
0008ac  ea424213          ORR      r2,r2,r3,LSR #16
0008b0  8382              STRH     r2,[r0,#0x1c]
;;;2166   }
0008b2  4770              BX       lr
;;;2167   /**
                          ENDP

                  TI4_Config PROC
;;;3311     */
;;;3312   static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
0008b4  b5f0              PUSH     {r4-r7,lr}
;;;3313                          uint16_t TIM_ICFilter)
;;;3314   {
0008b6  460c              MOV      r4,r1
0008b8  4615              MOV      r5,r2
;;;3315     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
0008ba  f04f0100          MOV      r1,#0
0008be  460a              MOV      r2,r1
0008c0  460e              MOV      r6,r1
;;;3316   
;;;3317     /* Disable the Channel 4: Reset the CC4E Bit */
;;;3318     TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
0008c2  8c07              LDRH     r7,[r0,#0x20]
0008c4  f64e7cff          MOV      r12,#0xefff
0008c8  ea07070c          AND      r7,r7,r12
0008cc  8407              STRH     r7,[r0,#0x20]
;;;3319     tmpccmr2 = TIMx->CCMR2;
0008ce  8b81              LDRH     r1,[r0,#0x1c]
;;;3320     tmpccer = TIMx->CCER;
0008d0  8c02              LDRH     r2,[r0,#0x20]
;;;3321     tmp = (uint16_t)(TIM_ICPolarity << 12);
0008d2  ea4f7704          LSL      r7,r4,#28
0008d6  ea4f4617          LSR      r6,r7,#16
;;;3322   
;;;3323     /* Select the Input and set the filter */
;;;3324     tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
0008da  f64047ff          MOV      r7,#0xcff
0008de  ea010107          AND      r1,r1,r7
;;;3325     tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
0008e2  ea4f6705          LSL      r7,r5,#24
0008e6  ea414117          ORR      r1,r1,r7,LSR #16
;;;3326     tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
0008ea  ea4f7703          LSL      r7,r3,#28
0008ee  ea414117          ORR      r1,r1,r7,LSR #16
;;;3327   
;;;3328     /* Select the Polarity and set the CC4E Bit */
;;;3329     tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
0008f2  f64577ff          MOV      r7,#0x5fff
0008f6  ea020207          AND      r2,r2,r7
;;;3330     tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
0008fa  f4465780          ORR      r7,r6,#0x1000
0008fe  ea470202          ORR      r2,r7,r2
;;;3331   
;;;3332     /* Write to TIMx CCMR2 and CCER registers */
;;;3333     TIMx->CCMR2 = tmpccmr2;
000902  8381              STRH     r1,[r0,#0x1c]
;;;3334     TIMx->CCER = tmpccer ;
000904  8402              STRH     r2,[r0,#0x20]
;;;3335   }
000906  bdf0              POP      {r4-r7,pc}
;;;3336   
                          ENDP

                  TIM_SetIC3Prescaler PROC
;;;2130     */
;;;2131   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000908  8b82              LDRH     r2,[r0,#0x1c]
;;;2132   {
;;;2133     /* Check the parameters */
;;;2134     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2135     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2136   
;;;2137     /* Reset the IC3PSC Bits */
;;;2138     TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC;
00090a  f64f73f3          MOV      r3,#0xfff3
00090e  ea020203          AND      r2,r2,r3
000912  8382              STRH     r2,[r0,#0x1c]
;;;2139   
;;;2140     /* Set the IC3PSC value */
;;;2141     TIMx->CCMR2 |= TIM_ICPSC;
000914  8b82              LDRH     r2,[r0,#0x1c]
000916  ea420201          ORR      r2,r2,r1
00091a  8382              STRH     r2,[r0,#0x1c]
;;;2142   }
00091c  4770              BX       lr
;;;2143   
                          ENDP

                  TI3_Config PROC
;;;3270     */
;;;3271   static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
00091e  b5f0              PUSH     {r4-r7,lr}
;;;3272                          uint16_t TIM_ICFilter)
;;;3273   {
000920  460c              MOV      r4,r1
000922  4615              MOV      r5,r2
;;;3274     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000924  f04f0100          MOV      r1,#0
000928  460a              MOV      r2,r1
00092a  460e              MOV      r6,r1
;;;3275   
;;;3276     /* Disable the Channel 3: Reset the CC3E Bit */
;;;3277     TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
00092c  8c07              LDRH     r7,[r0,#0x20]
00092e  f64f6cff          MOV      r12,#0xfeff
000932  ea07070c          AND      r7,r7,r12
000936  8407              STRH     r7,[r0,#0x20]
;;;3278     tmpccmr2 = TIMx->CCMR2;
000938  8b81              LDRH     r1,[r0,#0x1c]
;;;3279     tmpccer = TIMx->CCER;
00093a  8c02              LDRH     r2,[r0,#0x20]
;;;3280     tmp = (uint16_t)(TIM_ICPolarity << 8);
00093c  ea4f6704          LSL      r7,r4,#24
000940  ea4f4617          LSR      r6,r7,#16
;;;3281   
;;;3282     /* Select the Input and set the filter */
;;;3283     tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
000944  f64f770c          MOV      r7,#0xff0c
000948  ea010107          AND      r1,r1,r7
;;;3284     tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
00094c  ea4f5703          LSL      r7,r3,#20
000950  ea454717          ORR      r7,r5,r7,LSR #16
000954  ea470101          ORR      r1,r7,r1
;;;3285   
;;;3286     /* Select the Polarity and set the CC3E Bit */
;;;3287     tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
000958  f24f57ff          MOV      r7,#0xf5ff
00095c  ea020207          AND      r2,r2,r7
;;;3288     tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
000960  f4467780          ORR      r7,r6,#0x100
000964  ea470202          ORR      r2,r7,r2
;;;3289   
;;;3290     /* Write to TIMx CCMR2 and CCER registers */
;;;3291     TIMx->CCMR2 = tmpccmr2;
000968  8381              STRH     r1,[r0,#0x1c]
;;;3292     TIMx->CCER = tmpccer;
00096a  8402              STRH     r2,[r0,#0x20]
;;;3293   }
00096c  bdf0              POP      {r4-r7,pc}
;;;3294   
                          ENDP

                  TIM_SetIC2Prescaler PROC
;;;2106     */
;;;2107   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
00096e  8b02              LDRH     r2,[r0,#0x18]
;;;2108   {
;;;2109     /* Check the parameters */
;;;2110     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2111     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2112   
;;;2113     /* Reset the IC2PSC Bits */
;;;2114     TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC;
000970  f24f33ff          MOV      r3,#0xf3ff
000974  ea020203          AND      r2,r2,r3
000978  8302              STRH     r2,[r0,#0x18]
;;;2115   
;;;2116     /* Set the IC2PSC value */
;;;2117     TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
00097a  8b02              LDRH     r2,[r0,#0x18]
00097c  ea4f6301          LSL      r3,r1,#24
000980  ea424213          ORR      r2,r2,r3,LSR #16
000984  8302              STRH     r2,[r0,#0x18]
;;;2118   }
000986  4770              BX       lr
;;;2119   
                          ENDP

                  TI2_Config PROC
;;;3228     */
;;;3229   static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000988  b5f0              PUSH     {r4-r7,lr}
;;;3230                          uint16_t TIM_ICFilter)
;;;3231   {
00098a  460c              MOV      r4,r1
00098c  4615              MOV      r5,r2
;;;3232     uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
00098e  f04f0100          MOV      r1,#0
000992  460a              MOV      r2,r1
000994  460e              MOV      r6,r1
;;;3233   
;;;3234     /* Disable the Channel 2: Reset the CC2E Bit */
;;;3235     TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
000996  8c07              LDRH     r7,[r0,#0x20]
000998  f64f7cef          MOV      r12,#0xffef
00099c  ea07070c          AND      r7,r7,r12
0009a0  8407              STRH     r7,[r0,#0x20]
;;;3236     tmpccmr1 = TIMx->CCMR1;
0009a2  8b01              LDRH     r1,[r0,#0x18]
;;;3237     tmpccer = TIMx->CCER;
0009a4  8c02              LDRH     r2,[r0,#0x20]
;;;3238     tmp = (uint16_t)(TIM_ICPolarity << 4);
0009a6  ea4f5704          LSL      r7,r4,#20
0009aa  ea4f4617          LSR      r6,r7,#16
;;;3239   
;;;3240     /* Select the Input and set the filter */
;;;3241     tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
0009ae  f64047ff          MOV      r7,#0xcff
0009b2  ea010107          AND      r1,r1,r7
;;;3242     tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
0009b6  ea4f7703          LSL      r7,r3,#28
0009ba  ea414117          ORR      r1,r1,r7,LSR #16
;;;3243     tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
0009be  ea4f6705          LSL      r7,r5,#24
0009c2  ea414117          ORR      r1,r1,r7,LSR #16
;;;3244   
;;;3245     /* Select the Polarity and set the CC2E Bit */
;;;3246     tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
0009c6  f64f775f          MOV      r7,#0xff5f
0009ca  ea020207          AND      r2,r2,r7
;;;3247     tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
0009ce  f0460710          ORR      r7,r6,#0x10
0009d2  ea470202          ORR      r2,r7,r2
;;;3248   
;;;3249     /* Write to TIMx CCMR1 and CCER registers */
;;;3250     TIMx->CCMR1 = tmpccmr1 ;
0009d6  8301              STRH     r1,[r0,#0x18]
;;;3251     TIMx->CCER = tmpccer;
0009d8  8402              STRH     r2,[r0,#0x20]
;;;3252   }
0009da  bdf0              POP      {r4-r7,pc}
;;;3253   
                          ENDP

                  TIM_SetIC1Prescaler PROC
;;;2081     */
;;;2082   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
0009dc  8b02              LDRH     r2,[r0,#0x18]
;;;2083   {
;;;2084     /* Check the parameters */
;;;2085     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2086     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2087   
;;;2088     /* Reset the IC1PSC Bits */
;;;2089     TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC;
0009de  f64f73f3          MOV      r3,#0xfff3
0009e2  ea020203          AND      r2,r2,r3
0009e6  8302              STRH     r2,[r0,#0x18]
;;;2090   
;;;2091     /* Set the IC1PSC value */
;;;2092     TIMx->CCMR1 |= TIM_ICPSC;
0009e8  8b02              LDRH     r2,[r0,#0x18]
0009ea  ea420201          ORR      r2,r2,r1
0009ee  8302              STRH     r2,[r0,#0x18]
;;;2093   }
0009f0  4770              BX       lr
;;;2094   
                          ENDP

                  TI1_Config PROC
;;;3187     */
;;;3188   static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
0009f2  b5f0              PUSH     {r4-r7,lr}
;;;3189                          uint16_t TIM_ICFilter)
;;;3190   {
0009f4  460c              MOV      r4,r1
0009f6  4615              MOV      r5,r2
;;;3191     uint16_t tmpccmr1 = 0, tmpccer = 0;
0009f8  f04f0100          MOV      r1,#0
0009fc  460a              MOV      r2,r1
;;;3192   
;;;3193     /* Disable the Channel 1: Reset the CC1E Bit */
;;;3194     TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
0009fe  8c06              LDRH     r6,[r0,#0x20]
000a00  f64f77fe          MOV      r7,#0xfffe
000a04  ea060607          AND      r6,r6,r7
000a08  8406              STRH     r6,[r0,#0x20]
;;;3195     tmpccmr1 = TIMx->CCMR1;
000a0a  8b01              LDRH     r1,[r0,#0x18]
;;;3196     tmpccer = TIMx->CCER;
000a0c  8c02              LDRH     r2,[r0,#0x20]
;;;3197   
;;;3198     /* Select the Input and set the filter */
;;;3199     tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
000a0e  f64f760c          MOV      r6,#0xff0c
000a12  ea010106          AND      r1,r1,r6
;;;3200     tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
000a16  ea4f5603          LSL      r6,r3,#20
000a1a  ea454616          ORR      r6,r5,r6,LSR #16
000a1e  ea460101          ORR      r1,r6,r1
;;;3201   
;;;3202     /* Select the Polarity and set the CC1E Bit */
;;;3203     tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
000a22  f64f76f5          MOV      r6,#0xfff5
000a26  ea020206          AND      r2,r2,r6
;;;3204     tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
000a2a  f0440601          ORR      r6,r4,#1
000a2e  ea460202          ORR      r2,r6,r2
;;;3205   
;;;3206     /* Write to TIMx CCMR1 and CCER registers */
;;;3207     TIMx->CCMR1 = tmpccmr1;
000a32  8301              STRH     r1,[r0,#0x18]
;;;3208     TIMx->CCER = tmpccer;
000a34  8402              STRH     r2,[r0,#0x20]
;;;3209   }
000a36  bdf0              POP      {r4-r7,pc}
;;;3210   
                          ENDP

                  TIM_ICInit PROC
;;;1889     */
;;;1890   void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000a38  b570              PUSH     {r4-r6,lr}
;;;1891   {
000a3a  4605              MOV      r5,r0
000a3c  460c              MOV      r4,r1
;;;1892     /* Check the parameters */
;;;1893     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1894     assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;1895     assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;1896     assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;1897     assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;1898     
;;;1899     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000a3e  8820              LDRH     r0,[r4,#0]
000a40  b950              CBNZ     r0,|L1.2648|
;;;1900     {
;;;1901       /* TI1 Configuration */
;;;1902       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000a42  8923              LDRH     r3,[r4,#8]
000a44  88a2              LDRH     r2,[r4,#4]
000a46  8861              LDRH     r1,[r4,#2]
000a48  4628              MOV      r0,r5
000a4a  f7fffffe          BL       TI1_Config
;;;1903                  TIM_ICInitStruct->TIM_ICSelection,
;;;1904                  TIM_ICInitStruct->TIM_ICFilter);
;;;1905       /* Set the Input Capture Prescaler value */
;;;1906       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000a4e  88e1              LDRH     r1,[r4,#6]
000a50  4628              MOV      r0,r5
000a52  f7fffffe          BL       TIM_SetIC1Prescaler
000a56  e025              B        |L1.2724|
                  |L1.2648|
;;;1907     }
;;;1908     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
000a58  8820              LDRH     r0,[r4,#0]
000a5a  2804              CMP      r0,#4
000a5c  d10a              BNE      |L1.2676|
;;;1909     {
;;;1910       /* TI2 Configuration */
;;;1911       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000a5e  8923              LDRH     r3,[r4,#8]
000a60  88a2              LDRH     r2,[r4,#4]
000a62  8861              LDRH     r1,[r4,#2]
000a64  4628              MOV      r0,r5
000a66  f7fffffe          BL       TI2_Config
;;;1912                  TIM_ICInitStruct->TIM_ICSelection,
;;;1913                  TIM_ICInitStruct->TIM_ICFilter);
;;;1914       /* Set the Input Capture Prescaler value */
;;;1915       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000a6a  88e1              LDRH     r1,[r4,#6]
000a6c  4628              MOV      r0,r5
000a6e  f7fffffe          BL       TIM_SetIC2Prescaler
000a72  e017              B        |L1.2724|
                  |L1.2676|
;;;1916     }
;;;1917     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
000a74  8820              LDRH     r0,[r4,#0]
000a76  2808              CMP      r0,#8
000a78  d10a              BNE      |L1.2704|
;;;1918     {
;;;1919       /* TI3 Configuration */
;;;1920       TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
000a7a  8923              LDRH     r3,[r4,#8]
000a7c  88a2              LDRH     r2,[r4,#4]
000a7e  8861              LDRH     r1,[r4,#2]
000a80  4628              MOV      r0,r5
000a82  f7fffffe          BL       TI3_Config
;;;1921                  TIM_ICInitStruct->TIM_ICSelection,
;;;1922                  TIM_ICInitStruct->TIM_ICFilter);
;;;1923       /* Set the Input Capture Prescaler value */
;;;1924       TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000a86  88e1              LDRH     r1,[r4,#6]
000a88  4628              MOV      r0,r5
000a8a  f7fffffe          BL       TIM_SetIC3Prescaler
000a8e  e009              B        |L1.2724|
                  |L1.2704|
;;;1925     }
;;;1926     else
;;;1927     {
;;;1928       /* TI4 Configuration */
;;;1929       TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000a90  8923              LDRH     r3,[r4,#8]
000a92  88a2              LDRH     r2,[r4,#4]
000a94  8861              LDRH     r1,[r4,#2]
000a96  4628              MOV      r0,r5
000a98  f7fffffe          BL       TI4_Config
;;;1930                  TIM_ICInitStruct->TIM_ICSelection,
;;;1931                  TIM_ICInitStruct->TIM_ICFilter);
;;;1932       /* Set the Input Capture Prescaler value */
;;;1933       TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000a9c  88e1              LDRH     r1,[r4,#6]
000a9e  4628              MOV      r0,r5
000aa0  f7fffffe          BL       TIM_SetIC4Prescaler
                  |L1.2724|
;;;1934     }
;;;1935   }
000aa4  bd70              POP      {r4-r6,pc}
;;;1936   
                          ENDP

                  TIM_ICStructInit PROC
;;;1942     */
;;;1943   void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
000aa6  f04f0100          MOV      r1,#0
;;;1944   {
;;;1945     /* Set the default configuration */
;;;1946     TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
000aaa  8001              STRH     r1,[r0,#0]
;;;1947     TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
000aac  8041              STRH     r1,[r0,#2]
;;;1948     TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
000aae  f04f0101          MOV      r1,#1
000ab2  8081              STRH     r1,[r0,#4]
;;;1949     TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
000ab4  f04f0100          MOV      r1,#0
000ab8  80c1              STRH     r1,[r0,#6]
;;;1950     TIM_ICInitStruct->TIM_ICFilter = 0x00;
000aba  8101              STRH     r1,[r0,#8]
;;;1951   }
000abc  4770              BX       lr
;;;1952   
                          ENDP

                  TIM_PWMIConfig PROC
;;;1961     */
;;;1962   void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000abe  e92d41f0          PUSH     {r4-r8,lr}
;;;1963   {
000ac2  4605              MOV      r5,r0
000ac4  460c              MOV      r4,r1
;;;1964     uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
000ac6  f04f0600          MOV      r6,#0
;;;1965     uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
000aca  f04f0701          MOV      r7,#1
;;;1966   
;;;1967     /* Check the parameters */
;;;1968     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1969   
;;;1970     /* Select the Opposite Input Polarity */
;;;1971     if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
000ace  8860              LDRH     r0,[r4,#2]
000ad0  b910              CBNZ     r0,|L1.2776|
;;;1972     {
;;;1973       icoppositepolarity = TIM_ICPolarity_Falling;
000ad2  f04f0602          MOV      r6,#2
000ad6  e001              B        |L1.2780|
                  |L1.2776|
;;;1974     }
;;;1975     else
;;;1976     {
;;;1977       icoppositepolarity = TIM_ICPolarity_Rising;
000ad8  f04f0600          MOV      r6,#0
                  |L1.2780|
;;;1978     }
;;;1979     /* Select the Opposite Input */
;;;1980     if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
000adc  88a0              LDRH     r0,[r4,#4]
000ade  2801              CMP      r0,#1
000ae0  d102              BNE      |L1.2792|
;;;1981     {
;;;1982       icoppositeselection = TIM_ICSelection_IndirectTI;
000ae2  f04f0702          MOV      r7,#2
000ae6  e001              B        |L1.2796|
                  |L1.2792|
;;;1983     }
;;;1984     else
;;;1985     {
;;;1986       icoppositeselection = TIM_ICSelection_DirectTI;
000ae8  f04f0701          MOV      r7,#1
                  |L1.2796|
;;;1987     }
;;;1988     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000aec  8820              LDRH     r0,[r4,#0]
000aee  b9a0              CBNZ     r0,|L1.2842|
;;;1989     {
;;;1990       /* TI1 Configuration */
;;;1991       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000af0  8923              LDRH     r3,[r4,#8]
000af2  88a2              LDRH     r2,[r4,#4]
000af4  8861              LDRH     r1,[r4,#2]
000af6  4628              MOV      r0,r5
000af8  f7fffffe          BL       TI1_Config
;;;1992                  TIM_ICInitStruct->TIM_ICFilter);
;;;1993       /* Set the Input Capture Prescaler value */
;;;1994       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000afc  88e1              LDRH     r1,[r4,#6]
000afe  4628              MOV      r0,r5
000b00  f7fffffe          BL       TIM_SetIC1Prescaler
;;;1995       /* TI2 Configuration */
;;;1996       TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
000b04  8923              LDRH     r3,[r4,#8]
000b06  463a              MOV      r2,r7
000b08  4631              MOV      r1,r6
000b0a  4628              MOV      r0,r5
000b0c  f7fffffe          BL       TI2_Config
;;;1997       /* Set the Input Capture Prescaler value */
;;;1998       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000b10  88e1              LDRH     r1,[r4,#6]
000b12  4628              MOV      r0,r5
000b14  f7fffffe          BL       TIM_SetIC2Prescaler
000b18  e013              B        |L1.2882|
                  |L1.2842|
;;;1999     }
;;;2000     else
;;;2001     { 
;;;2002       /* TI2 Configuration */
;;;2003       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000b1a  8923              LDRH     r3,[r4,#8]
000b1c  88a2              LDRH     r2,[r4,#4]
000b1e  8861              LDRH     r1,[r4,#2]
000b20  4628              MOV      r0,r5
000b22  f7fffffe          BL       TI2_Config
;;;2004                  TIM_ICInitStruct->TIM_ICFilter);
;;;2005       /* Set the Input Capture Prescaler value */
;;;2006       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000b26  88e1              LDRH     r1,[r4,#6]
000b28  4628              MOV      r0,r5
000b2a  f7fffffe          BL       TIM_SetIC2Prescaler
;;;2007       /* TI1 Configuration */
;;;2008       TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
000b2e  8923              LDRH     r3,[r4,#8]
000b30  463a              MOV      r2,r7
000b32  4631              MOV      r1,r6
000b34  4628              MOV      r0,r5
000b36  f7fffffe          BL       TI1_Config
;;;2009       /* Set the Input Capture Prescaler value */
;;;2010       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000b3a  88e1              LDRH     r1,[r4,#6]
000b3c  4628              MOV      r0,r5
000b3e  f7fffffe          BL       TIM_SetIC1Prescaler
                  |L1.2882|
;;;2011     }
;;;2012   }
000b42  e8bd81f0          POP      {r4-r8,pc}
;;;2013   
                          ENDP

                  TIM_GetCapture1 PROC
;;;2018     */
;;;2019   uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
000b46  4601              MOV      r1,r0
;;;2020   {
;;;2021     /* Check the parameters */
;;;2022     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2023   
;;;2024     /* Get the Capture 1 Register value */
;;;2025     return TIMx->CCR1;
000b48  6b48              LDR      r0,[r1,#0x34]
;;;2026   }
000b4a  4770              BX       lr
;;;2027   
                          ENDP

                  TIM_GetCapture2 PROC
;;;2033     */
;;;2034   uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
000b4c  4601              MOV      r1,r0
;;;2035   {
;;;2036     /* Check the parameters */
;;;2037     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2038   
;;;2039     /* Get the Capture 2 Register value */
;;;2040     return TIMx->CCR2;
000b4e  6b88              LDR      r0,[r1,#0x38]
;;;2041   }
000b50  4770              BX       lr
;;;2042   
                          ENDP

                  TIM_GetCapture3 PROC
;;;2047     */
;;;2048   uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
000b52  4601              MOV      r1,r0
;;;2049   {
;;;2050     /* Check the parameters */
;;;2051     assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;2052   
;;;2053     /* Get the Capture 3 Register value */
;;;2054     return TIMx->CCR3;
000b54  6bc8              LDR      r0,[r1,#0x3c]
;;;2055   }
000b56  4770              BX       lr
;;;2056   
                          ENDP

                  TIM_GetCapture4 PROC
;;;2061     */
;;;2062   uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
000b58  4601              MOV      r1,r0
;;;2063   {
;;;2064     /* Check the parameters */
;;;2065     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2066   
;;;2067     /* Get the Capture 4 Register value */
;;;2068     return TIMx->CCR4;
000b5a  6c08              LDR      r0,[r1,#0x40]
;;;2069   }
000b5c  4770              BX       lr
;;;2070   
                          ENDP

                  TIM_BDTRConfig PROC
;;;2207     */
;;;2208   void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
000b5e  880a              LDRH     r2,[r1,#0]
;;;2209   {
;;;2210     /* Check the parameters */
;;;2211     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2212     assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;2213     assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;2214     assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;2215     assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;2216     assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;2217     assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;2218   
;;;2219     /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
;;;2220        the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;2221     TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
000b60  884b              LDRH     r3,[r1,#2]
000b62  ea420203          ORR      r2,r2,r3
000b66  888b              LDRH     r3,[r1,#4]
000b68  ea420203          ORR      r2,r2,r3
000b6c  88cb              LDRH     r3,[r1,#6]
000b6e  ea420203          ORR      r2,r2,r3
000b72  890b              LDRH     r3,[r1,#8]
000b74  ea420203          ORR      r2,r2,r3
000b78  894b              LDRH     r3,[r1,#0xa]
000b7a  ea420203          ORR      r2,r2,r3
000b7e  898b              LDRH     r3,[r1,#0xc]
000b80  ea420203          ORR      r2,r2,r3
000b84  f8a02044          STRH     r2,[r0,#0x44]
;;;2222                TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;2223                TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;2224                TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;2225   }
000b88  4770              BX       lr
;;;2226   
                          ENDP

                  TIM_BDTRStructInit PROC
;;;2232     */
;;;2233   void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
000b8a  f04f0100          MOV      r1,#0
;;;2234   {
;;;2235     /* Set the default configuration */
;;;2236     TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
000b8e  8001              STRH     r1,[r0,#0]
;;;2237     TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
000b90  8041              STRH     r1,[r0,#2]
;;;2238     TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
000b92  8081              STRH     r1,[r0,#4]
;;;2239     TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
000b94  80c1              STRH     r1,[r0,#6]
;;;2240     TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
000b96  8101              STRH     r1,[r0,#8]
;;;2241     TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
000b98  8141              STRH     r1,[r0,#0xa]
;;;2242     TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
000b9a  8181              STRH     r1,[r0,#0xc]
;;;2243   }
000b9c  4770              BX       lr
;;;2244   
                          ENDP

                  TIM_CtrlPWMOutputs PROC
;;;2251     */
;;;2252   void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
000b9e  b131              CBZ      r1,|L1.2990|
;;;2253   {
;;;2254     /* Check the parameters */
;;;2255     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2256     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2257   
;;;2258     if (NewState != DISABLE)
;;;2259     {
;;;2260       /* Enable the TIM Main Output */
;;;2261       TIMx->BDTR |= TIM_BDTR_MOE;
000ba0  f8b02044          LDRH     r2,[r0,#0x44]
000ba4  f4424200          ORR      r2,r2,#0x8000
000ba8  f8a02044          STRH     r2,[r0,#0x44]
000bac  e005              B        |L1.3002|
                  |L1.2990|
;;;2262     }
;;;2263     else
;;;2264     {
;;;2265       /* Disable the TIM Main Output */
;;;2266       TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
000bae  f8b02044          LDRH     r2,[r0,#0x44]
000bb2  f3c2020e          UBFX     r2,r2,#0,#15
000bb6  f8a02044          STRH     r2,[r0,#0x44]
                  |L1.3002|
;;;2267     }  
;;;2268   }
000bba  4770              BX       lr
;;;2269   
                          ENDP

                  TIM_SelectCOM PROC
;;;2276     */
;;;2277   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
000bbc  b121              CBZ      r1,|L1.3016|
;;;2278   {
;;;2279     /* Check the parameters */
;;;2280     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2281     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2282   
;;;2283     if (NewState != DISABLE)
;;;2284     {
;;;2285       /* Set the COM Bit */
;;;2286       TIMx->CR2 |= TIM_CR2_CCUS;
000bbe  8882              LDRH     r2,[r0,#4]
000bc0  f0420204          ORR      r2,r2,#4
000bc4  8082              STRH     r2,[r0,#4]
000bc6  e005              B        |L1.3028|
                  |L1.3016|
;;;2287     }
;;;2288     else
;;;2289     {
;;;2290       /* Reset the COM Bit */
;;;2291       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCUS;
000bc8  8882              LDRH     r2,[r0,#4]
000bca  f64f73fb          MOV      r3,#0xfffb
000bce  ea020203          AND      r2,r2,r3
000bd2  8082              STRH     r2,[r0,#4]
                  |L1.3028|
;;;2292     }
;;;2293   }
000bd4  4770              BX       lr
;;;2294   
                          ENDP

                  TIM_CCPreloadControl PROC
;;;2301     */
;;;2302   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
000bd6  b121              CBZ      r1,|L1.3042|
;;;2303   { 
;;;2304     /* Check the parameters */
;;;2305     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2306     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2307     if (NewState != DISABLE)
;;;2308     {
;;;2309       /* Set the CCPC Bit */
;;;2310       TIMx->CR2 |= TIM_CR2_CCPC;
000bd8  8882              LDRH     r2,[r0,#4]
000bda  f0420201          ORR      r2,r2,#1
000bde  8082              STRH     r2,[r0,#4]
000be0  e005              B        |L1.3054|
                  |L1.3042|
;;;2311     }
;;;2312     else
;;;2313     {
;;;2314       /* Reset the CCPC Bit */
;;;2315       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCPC;
000be2  8882              LDRH     r2,[r0,#4]
000be4  f64f73fe          MOV      r3,#0xfffe
000be8  ea020203          AND      r2,r2,r3
000bec  8082              STRH     r2,[r0,#4]
                  |L1.3054|
;;;2316     }
;;;2317   }
000bee  4770              BX       lr
;;;2318   /**
                          ENDP

                  TIM_ITConfig PROC
;;;2358     */
;;;2359   void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
000bf0  b510              PUSH     {r4,lr}
;;;2360   {  
;;;2361     /* Check the parameters */
;;;2362     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2363     assert_param(IS_TIM_IT(TIM_IT));
;;;2364     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2365     
;;;2366     if (NewState != DISABLE)
000bf2  b122              CBZ      r2,|L1.3070|
;;;2367     {
;;;2368       /* Enable the Interrupt sources */
;;;2369       TIMx->DIER |= TIM_IT;
000bf4  8983              LDRH     r3,[r0,#0xc]
000bf6  ea430301          ORR      r3,r3,r1
000bfa  8183              STRH     r3,[r0,#0xc]
000bfc  e006              B        |L1.3084|
                  |L1.3070|
;;;2370     }
;;;2371     else
;;;2372     {
;;;2373       /* Disable the Interrupt sources */
;;;2374       TIMx->DIER &= (uint16_t)~TIM_IT;
000bfe  8983              LDRH     r3,[r0,#0xc]
000c00  ea6f0401          MVN      r4,r1
000c04  b2a4              UXTH     r4,r4
000c06  ea030304          AND      r3,r3,r4
000c0a  8183              STRH     r3,[r0,#0xc]
                  |L1.3084|
;;;2375     }
;;;2376   }
000c0c  bd10              POP      {r4,pc}
;;;2377   
                          ENDP

                  TIM_GenerateEvent PROC
;;;2396     */
;;;2397   void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
000c0e  8281              STRH     r1,[r0,#0x14]
;;;2398   { 
;;;2399     /* Check the parameters */
;;;2400     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2401     assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
;;;2402    
;;;2403     /* Set the event sources */
;;;2404     TIMx->EGR = TIM_EventSource;
;;;2405   }
000c10  4770              BX       lr
;;;2406   
                          ENDP

                  TIM_GetFlagStatus PROC
;;;2429     */
;;;2430   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000c12  4602              MOV      r2,r0
;;;2431   { 
;;;2432     ITStatus bitstatus = RESET;  
000c14  f04f0000          MOV      r0,#0
;;;2433     /* Check the parameters */
;;;2434     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2435     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;2436   
;;;2437     
;;;2438     if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
000c18  8a13              LDRH     r3,[r2,#0x10]
000c1a  420b              TST      r3,r1
000c1c  d002              BEQ      |L1.3108|
;;;2439     {
;;;2440       bitstatus = SET;
000c1e  f04f0001          MOV      r0,#1
000c22  e001              B        |L1.3112|
                  |L1.3108|
;;;2441     }
;;;2442     else
;;;2443     {
;;;2444       bitstatus = RESET;
000c24  f04f0000          MOV      r0,#0
                  |L1.3112|
;;;2445     }
;;;2446     return bitstatus;
;;;2447   }
000c28  4770              BX       lr
;;;2448   
                          ENDP

                  TIM_ClearFlag PROC
;;;2471     */
;;;2472   void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000c2a  ea6f0201          MVN      r2,r1
;;;2473   {  
;;;2474     /* Check the parameters */
;;;2475     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2476      
;;;2477     /* Clear the flags */
;;;2478     TIMx->SR = (uint16_t)~TIM_FLAG;
000c2e  8202              STRH     r2,[r0,#0x10]
;;;2479   }
000c30  4770              BX       lr
;;;2480   
                          ENDP

                  TIM_GetITStatus PROC
;;;2499     */
;;;2500   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000c32  b530              PUSH     {r4,r5,lr}
;;;2501   {
000c34  4602              MOV      r2,r0
;;;2502     ITStatus bitstatus = RESET;  
000c36  f04f0000          MOV      r0,#0
;;;2503     uint16_t itstatus = 0x0, itenable = 0x0;
000c3a  4603              MOV      r3,r0
000c3c  4604              MOV      r4,r0
;;;2504     /* Check the parameters */
;;;2505     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2506     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2507      
;;;2508     itstatus = TIMx->SR & TIM_IT;
000c3e  8a15              LDRH     r5,[r2,#0x10]
000c40  ea050301          AND      r3,r5,r1
;;;2509     
;;;2510     itenable = TIMx->DIER & TIM_IT;
000c44  8995              LDRH     r5,[r2,#0xc]
000c46  ea050401          AND      r4,r5,r1
;;;2511     if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
000c4a  b11b              CBZ      r3,|L1.3156|
000c4c  b114              CBZ      r4,|L1.3156|
;;;2512     {
;;;2513       bitstatus = SET;
000c4e  f04f0001          MOV      r0,#1
000c52  e001              B        |L1.3160|
                  |L1.3156|
;;;2514     }
;;;2515     else
;;;2516     {
;;;2517       bitstatus = RESET;
000c54  f04f0000          MOV      r0,#0
                  |L1.3160|
;;;2518     }
;;;2519     return bitstatus;
;;;2520   }
000c58  bd30              POP      {r4,r5,pc}
;;;2521   
                          ENDP

                  TIM_ClearITPendingBit PROC
;;;2540     */
;;;2541   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000c5a  ea6f0201          MVN      r2,r1
;;;2542   {
;;;2543     /* Check the parameters */
;;;2544     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2545   
;;;2546     /* Clear the IT pending Bit */
;;;2547     TIMx->SR = (uint16_t)~TIM_IT;
000c5e  8202              STRH     r2,[r0,#0x10]
;;;2548   }
000c60  4770              BX       lr
;;;2549   
                          ENDP

                  TIM_DMAConfig PROC
;;;2577     */
;;;2578   void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
000c62  ea410302          ORR      r3,r1,r2
;;;2579   {
;;;2580     /* Check the parameters */
;;;2581     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2582     assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
;;;2583     assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;2584   
;;;2585     /* Set the DMA Base and the DMA Burst Length */
;;;2586     TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
000c66  f8a03048          STRH     r3,[r0,#0x48]
;;;2587   }
000c6a  4770              BX       lr
;;;2588   
                          ENDP

                  TIM_DMACmd PROC
;;;2604     */
;;;2605   void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
000c6c  b510              PUSH     {r4,lr}
;;;2606   { 
;;;2607     /* Check the parameters */
;;;2608     assert_param(IS_TIM_LIST5_PERIPH(TIMx)); 
;;;2609     assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;2610     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2611     
;;;2612     if (NewState != DISABLE)
000c6e  b122              CBZ      r2,|L1.3194|
;;;2613     {
;;;2614       /* Enable the DMA sources */
;;;2615       TIMx->DIER |= TIM_DMASource; 
000c70  8983              LDRH     r3,[r0,#0xc]
000c72  ea430301          ORR      r3,r3,r1
000c76  8183              STRH     r3,[r0,#0xc]
000c78  e006              B        |L1.3208|
                  |L1.3194|
;;;2616     }
;;;2617     else
;;;2618     {
;;;2619       /* Disable the DMA sources */
;;;2620       TIMx->DIER &= (uint16_t)~TIM_DMASource;
000c7a  8983              LDRH     r3,[r0,#0xc]
000c7c  ea6f0401          MVN      r4,r1
000c80  b2a4              UXTH     r4,r4
000c82  ea030304          AND      r3,r3,r4
000c86  8183              STRH     r3,[r0,#0xc]
                  |L1.3208|
;;;2621     }
;;;2622   }
000c88  bd10              POP      {r4,pc}
;;;2623   
                          ENDP

                  TIM_SelectCCDMA PROC
;;;2630     */
;;;2631   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
000c8a  b121              CBZ      r1,|L1.3222|
;;;2632   {
;;;2633     /* Check the parameters */
;;;2634     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2635     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2636   
;;;2637     if (NewState != DISABLE)
;;;2638     {
;;;2639       /* Set the CCDS Bit */
;;;2640       TIMx->CR2 |= TIM_CR2_CCDS;
000c8c  8882              LDRH     r2,[r0,#4]
000c8e  f0420208          ORR      r2,r2,#8
000c92  8082              STRH     r2,[r0,#4]
000c94  e005              B        |L1.3234|
                  |L1.3222|
;;;2641     }
;;;2642     else
;;;2643     {
;;;2644       /* Reset the CCDS Bit */
;;;2645       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCDS;
000c96  8882              LDRH     r2,[r0,#4]
000c98  f64f73f7          MOV      r3,#0xfff7
000c9c  ea020203          AND      r2,r2,r3
000ca0  8082              STRH     r2,[r0,#4]
                  |L1.3234|
;;;2646     }
;;;2647   }
000ca2  4770              BX       lr
;;;2648   /**
                          ENDP

                  TIM_InternalClockConfig PROC
;;;2669     */
;;;2670   void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
000ca4  8901              LDRH     r1,[r0,#8]
;;;2671   {
;;;2672     /* Check the parameters */
;;;2673     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2674   
;;;2675     /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;2676     TIMx->SMCR &=  (uint16_t)~TIM_SMCR_SMS;
000ca6  f64f72f8          MOV      r2,#0xfff8
000caa  ea010102          AND      r1,r1,r2
000cae  8101              STRH     r1,[r0,#8]
;;;2677   }
000cb0  4770              BX       lr
;;;2678   
                          ENDP

                  TIM_SelectInputTrigger PROC
;;;2875     */
;;;2876   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000cb2  460a              MOV      r2,r1
;;;2877   {
;;;2878     uint16_t tmpsmcr = 0;
000cb4  f04f0100          MOV      r1,#0
;;;2879   
;;;2880     /* Check the parameters */
;;;2881     assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;2882     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;2883   
;;;2884     /* Get the TIMx SMCR register value */
;;;2885     tmpsmcr = TIMx->SMCR;
000cb8  8901              LDRH     r1,[r0,#8]
;;;2886   
;;;2887     /* Reset the TS Bits */
;;;2888     tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
000cba  f64f738f          MOV      r3,#0xff8f
000cbe  ea010103          AND      r1,r1,r3
;;;2889   
;;;2890     /* Set the Input Trigger source */
;;;2891     tmpsmcr |= TIM_InputTriggerSource;
000cc2  ea410102          ORR      r1,r1,r2
;;;2892   
;;;2893     /* Write to TIMx SMCR */
;;;2894     TIMx->SMCR = tmpsmcr;
000cc6  8101              STRH     r1,[r0,#8]
;;;2895   }
000cc8  4770              BX       lr
;;;2896   
                          ENDP

                  TIM_ITRxExternalClockConfig PROC
;;;2690     */
;;;2691   void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000cca  b530              PUSH     {r4,r5,lr}
;;;2692   {
000ccc  4604              MOV      r4,r0
000cce  460d              MOV      r5,r1
;;;2693     /* Check the parameters */
;;;2694     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2695     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;2696   
;;;2697     /* Select the Internal Trigger */
;;;2698     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
000cd0  4629              MOV      r1,r5
000cd2  4620              MOV      r0,r4
000cd4  f7fffffe          BL       TIM_SelectInputTrigger
;;;2699   
;;;2700     /* Select the External clock mode1 */
;;;2701     TIMx->SMCR |= TIM_SlaveMode_External1;
000cd8  8920              LDRH     r0,[r4,#8]
000cda  f0400007          ORR      r0,r0,#7
000cde  8120              STRH     r0,[r4,#8]
;;;2702   }
000ce0  bd30              POP      {r4,r5,pc}
;;;2703   
                          ENDP

                  TIM_TIxExternalClockConfig PROC
;;;2720     */
;;;2721   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
000ce2  e92d41f0          PUSH     {r4-r8,lr}
;;;2722                                   uint16_t TIM_ICPolarity, uint16_t ICFilter)
;;;2723   {
000ce6  4604              MOV      r4,r0
000ce8  460d              MOV      r5,r1
000cea  4616              MOV      r6,r2
000cec  461f              MOV      r7,r3
;;;2724     /* Check the parameters */
;;;2725     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2726     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;2727     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;2728   
;;;2729     /* Configure the Timer Input Clock Source */
;;;2730     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
000cee  2d60              CMP      r5,#0x60
000cf0  d106              BNE      |L1.3328|
;;;2731     {
;;;2732       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
000cf2  463b              MOV      r3,r7
000cf4  2201              MOVS     r2,#1
000cf6  4631              MOV      r1,r6
000cf8  4620              MOV      r0,r4
000cfa  f7fffffe          BL       TI2_Config
000cfe  e005              B        |L1.3340|
                  |L1.3328|
;;;2733     }
;;;2734     else
;;;2735     {
;;;2736       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
000d00  463b              MOV      r3,r7
000d02  2201              MOVS     r2,#1
000d04  4631              MOV      r1,r6
000d06  4620              MOV      r0,r4
000d08  f7fffffe          BL       TI1_Config
                  |L1.3340|
;;;2737     }
;;;2738     /* Select the Trigger source */
;;;2739     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
000d0c  4629              MOV      r1,r5
000d0e  4620              MOV      r0,r4
000d10  f7fffffe          BL       TIM_SelectInputTrigger
;;;2740     /* Select the External clock mode1 */
;;;2741     TIMx->SMCR |= TIM_SlaveMode_External1;
000d14  8920              LDRH     r0,[r4,#8]
000d16  f0400007          ORR      r0,r0,#7
000d1a  8120              STRH     r0,[r4,#8]
;;;2742   }
000d1c  e8bd81f0          POP      {r4-r8,pc}
;;;2743   
                          ENDP

                  TIM_ETRConfig PROC
;;;2995     */
;;;2996   void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
000d20  b530              PUSH     {r4,r5,lr}
;;;2997                      uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;2998   {
000d22  460c              MOV      r4,r1
;;;2999     uint16_t tmpsmcr = 0;
000d24  f04f0100          MOV      r1,#0
;;;3000   
;;;3001     /* Check the parameters */
;;;3002     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;3003     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;3004     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;3005     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;3006   
;;;3007     tmpsmcr = TIMx->SMCR;
000d28  8901              LDRH     r1,[r0,#8]
;;;3008   
;;;3009     /* Reset the ETR Bits */
;;;3010     tmpsmcr &= SMCR_ETR_MASK;
000d2a  b2c9              UXTB     r1,r1
;;;3011   
;;;3012     /* Set the Prescaler, the Filter value and the Polarity */
;;;3013     tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
000d2c  ea4f6503          LSL      r5,r3,#24
000d30  ea424515          ORR      r5,r2,r5,LSR #16
000d34  ea450504          ORR      r5,r5,r4
000d38  ea450101          ORR      r1,r5,r1
;;;3014   
;;;3015     /* Write to TIMx SMCR */
;;;3016     TIMx->SMCR = tmpsmcr;
000d3c  8101              STRH     r1,[r0,#8]
;;;3017   }
000d3e  bd30              POP      {r4,r5,pc}
;;;3018   /**
                          ENDP

                  TIM_ETRClockMode1Config PROC
;;;2760     */
;;;2761   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
000d40  e92d41f0          PUSH     {r4-r8,lr}
;;;2762                               uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;2763   {
000d44  4605              MOV      r5,r0
000d46  460e              MOV      r6,r1
000d48  4617              MOV      r7,r2
000d4a  4698              MOV      r8,r3
;;;2764     uint16_t tmpsmcr = 0;
000d4c  f04f0400          MOV      r4,#0
;;;2765   
;;;2766     /* Check the parameters */
;;;2767     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2768     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2769     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2770     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2771     /* Configure the ETR Clock source */
;;;2772     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
000d50  4643              MOV      r3,r8
000d52  463a              MOV      r2,r7
000d54  4631              MOV      r1,r6
000d56  4628              MOV      r0,r5
000d58  f7fffffe          BL       TIM_ETRConfig
;;;2773     
;;;2774     /* Get the TIMx SMCR register value */
;;;2775     tmpsmcr = TIMx->SMCR;
000d5c  892c              LDRH     r4,[r5,#8]
;;;2776   
;;;2777     /* Reset the SMS Bits */
;;;2778     tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
000d5e  f64f70f8          MOV      r0,#0xfff8
000d62  ea040400          AND      r4,r4,r0
;;;2779   
;;;2780     /* Select the External clock mode1 */
;;;2781     tmpsmcr |= TIM_SlaveMode_External1;
000d66  f0440407          ORR      r4,r4,#7
;;;2782   
;;;2783     /* Select the Trigger selection : ETRF */
;;;2784     tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
000d6a  f64f708f          MOV      r0,#0xff8f
000d6e  ea040400          AND      r4,r4,r0
;;;2785     tmpsmcr |= TIM_TS_ETRF;
000d72  f0440470          ORR      r4,r4,#0x70
;;;2786   
;;;2787     /* Write to TIMx SMCR */
;;;2788     TIMx->SMCR = tmpsmcr;
000d76  812c              STRH     r4,[r5,#8]
;;;2789   }
000d78  e8bd81f0          POP      {r4-r8,pc}
;;;2790   
                          ENDP

                  TIM_ETRClockMode2Config PROC
;;;2807     */
;;;2808   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
000d7c  b5f0              PUSH     {r4-r7,lr}
;;;2809                                uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;2810   {
000d7e  4604              MOV      r4,r0
000d80  460d              MOV      r5,r1
000d82  4616              MOV      r6,r2
000d84  461f              MOV      r7,r3
;;;2811     /* Check the parameters */
;;;2812     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2813     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2814     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2815     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2816   
;;;2817     /* Configure the ETR Clock source */
;;;2818     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
000d86  463b              MOV      r3,r7
000d88  4632              MOV      r2,r6
000d8a  4629              MOV      r1,r5
000d8c  4620              MOV      r0,r4
000d8e  f7fffffe          BL       TIM_ETRConfig
;;;2819   
;;;2820     /* Enable the External clock mode2 */
;;;2821     TIMx->SMCR |= TIM_SMCR_ECE;
000d92  8920              LDRH     r0,[r4,#8]
000d94  f4404080          ORR      r0,r0,#0x4000
000d98  8120              STRH     r0,[r4,#8]
;;;2822   }
000d9a  bdf0              POP      {r4-r7,pc}
;;;2823   /**
                          ENDP

                  TIM_SelectOutputTrigger PROC
;;;2918     */
;;;2919   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
000d9c  8882              LDRH     r2,[r0,#4]
;;;2920   {
;;;2921     /* Check the parameters */
;;;2922     assert_param(IS_TIM_LIST5_PERIPH(TIMx));
;;;2923     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2924   
;;;2925     /* Reset the MMS Bits */
;;;2926     TIMx->CR2 &= (uint16_t)~TIM_CR2_MMS;
000d9e  f64f738f          MOV      r3,#0xff8f
000da2  ea020203          AND      r2,r2,r3
000da6  8082              STRH     r2,[r0,#4]
;;;2927     /* Select the TRGO source */
;;;2928     TIMx->CR2 |=  TIM_TRGOSource;
000da8  8882              LDRH     r2,[r0,#4]
000daa  ea420201          ORR      r2,r2,r1
000dae  8082              STRH     r2,[r0,#4]
;;;2929   }
000db0  4770              BX       lr
;;;2930   
                          ENDP

                  TIM_SelectSlaveMode PROC
;;;2942     */
;;;2943   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
000db2  8902              LDRH     r2,[r0,#8]
;;;2944   {
;;;2945     /* Check the parameters */
;;;2946     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2947     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2948   
;;;2949     /* Reset the SMS Bits */
;;;2950     TIMx->SMCR &= (uint16_t)~TIM_SMCR_SMS;
000db4  f64f73f8          MOV      r3,#0xfff8
000db8  ea020203          AND      r2,r2,r3
000dbc  8102              STRH     r2,[r0,#8]
;;;2951   
;;;2952     /* Select the Slave Mode */
;;;2953     TIMx->SMCR |= TIM_SlaveMode;
000dbe  8902              LDRH     r2,[r0,#8]
000dc0  ea420201          ORR      r2,r2,r1
000dc4  8102              STRH     r2,[r0,#8]
;;;2954   }
000dc6  4770              BX       lr
;;;2955   
                          ENDP

                  TIM_SelectMasterSlaveMode PROC
;;;2965     */
;;;2966   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
000dc8  8902              LDRH     r2,[r0,#8]
;;;2967   {
;;;2968     /* Check the parameters */
;;;2969     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2970     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2971   
;;;2972     /* Reset the MSM Bit */
;;;2973     TIMx->SMCR &= (uint16_t)~TIM_SMCR_MSM;
000dca  f64f737f          MOV      r3,#0xff7f
000dce  ea020203          AND      r2,r2,r3
000dd2  8102              STRH     r2,[r0,#8]
;;;2974     
;;;2975     /* Set or Reset the MSM Bit */
;;;2976     TIMx->SMCR |= TIM_MasterSlaveMode;
000dd4  8902              LDRH     r2,[r0,#8]
000dd6  ea420201          ORR      r2,r2,r1
000dda  8102              STRH     r2,[r0,#8]
;;;2977   }
000ddc  4770              BX       lr
;;;2978   
                          ENDP

                  TIM_EncoderInterfaceConfig PROC
;;;3053     */
;;;3054   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
000dde  b5f0              PUSH     {r4-r7,lr}
;;;3055                                   uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
;;;3056   {
000de0  460c              MOV      r4,r1
000de2  4615              MOV      r5,r2
000de4  461e              MOV      r6,r3
;;;3057     uint16_t tmpsmcr = 0;
000de6  f04f0100          MOV      r1,#0
;;;3058     uint16_t tmpccmr1 = 0;
000dea  460a              MOV      r2,r1
;;;3059     uint16_t tmpccer = 0;
000dec  460b              MOV      r3,r1
;;;3060       
;;;3061     /* Check the parameters */
;;;3062     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;3063     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;3064     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;3065     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;3066   
;;;3067     /* Get the TIMx SMCR register value */
;;;3068     tmpsmcr = TIMx->SMCR;
000dee  8901              LDRH     r1,[r0,#8]
;;;3069   
;;;3070     /* Get the TIMx CCMR1 register value */
;;;3071     tmpccmr1 = TIMx->CCMR1;
000df0  8b02              LDRH     r2,[r0,#0x18]
;;;3072   
;;;3073     /* Get the TIMx CCER register value */
;;;3074     tmpccer = TIMx->CCER;
000df2  8c03              LDRH     r3,[r0,#0x20]
;;;3075   
;;;3076     /* Set the encoder Mode */
;;;3077     tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
000df4  f64f77f8          MOV      r7,#0xfff8
000df8  ea010107          AND      r1,r1,r7
;;;3078     tmpsmcr |= TIM_EncoderMode;
000dfc  ea410104          ORR      r1,r1,r4
;;;3079   
;;;3080     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;3081     tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
000e00  f64f47fc          MOV      r7,#0xfcfc
000e04  ea020207          AND      r2,r2,r7
;;;3082     tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
000e08  f2401701          MOV      r7,#0x101
000e0c  ea420207          ORR      r2,r2,r7
;;;3083   
;;;3084     /* Set the TI1 and the TI2 Polarities */
;;;3085     tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
000e10  f64f77dd          MOV      r7,#0xffdd
000e14  ea030307          AND      r3,r3,r7
;;;3086     tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
000e18  ea4f5706          LSL      r7,r6,#20
000e1c  ea454717          ORR      r7,r5,r7,LSR #16
000e20  ea470303          ORR      r3,r7,r3
;;;3087   
;;;3088     /* Write to TIMx SMCR */
;;;3089     TIMx->SMCR = tmpsmcr;
000e24  8101              STRH     r1,[r0,#8]
;;;3090   
;;;3091     /* Write to TIMx CCMR1 */
;;;3092     TIMx->CCMR1 = tmpccmr1;
000e26  8302              STRH     r2,[r0,#0x18]
;;;3093   
;;;3094     /* Write to TIMx CCER */
;;;3095     TIMx->CCER = tmpccer;
000e28  8403              STRH     r3,[r0,#0x20]
;;;3096   }
000e2a  bdf0              POP      {r4-r7,pc}
;;;3097   
                          ENDP

                  TIM_SelectHallSensor PROC
;;;3105     */
;;;3106   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000e2c  b121              CBZ      r1,|L1.3640|
;;;3107   {
;;;3108     /* Check the parameters */
;;;3109     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;3110     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;3111   
;;;3112     if (NewState != DISABLE)
;;;3113     {
;;;3114       /* Set the TI1S Bit */
;;;3115       TIMx->CR2 |= TIM_CR2_TI1S;
000e2e  8882              LDRH     r2,[r0,#4]
000e30  f0420280          ORR      r2,r2,#0x80
000e34  8082              STRH     r2,[r0,#4]
000e36  e005              B        |L1.3652|
                  |L1.3640|
;;;3116     }
;;;3117     else
;;;3118     {
;;;3119       /* Reset the TI1S Bit */
;;;3120       TIMx->CR2 &= (uint16_t)~TIM_CR2_TI1S;
000e38  8882              LDRH     r2,[r0,#4]
000e3a  f64f737f          MOV      r3,#0xff7f
000e3e  ea020203          AND      r2,r2,r3
000e42  8082              STRH     r2,[r0,#4]
                  |L1.3652|
;;;3121     }
;;;3122   }
000e44  4770              BX       lr
;;;3123   /**
                          ENDP

                  TIM_RemapConfig PROC
;;;3156     */
;;;3157   void TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap)
000e46  f8a01050          STRH     r1,[r0,#0x50]
;;;3158   {
;;;3159    /* Check the parameters */
;;;3160     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;3161     assert_param(IS_TIM_REMAP(TIM_Remap));
;;;3162   
;;;3163     /* Set the Timer remapping configuration */
;;;3164     TIMx->OR =  TIM_Remap;
;;;3165   }
000e4a  4770              BX       lr
;;;3166   /**
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\BSP\\STM32F2xx\\src\\stm32f2xx_tim.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f2xx_tim_c_c458916b____REV16|
#line 112 "..\\BSP\\CMSIS\\core_cmInstr.h"
|__asm___15_stm32f2xx_tim_c_c458916b____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f2xx_tim_c_c458916b____REVSH|
#line 130
|__asm___15_stm32f2xx_tim_c_c458916b____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
