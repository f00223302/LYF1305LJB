; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Output\os_core.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\Output\os_core.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\BSP -I..\BSP\UCOS-II -I..\BSP\STM32F2xx\inc -I..\BSP\CMSIS -I..\BSP\CMSIS\Device_Support -I..\BSP\UCOS-II -I..\..\uC-CPU -I..\..\uC-CPU\ARM-Cortex-M3 -I..\..\uC-LIB -I..\..\uC-LIB\Ports\ARM-Cortex-M3 -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3 -I..\App -I..\Prj -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DDEBUG -DLJB_CPU_MAIN -DUSE_CPU_F205RC --omf_browse=.\Output\os_core.crf ..\..\uCOS-II\Source\os_core.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  OS_StrLen PROC
;;;1725   #if (OS_EVENT_NAME_EN > 0u) || (OS_FLAG_NAME_EN > 0u) || (OS_MEM_NAME_EN > 0u) || (OS_TASK_NAME_EN > 0u) || (OS_TMR_CFG_NAME_EN > 0u)
;;;1726   INT8U  OS_StrLen (INT8U *psrc)
000000  4601              MOV      r1,r0
;;;1727   {
;;;1728       INT8U  len;
;;;1729   
;;;1730   
;;;1731   #if OS_ARG_CHK_EN > 0u
;;;1732       if (psrc == (INT8U *)0) {
;;;1733           return (0u);
;;;1734       }
;;;1735   #endif
;;;1736   
;;;1737       len = 0u;
000002  f04f0000          MOV      r0,#0
;;;1738       while (*psrc != OS_ASCII_NUL) {
000006  e004              B        |L1.18|
                  |L1.8|
;;;1739           psrc++;
000008  f1010101          ADD      r1,r1,#1
;;;1740           len++;
00000c  f1000201          ADD      r2,r0,#1
000010  b2d0              UXTB     r0,r2
                  |L1.18|
000012  780a              LDRB     r2,[r1,#0]            ;1738
000014  2a00              CMP      r2,#0                 ;1738
000016  d1f7              BNE      |L1.8|
;;;1741       }
;;;1742       return (len);
;;;1743   }
000018  4770              BX       lr
;;;1744   #endif
                          ENDP

                  OSEventNameGet PROC
;;;109    #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
;;;110    INT8U  OSEventNameGet (OS_EVENT   *pevent,
00001a  e92d41f0          PUSH     {r4-r8,lr}
;;;111                           INT8U     **pname,
;;;112                           INT8U      *perr)
;;;113    {
00001e  4605              MOV      r5,r0
000020  460e              MOV      r6,r1
000022  4614              MOV      r4,r2
;;;114        INT8U      len;
;;;115    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;116        OS_CPU_SR  cpu_sr = 0u;
000024  f04f0700          MOV      r7,#0
;;;117    #endif
;;;118    
;;;119    
;;;120    
;;;121    #ifdef OS_SAFETY_CRITICAL
;;;122        if (perr == (INT8U *)0) {
;;;123            OS_SAFETY_CRITICAL_EXCEPTION();
;;;124            return (0u);
;;;125        }
;;;126    #endif
;;;127    
;;;128    #if OS_ARG_CHK_EN > 0u
;;;129        if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
;;;130            *perr = OS_ERR_PEVENT_NULL;
;;;131            return (0u);
;;;132        }
;;;133        if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;134            *perr = OS_ERR_PNAME_NULL;
;;;135            return (0u);
;;;136        }
;;;137    #endif
;;;138        if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
000028  48fe              LDR      r0,|L1.1060|
00002a  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00002c  b130              CBZ      r0,|L1.60|
;;;139            *perr  = OS_ERR_NAME_GET_ISR;
00002e  f04f0011          MOV      r0,#0x11
000032  7020              STRB     r0,[r4,#0]
;;;140            return (0u);
000034  f04f0000          MOV      r0,#0
                  |L1.56|
;;;141        }
;;;142        switch (pevent->OSEventType) {
;;;143            case OS_EVENT_TYPE_SEM:
;;;144            case OS_EVENT_TYPE_MUTEX:
;;;145            case OS_EVENT_TYPE_MBOX:
;;;146            case OS_EVENT_TYPE_Q:
;;;147                 break;
;;;148    
;;;149            default:
;;;150                 *perr = OS_ERR_EVENT_TYPE;
;;;151                 return (0u);
;;;152        }
;;;153        OS_ENTER_CRITICAL();
;;;154        *pname = pevent->OSEventName;
;;;155        len    = OS_StrLen(*pname);
;;;156        OS_EXIT_CRITICAL();
;;;157        *perr  = OS_ERR_NONE;
;;;158        return (len);
;;;159    }
000038  e8bd81f0          POP      {r4-r8,pc}
                  |L1.60|
00003c  7828              LDRB     r0,[r5,#0]            ;142
00003e  2801              CMP      r0,#1                 ;142
000040  d008              BEQ      |L1.84|
000042  2802              CMP      r0,#2                 ;142
000044  d007              BEQ      |L1.86|
000046  2803              CMP      r0,#3                 ;142
000048  d002              BEQ      |L1.80|
00004a  2804              CMP      r0,#4                 ;142
00004c  d104              BNE      |L1.88|
00004e  e000              B        |L1.82|
                  |L1.80|
000050  bf00              NOP                            ;144
                  |L1.82|
000052  bf00              NOP                            ;145
                  |L1.84|
000054  bf00              NOP                            ;146
                  |L1.86|
000056  e005              B        |L1.100|
                  |L1.88|
000058  f04f0001          MOV      r0,#1                 ;150
00005c  7020              STRB     r0,[r4,#0]            ;150
00005e  f04f0000          MOV      r0,#0                 ;151
000062  e7e9              B        |L1.56|
                  |L1.100|
000064  bf00              NOP                            ;147
000066  f7fffffe          BL       OS_CPU_SR_Save
00006a  4607              MOV      r7,r0                 ;153
00006c  6968              LDR      r0,[r5,#0x14]         ;154
00006e  6030              STR      r0,[r6,#0]            ;154
000070  6830              LDR      r0,[r6,#0]            ;155
000072  f7fffffe          BL       OS_StrLen
000076  4680              MOV      r8,r0                 ;155
000078  4638              MOV      r0,r7                 ;156
00007a  f7fffffe          BL       OS_CPU_SR_Restore
00007e  f04f0000          MOV      r0,#0                 ;157
000082  7020              STRB     r0,[r4,#0]            ;157
000084  4640              MOV      r0,r8                 ;158
000086  e7d7              B        |L1.56|
;;;160    #endif
                          ENDP

                  OSEventNameSet PROC
;;;189    #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
;;;190    void  OSEventNameSet (OS_EVENT  *pevent,
000088  e92d41f0          PUSH     {r4-r8,lr}
;;;191                          INT8U     *pname,
;;;192                          INT8U     *perr)
;;;193    {
00008c  4605              MOV      r5,r0
00008e  460e              MOV      r6,r1
000090  4614              MOV      r4,r2
;;;194    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;195        OS_CPU_SR  cpu_sr = 0u;
000092  f04f0700          MOV      r7,#0
;;;196    #endif
;;;197    
;;;198    
;;;199    
;;;200    #ifdef OS_SAFETY_CRITICAL
;;;201        if (perr == (INT8U *)0) {
;;;202            OS_SAFETY_CRITICAL_EXCEPTION();
;;;203            return;
;;;204        }
;;;205    #endif
;;;206    
;;;207    #if OS_ARG_CHK_EN > 0u
;;;208        if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
;;;209            *perr = OS_ERR_PEVENT_NULL;
;;;210            return;
;;;211        }
;;;212        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;213            *perr = OS_ERR_PNAME_NULL;
;;;214            return;
;;;215        }
;;;216    #endif
;;;217        if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
000096  48e3              LDR      r0,|L1.1060|
000098  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00009a  b120              CBZ      r0,|L1.166|
;;;218            *perr = OS_ERR_NAME_SET_ISR;
00009c  f04f0012          MOV      r0,#0x12
0000a0  7020              STRB     r0,[r4,#0]
                  |L1.162|
;;;219            return;
;;;220        }
;;;221        switch (pevent->OSEventType) {
;;;222            case OS_EVENT_TYPE_SEM:
;;;223            case OS_EVENT_TYPE_MUTEX:
;;;224            case OS_EVENT_TYPE_MBOX:
;;;225            case OS_EVENT_TYPE_Q:
;;;226                 break;
;;;227    
;;;228            default:
;;;229                 *perr = OS_ERR_EVENT_TYPE;
;;;230                 return;
;;;231        }
;;;232        OS_ENTER_CRITICAL();
;;;233        pevent->OSEventName = pname;
;;;234        OS_EXIT_CRITICAL();
;;;235        *perr = OS_ERR_NONE;
;;;236    }
0000a2  e8bd81f0          POP      {r4-r8,pc}
                  |L1.166|
0000a6  7828              LDRB     r0,[r5,#0]            ;221
0000a8  2801              CMP      r0,#1                 ;221
0000aa  d008              BEQ      |L1.190|
0000ac  2802              CMP      r0,#2                 ;221
0000ae  d007              BEQ      |L1.192|
0000b0  2803              CMP      r0,#3                 ;221
0000b2  d002              BEQ      |L1.186|
0000b4  2804              CMP      r0,#4                 ;221
0000b6  d104              BNE      |L1.194|
0000b8  e000              B        |L1.188|
                  |L1.186|
0000ba  bf00              NOP                            ;223
                  |L1.188|
0000bc  bf00              NOP                            ;224
                  |L1.190|
0000be  bf00              NOP                            ;225
                  |L1.192|
0000c0  e003              B        |L1.202|
                  |L1.194|
0000c2  f04f0001          MOV      r0,#1                 ;229
0000c6  7020              STRB     r0,[r4,#0]            ;229
0000c8  e7eb              B        |L1.162|
                  |L1.202|
0000ca  bf00              NOP                            ;226
0000cc  f7fffffe          BL       OS_CPU_SR_Save
0000d0  4607              MOV      r7,r0                 ;232
0000d2  616e              STR      r6,[r5,#0x14]         ;233
0000d4  4638              MOV      r0,r7                 ;234
0000d6  f7fffffe          BL       OS_CPU_SR_Restore
0000da  f04f0000          MOV      r0,#0                 ;235
0000de  7020              STRB     r0,[r4,#0]            ;235
0000e0  bf00              NOP      
0000e2  e7de              B        |L1.162|
;;;237    #endif
                          ENDP

                  OS_EventTaskRemoveMulti PROC
;;;1214   #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
;;;1215   void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
0000e4  b5f0              PUSH     {r4-r7,lr}
;;;1216                                  OS_EVENT **pevents_multi)
;;;1217   {
0000e6  4602              MOV      r2,r0
;;;1218       OS_EVENT **pevents;
;;;1219       OS_EVENT  *pevent;
;;;1220       INT8U      y;
;;;1221       OS_PRIO    bity;
;;;1222       OS_PRIO    bitx;
;;;1223   
;;;1224   
;;;1225       y       =  ptcb->OSTCBY;
0000e8  f8124f38          LDRB     r4,[r2,#0x38]!
;;;1226       bity    =  ptcb->OSTCBBitY;
0000ec  7895              LDRB     r5,[r2,#2]
;;;1227       bitx    =  ptcb->OSTCBBitX;
0000ee  7856              LDRB     r6,[r2,#1]
0000f0  f1a20238          SUB      r2,r2,#0x38
;;;1228       pevents =  pevents_multi;
0000f4  460b              MOV      r3,r1
;;;1229       pevent  = *pevents;
0000f6  6818              LDR      r0,[r3,#0]
;;;1230       while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
0000f8  e01a              B        |L1.304|
                  |L1.250|
;;;1231           pevent->OSEventTbl[y]  &= (OS_PRIO)~bitx;
0000fa  f100070b          ADD      r7,r0,#0xb
0000fe  5d3f              LDRB     r7,[r7,r4]
000100  ea6f0c06          MVN      r12,r6
000104  f00c0cff          AND      r12,r12,#0xff
000108  ea07070c          AND      r7,r7,r12
00010c  f1000c0b          ADD      r12,r0,#0xb
000110  f80c7004          STRB     r7,[r12,r4]
;;;1232           if (pevent->OSEventTbl[y] == 0u) {
000114  4667              MOV      r7,r12
000116  5d3f              LDRB     r7,[r7,r4]
000118  b93f              CBNZ     r7,|L1.298|
;;;1233               pevent->OSEventGrp &= (OS_PRIO)~bity;
00011a  7a87              LDRB     r7,[r0,#0xa]
00011c  ea6f0c05          MVN      r12,r5
000120  f00c0cff          AND      r12,r12,#0xff
000124  ea07070c          AND      r7,r7,r12
000128  7287              STRB     r7,[r0,#0xa]
                  |L1.298|
;;;1234           }
;;;1235           pevents++;
00012a  f1030304          ADD      r3,r3,#4
;;;1236           pevent = *pevents;
00012e  6818              LDR      r0,[r3,#0]
                  |L1.304|
000130  2800              CMP      r0,#0                 ;1230
000132  d1e2              BNE      |L1.250|
;;;1237       }
;;;1238   }
000134  bdf0              POP      {r4-r7,pc}
;;;1239   #endif
                          ENDP

                  OS_SchedNew PROC
;;;1680   
;;;1681   static  void  OS_SchedNew (void)
000136  49bc              LDR      r1,|L1.1064|
;;;1682   {
;;;1683   #if OS_LOWEST_PRIO <= 63u                        /* See if we support up to 64 tasks                   */
;;;1684       INT8U   y;
;;;1685   
;;;1686   
;;;1687       y             = OSUnMapTbl[OSRdyGrp];
000138  4abc              LDR      r2,|L1.1068|
00013a  7812              LDRB     r2,[r2,#0]  ; OSRdyGrp
00013c  5c88              LDRB     r0,[r1,r2]
;;;1688       OSPrioHighRdy = (INT8U)((y << 3u) + OSUnMapTbl[OSRdyTbl[y]]);
00013e  49bc              LDR      r1,|L1.1072|
000140  5c09              LDRB     r1,[r1,r0]
000142  4ab9              LDR      r2,|L1.1064|
000144  5c51              LDRB     r1,[r2,r1]
000146  eb0101c0          ADD      r1,r1,r0,LSL #3
00014a  4aba              LDR      r2,|L1.1076|
00014c  7011              STRB     r1,[r2,#0]
;;;1689   #else                                            /* We support up to 256 tasks                         */
;;;1690       INT8U     y;
;;;1691       OS_PRIO  *ptbl;
;;;1692   
;;;1693   
;;;1694       if ((OSRdyGrp & 0xFFu) != 0u) {
;;;1695           y = OSUnMapTbl[OSRdyGrp & 0xFFu];
;;;1696       } else {
;;;1697           y = OSUnMapTbl[(OS_PRIO)(OSRdyGrp >> 8u) & 0xFFu] + 8u;
;;;1698       }
;;;1699       ptbl = &OSRdyTbl[y];
;;;1700       if ((*ptbl & 0xFFu) != 0u) {
;;;1701           OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(*ptbl & 0xFFu)]);
;;;1702       } else {
;;;1703           OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u);
;;;1704       }
;;;1705   #endif
;;;1706   }
00014e  4770              BX       lr
;;;1707   
                          ENDP

                  OS_Sched PROC
;;;1638   
;;;1639   void  OS_Sched (void)
000150  b510              PUSH     {r4,lr}
;;;1640   {
;;;1641   #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
;;;1642       OS_CPU_SR  cpu_sr = 0u;
000152  f04f0400          MOV      r4,#0
;;;1643   #endif
;;;1644   
;;;1645   
;;;1646   
;;;1647       OS_ENTER_CRITICAL();
000156  f7fffffe          BL       OS_CPU_SR_Save
00015a  4604              MOV      r4,r0
;;;1648       if (OSIntNesting == 0u) {                          /* Schedule only if all ISRs done and ...       */
00015c  48b1              LDR      r0,|L1.1060|
00015e  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000160  bb08              CBNZ     r0,|L1.422|
;;;1649           if (OSLockNesting == 0u) {                     /* ... scheduler is not locked                  */
000162  48b5              LDR      r0,|L1.1080|
000164  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000166  b9f0              CBNZ     r0,|L1.422|
;;;1650               OS_SchedNew();
000168  f7fffffe          BL       OS_SchedNew
;;;1651               OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
00016c  48b3              LDR      r0,|L1.1084|
00016e  49b1              LDR      r1,|L1.1076|
000170  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
000172  f8500021          LDR      r0,[r0,r1,LSL #2]
000176  49b2              LDR      r1,|L1.1088|
000178  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;1652               if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
00017a  48ae              LDR      r0,|L1.1076|
00017c  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
00017e  49b1              LDR      r1,|L1.1092|
000180  7809              LDRB     r1,[r1,#0]  ; OSPrioCur
000182  4288              CMP      r0,r1
000184  d00f              BEQ      |L1.422|
;;;1653   #if OS_TASK_PROFILE_EN > 0u
;;;1654                   OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
000186  48ae              LDR      r0,|L1.1088|
000188  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
00018a  6bc0              LDR      r0,[r0,#0x3c]
00018c  f1000001          ADD      r0,r0,#1
000190  49ab              LDR      r1,|L1.1088|
000192  6809              LDR      r1,[r1,#0]  ; OSTCBHighRdy
000194  63c8              STR      r0,[r1,#0x3c]
;;;1655   #endif
;;;1656                   OSCtxSwCtr++;                          /* Increment context switch counter             */
000196  48ac              LDR      r0,|L1.1096|
000198  6800              LDR      r0,[r0,#0]  ; OSCtxSwCtr
00019a  f1000001          ADD      r0,r0,#1
00019e  49aa              LDR      r1,|L1.1096|
0001a0  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;1657                   OS_TASK_SW();                          /* Perform a context switch                     */
0001a2  f7fffffe          BL       OSCtxSw
                  |L1.422|
;;;1658               }
;;;1659           }
;;;1660       }
;;;1661       OS_EXIT_CRITICAL();
0001a6  4620              MOV      r0,r4
0001a8  f7fffffe          BL       OS_CPU_SR_Restore
;;;1662   }
0001ac  bd10              POP      {r4,pc}
;;;1663   
                          ENDP

                  OS_EventTaskWaitMulti PROC
;;;1141   #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
;;;1142   void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
0001ae  b570              PUSH     {r4-r6,lr}
;;;1143   {
0001b0  4601              MOV      r1,r0
;;;1144       OS_EVENT **pevents;
;;;1145       OS_EVENT  *pevent;
;;;1146       INT8U      y;
;;;1147   
;;;1148   
;;;1149       OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
0001b2  f04f0400          MOV      r4,#0
0001b6  4da5              LDR      r5,|L1.1100|
0001b8  682d              LDR      r5,[r5,#0]  ; OSTCBCur
0001ba  61ec              STR      r4,[r5,#0x1c]
;;;1150       OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
0001bc  4ca3              LDR      r4,|L1.1100|
0001be  6824              LDR      r4,[r4,#0]  ; OSTCBCur
0001c0  6221              STR      r1,[r4,#0x20]
;;;1151   
;;;1152       pevents =  pevents_wait;
0001c2  460b              MOV      r3,r1
;;;1153       pevent  = *pevents;
0001c4  6818              LDR      r0,[r3,#0]
;;;1154       while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
0001c6  e01e              B        |L1.518|
                  |L1.456|
;;;1155           pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
0001c8  4ca0              LDR      r4,|L1.1100|
0001ca  6824              LDR      r4,[r4,#0]  ; OSTCBCur
0001cc  f8945038          LDRB     r5,[r4,#0x38]
0001d0  f100040b          ADD      r4,r0,#0xb
0001d4  5d64              LDRB     r4,[r4,r5]
0001d6  4d9d              LDR      r5,|L1.1100|
0001d8  682d              LDR      r5,[r5,#0]  ; OSTCBCur
0001da  f8955039          LDRB     r5,[r5,#0x39]
0001de  ea440405          ORR      r4,r4,r5
0001e2  4d9a              LDR      r5,|L1.1100|
0001e4  682d              LDR      r5,[r5,#0]  ; OSTCBCur
0001e6  f8956038          LDRB     r6,[r5,#0x38]
0001ea  f100050b          ADD      r5,r0,#0xb
0001ee  55ac              STRB     r4,[r5,r6]
;;;1156           pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
0001f0  7a84              LDRB     r4,[r0,#0xa]
0001f2  4d96              LDR      r5,|L1.1100|
0001f4  682d              LDR      r5,[r5,#0]  ; OSTCBCur
0001f6  f895503a          LDRB     r5,[r5,#0x3a]
0001fa  ea440405          ORR      r4,r4,r5
0001fe  7284              STRB     r4,[r0,#0xa]
;;;1157           pevents++;
000200  f1030304          ADD      r3,r3,#4
;;;1158           pevent = *pevents;
000204  6818              LDR      r0,[r3,#0]
                  |L1.518|
000206  2800              CMP      r0,#0                 ;1154
000208  d1de              BNE      |L1.456|
;;;1159       }
;;;1160   
;;;1161       y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
00020a  4c90              LDR      r4,|L1.1100|
00020c  6824              LDR      r4,[r4,#0]  ; OSTCBCur
00020e  f8942038          LDRB     r2,[r4,#0x38]
;;;1162       OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
000212  4c87              LDR      r4,|L1.1072|
000214  5ca4              LDRB     r4,[r4,r2]
000216  4d8d              LDR      r5,|L1.1100|
000218  682d              LDR      r5,[r5,#0]  ; OSTCBCur
00021a  f8955039          LDRB     r5,[r5,#0x39]
00021e  ea6f0505          MVN      r5,r5
000222  b2ed              UXTB     r5,r5
000224  ea040405          AND      r4,r4,r5
000228  4d81              LDR      r5,|L1.1072|
00022a  54ac              STRB     r4,[r5,r2]
;;;1163       if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
00022c  462c              MOV      r4,r5
00022e  5ca4              LDRB     r4,[r4,r2]
000230  b964              CBNZ     r4,|L1.588|
;;;1164           OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
000232  4c86              LDR      r4,|L1.1100|
000234  6824              LDR      r4,[r4,#0]  ; OSTCBCur
000236  f894403a          LDRB     r4,[r4,#0x3a]
00023a  ea6f0404          MVN      r4,r4
00023e  b2e4              UXTB     r4,r4
000240  4d7a              LDR      r5,|L1.1068|
000242  782d              LDRB     r5,[r5,#0]  ; OSRdyGrp
000244  ea040405          AND      r4,r4,r5
000248  4d78              LDR      r5,|L1.1068|
00024a  702c              STRB     r4,[r5,#0]
                  |L1.588|
;;;1165       }
;;;1166   }
00024c  bd70              POP      {r4-r6,pc}
;;;1167   #endif
                          ENDP

                  OSEventPendMulti PROC
;;;311    #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
;;;312    INT16U  OSEventPendMulti (OS_EVENT  **pevents_pend,
00024e  e92d4fff          PUSH     {r0-r11,lr}
;;;313                              OS_EVENT  **pevents_rdy,
;;;314                              void      **pmsgs_rdy,
;;;315                              INT32U      timeout,
;;;316                              INT8U      *perr)
;;;317    {
000252  b083              SUB      sp,sp,#0xc
000254  4681              MOV      r9,r0
000256  460e              MOV      r6,r1
000258  4615              MOV      r5,r2
00025a  f8dd8040          LDR      r8,[sp,#0x40]
;;;318        OS_EVENT  **pevents;
;;;319        OS_EVENT   *pevent;
;;;320    #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
;;;321        OS_Q       *pq;
;;;322    #endif
;;;323        BOOLEAN     events_rdy;
;;;324        INT16U      events_rdy_nbr;
;;;325        INT8U       events_stat;
;;;326    #if (OS_CRITICAL_METHOD == 3u)                          /* Allocate storage for CPU status register    */
;;;327        OS_CPU_SR   cpu_sr = 0u;
00025e  f04f0000          MOV      r0,#0
000262  9000              STR      r0,[sp,#0]
;;;328    #endif
;;;329    
;;;330    
;;;331    
;;;332    #ifdef OS_SAFETY_CRITICAL
;;;333        if (perr == (INT8U *)0) {
;;;334            OS_SAFETY_CRITICAL_EXCEPTION();
;;;335            return (0u);
;;;336        }
;;;337    #endif
;;;338    
;;;339    #if (OS_ARG_CHK_EN > 0u)
;;;340        if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
;;;341           *perr =  OS_ERR_PEVENT_NULL;
;;;342            return (0u);
;;;343        }
;;;344        if (*pevents_pend  == (OS_EVENT *)0) {              /* Validate 'pevents_pend'                     */
;;;345           *perr =  OS_ERR_PEVENT_NULL;
;;;346            return (0u);
;;;347        }
;;;348        if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
;;;349           *perr =  OS_ERR_PEVENT_NULL;
;;;350            return (0u);
;;;351        }
;;;352        if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
;;;353           *perr =  OS_ERR_PEVENT_NULL;
;;;354            return (0u);
;;;355        }
;;;356    #endif
;;;357    
;;;358       *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
000264  6030              STR      r0,[r6,#0]
;;;359    
;;;360        pevents     =  pevents_pend;
000266  46ca              MOV      r10,r9
;;;361        pevent      = *pevents;
000268  f8da4000          LDR      r4,[r10,#0]
;;;362        while  (pevent != (OS_EVENT *)0) {
00026c  e01a              B        |L1.676|
                  |L1.622|
;;;363            switch (pevent->OSEventType) {                  /* Validate event block types                  */
00026e  7820              LDRB     r0,[r4,#0]
000270  2806              CMP      r0,#6
000272  d207              BCS      |L1.644|
000274  e8dff000          TBB      [pc,r0]
000278  06040503          DCB      0x06,0x04,0x05,0x03
00027c  0708              DCB      0x07,0x08
;;;364    #if (OS_SEM_EN  > 0u)
;;;365                case OS_EVENT_TYPE_SEM:
;;;366                     break;
00027e  e00c              B        |L1.666|
;;;367    #endif
;;;368    #if (OS_MBOX_EN > 0u)
;;;369                case OS_EVENT_TYPE_MBOX:
;;;370                     break;
000280  e00b              B        |L1.666|
;;;371    #endif
;;;372    #if ((OS_Q_EN   > 0u) && (OS_MAX_QS > 0u))
;;;373                case OS_EVENT_TYPE_Q:
;;;374                     break;
000282  e00a              B        |L1.666|
                  |L1.644|
;;;375    #endif
;;;376    
;;;377                case OS_EVENT_TYPE_MUTEX:
000284  bf00              NOP      
;;;378                case OS_EVENT_TYPE_FLAG:
000286  bf00              NOP      
;;;379                default:
;;;380                    *perr = OS_ERR_EVENT_TYPE;
000288  f04f0001          MOV      r0,#1
00028c  f8880000          STRB     r0,[r8,#0]
;;;381                     return (0u);
000290  f04f0000          MOV      r0,#0
                  |L1.660|
;;;382            }
;;;383            pevents++;
;;;384            pevent = *pevents;
;;;385        }
;;;386    
;;;387        if (OSIntNesting  > 0u) {                           /* See if called from ISR ...                  */
;;;388           *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
;;;389            return (0u);
;;;390        }
;;;391        if (OSLockNesting > 0u) {                           /* See if called with scheduler locked ...     */
;;;392           *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
;;;393            return (0u);
;;;394        }
;;;395    
;;;396    /*$PAGE*/
;;;397        events_rdy     =  OS_FALSE;
;;;398        events_rdy_nbr =  0u;
;;;399        events_stat    =  OS_STAT_RDY;
;;;400        pevents        =  pevents_pend;
;;;401        pevent         = *pevents;
;;;402        OS_ENTER_CRITICAL();
;;;403        while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
;;;404            switch (pevent->OSEventType) {
;;;405    #if (OS_SEM_EN > 0u)
;;;406                case OS_EVENT_TYPE_SEM:
;;;407                     if (pevent->OSEventCnt > 0u) {         /* If semaphore count > 0, resource available; */
;;;408                         pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
;;;409                        *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
;;;410                          events_rdy   =  OS_TRUE;
;;;411                        *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
;;;412                          events_rdy_nbr++;
;;;413    
;;;414                     } else {
;;;415                          events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
;;;416                     }
;;;417                     break;
;;;418    #endif
;;;419    
;;;420    #if (OS_MBOX_EN > 0u)
;;;421                case OS_EVENT_TYPE_MBOX:
;;;422                     if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
;;;423                                                            /* ... return available message,           ... */
;;;424                        *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
;;;425                         pevent->OSEventPtr  = (void *)0;
;;;426                        *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
;;;427                          events_rdy         =  OS_TRUE;
;;;428                          events_rdy_nbr++;
;;;429    
;;;430                     } else {
;;;431                          events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
;;;432                     }
;;;433                     break;
;;;434    #endif
;;;435    
;;;436    #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
;;;437                case OS_EVENT_TYPE_Q:
;;;438                     pq = (OS_Q *)pevent->OSEventPtr;
;;;439                     if (pq->OSQEntries > 0u) {             /* If queue NOT empty;                     ... */
;;;440                                                            /* ... return available message,           ... */
;;;441                        *pmsgs_rdy++ = (void *)*pq->OSQOut++;
;;;442                         if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
;;;443                             pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
;;;444                         }
;;;445                         pq->OSQEntries--;                  /* Update number of queue entries              */
;;;446                        *pevents_rdy++ = pevent;            /* ... and return available queue event        */
;;;447                          events_rdy   = OS_TRUE;
;;;448                          events_rdy_nbr++;
;;;449    
;;;450                     } else {
;;;451                          events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
;;;452                     }
;;;453                     break;
;;;454    #endif
;;;455    
;;;456                case OS_EVENT_TYPE_MUTEX:
;;;457                case OS_EVENT_TYPE_FLAG:
;;;458                default:
;;;459                     OS_EXIT_CRITICAL();
;;;460                    *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
;;;461                    *perr        =  OS_ERR_EVENT_TYPE;
;;;462                     return (events_rdy_nbr);
;;;463            }
;;;464            pevents++;
;;;465            pevent = *pevents;
;;;466        }
;;;467    
;;;468        if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
;;;469           *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
;;;470            OS_EXIT_CRITICAL();
;;;471           *perr        =  OS_ERR_NONE;
;;;472            return (events_rdy_nbr);
;;;473        }
;;;474    /*$PAGE*/
;;;475                                                            /* Otherwise, must wait until any event occurs */
;;;476        OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
;;;477                                   OS_STAT_MULTI;           /* ... pend on multiple events                 */
;;;478        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;479        OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
;;;480        OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
;;;481    
;;;482        OS_EXIT_CRITICAL();
;;;483        OS_Sched();                                         /* Find next highest priority task ready       */
;;;484        OS_ENTER_CRITICAL();
;;;485    
;;;486        switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
;;;487            case OS_STAT_PEND_OK:
;;;488            case OS_STAT_PEND_ABORT:
;;;489                 pevent = OSTCBCur->OSTCBEventPtr;
;;;490                 if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
;;;491                    *pevents_rdy++   =  pevent;             /* ... return available event ...              */
;;;492                    *pevents_rdy     = (OS_EVENT *)0;       /* ... & NULL terminate return event array     */
;;;493                      events_rdy_nbr =  1;
;;;494    
;;;495                 } else {                                   /* Else NO event available, handle as timeout  */
;;;496                     OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
;;;497                     OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
;;;498                 }
;;;499                 break;
;;;500    
;;;501            case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
;;;502            default:                                        /* ... remove task from events' wait lists     */
;;;503                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
;;;504                 break;
;;;505        }
;;;506    
;;;507        switch (OSTCBCur->OSTCBStatPend) {
;;;508            case OS_STAT_PEND_OK:
;;;509                 switch (pevent->OSEventType) {             /* Return event's message                      */
;;;510    #if (OS_SEM_EN > 0u)
;;;511                     case OS_EVENT_TYPE_SEM:
;;;512                         *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
;;;513                          break;
;;;514    #endif
;;;515    
;;;516    #if ((OS_MBOX_EN > 0u) ||                 \
;;;517        ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
;;;518                     case OS_EVENT_TYPE_MBOX:
;;;519                     case OS_EVENT_TYPE_Q:
;;;520                         *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
;;;521                          break;
;;;522    #endif
;;;523    
;;;524                     case OS_EVENT_TYPE_MUTEX:
;;;525                     case OS_EVENT_TYPE_FLAG:
;;;526                     default:
;;;527                          OS_EXIT_CRITICAL();
;;;528                         *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
;;;529                         *perr        =  OS_ERR_EVENT_TYPE;
;;;530                          return (events_rdy_nbr);
;;;531                 }
;;;532                *perr = OS_ERR_NONE;
;;;533                 break;
;;;534    
;;;535            case OS_STAT_PEND_ABORT:
;;;536                *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
;;;537                *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
;;;538                 break;
;;;539    
;;;540            case OS_STAT_PEND_TO:
;;;541            default:
;;;542                *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
;;;543                *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
;;;544                 break;
;;;545        }
;;;546    
;;;547        OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
;;;548        OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
;;;549        OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
;;;550        OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
;;;551    #if ((OS_MBOX_EN > 0u) ||                 \
;;;552        ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
;;;553        OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
;;;554    #endif
;;;555        OS_EXIT_CRITICAL();
;;;556    
;;;557        return (events_rdy_nbr);
;;;558    }
000294  b007              ADD      sp,sp,#0x1c
000296  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.666|
00029a  bf00              NOP                            ;366
00029c  f10a0a04          ADD      r10,r10,#4            ;383
0002a0  f8da4000          LDR      r4,[r10,#0]           ;384
                  |L1.676|
0002a4  2c00              CMP      r4,#0                 ;362
0002a6  d1e2              BNE      |L1.622|
0002a8  485e              LDR      r0,|L1.1060|
0002aa  7800              LDRB     r0,[r0,#0]            ;387  ; OSIntNesting
0002ac  b130              CBZ      r0,|L1.700|
0002ae  f04f0002          MOV      r0,#2                 ;388
0002b2  f8880000          STRB     r0,[r8,#0]            ;388
0002b6  f04f0000          MOV      r0,#0                 ;389
0002ba  e7eb              B        |L1.660|
                  |L1.700|
0002bc  485e              LDR      r0,|L1.1080|
0002be  7800              LDRB     r0,[r0,#0]            ;391  ; OSLockNesting
0002c0  b130              CBZ      r0,|L1.720|
0002c2  f04f000d          MOV      r0,#0xd               ;392
0002c6  f8880000          STRB     r0,[r8,#0]            ;392
0002ca  f04f0000          MOV      r0,#0                 ;393
0002ce  e7e1              B        |L1.660|
                  |L1.720|
0002d0  f04f0000          MOV      r0,#0                 ;397
0002d4  9002              STR      r0,[sp,#8]            ;397
0002d6  9001              STR      r0,[sp,#4]            ;398
0002d8  4683              MOV      r11,r0                ;399
0002da  46ca              MOV      r10,r9                ;400
0002dc  f8da4000          LDR      r4,[r10,#0]           ;401
0002e0  f7fffffe          BL       OS_CPU_SR_Save
0002e4  9000              STR      r0,[sp,#0]            ;402
0002e6  e064              B        |L1.946|
                  |L1.744|
0002e8  7820              LDRB     r0,[r4,#0]            ;404
0002ea  2806              CMP      r0,#6                 ;404
0002ec  d24e              BCS      |L1.908|
0002ee  e8dff000          TBB      [pc,r0]               ;404
0002f2  4d19              DCB      0x4d,0x19
0002f4  2d034e4f          DCB      0x2d,0x03,0x4e,0x4f
0002f8  8920              LDRH     r0,[r4,#8]            ;407
0002fa  b180              CBZ      r0,|L1.798|
0002fc  8920              LDRH     r0,[r4,#8]            ;408
0002fe  f1a00001          SUB      r0,r0,#1              ;408
000302  8120              STRH     r0,[r4,#8]            ;408
000304  c610              STM      r6!,{r4}              ;409
000306  f04f0001          MOV      r0,#1                 ;410
00030a  9002              STR      r0,[sp,#8]            ;410
00030c  f04f0000          MOV      r0,#0                 ;411
000310  c501              STM      r5!,{r0}              ;411
000312  9801              LDR      r0,[sp,#4]            ;412
000314  f1000001          ADD      r0,r0,#1              ;412
000318  b280              UXTH     r0,r0                 ;412
00031a  9001              STR      r0,[sp,#4]            ;412
00031c  e001              B        |L1.802|
                  |L1.798|
00031e  f04b0b01          ORR      r11,r11,#1            ;415
                  |L1.802|
000322  e041              B        |L1.936|
000324  6860              LDR      r0,[r4,#4]            ;422
000326  b170              CBZ      r0,|L1.838|
000328  6860              LDR      r0,[r4,#4]            ;424
00032a  c501              STM      r5!,{r0}              ;424
00032c  f04f0000          MOV      r0,#0                 ;425
000330  6060              STR      r0,[r4,#4]            ;425
000332  c610              STM      r6!,{r4}              ;426
000334  f04f0001          MOV      r0,#1                 ;427
000338  9002              STR      r0,[sp,#8]            ;427
00033a  9801              LDR      r0,[sp,#4]            ;428
00033c  f1000001          ADD      r0,r0,#1              ;428
000340  b280              UXTH     r0,r0                 ;428
000342  9001              STR      r0,[sp,#4]            ;428
000344  e001              B        |L1.842|
                  |L1.838|
000346  f04b0b02          ORR      r11,r11,#2            ;431
                  |L1.842|
00034a  e02d              B        |L1.936|
00034c  6867              LDR      r7,[r4,#4]            ;438
00034e  8af8              LDRH     r0,[r7,#0x16]         ;439
000350  b1c8              CBZ      r0,|L1.902|
000352  6939              LDR      r1,[r7,#0x10]         ;441
000354  f1010004          ADD      r0,r1,#4              ;441
000358  6138              STR      r0,[r7,#0x10]         ;441
00035a  6808              LDR      r0,[r1,#0]            ;441
00035c  c501              STM      r5!,{r0}              ;441
00035e  68b9              LDR      r1,[r7,#8]            ;442
000360  6938              LDR      r0,[r7,#0x10]         ;442
000362  4288              CMP      r0,r1                 ;442
000364  d101              BNE      |L1.874|
000366  6878              LDR      r0,[r7,#4]            ;443
000368  6138              STR      r0,[r7,#0x10]         ;443
                  |L1.874|
00036a  8af8              LDRH     r0,[r7,#0x16]         ;445
00036c  f1a00001          SUB      r0,r0,#1              ;445
000370  82f8              STRH     r0,[r7,#0x16]         ;445
000372  c610              STM      r6!,{r4}              ;446
000374  f04f0001          MOV      r0,#1                 ;447
000378  9002              STR      r0,[sp,#8]            ;447
00037a  9801              LDR      r0,[sp,#4]            ;448
00037c  f1000001          ADD      r0,r0,#1              ;448
000380  b280              UXTH     r0,r0                 ;448
000382  9001              STR      r0,[sp,#4]            ;448
000384  e001              B        |L1.906|
                  |L1.902|
000386  f04b0b04          ORR      r11,r11,#4            ;451
                  |L1.906|
00038a  e00d              B        |L1.936|
                  |L1.908|
00038c  bf00              NOP                            ;456
00038e  bf00              NOP                            ;457
000390  9800              LDR      r0,[sp,#0]            ;459
000392  f7fffffe          BL       OS_CPU_SR_Restore
000396  f04f0000          MOV      r0,#0                 ;460
00039a  6030              STR      r0,[r6,#0]            ;460
00039c  f04f0001          MOV      r0,#1                 ;461
0003a0  f8880000          STRB     r0,[r8,#0]            ;461
0003a4  9801              LDR      r0,[sp,#4]            ;462
0003a6  e775              B        |L1.660|
                  |L1.936|
0003a8  bf00              NOP                            ;417
0003aa  f10a0a04          ADD      r10,r10,#4            ;464
0003ae  f8da4000          LDR      r4,[r10,#0]           ;465
                  |L1.946|
0003b2  2c00              CMP      r4,#0                 ;403
0003b4  d198              BNE      |L1.744|
0003b6  9802              LDR      r0,[sp,#8]            ;468
0003b8  2801              CMP      r0,#1                 ;468
0003ba  d10a              BNE      |L1.978|
0003bc  f04f0000          MOV      r0,#0                 ;469
0003c0  6030              STR      r0,[r6,#0]            ;469
0003c2  9800              LDR      r0,[sp,#0]            ;470
0003c4  f7fffffe          BL       OS_CPU_SR_Restore
0003c8  4620              MOV      r0,r4                 ;471
0003ca  f8880000          STRB     r0,[r8,#0]            ;471
0003ce  9801              LDR      r0,[sp,#4]            ;472
0003d0  e760              B        |L1.660|
                  |L1.978|
0003d2  481e              LDR      r0,|L1.1100|
0003d4  6800              LDR      r0,[r0,#0]            ;476  ; OSTCBCur
0003d6  f8900034          LDRB     r0,[r0,#0x34]         ;476
0003da  f04b0180          ORR      r1,r11,#0x80          ;476
0003de  ea400001          ORR      r0,r0,r1              ;476
0003e2  491a              LDR      r1,|L1.1100|
0003e4  6809              LDR      r1,[r1,#0]            ;476  ; OSTCBCur
0003e6  f8810034          STRB     r0,[r1,#0x34]         ;476
0003ea  f04f0000          MOV      r0,#0                 ;478
0003ee  4917              LDR      r1,|L1.1100|
0003f0  6809              LDR      r1,[r1,#0]            ;478  ; OSTCBCur
0003f2  f8810035          STRB     r0,[r1,#0x35]         ;478
0003f6  4915              LDR      r1,|L1.1100|
0003f8  9806              LDR      r0,[sp,#0x18]         ;479
0003fa  6809              LDR      r1,[r1,#0]            ;479  ; OSTCBCur
0003fc  6308              STR      r0,[r1,#0x30]         ;479
0003fe  4648              MOV      r0,r9                 ;480
000400  f7fffffe          BL       OS_EventTaskWaitMulti
000404  9800              LDR      r0,[sp,#0]            ;482
000406  f7fffffe          BL       OS_CPU_SR_Restore
00040a  f7fffffe          BL       OS_Sched
00040e  f7fffffe          BL       OS_CPU_SR_Save
000412  9000              STR      r0,[sp,#0]            ;484
000414  480d              LDR      r0,|L1.1100|
000416  6800              LDR      r0,[r0,#0]            ;486  ; OSTCBCur
000418  f8900035          LDRB     r0,[r0,#0x35]         ;486
00041c  b1d8              CBZ      r0,|L1.1110|
00041e  2801              CMP      r0,#1                 ;486
000420  d033              BEQ      |L1.1162|
000422  e015              B        |L1.1104|
                  |L1.1060|
                          DCD      OSIntNesting
                  |L1.1064|
                          DCD      OSUnMapTbl
                  |L1.1068|
                          DCD      OSRdyGrp
                  |L1.1072|
                          DCD      OSRdyTbl
                  |L1.1076|
                          DCD      OSPrioHighRdy
                  |L1.1080|
                          DCD      OSLockNesting
                  |L1.1084|
                          DCD      OSTCBPrioTbl
                  |L1.1088|
                          DCD      OSTCBHighRdy
                  |L1.1092|
                          DCD      OSPrioCur
                  |L1.1096|
                          DCD      OSCtxSwCtr
                  |L1.1100|
                          DCD      OSTCBCur
                  |L1.1104|
000450  2802              CMP      r0,#2                 ;486
000452  d119              BNE      |L1.1160|
000454  e000              B        |L1.1112|
                  |L1.1110|
000456  bf00              NOP                            ;488
                  |L1.1112|
000458  48fd              LDR      r0,|L1.2128|
00045a  6800              LDR      r0,[r0,#0]            ;489  ; OSTCBCur
00045c  69c4              LDR      r4,[r0,#0x1c]         ;489
00045e  b13c              CBZ      r4,|L1.1136|
000460  c610              STM      r6!,{r4}              ;491
000462  f04f0000          MOV      r0,#0                 ;492
000466  6030              STR      r0,[r6,#0]            ;492
000468  f04f0001          MOV      r0,#1                 ;493
00046c  9001              STR      r0,[sp,#4]            ;493
00046e  e00a              B        |L1.1158|
                  |L1.1136|
000470  f04f0001          MOV      r0,#1                 ;496
000474  49f6              LDR      r1,|L1.2128|
000476  6809              LDR      r1,[r1,#0]            ;496  ; OSTCBCur
000478  f8810035          STRB     r0,[r1,#0x35]         ;496
00047c  4649              MOV      r1,r9                 ;497
00047e  48f4              LDR      r0,|L1.2128|
000480  6800              LDR      r0,[r0,#0]            ;497  ; OSTCBCur
000482  f7fffffe          BL       OS_EventTaskRemoveMulti
                  |L1.1158|
000486  e006              B        |L1.1174|
                  |L1.1160|
000488  bf00              NOP                            ;501
                  |L1.1162|
00048a  4649              MOV      r1,r9                 ;503
00048c  48f0              LDR      r0,|L1.2128|
00048e  6800              LDR      r0,[r0,#0]            ;503  ; OSTCBCur
000490  f7fffffe          BL       OS_EventTaskRemoveMulti
000494  bf00              NOP                            ;504
                  |L1.1174|
000496  bf00              NOP                            ;499
000498  48ed              LDR      r0,|L1.2128|
00049a  6800              LDR      r0,[r0,#0]            ;507  ; OSTCBCur
00049c  f8900035          LDRB     r0,[r0,#0x35]         ;507
0004a0  b120              CBZ      r0,|L1.1196|
0004a2  2801              CMP      r0,#1                 ;507
0004a4  d031              BEQ      |L1.1290|
0004a6  2802              CMP      r0,#2                 ;507
0004a8  d12e              BNE      |L1.1288|
0004aa  e025              B        |L1.1272|
                  |L1.1196|
0004ac  7820              LDRB     r0,[r4,#0]            ;509
0004ae  2806              CMP      r0,#6                 ;509
0004b0  d20e              BCS      |L1.1232|
0004b2  e8dff000          TBB      [pc,r0]               ;509
0004b6  0d07              DCB      0x0d,0x07
0004b8  08030e0f          DCB      0x08,0x03,0x0e,0x0f
0004bc  f04f0000          MOV      r0,#0                 ;512
0004c0  c501              STM      r5!,{r0}              ;512
0004c2  e013              B        |L1.1260|
0004c4  bf00              NOP                            ;519
0004c6  48e2              LDR      r0,|L1.2128|
0004c8  6800              LDR      r0,[r0,#0]            ;520  ; OSTCBCur
0004ca  6a40              LDR      r0,[r0,#0x24]         ;520
0004cc  c501              STM      r5!,{r0}              ;520
0004ce  e00d              B        |L1.1260|
                  |L1.1232|
0004d0  bf00              NOP                            ;524
0004d2  bf00              NOP                            ;525
0004d4  9800              LDR      r0,[sp,#0]            ;527
0004d6  f7fffffe          BL       OS_CPU_SR_Restore
0004da  f04f0000          MOV      r0,#0                 ;528
0004de  6030              STR      r0,[r6,#0]            ;528
0004e0  f04f0001          MOV      r0,#1                 ;529
0004e4  f8880000          STRB     r0,[r8,#0]            ;529
0004e8  9801              LDR      r0,[sp,#4]            ;530
0004ea  e6d3              B        |L1.660|
                  |L1.1260|
0004ec  bf00              NOP                            ;513
0004ee  f04f0000          MOV      r0,#0                 ;532
0004f2  f8880000          STRB     r0,[r8,#0]            ;532
0004f6  e010              B        |L1.1306|
                  |L1.1272|
0004f8  f04f0000          MOV      r0,#0                 ;536
0004fc  c501              STM      r5!,{r0}              ;536
0004fe  f04f000e          MOV      r0,#0xe               ;537
000502  f8880000          STRB     r0,[r8,#0]            ;537
000506  e008              B        |L1.1306|
                  |L1.1288|
000508  bf00              NOP                            ;540
                  |L1.1290|
00050a  f04f0000          MOV      r0,#0                 ;542
00050e  c501              STM      r5!,{r0}              ;542
000510  f04f000a          MOV      r0,#0xa               ;543
000514  f8880000          STRB     r0,[r8,#0]            ;543
000518  bf00              NOP                            ;544
                  |L1.1306|
00051a  bf00              NOP                            ;533
00051c  f04f0000          MOV      r0,#0                 ;547
000520  49cb              LDR      r1,|L1.2128|
000522  6809              LDR      r1,[r1,#0]            ;547  ; OSTCBCur
000524  f8810034          STRB     r0,[r1,#0x34]         ;547
000528  49c9              LDR      r1,|L1.2128|
00052a  6809              LDR      r1,[r1,#0]            ;548  ; OSTCBCur
00052c  f8810035          STRB     r0,[r1,#0x35]         ;548
000530  49c7              LDR      r1,|L1.2128|
000532  6809              LDR      r1,[r1,#0]            ;549  ; OSTCBCur
000534  61c8              STR      r0,[r1,#0x1c]         ;549
000536  49c6              LDR      r1,|L1.2128|
000538  6809              LDR      r1,[r1,#0]            ;550  ; OSTCBCur
00053a  6208              STR      r0,[r1,#0x20]         ;550
00053c  49c4              LDR      r1,|L1.2128|
00053e  6809              LDR      r1,[r1,#0]            ;553  ; OSTCBCur
000540  6248              STR      r0,[r1,#0x24]         ;553
000542  9800              LDR      r0,[sp,#0]            ;555
000544  f7fffffe          BL       OS_CPU_SR_Restore
000548  9801              LDR      r0,[sp,#4]            ;557
00054a  e6a3              B        |L1.660|
;;;559    #endif
                          ENDP

                  OS_TaskStatStkChk PROC
;;;1862   #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
;;;1863   void  OS_TaskStatStkChk (void)
00054c  b57c              PUSH     {r2-r6,lr}
;;;1864   {
;;;1865       OS_TCB      *ptcb;
;;;1866       OS_STK_DATA  stk_data;
;;;1867       INT8U        err;
;;;1868       INT8U        prio;
;;;1869   
;;;1870   
;;;1871       for (prio = 0u; prio <= OS_TASK_IDLE_PRIO; prio++) {
00054e  f04f0500          MOV      r5,#0
000552  e015              B        |L1.1408|
                  |L1.1364|
;;;1872           err = OSTaskStkChk(prio, &stk_data);
000554  4669              MOV      r1,sp
000556  4628              MOV      r0,r5
000558  f7fffffe          BL       OSTaskStkChk
00055c  4606              MOV      r6,r0
;;;1873           if (err == OS_ERR_NONE) {
00055e  b966              CBNZ     r6,|L1.1402|
;;;1874               ptcb = OSTCBPrioTbl[prio];
000560  48bc              LDR      r0,|L1.2132|
000562  f8504025          LDR      r4,[r0,r5,LSL #2]
;;;1875               if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
000566  b144              CBZ      r4,|L1.1402|
;;;1876                   if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
000568  2c01              CMP      r4,#1
00056a  d006              BEQ      |L1.1402|
;;;1877   #if OS_TASK_PROFILE_EN > 0u
;;;1878                       #if OS_STK_GROWTH == 1u
;;;1879                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
00056c  e9d40102          LDRD     r0,r1,[r4,#8]
000570  eb000081          ADD      r0,r0,r1,LSL #2
000574  64a0              STR      r0,[r4,#0x48]
;;;1880                       #else
;;;1881                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
;;;1882                       #endif
;;;1883                       ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store number of entries used   */
000576  9801              LDR      r0,[sp,#4]
000578  64e0              STR      r0,[r4,#0x4c]
                  |L1.1402|
00057a  f1050001          ADD      r0,r5,#1              ;1871
00057e  b2c5              UXTB     r5,r0                 ;1871
                  |L1.1408|
000580  2d3f              CMP      r5,#0x3f              ;1871
000582  d9e7              BLS      |L1.1364|
;;;1884   #endif
;;;1885                   }
;;;1886               }
;;;1887           }
;;;1888       }
;;;1889   }
000584  bd7c              POP      {r2-r6,pc}
;;;1890   #endif
                          ENDP

                  OS_TaskStat PROC
;;;1808   #if OS_TASK_STAT_EN > 0u
;;;1809   void  OS_TaskStat (void *p_arg)
000586  bf00              NOP      
;;;1810   {
;;;1811   #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;1812       OS_CPU_SR  cpu_sr = 0u;
;;;1813   #endif
;;;1814   
;;;1815   
;;;1816   
;;;1817       p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
000588  bf00              NOP      
;;;1818       while (OSStatRdy == OS_FALSE) {
00058a  e002              B        |L1.1426|
                  |L1.1420|
;;;1819           OSTimeDly(2u * OS_TICKS_PER_SEC / 10u);  /* Wait until statistic task is ready                 */
00058c  20c8              MOVS     r0,#0xc8
00058e  f7fffffe          BL       OSTimeDly
                  |L1.1426|
000592  48b1              LDR      r0,|L1.2136|
000594  7800              LDRB     r0,[r0,#0]            ;1818  ; OSStatRdy
000596  2800              CMP      r0,#0                 ;1818
000598  d0f8              BEQ      |L1.1420|
;;;1820       }
;;;1821       OSIdleCtrMax /= 100uL;
00059a  48b0              LDR      r0,|L1.2140|
00059c  6800              LDR      r0,[r0,#0]  ; OSIdleCtrMax
00059e  f04f0164          MOV      r1,#0x64
0005a2  fbb0f0f1          UDIV     r0,r0,r1
0005a6  49ad              LDR      r1,|L1.2140|
0005a8  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;1822       if (OSIdleCtrMax == 0uL) {
0005aa  4608              MOV      r0,r1
0005ac  6800              LDR      r0,[r0,#0]  ; OSIdleCtrMax
0005ae  b938              CBNZ     r0,|L1.1472|
;;;1823           OSCPUUsage = 0u;
0005b0  f04f0000          MOV      r0,#0
0005b4  49aa              LDR      r1,|L1.2144|
0005b6  7008              STRB     r0,[r1,#0]
;;;1824   #if OS_TASK_SUSPEND_EN > 0u
;;;1825           (void)OSTaskSuspend(OS_PRIO_SELF);
0005b8  f04f00ff          MOV      r0,#0xff
0005bc  f7fffffe          BL       OSTaskSuspend
                  |L1.1472|
;;;1826   #else
;;;1827           for (;;) {
;;;1828               OSTimeDly(OS_TICKS_PER_SEC);
;;;1829           }
;;;1830   #endif
;;;1831       }
;;;1832       OS_ENTER_CRITICAL();
0005c0  f7fffffe          BL       OS_CPU_SR_Save
0005c4  4604              MOV      r4,r0
;;;1833       OSIdleCtr = OSIdleCtrMax * 100uL;            /* Set initial CPU usage as 0%                        */
0005c6  48a5              LDR      r0,|L1.2140|
0005c8  6800              LDR      r0,[r0,#0]  ; OSIdleCtrMax
0005ca  f04f0164          MOV      r1,#0x64
0005ce  fb00f001          MUL      r0,r0,r1
0005d2  49a4              LDR      r1,|L1.2148|
0005d4  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1834       OS_EXIT_CRITICAL();
0005d6  4620              MOV      r0,r4
0005d8  f7fffffe          BL       OS_CPU_SR_Restore
;;;1835       for (;;) {
0005dc  bf00              NOP      
                  |L1.1502|
;;;1836           OS_ENTER_CRITICAL();
0005de  f7fffffe          BL       OS_CPU_SR_Save
0005e2  4604              MOV      r4,r0
;;;1837           OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
0005e4  489f              LDR      r0,|L1.2148|
0005e6  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
0005e8  499f              LDR      r1,|L1.2152|
0005ea  6008              STR      r0,[r1,#0]  ; OSIdleCtrRun
;;;1838           OSIdleCtr    = 0uL;                      /* Reset the idle counter for the next second         */
0005ec  f04f0000          MOV      r0,#0
0005f0  499c              LDR      r1,|L1.2148|
0005f2  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1839           OS_EXIT_CRITICAL();
0005f4  4620              MOV      r0,r4
0005f6  f7fffffe          BL       OS_CPU_SR_Restore
;;;1840           OSCPUUsage   = (INT8U)(100uL - OSIdleCtrRun / OSIdleCtrMax);
0005fa  489b              LDR      r0,|L1.2152|
0005fc  6800              LDR      r0,[r0,#0]  ; OSIdleCtrRun
0005fe  4997              LDR      r1,|L1.2140|
000600  6809              LDR      r1,[r1,#0]  ; OSIdleCtrMax
000602  fbb0f0f1          UDIV     r0,r0,r1
000606  f1c00064          RSB      r0,r0,#0x64
00060a  4995              LDR      r1,|L1.2144|
00060c  7008              STRB     r0,[r1,#0]
;;;1841           OSTaskStatHook();                        /* Invoke user definable hook                         */
00060e  f7fffffe          BL       OSTaskStatHook
;;;1842   #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
;;;1843           OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
000612  f7fffffe          BL       OS_TaskStatStkChk
;;;1844   #endif
;;;1845           OSTimeDly(OS_TICKS_PER_SEC / 10u);       /* Accumulate OSIdleCtr for the next 1/10 second      */
000616  2064              MOVS     r0,#0x64
000618  f7fffffe          BL       OSTimeDly
00061c  e7df              B        |L1.1502|
;;;1846       }
;;;1847   }
;;;1848   #endif
                          ENDP

                  OS_InitTaskStat PROC
;;;1468   #if OS_TASK_STAT_EN > 0u
;;;1469   static  void  OS_InitTaskStat (void)
00061e  b500              PUSH     {lr}
;;;1470   {
000620  b087              SUB      sp,sp,#0x1c
;;;1471   #if OS_TASK_NAME_EN > 0u
;;;1472       INT8U  err;
;;;1473   #endif
;;;1474   
;;;1475   
;;;1476   #if OS_TASK_CREATE_EXT_EN > 0u
;;;1477       #if OS_STK_GROWTH == 1u
;;;1478       (void)OSTaskCreateExt(OS_TaskStat,
000622  2003              MOVS     r0,#3
000624  2100              MOVS     r1,#0
000626  2280              MOVS     r2,#0x80
000628  4b90              LDR      r3,|L1.2156|
00062a  e9cd3201          STRD     r3,r2,[sp,#4]
00062e  e9cd1003          STRD     r1,r0,[sp,#0xc]
000632  f64f70fe          MOV      r0,#0xfffe
000636  233e              MOVS     r3,#0x3e
000638  4a8d              LDR      r2,|L1.2160|
00063a  9000              STR      r0,[sp,#0]
00063c  f2af00b9          ADR      r0,OS_TaskStat + 1
000640  f7fffffe          BL       OSTaskCreateExt
;;;1479                             (void *)0,                                   /* No args passed to OS_TaskStat()*/
;;;1480                             &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Top-Of-Stack               */
;;;1481                             OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
;;;1482                             OS_TASK_STAT_ID,
;;;1483                             &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
;;;1484                             OS_TASK_STAT_STK_SIZE,
;;;1485                             (void *)0,                                   /* No TCB extension               */
;;;1486                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
;;;1487       #else
;;;1488       (void)OSTaskCreateExt(OS_TaskStat,
;;;1489                             (void *)0,                                   /* No args passed to OS_TaskStat()*/
;;;1490                             &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
;;;1491                             OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
;;;1492                             OS_TASK_STAT_ID,
;;;1493                             &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Bottom-Of-Stack            */
;;;1494                             OS_TASK_STAT_STK_SIZE,
;;;1495                             (void *)0,                                   /* No TCB extension               */
;;;1496                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
;;;1497       #endif
;;;1498   #else
;;;1499       #if OS_STK_GROWTH == 1u
;;;1500       (void)OSTaskCreate(OS_TaskStat,
;;;1501                          (void *)0,                                      /* No args passed to OS_TaskStat()*/
;;;1502                          &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],     /* Set Top-Of-Stack               */
;;;1503                          OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
;;;1504       #else
;;;1505       (void)OSTaskCreate(OS_TaskStat,
;;;1506                          (void *)0,                                      /* No args passed to OS_TaskStat()*/
;;;1507                          &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
;;;1508                          OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
;;;1509       #endif
;;;1510   #endif
;;;1511   
;;;1512   #if OS_TASK_NAME_EN > 0u
;;;1513       OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)(void *)"uC/OS-II Stat", &err);
000644  aa06              ADD      r2,sp,#0x18
000646  a18b              ADR      r1,|L1.2164|
000648  203e              MOVS     r0,#0x3e
00064a  f7fffffe          BL       OSTaskNameSet
;;;1514   #endif
;;;1515   }
00064e  b007              ADD      sp,sp,#0x1c
000650  bd00              POP      {pc}
;;;1516   #endif
                          ENDP

                  OS_TaskIdle PROC
;;;1766   
;;;1767   void  OS_TaskIdle (void *p_arg)
000652  f04f0400          MOV      r4,#0
;;;1768   {
;;;1769   #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;1770       OS_CPU_SR  cpu_sr = 0u;
;;;1771   #endif
;;;1772   
;;;1773   
;;;1774   
;;;1775       p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
000656  bf00              NOP      
;;;1776       for (;;) {
000658  bf00              NOP      
                  |L1.1626|
;;;1777           OS_ENTER_CRITICAL();
00065a  f7fffffe          BL       OS_CPU_SR_Save
00065e  4604              MOV      r4,r0
;;;1778           OSIdleCtr++;
000660  4880              LDR      r0,|L1.2148|
000662  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
000664  f1000001          ADD      r0,r0,#1
000668  497e              LDR      r1,|L1.2148|
00066a  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1779           OS_EXIT_CRITICAL();
00066c  4620              MOV      r0,r4
00066e  f7fffffe          BL       OS_CPU_SR_Restore
;;;1780           OSTaskIdleHook();                        /* Call user definable HOOK                           */
000672  f7fffffe          BL       OSTaskIdleHook
000676  e7f0              B        |L1.1626|
;;;1781       }
;;;1782   }
;;;1783   /*$PAGE*/
                          ENDP

                  OS_InitTaskIdle PROC
;;;1406   
;;;1407   static  void  OS_InitTaskIdle (void)
000678  b500              PUSH     {lr}
;;;1408   {
00067a  b087              SUB      sp,sp,#0x1c
;;;1409   #if OS_TASK_NAME_EN > 0u
;;;1410       INT8U  err;
;;;1411   #endif
;;;1412   
;;;1413   
;;;1414   #if OS_TASK_CREATE_EXT_EN > 0u
;;;1415       #if OS_STK_GROWTH == 1u
;;;1416       (void)OSTaskCreateExt(OS_TaskIdle,
00067c  2003              MOVS     r0,#3
00067e  2100              MOVS     r1,#0
000680  2280              MOVS     r2,#0x80
000682  4b80              LDR      r3,|L1.2180|
000684  e9cd3201          STRD     r3,r2,[sp,#4]
000688  e9cd1003          STRD     r1,r0,[sp,#0xc]
00068c  f64f70ff          MOV      r0,#0xffff
000690  233f              MOVS     r3,#0x3f
000692  4a7d              LDR      r2,|L1.2184|
000694  9000              STR      r0,[sp,#0]
000696  f2af0045          ADR      r0,OS_TaskIdle + 1
00069a  f7fffffe          BL       OSTaskCreateExt
;;;1417                             (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;1418                             &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Top-Of-Stack                     */
;;;1419                             OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;1420                             OS_TASK_IDLE_ID,
;;;1421                             &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
;;;1422                             OS_TASK_IDLE_STK_SIZE,
;;;1423                             (void *)0,                                 /* No TCB extension                     */
;;;1424                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;1425       #else
;;;1426       (void)OSTaskCreateExt(OS_TaskIdle,
;;;1427                             (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;1428                             &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
;;;1429                             OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;1430                             OS_TASK_IDLE_ID,
;;;1431                             &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Bottom-Of-Stack                  */
;;;1432                             OS_TASK_IDLE_STK_SIZE,
;;;1433                             (void *)0,                                 /* No TCB extension                     */
;;;1434                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;1435       #endif
;;;1436   #else
;;;1437       #if OS_STK_GROWTH == 1u
;;;1438       (void)OSTaskCreate(OS_TaskIdle,
;;;1439                          (void *)0,
;;;1440                          &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],
;;;1441                          OS_TASK_IDLE_PRIO);
;;;1442       #else
;;;1443       (void)OSTaskCreate(OS_TaskIdle,
;;;1444                          (void *)0,
;;;1445                          &OSTaskIdleStk[0],
;;;1446                          OS_TASK_IDLE_PRIO);
;;;1447       #endif
;;;1448   #endif
;;;1449   
;;;1450   #if OS_TASK_NAME_EN > 0u
;;;1451       OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)(void *)"uC/OS-II Idle", &err);
00069e  aa06              ADD      r2,sp,#0x18
0006a0  a17a              ADR      r1,|L1.2188|
0006a2  203f              MOVS     r0,#0x3f
0006a4  f7fffffe          BL       OSTaskNameSet
;;;1452   #endif
;;;1453   }
0006a8  b007              ADD      sp,sp,#0x1c
0006aa  bd00              POP      {pc}
;;;1454   /*$PAGE*/
                          ENDP

                  OS_MemClr PROC
;;;1578   
;;;1579   void  OS_MemClr (INT8U  *pdest,
0006ac  e006              B        |L1.1724|
                  |L1.1710|
;;;1580                    INT16U  size)
;;;1581   {
;;;1582       while (size > 0u) {
;;;1583           *pdest++ = (INT8U)0;
0006ae  f04f0200          MOV      r2,#0
0006b2  f8002b01          STRB     r2,[r0],#1
;;;1584           size--;
0006b6  f1a10201          SUB      r2,r1,#1
0006ba  b291              UXTH     r1,r2
                  |L1.1724|
0006bc  2900              CMP      r1,#0                 ;1582
0006be  d1f6              BNE      |L1.1710|
;;;1585       }
;;;1586   }
0006c0  4770              BX       lr
;;;1587   /*$PAGE*/
                          ENDP

                  OS_InitEventList PROC
;;;1279   
;;;1280   static  void  OS_InitEventList (void)
0006c2  b570              PUSH     {r4-r6,lr}
;;;1281   {
;;;1282   #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
;;;1283   #if (OS_MAX_EVENTS > 1u)
;;;1284       INT16U     ix;
;;;1285       INT16U     ix_next;
;;;1286       OS_EVENT  *pevent1;
;;;1287       OS_EVENT  *pevent2;
;;;1288   
;;;1289   
;;;1290       OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
0006c4  f44f61f0          MOV      r1,#0x780
0006c8  4874              LDR      r0,|L1.2204|
0006ca  f7fffffe          BL       OS_MemClr
;;;1291       for (ix = 0u; ix < (OS_MAX_EVENTS - 1u); ix++) {        /* Init. list of free EVENT control blocks */
0006ce  f04f0400          MOV      r4,#0
0006d2  e014              B        |L1.1790|
                  |L1.1748|
;;;1292           ix_next = ix + 1u;
0006d4  f1040001          ADD      r0,r4,#1
0006d8  b285              UXTH     r5,r0
;;;1293           pevent1 = &OSEventTbl[ix];
0006da  eb040044          ADD      r0,r4,r4,LSL #1
0006de  496f              LDR      r1,|L1.2204|
0006e0  eb0103c0          ADD      r3,r1,r0,LSL #3
;;;1294           pevent2 = &OSEventTbl[ix_next];
0006e4  eb050045          ADD      r0,r5,r5,LSL #1
0006e8  eb0106c0          ADD      r6,r1,r0,LSL #3
;;;1295           pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
0006ec  f04f0000          MOV      r0,#0
0006f0  7018              STRB     r0,[r3,#0]
;;;1296           pevent1->OSEventPtr     = pevent2;
0006f2  605e              STR      r6,[r3,#4]
;;;1297   #if OS_EVENT_NAME_EN > 0u
;;;1298           pevent1->OSEventName    = (INT8U *)(void *)"?";     /* Unknown name                            */
0006f4  a06a              ADR      r0,|L1.2208|
0006f6  6158              STR      r0,[r3,#0x14]
0006f8  f1040001          ADD      r0,r4,#1              ;1291
0006fc  b284              UXTH     r4,r0                 ;1291
                  |L1.1790|
0006fe  2c4f              CMP      r4,#0x4f              ;1291
000700  d3e8              BCC      |L1.1748|
;;;1299   #endif
;;;1300       }
;;;1301       pevent1                         = &OSEventTbl[ix];
000702  eb040044          ADD      r0,r4,r4,LSL #1
000706  4965              LDR      r1,|L1.2204|
000708  eb0103c0          ADD      r3,r1,r0,LSL #3
;;;1302       pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
00070c  f04f0000          MOV      r0,#0
000710  7018              STRB     r0,[r3,#0]
;;;1303       pevent1->OSEventPtr             = (OS_EVENT *)0;
000712  6058              STR      r0,[r3,#4]
;;;1304   #if OS_EVENT_NAME_EN > 0u
;;;1305       pevent1->OSEventName            = (INT8U *)(void *)"?"; /* Unknown name                            */
000714  a062              ADR      r0,|L1.2208|
000716  6158              STR      r0,[r3,#0x14]
;;;1306   #endif
;;;1307       OSEventFreeList                 = &OSEventTbl[0];
000718  4608              MOV      r0,r1
00071a  4962              LDR      r1,|L1.2212|
00071c  6008              STR      r0,[r1,#0]  ; OSEventFreeList
;;;1308   #else
;;;1309       OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
;;;1310       OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;1311       OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
;;;1312   #if OS_EVENT_NAME_EN > 0u
;;;1313       OSEventFreeList->OSEventName    = (INT8U *)"?";         /* Unknown name                            */
;;;1314   #endif
;;;1315   #endif
;;;1316   #endif
;;;1317   }
00071e  bd70              POP      {r4-r6,pc}
;;;1318   /*$PAGE*/
                          ENDP

                  OS_InitTCBList PROC
;;;1530   
;;;1531   static  void  OS_InitTCBList (void)
000720  b570              PUSH     {r4-r6,lr}
;;;1532   {
;;;1533       INT8U    ix;
;;;1534       INT8U    ix_next;
;;;1535       OS_TCB  *ptcb1;
;;;1536       OS_TCB  *ptcb2;
;;;1537   
;;;1538   
;;;1539       OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
000722  f44f61f2          MOV      r1,#0x790
000726  4860              LDR      r0,|L1.2216|
000728  f7fffffe          BL       OS_MemClr
;;;1540       OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
00072c  f44f7180          MOV      r1,#0x100
000730  4848              LDR      r0,|L1.2132|
000732  f7fffffe          BL       OS_MemClr
;;;1541       for (ix = 0u; ix < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); ix++) {    /* Init. list of free TCBs     */
000736  f04f0400          MOV      r4,#0
00073a  e015              B        |L1.1896|
                  |L1.1852|
;;;1542           ix_next =  ix + 1u;
00073c  f1040001          ADD      r0,r4,#1
000740  b2c5              UXTB     r5,r0
;;;1543           ptcb1   = &OSTCBTbl[ix];
000742  eb040044          ADD      r0,r4,r4,LSL #1
000746  eb0000c4          ADD      r0,r0,r4,LSL #3
00074a  4957              LDR      r1,|L1.2216|
00074c  eb0103c0          ADD      r3,r1,r0,LSL #3
;;;1544           ptcb2   = &OSTCBTbl[ix_next];
000750  eb050045          ADD      r0,r5,r5,LSL #1
000754  eb0000c5          ADD      r0,r0,r5,LSL #3
000758  eb0106c0          ADD      r6,r1,r0,LSL #3
;;;1545           ptcb1->OSTCBNext = ptcb2;
00075c  615e              STR      r6,[r3,#0x14]
;;;1546   #if OS_TASK_NAME_EN > 0u
;;;1547           ptcb1->OSTCBTaskName = (INT8U *)(void *)"?";             /* Unknown name                       */
00075e  a050              ADR      r0,|L1.2208|
000760  6518              STR      r0,[r3,#0x50]
000762  f1040001          ADD      r0,r4,#1              ;1541
000766  b2c4              UXTB     r4,r0                 ;1541
                  |L1.1896|
000768  2c15              CMP      r4,#0x15              ;1541
00076a  d3e7              BCC      |L1.1852|
;;;1548   #endif
;;;1549       }
;;;1550       ptcb1                   = &OSTCBTbl[ix];
00076c  eb040044          ADD      r0,r4,r4,LSL #1
000770  eb0000c4          ADD      r0,r0,r4,LSL #3
000774  494c              LDR      r1,|L1.2216|
000776  eb0103c0          ADD      r3,r1,r0,LSL #3
;;;1551       ptcb1->OSTCBNext        = (OS_TCB *)0;                       /* Last OS_TCB                        */
00077a  f04f0000          MOV      r0,#0
00077e  6158              STR      r0,[r3,#0x14]
;;;1552   #if OS_TASK_NAME_EN > 0u
;;;1553       ptcb1->OSTCBTaskName    = (INT8U *)(void *)"?";              /* Unknown name                       */
000780  a047              ADR      r0,|L1.2208|
000782  6518              STR      r0,[r3,#0x50]
;;;1554   #endif
;;;1555       OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
000784  f04f0000          MOV      r0,#0
000788  4948              LDR      r1,|L1.2220|
00078a  6008              STR      r0,[r1,#0]  ; OSTCBList
;;;1556       OSTCBFreeList           = &OSTCBTbl[0];
00078c  4846              LDR      r0,|L1.2216|
00078e  4948              LDR      r1,|L1.2224|
000790  6008              STR      r0,[r1,#0]  ; OSTCBFreeList
;;;1557   }
000792  bd70              POP      {r4-r6,pc}
;;;1558   /*$PAGE*/
                          ENDP

                  OS_InitRdyList PROC
;;;1375   
;;;1376   static  void  OS_InitRdyList (void)
000794  f04f0100          MOV      r1,#0
;;;1377   {
;;;1378       INT8U  i;
;;;1379   
;;;1380   
;;;1381       OSRdyGrp      = 0u;                                    /* Clear the ready list                     */
000798  4a46              LDR      r2,|L1.2228|
00079a  7011              STRB     r1,[r2,#0]
;;;1382       for (i = 0u; i < OS_RDY_TBL_SIZE; i++) {
00079c  4608              MOV      r0,r1
00079e  e006              B        |L1.1966|
                  |L1.1952|
;;;1383           OSRdyTbl[i] = 0u;
0007a0  f04f0100          MOV      r1,#0
0007a4  4a44              LDR      r2,|L1.2232|
0007a6  5411              STRB     r1,[r2,r0]
0007a8  f1000101          ADD      r1,r0,#1              ;1382
0007ac  b2c8              UXTB     r0,r1                 ;1382
                  |L1.1966|
0007ae  2808              CMP      r0,#8                 ;1382
0007b0  d3f6              BCC      |L1.1952|
;;;1384       }
;;;1385   
;;;1386       OSPrioCur     = 0u;
0007b2  f04f0100          MOV      r1,#0
0007b6  4a41              LDR      r2,|L1.2236|
0007b8  7011              STRB     r1,[r2,#0]
;;;1387       OSPrioHighRdy = 0u;
0007ba  4a41              LDR      r2,|L1.2240|
0007bc  7011              STRB     r1,[r2,#0]
;;;1388   
;;;1389       OSTCBHighRdy  = (OS_TCB *)0;
0007be  4a41              LDR      r2,|L1.2244|
0007c0  6011              STR      r1,[r2,#0]  ; OSTCBHighRdy
;;;1390       OSTCBCur      = (OS_TCB *)0;
0007c2  4a23              LDR      r2,|L1.2128|
0007c4  6011              STR      r1,[r2,#0]  ; OSTCBCur
;;;1391   }
0007c6  4770              BX       lr
;;;1392   
                          ENDP

                  OS_InitMisc PROC
;;;1331   
;;;1332   static  void  OS_InitMisc (void)
0007c8  f04f0000          MOV      r0,#0
;;;1333   {
;;;1334   #if OS_TIME_GET_SET_EN > 0u
;;;1335       OSTime                    = 0uL;                       /* Clear the 32-bit system clock            */
0007cc  493e              LDR      r1,|L1.2248|
0007ce  6008              STR      r0,[r1,#0]  ; OSTime
;;;1336   #endif
;;;1337   
;;;1338       OSIntNesting              = 0u;                        /* Clear the interrupt nesting counter      */
0007d0  493e              LDR      r1,|L1.2252|
0007d2  7008              STRB     r0,[r1,#0]
;;;1339       OSLockNesting             = 0u;                        /* Clear the scheduling lock counter        */
0007d4  493e              LDR      r1,|L1.2256|
0007d6  7008              STRB     r0,[r1,#0]
;;;1340   
;;;1341       OSTaskCtr                 = 0u;                        /* Clear the number of tasks                */
0007d8  493e              LDR      r1,|L1.2260|
0007da  7008              STRB     r0,[r1,#0]
;;;1342   
;;;1343       OSRunning                 = OS_FALSE;                  /* Indicate that multitasking not started   */
0007dc  493e              LDR      r1,|L1.2264|
0007de  7008              STRB     r0,[r1,#0]
;;;1344   
;;;1345       OSCtxSwCtr                = 0u;                        /* Clear the context switch counter         */
0007e0  493e              LDR      r1,|L1.2268|
0007e2  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;1346       OSIdleCtr                 = 0uL;                       /* Clear the 32-bit idle counter            */
0007e4  491f              LDR      r1,|L1.2148|
0007e6  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1347   
;;;1348   #if OS_TASK_STAT_EN > 0u
;;;1349       OSIdleCtrRun              = 0uL;
0007e8  491f              LDR      r1,|L1.2152|
0007ea  6008              STR      r0,[r1,#0]  ; OSIdleCtrRun
;;;1350       OSIdleCtrMax              = 0uL;
0007ec  491b              LDR      r1,|L1.2140|
0007ee  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;1351       OSStatRdy                 = OS_FALSE;                  /* Statistic task is not ready              */
0007f0  4919              LDR      r1,|L1.2136|
0007f2  7008              STRB     r0,[r1,#0]
;;;1352   #endif
;;;1353   
;;;1354   #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;1355       OSSafetyCriticalStartFlag = OS_FALSE;                  /* Still allow creation of objects          */
;;;1356   #endif
;;;1357   
;;;1358   #if OS_TASK_REG_TBL_SIZE > 0u
;;;1359       OSTaskRegNextAvailID      = 0u;                        /* Initialize the task register ID          */
0007f4  493a              LDR      r1,|L1.2272|
0007f6  7008              STRB     r0,[r1,#0]
;;;1360   #endif
;;;1361   }
0007f8  4770              BX       lr
;;;1362   /*$PAGE*/
                          ENDP

                  OSInit PROC
;;;574    
;;;575    void  OSInit (void)
0007fa  b510              PUSH     {r4,lr}
;;;576    {
;;;577        OSInitHookBegin();                                           /* Call port specific initialization code   */
0007fc  f7fffffe          BL       OSInitHookBegin
;;;578    
;;;579        OS_InitMisc();                                               /* Initialize miscellaneous variables       */
000800  f7fffffe          BL       OS_InitMisc
;;;580    
;;;581        OS_InitRdyList();                                            /* Initialize the Ready List                */
000804  f7fffffe          BL       OS_InitRdyList
;;;582    
;;;583        OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
000808  f7fffffe          BL       OS_InitTCBList
;;;584    
;;;585        OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
00080c  f7fffffe          BL       OS_InitEventList
;;;586    
;;;587    #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
;;;588        OS_FlagInit();                                               /* Initialize the event flag structures     */
000810  f7fffffe          BL       OS_FlagInit
;;;589    #endif
;;;590    
;;;591    #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
;;;592        OS_MemInit();                                                /* Initialize the memory manager            */
000814  f7fffffe          BL       OS_MemInit
;;;593    #endif
;;;594    
;;;595    #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
;;;596        OS_QInit();                                                  /* Initialize the message queue structures  */
000818  f7fffffe          BL       OS_QInit
;;;597    #endif
;;;598    
;;;599        OS_InitTaskIdle();                                           /* Create the Idle Task                     */
00081c  f7fffffe          BL       OS_InitTaskIdle
;;;600    #if OS_TASK_STAT_EN > 0u
;;;601        OS_InitTaskStat();                                           /* Create the Statistic Task                */
000820  f7fffffe          BL       OS_InitTaskStat
;;;602    #endif
;;;603    
;;;604    #if OS_TMR_EN > 0u
;;;605        OSTmr_Init();                                                /* Initialize the Timer Manager             */
000824  f7fffffe          BL       OSTmr_Init
;;;606    #endif
;;;607    
;;;608        OSInitHookEnd();                                             /* Call port specific init. code            */
000828  f7fffffe          BL       OSInitHookEnd
;;;609    
;;;610    #if OS_DEBUG_EN > 0u
;;;611        OSDebugInit();
00082c  f7fffffe          BL       OSDebugInit
;;;612    #endif
;;;613    }
000830  bd10              POP      {r4,pc}
;;;614    /*$PAGE*/
                          ENDP

                  OSIntEnter PROC
;;;639    
;;;640    void  OSIntEnter (void)
000832  4829              LDR      r0,|L1.2264|
;;;641    {
;;;642        if (OSRunning == OS_TRUE) {
000834  7800              LDRB     r0,[r0,#0]  ; OSRunning
000836  2801              CMP      r0,#1
000838  d109              BNE      |L1.2126|
;;;643            if (OSIntNesting < 255u) {
00083a  4824              LDR      r0,|L1.2252|
00083c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00083e  28ff              CMP      r0,#0xff
000840  d205              BCS      |L1.2126|
;;;644                OSIntNesting++;                      /* Increment ISR nesting level                        */
000842  4822              LDR      r0,|L1.2252|
000844  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000846  f1000001          ADD      r0,r0,#1
00084a  4920              LDR      r1,|L1.2252|
00084c  7008              STRB     r0,[r1,#0]
                  |L1.2126|
;;;645            }
;;;646        }
;;;647    }
00084e  4770              BX       lr
                  |L1.2128|
                          DCD      OSTCBCur
                  |L1.2132|
                          DCD      OSTCBPrioTbl
                  |L1.2136|
                          DCD      OSStatRdy
                  |L1.2140|
                          DCD      OSIdleCtrMax
                  |L1.2144|
                          DCD      OSCPUUsage
                  |L1.2148|
                          DCD      OSIdleCtr
                  |L1.2152|
                          DCD      OSIdleCtrRun
                  |L1.2156|
                          DCD      OSTaskStatStk
                  |L1.2160|
                          DCD      OSTaskStatStk+0x1fc
                  |L1.2164|
000874  75432f4f          DCB      "uC/OS-II Stat",0
000878  532d4949
00087c  20537461
000880  7400    
000882  00                DCB      0
000883  00                DCB      0
                  |L1.2180|
                          DCD      OSTaskIdleStk
                  |L1.2184|
                          DCD      OSTaskIdleStk+0x1fc
                  |L1.2188|
00088c  75432f4f          DCB      "uC/OS-II Idle",0
000890  532d4949
000894  2049646c
000898  6500    
00089a  00                DCB      0
00089b  00                DCB      0
                  |L1.2204|
                          DCD      OSEventTbl
                  |L1.2208|
0008a0  3f00              DCB      "?",0
0008a2  00                DCB      0
0008a3  00                DCB      0
                  |L1.2212|
                          DCD      OSEventFreeList
                  |L1.2216|
                          DCD      OSTCBTbl
                  |L1.2220|
                          DCD      OSTCBList
                  |L1.2224|
                          DCD      OSTCBFreeList
                  |L1.2228|
                          DCD      OSRdyGrp
                  |L1.2232|
                          DCD      OSRdyTbl
                  |L1.2236|
                          DCD      OSPrioCur
                  |L1.2240|
                          DCD      OSPrioHighRdy
                  |L1.2244|
                          DCD      OSTCBHighRdy
                  |L1.2248|
                          DCD      OSTime
                  |L1.2252|
                          DCD      OSIntNesting
                  |L1.2256|
                          DCD      OSLockNesting
                  |L1.2260|
                          DCD      OSTaskCtr
                  |L1.2264|
                          DCD      OSRunning
                  |L1.2268|
                          DCD      OSCtxSwCtr
                  |L1.2272|
                          DCD      OSTaskRegNextAvailID
                          ENDP

                  OSIntExit PROC
;;;667    
;;;668    void  OSIntExit (void)
0008e4  b510              PUSH     {r4,lr}
;;;669    {
;;;670    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;671        OS_CPU_SR  cpu_sr = 0u;
0008e6  f04f0400          MOV      r4,#0
;;;672    #endif
;;;673    
;;;674    
;;;675    
;;;676        if (OSRunning == OS_TRUE) {
0008ea  48f6              LDR      r0,|L1.3268|
0008ec  7800              LDRB     r0,[r0,#0]  ; OSRunning
0008ee  2801              CMP      r0,#1
0008f0  d133              BNE      |L1.2394|
;;;677            OS_ENTER_CRITICAL();
0008f2  f7fffffe          BL       OS_CPU_SR_Save
0008f6  4604              MOV      r4,r0
;;;678            if (OSIntNesting > 0u) {                           /* Prevent OSIntNesting from wrapping       */
0008f8  48f3              LDR      r0,|L1.3272|
0008fa  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
0008fc  b128              CBZ      r0,|L1.2314|
;;;679                OSIntNesting--;
0008fe  48f2              LDR      r0,|L1.3272|
000900  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000902  f1a00001          SUB      r0,r0,#1
000906  49f0              LDR      r1,|L1.3272|
000908  7008              STRB     r0,[r1,#0]
                  |L1.2314|
;;;680            }
;;;681            if (OSIntNesting == 0u) {                          /* Reschedule only if all ISRs complete ... */
00090a  48ef              LDR      r0,|L1.3272|
00090c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00090e  bb08              CBNZ     r0,|L1.2388|
;;;682                if (OSLockNesting == 0u) {                     /* ... and not locked.                      */
000910  48ee              LDR      r0,|L1.3276|
000912  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000914  b9f0              CBNZ     r0,|L1.2388|
;;;683                    OS_SchedNew();
000916  f7fffffe          BL       OS_SchedNew
;;;684                    OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
00091a  48ed              LDR      r0,|L1.3280|
00091c  49ed              LDR      r1,|L1.3284|
00091e  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
000920  f8500021          LDR      r0,[r0,r1,LSL #2]
000924  49ec              LDR      r1,|L1.3288|
000926  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;685                    if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
000928  48ea              LDR      r0,|L1.3284|
00092a  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
00092c  49eb              LDR      r1,|L1.3292|
00092e  7809              LDRB     r1,[r1,#0]  ; OSPrioCur
000930  4288              CMP      r0,r1
000932  d00f              BEQ      |L1.2388|
;;;686    #if OS_TASK_PROFILE_EN > 0u
;;;687                        OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
000934  48e8              LDR      r0,|L1.3288|
000936  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
000938  6bc0              LDR      r0,[r0,#0x3c]
00093a  f1000001          ADD      r0,r0,#1
00093e  49e6              LDR      r1,|L1.3288|
000940  6809              LDR      r1,[r1,#0]  ; OSTCBHighRdy
000942  63c8              STR      r0,[r1,#0x3c]
;;;688    #endif
;;;689                        OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
000944  48e6              LDR      r0,|L1.3296|
000946  6800              LDR      r0,[r0,#0]  ; OSCtxSwCtr
000948  f1000001          ADD      r0,r0,#1
00094c  49e4              LDR      r1,|L1.3296|
00094e  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;690                        OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
000950  f7fffffe          BL       OSIntCtxSw
                  |L1.2388|
;;;691                    }
;;;692                }
;;;693            }
;;;694            OS_EXIT_CRITICAL();
000954  4620              MOV      r0,r4
000956  f7fffffe          BL       OS_CPU_SR_Restore
                  |L1.2394|
;;;695        }
;;;696    }
00095a  bd10              POP      {r4,pc}
;;;697    /*$PAGE*/
                          ENDP

                  OSSchedLock PROC
;;;740    #if OS_SCHED_LOCK_EN > 0u
;;;741    void  OSSchedLock (void)
00095c  b510              PUSH     {r4,lr}
;;;742    {
;;;743    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;744        OS_CPU_SR  cpu_sr = 0u;
00095e  f04f0400          MOV      r4,#0
;;;745    #endif
;;;746    
;;;747    
;;;748    
;;;749        if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
000962  48d8              LDR      r0,|L1.3268|
000964  7800              LDRB     r0,[r0,#0]  ; OSRunning
000966  2801              CMP      r0,#1
000968  d112              BNE      |L1.2448|
;;;750            OS_ENTER_CRITICAL();
00096a  f7fffffe          BL       OS_CPU_SR_Save
00096e  4604              MOV      r4,r0
;;;751            if (OSIntNesting == 0u) {                /* Can't call from an ISR                             */
000970  48d5              LDR      r0,|L1.3272|
000972  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000974  b948              CBNZ     r0,|L1.2442|
;;;752                if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
000976  48d5              LDR      r0,|L1.3276|
000978  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
00097a  28ff              CMP      r0,#0xff
00097c  d205              BCS      |L1.2442|
;;;753                    OSLockNesting++;                 /* Increment lock nesting level                       */
00097e  48d3              LDR      r0,|L1.3276|
000980  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000982  f1000001          ADD      r0,r0,#1
000986  49d1              LDR      r1,|L1.3276|
000988  7008              STRB     r0,[r1,#0]
                  |L1.2442|
;;;754                }
;;;755            }
;;;756            OS_EXIT_CRITICAL();
00098a  4620              MOV      r0,r4
00098c  f7fffffe          BL       OS_CPU_SR_Restore
                  |L1.2448|
;;;757        }
;;;758    }
000990  bd10              POP      {r4,pc}
;;;759    #endif
                          ENDP

                  OSSchedUnlock PROC
;;;777    #if OS_SCHED_LOCK_EN > 0u
;;;778    void  OSSchedUnlock (void)
000992  b510              PUSH     {r4,lr}
;;;779    {
;;;780    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;781        OS_CPU_SR  cpu_sr = 0u;
000994  f04f0400          MOV      r4,#0
;;;782    #endif
;;;783    
;;;784    
;;;785    
;;;786        if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
000998  48ca              LDR      r0,|L1.3268|
00099a  7800              LDRB     r0,[r0,#0]  ; OSRunning
00099c  2801              CMP      r0,#1
00099e  d122              BNE      |L1.2534|
;;;787            OS_ENTER_CRITICAL();
0009a0  f7fffffe          BL       OS_CPU_SR_Save
0009a4  4604              MOV      r4,r0
;;;788            if (OSIntNesting == 0u) {                          /* Can't call from an ISR                   */
0009a6  48c8              LDR      r0,|L1.3272|
0009a8  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
0009aa  b9c8              CBNZ     r0,|L1.2528|
;;;789                if (OSLockNesting > 0u) {                      /* Do not decrement if already 0            */
0009ac  48c7              LDR      r0,|L1.3276|
0009ae  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
0009b0  b190              CBZ      r0,|L1.2520|
;;;790                    OSLockNesting--;                           /* Decrement lock nesting level             */
0009b2  48c6              LDR      r0,|L1.3276|
0009b4  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
0009b6  f1a00001          SUB      r0,r0,#1
0009ba  49c4              LDR      r1,|L1.3276|
0009bc  7008              STRB     r0,[r1,#0]
;;;791                    if (OSLockNesting == 0u) {                 /* See if scheduler is enabled              */
0009be  4608              MOV      r0,r1
0009c0  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
0009c2  b928              CBNZ     r0,|L1.2512|
;;;792                        OS_EXIT_CRITICAL();
0009c4  4620              MOV      r0,r4
0009c6  f7fffffe          BL       OS_CPU_SR_Restore
;;;793                        OS_Sched();                            /* See if a HPT is ready                    */
0009ca  f7fffffe          BL       OS_Sched
0009ce  e00a              B        |L1.2534|
                  |L1.2512|
;;;794                    } else {
;;;795                        OS_EXIT_CRITICAL();
0009d0  4620              MOV      r0,r4
0009d2  f7fffffe          BL       OS_CPU_SR_Restore
0009d6  e006              B        |L1.2534|
                  |L1.2520|
;;;796                    }
;;;797                } else {
;;;798                    OS_EXIT_CRITICAL();
0009d8  4620              MOV      r0,r4
0009da  f7fffffe          BL       OS_CPU_SR_Restore
0009de  e002              B        |L1.2534|
                  |L1.2528|
;;;799                }
;;;800            } else {
;;;801                OS_EXIT_CRITICAL();
0009e0  4620              MOV      r0,r4
0009e2  f7fffffe          BL       OS_CPU_SR_Restore
                  |L1.2534|
;;;802            }
;;;803        }
;;;804    }
0009e6  bd10              POP      {r4,pc}
;;;805    #endif
                          ENDP

                  OSStart PROC
;;;827    
;;;828    void  OSStart (void)
0009e8  b510              PUSH     {r4,lr}
;;;829    {
;;;830        if (OSRunning == OS_FALSE) {
0009ea  48b6              LDR      r0,|L1.3268|
0009ec  7800              LDRB     r0,[r0,#0]  ; OSRunning
0009ee  b990              CBNZ     r0,|L1.2582|
;;;831            OS_SchedNew();                               /* Find highest priority's task priority number   */
0009f0  f7fffffe          BL       OS_SchedNew
;;;832            OSPrioCur     = OSPrioHighRdy;
0009f4  48b7              LDR      r0,|L1.3284|
0009f6  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
0009f8  49b8              LDR      r1,|L1.3292|
0009fa  7008              STRB     r0,[r1,#0]
;;;833            OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
0009fc  48b4              LDR      r0,|L1.3280|
0009fe  49b5              LDR      r1,|L1.3284|
000a00  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
000a02  f8500021          LDR      r0,[r0,r1,LSL #2]
000a06  49b4              LDR      r1,|L1.3288|
000a08  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;834            OSTCBCur      = OSTCBHighRdy;
000a0a  4608              MOV      r0,r1
000a0c  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
000a0e  49b5              LDR      r1,|L1.3300|
000a10  6008              STR      r0,[r1,#0]  ; OSTCBCur
;;;835            OSStartHighRdy();                            /* Execute target specific code to start task     */
000a12  f7fffffe          BL       OSStartHighRdy
                  |L1.2582|
;;;836        }
;;;837    }
000a16  bd10              POP      {r4,pc}
;;;838    /*$PAGE*/
                          ENDP

                  OSStatInit PROC
;;;859    #if OS_TASK_STAT_EN > 0u
;;;860    void  OSStatInit (void)
000a18  b510              PUSH     {r4,lr}
;;;861    {
;;;862    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;863        OS_CPU_SR  cpu_sr = 0u;
000a1a  f04f0400          MOV      r4,#0
;;;864    #endif
;;;865    
;;;866    
;;;867    
;;;868        OSTimeDly(2u);                               /* Synchronize with clock tick                        */
000a1e  f04f0002          MOV      r0,#2
000a22  f7fffffe          BL       OSTimeDly
;;;869        OS_ENTER_CRITICAL();
000a26  f7fffffe          BL       OS_CPU_SR_Save
000a2a  4604              MOV      r4,r0
;;;870        OSIdleCtr    = 0uL;                          /* Clear idle counter                                 */
000a2c  f04f0000          MOV      r0,#0
000a30  49ad              LDR      r1,|L1.3304|
000a32  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;871        OS_EXIT_CRITICAL();
000a34  4620              MOV      r0,r4
000a36  f7fffffe          BL       OS_CPU_SR_Restore
;;;872        OSTimeDly(OS_TICKS_PER_SEC / 10u);           /* Determine MAX. idle counter value for 1/10 second  */
000a3a  2064              MOVS     r0,#0x64
000a3c  f7fffffe          BL       OSTimeDly
;;;873        OS_ENTER_CRITICAL();
000a40  f7fffffe          BL       OS_CPU_SR_Save
000a44  4604              MOV      r4,r0
;;;874        OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
000a46  48a8              LDR      r0,|L1.3304|
000a48  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
000a4a  49a8              LDR      r1,|L1.3308|
000a4c  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;875        OSStatRdy    = OS_TRUE;
000a4e  f04f0001          MOV      r0,#1
000a52  49a7              LDR      r1,|L1.3312|
000a54  7008              STRB     r0,[r1,#0]
;;;876        OS_EXIT_CRITICAL();
000a56  4620              MOV      r0,r4
000a58  f7fffffe          BL       OS_CPU_SR_Restore
;;;877    }
000a5c  bd10              POP      {r4,pc}
;;;878    #endif
                          ENDP

                  OSTimeTick PROC
;;;893    
;;;894    void  OSTimeTick (void)
000a5e  b570              PUSH     {r4-r6,lr}
;;;895    {
;;;896        OS_TCB    *ptcb;
;;;897    #if OS_TICK_STEP_EN > 0u
;;;898        BOOLEAN    step;
;;;899    #endif
;;;900    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register     */
;;;901        OS_CPU_SR  cpu_sr = 0u;
000a60  f04f0600          MOV      r6,#0
;;;902    #endif
;;;903    
;;;904    
;;;905    
;;;906    #if OS_TIME_TICK_HOOK_EN > 0u
;;;907        OSTimeTickHook();                                      /* Call user definable hook                     */
000a64  f7fffffe          BL       OSTimeTickHook
;;;908    #endif
;;;909    #if OS_TIME_GET_SET_EN > 0u
;;;910        OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
000a68  f7fffffe          BL       OS_CPU_SR_Save
000a6c  4606              MOV      r6,r0
;;;911        OSTime++;
000a6e  48a1              LDR      r0,|L1.3316|
000a70  6800              LDR      r0,[r0,#0]  ; OSTime
000a72  f1000001          ADD      r0,r0,#1
000a76  499f              LDR      r1,|L1.3316|
000a78  6008              STR      r0,[r1,#0]  ; OSTime
;;;912        OS_EXIT_CRITICAL();
000a7a  4630              MOV      r0,r6
000a7c  f7fffffe          BL       OS_CPU_SR_Restore
;;;913    #endif
;;;914        if (OSRunning == OS_TRUE) {
000a80  4890              LDR      r0,|L1.3268|
000a82  7800              LDRB     r0,[r0,#0]  ; OSRunning
000a84  2801              CMP      r0,#1
000a86  d15f              BNE      |L1.2888|
;;;915    #if OS_TICK_STEP_EN > 0u
;;;916            switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
000a88  489b              LDR      r0,|L1.3320|
000a8a  7800              LDRB     r0,[r0,#0]  ; OSTickStepState
000a8c  b120              CBZ      r0,|L1.2712|
000a8e  2801              CMP      r0,#1
000a90  d005              BEQ      |L1.2718|
000a92  2802              CMP      r0,#2
000a94  d10c              BNE      |L1.2736|
000a96  e005              B        |L1.2724|
                  |L1.2712|
;;;917                case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
;;;918                     step = OS_TRUE;
000a98  f04f0501          MOV      r5,#1
;;;919                     break;
000a9c  e00f              B        |L1.2750|
                  |L1.2718|
;;;920    
;;;921                case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
;;;922                     step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
000a9e  f04f0500          MOV      r5,#0
;;;923                     break;
000aa2  e00c              B        |L1.2750|
                  |L1.2724|
;;;924    
;;;925                case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
;;;926                     step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
000aa4  f04f0501          MOV      r5,#1
;;;927                     OSTickStepState = OS_TICK_STEP_WAIT;
000aa8  4628              MOV      r0,r5
000aaa  4993              LDR      r1,|L1.3320|
000aac  7008              STRB     r0,[r1,#0]
;;;928                     break;
000aae  e006              B        |L1.2750|
                  |L1.2736|
;;;929    
;;;930                default:                                       /* Invalid case, correct situation              */
;;;931                     step            = OS_TRUE;
000ab0  f04f0501          MOV      r5,#1
;;;932                     OSTickStepState = OS_TICK_STEP_DIS;
000ab4  f04f0000          MOV      r0,#0
000ab8  498f              LDR      r1,|L1.3320|
000aba  7008              STRB     r0,[r1,#0]
;;;933                     break;
000abc  bf00              NOP      
                  |L1.2750|
000abe  bf00              NOP                            ;919
;;;934            }
;;;935            if (step == OS_FALSE) {                            /* Return if waiting for step command           */
000ac0  b905              CBNZ     r5,|L1.2756|
                  |L1.2754|
;;;936                return;
;;;937            }
;;;938    #endif
;;;939            ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
;;;940            while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
;;;941                OS_ENTER_CRITICAL();
;;;942                if (ptcb->OSTCBDly != 0u) {                    /* No, Delayed or waiting for event with TO     */
;;;943                    ptcb->OSTCBDly--;                          /* Decrement nbr of ticks to end of delay       */
;;;944                    if (ptcb->OSTCBDly == 0u) {                /* Check for timeout                            */
;;;945    
;;;946                        if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
;;;947                            ptcb->OSTCBStat  &= (INT8U)~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
;;;948                            ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
;;;949                        } else {
;;;950                            ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
;;;951                        }
;;;952    
;;;953                        if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
;;;954                            OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
;;;955                            OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
;;;956                        }
;;;957                    }
;;;958                }
;;;959                ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
;;;960                OS_EXIT_CRITICAL();
;;;961            }
;;;962        }
;;;963    }
000ac2  bd70              POP      {r4-r6,pc}
                  |L1.2756|
000ac4  488d              LDR      r0,|L1.3324|
000ac6  6804              LDR      r4,[r0,#0]            ;939  ; OSTCBList
000ac8  e03a              B        |L1.2880|
                  |L1.2762|
000aca  f7fffffe          BL       OS_CPU_SR_Save
000ace  4606              MOV      r6,r0                 ;941
000ad0  6b20              LDR      r0,[r4,#0x30]         ;942
000ad2  b388              CBZ      r0,|L1.2872|
000ad4  6b20              LDR      r0,[r4,#0x30]         ;943
000ad6  f1a00001          SUB      r0,r0,#1              ;943
000ada  6320              STR      r0,[r4,#0x30]         ;943
000adc  6b20              LDR      r0,[r4,#0x30]         ;944
000ade  bb58              CBNZ     r0,|L1.2872|
000ae0  f8940034          LDRB     r0,[r4,#0x34]         ;946
000ae4  f0100f37          TST      r0,#0x37              ;946
000ae8  d00a              BEQ      |L1.2816|
000aea  f8140f34          LDRB     r0,[r4,#0x34]!        ;947
000aee  f00000c8          AND      r0,r0,#0xc8           ;947
000af2  7020              STRB     r0,[r4,#0]            ;947
000af4  f04f0001          MOV      r0,#1                 ;948
000af8  7060              STRB     r0,[r4,#1]            ;948
000afa  f1a40434          SUB      r4,r4,#0x34           ;948
000afe  e003              B        |L1.2824|
                  |L1.2816|
000b00  f04f0000          MOV      r0,#0                 ;950
000b04  f8840035          STRB     r0,[r4,#0x35]         ;950
                  |L1.2824|
000b08  f8940034          LDRB     r0,[r4,#0x34]         ;953
000b0c  f0100f08          TST      r0,#8                 ;953
000b10  d112              BNE      |L1.2872|
000b12  f1040438          ADD      r4,r4,#0x38           ;954
000b16  78a0              LDRB     r0,[r4,#2]            ;954
000b18  4979              LDR      r1,|L1.3328|
000b1a  7809              LDRB     r1,[r1,#0]            ;954  ; OSRdyGrp
000b1c  ea400001          ORR      r0,r0,r1              ;954
000b20  4977              LDR      r1,|L1.3328|
000b22  7008              STRB     r0,[r1,#0]            ;954
000b24  7820              LDRB     r0,[r4,#0]            ;955
000b26  4977              LDR      r1,|L1.3332|
000b28  5c08              LDRB     r0,[r1,r0]            ;955
000b2a  7861              LDRB     r1,[r4,#1]            ;955
000b2c  ea400001          ORR      r0,r0,r1              ;955
000b30  f8141938          LDRB     r1,[r4],#-0x38        ;955
000b34  4a73              LDR      r2,|L1.3332|
000b36  5450              STRB     r0,[r2,r1]            ;955
                  |L1.2872|
000b38  6964              LDR      r4,[r4,#0x14]         ;959
000b3a  4630              MOV      r0,r6                 ;960
000b3c  f7fffffe          BL       OS_CPU_SR_Restore
                  |L1.2880|
000b40  f8940036          LDRB     r0,[r4,#0x36]         ;940
000b44  283f              CMP      r0,#0x3f              ;940
000b46  d1c0              BNE      |L1.2762|
                  |L1.2888|
000b48  bf00              NOP      
000b4a  e7ba              B        |L1.2754|
;;;964    
                          ENDP

                  OSVersion PROC
;;;979    
;;;980    INT16U  OSVersion (void)
000b4c  f2472017          MOV      r0,#0x7217
;;;981    {
;;;982        return (OS_VERSION);
;;;983    }
000b50  4770              BX       lr
;;;984    
                          ENDP

                  OS_Dummy PROC
;;;998    #if OS_TASK_DEL_EN > 0u
;;;999    void  OS_Dummy (void)
000b52  4770              BX       lr
;;;1000   {
;;;1001   }
;;;1002   #endif
                          ENDP

                  OS_EventTaskRemove PROC
;;;1184   #if (OS_EVENT_EN)
;;;1185   void  OS_EventTaskRemove (OS_TCB   *ptcb,
000b54  b510              PUSH     {r4,lr}
;;;1186                             OS_EVENT *pevent)
;;;1187   {
;;;1188       INT8U  y;
;;;1189   
;;;1190   
;;;1191       y                       =  ptcb->OSTCBY;
000b56  f8902038          LDRB     r2,[r0,#0x38]
;;;1192       pevent->OSEventTbl[y]  &= (OS_PRIO)~ptcb->OSTCBBitX;    /* Remove task from wait list              */
000b5a  f101030b          ADD      r3,r1,#0xb
000b5e  5c9b              LDRB     r3,[r3,r2]
000b60  f8904039          LDRB     r4,[r0,#0x39]
000b64  ea6f0404          MVN      r4,r4
000b68  b2e4              UXTB     r4,r4
000b6a  ea030304          AND      r3,r3,r4
000b6e  f101040b          ADD      r4,r1,#0xb
000b72  54a3              STRB     r3,[r4,r2]
;;;1193       if (pevent->OSEventTbl[y] == 0u) {
000b74  4623              MOV      r3,r4
000b76  5c9b              LDRB     r3,[r3,r2]
000b78  b943              CBNZ     r3,|L1.2956|
;;;1194           pevent->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
000b7a  7a8b              LDRB     r3,[r1,#0xa]
000b7c  f890403a          LDRB     r4,[r0,#0x3a]
000b80  ea6f0404          MVN      r4,r4
000b84  b2e4              UXTB     r4,r4
000b86  ea030304          AND      r3,r3,r4
000b8a  728b              STRB     r3,[r1,#0xa]
                  |L1.2956|
;;;1195       }
;;;1196   }
000b8c  bd10              POP      {r4,pc}
;;;1197   #endif
                          ENDP

                  OS_EventTaskRdy PROC
;;;1032   #if (OS_EVENT_EN)
;;;1033   INT8U  OS_EventTaskRdy (OS_EVENT  *pevent,
000b8e  e92d4ff0          PUSH     {r4-r11,lr}
;;;1034                           void      *pmsg,
;;;1035                           INT8U      msk,
;;;1036                           INT8U      pend_stat)
;;;1037   {
000b92  4605              MOV      r5,r0
000b94  460f              MOV      r7,r1
000b96  4690              MOV      r8,r2
000b98  4699              MOV      r9,r3
;;;1038       OS_TCB   *ptcb;
;;;1039       INT8U     y;
;;;1040       INT8U     x;
;;;1041       INT8U     prio;
;;;1042   #if OS_LOWEST_PRIO > 63u
;;;1043       OS_PRIO  *ptbl;
;;;1044   #endif
;;;1045   
;;;1046   
;;;1047   #if OS_LOWEST_PRIO <= 63u
;;;1048       y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
000b9a  7aa8              LDRB     r0,[r5,#0xa]
000b9c  495a              LDR      r1,|L1.3336|
000b9e  5c0e              LDRB     r6,[r1,r0]
;;;1049       x    = OSUnMapTbl[pevent->OSEventTbl[y]];
000ba0  f105000b          ADD      r0,r5,#0xb
000ba4  5d80              LDRB     r0,[r0,r6]
000ba6  f811b000          LDRB     r11,[r1,r0]
;;;1050       prio = (INT8U)((y << 3u) + x);                      /* Find priority of task getting the msg       */
000baa  eb0b00c6          ADD      r0,r11,r6,LSL #3
000bae  f0000aff          AND      r10,r0,#0xff
;;;1051   #else
;;;1052       if ((pevent->OSEventGrp & 0xFFu) != 0u) {           /* Find HPT waiting for message                */
;;;1053           y = OSUnMapTbl[ pevent->OSEventGrp & 0xFFu];
;;;1054       } else {
;;;1055           y = OSUnMapTbl[(OS_PRIO)(pevent->OSEventGrp >> 8u) & 0xFFu] + 8u;
;;;1056       }
;;;1057       ptbl = &pevent->OSEventTbl[y];
;;;1058       if ((*ptbl & 0xFFu) != 0u) {
;;;1059           x = OSUnMapTbl[*ptbl & 0xFFu];
;;;1060       } else {
;;;1061           x = OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u;
;;;1062       }
;;;1063       prio = (INT8U)((y << 4u) + x);                      /* Find priority of task getting the msg       */
;;;1064   #endif
;;;1065   
;;;1066       ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
000bb2  4847              LDR      r0,|L1.3280|
000bb4  f850402a          LDR      r4,[r0,r10,LSL #2]
;;;1067       ptcb->OSTCBDly        =  0u;                        /* Prevent OSTimeTick() from readying task     */
000bb8  f04f0000          MOV      r0,#0
000bbc  f1040424          ADD      r4,r4,#0x24
000bc0  60e0              STR      r0,[r4,#0xc]
;;;1068   #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
;;;1069       ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
000bc2  6027              STR      r7,[r4,#0]
;;;1070   #else
;;;1071       pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
;;;1072   #endif
;;;1073       ptcb->OSTCBStat      &= (INT8U)~msk;                /* Clear bit associated with event type        */
000bc4  7c20              LDRB     r0,[r4,#0x10]
000bc6  ea6f0108          MVN      r1,r8
000bca  b2c9              UXTB     r1,r1
000bcc  ea000001          AND      r0,r0,r1
000bd0  7420              STRB     r0,[r4,#0x10]
;;;1074       ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
000bd2  f8849011          STRB     r9,[r4,#0x11]
;;;1075                                                           /* See if task is ready (could be susp'd)      */
;;;1076       if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
000bd6  7c20              LDRB     r0,[r4,#0x10]
000bd8  f1a40424          SUB      r4,r4,#0x24
000bdc  f0100f08          TST      r0,#8
000be0  d10f              BNE      |L1.3074|
;;;1077           OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
000be2  f894003a          LDRB     r0,[r4,#0x3a]
000be6  4946              LDR      r1,|L1.3328|
000be8  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
000bea  ea400001          ORR      r0,r0,r1
000bee  4944              LDR      r1,|L1.3328|
000bf0  7008              STRB     r0,[r1,#0]
;;;1078           OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
000bf2  4844              LDR      r0,|L1.3332|
000bf4  5d80              LDRB     r0,[r0,r6]
000bf6  f8941039          LDRB     r1,[r4,#0x39]
000bfa  ea400001          ORR      r0,r0,r1
000bfe  4941              LDR      r1,|L1.3332|
000c00  5588              STRB     r0,[r1,r6]
                  |L1.3074|
;;;1079       }
;;;1080   
;;;1081       OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
000c02  4629              MOV      r1,r5
000c04  4620              MOV      r0,r4
000c06  f7fffffe          BL       OS_EventTaskRemove
;;;1082   #if (OS_EVENT_MULTI_EN > 0u)
;;;1083       if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
000c0a  6a20              LDR      r0,[r4,#0x20]
000c0c  b120              CBZ      r0,|L1.3096|
;;;1084           OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
000c0e  4620              MOV      r0,r4
000c10  6a21              LDR      r1,[r4,#0x20]
000c12  f7fffffe          BL       OS_EventTaskRemoveMulti
;;;1085           ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
000c16  61e5              STR      r5,[r4,#0x1c]
                  |L1.3096|
;;;1086       }
;;;1087   #endif
;;;1088   
;;;1089       return (prio);
000c18  4650              MOV      r0,r10
;;;1090   }
000c1a  e8bd8ff0          POP      {r4-r11,pc}
;;;1091   #endif
                          ENDP

                  OS_EventTaskWait PROC
;;;1107   #if (OS_EVENT_EN)
;;;1108   void  OS_EventTaskWait (OS_EVENT *pevent)
000c1e  b510              PUSH     {r4,lr}
;;;1109   {
;;;1110       INT8U  y;
;;;1111   
;;;1112   
;;;1113       OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
000c20  4a30              LDR      r2,|L1.3300|
000c22  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000c24  61d0              STR      r0,[r2,#0x1c]
;;;1114   
;;;1115       pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
000c26  4a2f              LDR      r2,|L1.3300|
000c28  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000c2a  f8923038          LDRB     r3,[r2,#0x38]
000c2e  f100020b          ADD      r2,r0,#0xb
000c32  5cd2              LDRB     r2,[r2,r3]
000c34  4b2b              LDR      r3,|L1.3300|
000c36  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000c38  f8933039          LDRB     r3,[r3,#0x39]
000c3c  ea420203          ORR      r2,r2,r3
000c40  4b28              LDR      r3,|L1.3300|
000c42  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000c44  f8934038          LDRB     r4,[r3,#0x38]
000c48  f100030b          ADD      r3,r0,#0xb
000c4c  551a              STRB     r2,[r3,r4]
;;;1116       pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
000c4e  7a82              LDRB     r2,[r0,#0xa]
000c50  4b24              LDR      r3,|L1.3300|
000c52  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000c54  f893303a          LDRB     r3,[r3,#0x3a]
000c58  ea420203          ORR      r2,r2,r3
000c5c  7282              STRB     r2,[r0,#0xa]
;;;1117   
;;;1118       y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
000c5e  4a21              LDR      r2,|L1.3300|
000c60  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000c62  f8921038          LDRB     r1,[r2,#0x38]
;;;1119       OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
000c66  4a27              LDR      r2,|L1.3332|
000c68  5c52              LDRB     r2,[r2,r1]
000c6a  4b1e              LDR      r3,|L1.3300|
000c6c  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000c6e  f8933039          LDRB     r3,[r3,#0x39]
000c72  ea6f0303          MVN      r3,r3
000c76  b2db              UXTB     r3,r3
000c78  ea020203          AND      r2,r2,r3
000c7c  4b21              LDR      r3,|L1.3332|
000c7e  545a              STRB     r2,[r3,r1]
;;;1120       if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
000c80  461a              MOV      r2,r3
000c82  5c52              LDRB     r2,[r2,r1]
000c84  b962              CBNZ     r2,|L1.3232|
;;;1121           OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
000c86  4a17              LDR      r2,|L1.3300|
000c88  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000c8a  f892203a          LDRB     r2,[r2,#0x3a]
000c8e  ea6f0202          MVN      r2,r2
000c92  b2d2              UXTB     r2,r2
000c94  4b1a              LDR      r3,|L1.3328|
000c96  781b              LDRB     r3,[r3,#0]  ; OSRdyGrp
000c98  ea020203          AND      r2,r2,r3
000c9c  4b18              LDR      r3,|L1.3328|
000c9e  701a              STRB     r2,[r3,#0]
                  |L1.3232|
;;;1122       }
;;;1123   }
000ca0  bd10              POP      {r4,pc}
;;;1124   #endif
                          ENDP

                  OS_EventWaitListInit PROC
;;;1254   #if (OS_EVENT_EN)
;;;1255   void  OS_EventWaitListInit (OS_EVENT *pevent)
000ca2  4601              MOV      r1,r0
;;;1256   {
;;;1257       INT8U  i;
;;;1258   
;;;1259   
;;;1260       pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */
000ca4  f04f0200          MOV      r2,#0
000ca8  728a              STRB     r2,[r1,#0xa]
;;;1261       for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
000caa  4610              MOV      r0,r2
000cac  e007              B        |L1.3262|
                  |L1.3246|
;;;1262           pevent->OSEventTbl[i] = 0u;
000cae  f04f0300          MOV      r3,#0
000cb2  f101020b          ADD      r2,r1,#0xb
000cb6  5413              STRB     r3,[r2,r0]
000cb8  f1000201          ADD      r2,r0,#1              ;1261
000cbc  b2d0              UXTB     r0,r2                 ;1261
                  |L1.3262|
000cbe  2808              CMP      r0,#8                 ;1261
000cc0  d3f5              BCC      |L1.3246|
;;;1263       }
;;;1264   }
000cc2  4770              BX       lr
                  |L1.3268|
                          DCD      OSRunning
                  |L1.3272|
                          DCD      OSIntNesting
                  |L1.3276|
                          DCD      OSLockNesting
                  |L1.3280|
                          DCD      OSTCBPrioTbl
                  |L1.3284|
                          DCD      OSPrioHighRdy
                  |L1.3288|
                          DCD      OSTCBHighRdy
                  |L1.3292|
                          DCD      OSPrioCur
                  |L1.3296|
                          DCD      OSCtxSwCtr
                  |L1.3300|
                          DCD      OSTCBCur
                  |L1.3304|
                          DCD      OSIdleCtr
                  |L1.3308|
                          DCD      OSIdleCtrMax
                  |L1.3312|
                          DCD      OSStatRdy
                  |L1.3316|
                          DCD      OSTime
                  |L1.3320|
                          DCD      OSTickStepState
                  |L1.3324|
                          DCD      OSTCBList
                  |L1.3328|
                          DCD      OSRdyGrp
                  |L1.3332|
                          DCD      OSRdyTbl
                  |L1.3336|
                          DCD      OSUnMapTbl
                          ENDP

                  OS_MemCopy PROC
;;;1611   
;;;1612   void  OS_MemCopy (INT8U  *pdest,
000d0c  e006              B        |L1.3356|
                  |L1.3342|
;;;1613                     INT8U  *psrc,
;;;1614                     INT16U  size)
;;;1615   {
;;;1616       while (size > 0u) {
;;;1617           *pdest++ = *psrc++;
000d0e  f8113b01          LDRB     r3,[r1],#1
000d12  f8003b01          STRB     r3,[r0],#1
;;;1618           size--;
000d16  f1a20301          SUB      r3,r2,#1
000d1a  b29a              UXTH     r2,r3
                  |L1.3356|
000d1c  2a00              CMP      r2,#0                 ;1616
000d1e  d1f6              BNE      |L1.3342|
;;;1619       }
;;;1620   }
000d20  4770              BX       lr
;;;1621   /*$PAGE*/
                          ENDP

                  OS_TCBInit PROC
;;;1934   
;;;1935   INT8U  OS_TCBInit (INT8U    prio,
000d22  e92d4ff8          PUSH     {r3-r11,lr}
;;;1936                      OS_STK  *ptos,
;;;1937                      OS_STK  *pbos,
;;;1938                      INT16U   id,
;;;1939                      INT32U   stk_size,
;;;1940                      void    *pext,
;;;1941                      INT16U   opt)
;;;1942   {
000d26  4605              MOV      r5,r0
000d28  460f              MOV      r7,r1
000d2a  4690              MOV      r8,r2
000d2c  4699              MOV      r9,r3
000d2e  e9ddab0a          LDRD     r10,r11,[sp,#0x28]
;;;1943       OS_TCB    *ptcb;
;;;1944   #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;1945       OS_CPU_SR  cpu_sr = 0u;
000d32  f04f0000          MOV      r0,#0
000d36  9000              STR      r0,[sp,#0]
;;;1946   #endif
;;;1947   #if OS_TASK_REG_TBL_SIZE > 0u
;;;1948       INT8U      i;
;;;1949   #endif
;;;1950   
;;;1951   
;;;1952       OS_ENTER_CRITICAL();
000d38  f7fffffe          BL       OS_CPU_SR_Save
000d3c  9000              STR      r0,[sp,#0]
;;;1953       ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
000d3e  484c              LDR      r0,|L1.3696|
000d40  6804              LDR      r4,[r0,#0]  ; OSTCBFreeList
;;;1954       if (ptcb != (OS_TCB *)0) {
000d42  2c00              CMP      r4,#0
000d44  d07e              BEQ      |L1.3652|
;;;1955           OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
000d46  f104041c          ADD      r4,r4,#0x1c
000d4a  f8540c08          LDR      r0,[r4,#-8]
000d4e  4948              LDR      r1,|L1.3696|
000d50  6008              STR      r0,[r1,#0]  ; OSTCBFreeList
;;;1956           OS_EXIT_CRITICAL();
000d52  9800              LDR      r0,[sp,#0]
000d54  f7fffffe          BL       OS_CPU_SR_Restore
;;;1957           ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
000d58  f8447c1c          STR      r7,[r4,#-0x1c]
;;;1958           ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
000d5c  76a5              STRB     r5,[r4,#0x1a]
;;;1959           ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
000d5e  f04f0000          MOV      r0,#0
000d62  7620              STRB     r0,[r4,#0x18]
;;;1960           ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
000d64  7660              STRB     r0,[r4,#0x19]
;;;1961           ptcb->OSTCBDly           = 0u;                     /* Task is not delayed                      */
000d66  6160              STR      r0,[r4,#0x14]
;;;1962   
;;;1963   #if OS_TASK_CREATE_EXT_EN > 0u
;;;1964           ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
000d68  f844bc18          STR      r11,[r4,#-0x18]
;;;1965           ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
000d6c  f844ac10          STR      r10,[r4,#-0x10]
;;;1966           ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
000d70  f8448c14          STR      r8,[r4,#-0x14]
;;;1967           ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
000d74  980c              LDR      r0,[sp,#0x30]
000d76  f8240c0c          STRH     r0,[r4,#-0xc]
;;;1968           ptcb->OSTCBId            = id;                     /* Store task ID                            */
000d7a  f8249c0a          STRH     r9,[r4,#-0xa]
;;;1969   #else
;;;1970           pext                     = pext;                   /* Prevent compiler warning if not used     */
;;;1971           stk_size                 = stk_size;
;;;1972           pbos                     = pbos;
;;;1973           opt                      = opt;
;;;1974           id                       = id;
;;;1975   #endif
;;;1976   
;;;1977   #if OS_TASK_DEL_EN > 0u
;;;1978           ptcb->OSTCBDelReq        = OS_ERR_NONE;
000d7e  f04f0000          MOV      r0,#0
000d82  77e0              STRB     r0,[r4,#0x1f]
;;;1979   #endif
;;;1980   
;;;1981   #if OS_LOWEST_PRIO <= 63u                                         /* Pre-compute X, Y                  */
;;;1982           ptcb->OSTCBY             = (INT8U)(prio >> 3u);
000d84  ea4f00e5          ASR      r0,r5,#3
000d88  7720              STRB     r0,[r4,#0x1c]
;;;1983           ptcb->OSTCBX             = (INT8U)(prio & 0x07u);
000d8a  f0050007          AND      r0,r5,#7
000d8e  76e0              STRB     r0,[r4,#0x1b]
;;;1984   #else                                                             /* Pre-compute X, Y                  */
;;;1985           ptcb->OSTCBY             = (INT8U)((INT8U)(prio >> 4u) & 0xFFu);
;;;1986           ptcb->OSTCBX             = (INT8U) (prio & 0x0Fu);
;;;1987   #endif
;;;1988                                                                     /* Pre-compute BitX and BitY         */
;;;1989           ptcb->OSTCBBitY          = (OS_PRIO)(1uL << ptcb->OSTCBY);
000d90  7f21              LDRB     r1,[r4,#0x1c]
000d92  f04f0001          MOV      r0,#1
000d96  fa00f001          LSL      r0,r0,r1
000d9a  77a0              STRB     r0,[r4,#0x1e]
;;;1990           ptcb->OSTCBBitX          = (OS_PRIO)(1uL << ptcb->OSTCBX);
000d9c  7ee1              LDRB     r1,[r4,#0x1b]
000d9e  f04f0001          MOV      r0,#1
000da2  fa00f001          LSL      r0,r0,r1
000da6  7760              STRB     r0,[r4,#0x1d]
;;;1991   
;;;1992   #if (OS_EVENT_EN)
;;;1993           ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
000da8  f04f0000          MOV      r0,#0
000dac  6020              STR      r0,[r4,#0]
;;;1994   #if (OS_EVENT_MULTI_EN > 0u)
;;;1995           ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
000dae  6060              STR      r0,[r4,#4]
;;;1996   #endif
;;;1997   #endif
;;;1998   
;;;1999   #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u) && (OS_TASK_DEL_EN > 0u)
;;;2000           ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
000db0  60e0              STR      r0,[r4,#0xc]
;;;2001   #endif
;;;2002   
;;;2003   #if (OS_MBOX_EN > 0u) || ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
;;;2004           ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
000db2  60a0              STR      r0,[r4,#8]
;;;2005   #endif
;;;2006   
;;;2007   #if OS_TASK_PROFILE_EN > 0u
;;;2008           ptcb->OSTCBCtxSwCtr    = 0uL;                      /* Initialize profiling variables           */
000db4  6220              STR      r0,[r4,#0x20]
;;;2009           ptcb->OSTCBCyclesStart = 0uL;
000db6  62a0              STR      r0,[r4,#0x28]
;;;2010           ptcb->OSTCBCyclesTot   = 0uL;
000db8  6260              STR      r0,[r4,#0x24]
;;;2011           ptcb->OSTCBStkBase     = (OS_STK *)0;
000dba  62e0              STR      r0,[r4,#0x2c]
;;;2012           ptcb->OSTCBStkUsed     = 0uL;
000dbc  6320              STR      r0,[r4,#0x30]
;;;2013   #endif
;;;2014   
;;;2015   #if OS_TASK_NAME_EN > 0u
;;;2016           ptcb->OSTCBTaskName    = (INT8U *)(void *)"?";
000dbe  f2af5020          ADR      r0,|L1.2208|
000dc2  6360              STR      r0,[r4,#0x34]
000dc4  f1a4041c          SUB      r4,r4,#0x1c
;;;2017   #endif
;;;2018   
;;;2019   #if OS_TASK_REG_TBL_SIZE > 0u                              /* Initialize the task variables            */
;;;2020           for (i = 0u; i < OS_TASK_REG_TBL_SIZE; i++) {
000dc8  f04f0600          MOV      r6,#0
000dcc  e008              B        |L1.3552|
                  |L1.3534|
;;;2021               ptcb->OSTCBRegTbl[i] = 0u;
000dce  f04f0100          MOV      r1,#0
000dd2  f1040054          ADD      r0,r4,#0x54
000dd6  f8401026          STR      r1,[r0,r6,LSL #2]
000dda  f1060001          ADD      r0,r6,#1              ;2020
000dde  b2c6              UXTB     r6,r0                 ;2020
                  |L1.3552|
000de0  2e00              CMP      r6,#0                 ;2020
000de2  d0f4              BEQ      |L1.3534|
;;;2022           }
;;;2023   #endif
;;;2024   
;;;2025           OSTCBInitHook(ptcb);
000de4  4620              MOV      r0,r4
000de6  f7fffffe          BL       OSTCBInitHook
;;;2026   
;;;2027           OS_ENTER_CRITICAL();
000dea  f7fffffe          BL       OS_CPU_SR_Save
000dee  9000              STR      r0,[sp,#0]
;;;2028           OSTCBPrioTbl[prio] = ptcb;
000df0  4820              LDR      r0,|L1.3700|
000df2  f8404025          STR      r4,[r0,r5,LSL #2]
;;;2029           OS_EXIT_CRITICAL();
000df6  9800              LDR      r0,[sp,#0]
000df8  f7fffffe          BL       OS_CPU_SR_Restore
;;;2030   
;;;2031           OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
000dfc  4620              MOV      r0,r4
000dfe  f7fffffe          BL       OSTaskCreateHook
;;;2032   
;;;2033           OS_ENTER_CRITICAL();
000e02  f7fffffe          BL       OS_CPU_SR_Save
000e06  9000              STR      r0,[sp,#0]
;;;2034           ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
000e08  481b              LDR      r0,|L1.3704|
000e0a  6800              LDR      r0,[r0,#0]  ; OSTCBList
000e0c  6160              STR      r0,[r4,#0x14]
;;;2035           ptcb->OSTCBPrev    = (OS_TCB *)0;
000e0e  f04f0000          MOV      r0,#0
000e12  61a0              STR      r0,[r4,#0x18]
;;;2036           if (OSTCBList != (OS_TCB *)0) {
000e14  4818              LDR      r0,|L1.3704|
000e16  6800              LDR      r0,[r0,#0]  ; OSTCBList
000e18  b110              CBZ      r0,|L1.3616|
;;;2037               OSTCBList->OSTCBPrev = ptcb;
000e1a  4817              LDR      r0,|L1.3704|
000e1c  6800              LDR      r0,[r0,#0]  ; OSTCBList
000e1e  6184              STR      r4,[r0,#0x18]
                  |L1.3616|
;;;2038           }
;;;2039           OSTCBList               = ptcb;
000e20  4815              LDR      r0,|L1.3704|
000e22  6004              STR      r4,[r0,#0]  ; OSTCBList
;;;2040           OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
000e24  f1040438          ADD      r4,r4,#0x38
000e28  78a0              LDRB     r0,[r4,#2]
000e2a  4914              LDR      r1,|L1.3708|
000e2c  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
000e2e  ea400001          ORR      r0,r0,r1
000e32  4912              LDR      r1,|L1.3708|
000e34  7008              STRB     r0,[r1,#0]
;;;2041           OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000e36  7820              LDRB     r0,[r4,#0]
000e38  4911              LDR      r1,|L1.3712|
000e3a  5c08              LDRB     r0,[r1,r0]
000e3c  7861              LDRB     r1,[r4,#1]
000e3e  ea400001          ORR      r0,r0,r1
000e42  e000              B        |L1.3654|
                  |L1.3652|
000e44  e00f              B        |L1.3686|
                  |L1.3654|
000e46  f8141938          LDRB     r1,[r4],#-0x38
000e4a  4a0d              LDR      r2,|L1.3712|
000e4c  5450              STRB     r0,[r2,r1]
;;;2042           OSTaskCtr++;                                       /* Increment the #tasks counter             */
000e4e  480d              LDR      r0,|L1.3716|
000e50  7800              LDRB     r0,[r0,#0]  ; OSTaskCtr
000e52  f1000001          ADD      r0,r0,#1
000e56  490b              LDR      r1,|L1.3716|
000e58  7008              STRB     r0,[r1,#0]
;;;2043           OS_EXIT_CRITICAL();
000e5a  9800              LDR      r0,[sp,#0]
000e5c  f7fffffe          BL       OS_CPU_SR_Restore
;;;2044           return (OS_ERR_NONE);
000e60  2000              MOVS     r0,#0
                  |L1.3682|
;;;2045       }
;;;2046       OS_EXIT_CRITICAL();
;;;2047       return (OS_ERR_TASK_NO_MORE_TCB);
;;;2048   }
000e62  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.3686|
000e66  9800              LDR      r0,[sp,#0]            ;2046
000e68  f7fffffe          BL       OS_CPU_SR_Restore
000e6c  2042              MOVS     r0,#0x42              ;2047
000e6e  e7f8              B        |L1.3682|
                          ENDP

                  |L1.3696|
                          DCD      OSTCBFreeList
                  |L1.3700|
                          DCD      OSTCBPrioTbl
                  |L1.3704|
                          DCD      OSTCBList
                  |L1.3708|
                          DCD      OSRdyGrp
                  |L1.3712|
                          DCD      OSRdyTbl
                  |L1.3716|
                          DCD      OSTaskCtr

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  OSEventTbl
                          %        1920
                  OSFlagTbl
                          %        80
                  OSTaskStatStk
                          %        512
                  OSTaskIdleStk
                          %        512
                  OSTCBPrioTbl
                          %        256
                  OSTCBTbl
                          %        1936
                  OSMemTbl
                          %        120
                  OSQTbl
                          %        96
                  OSTmrTbl
                          %        640
                  OSTmrTaskStk
                          %        512
                  OSTmrWheelTbl
                          %        64

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  OSUnMapTbl
000000  00000100          DCB      0x00,0x00,0x01,0x00
000004  02000100          DCB      0x02,0x00,0x01,0x00
000008  03000100          DCB      0x03,0x00,0x01,0x00
00000c  02000100          DCB      0x02,0x00,0x01,0x00
000010  04000100          DCB      0x04,0x00,0x01,0x00
000014  02000100          DCB      0x02,0x00,0x01,0x00
000018  03000100          DCB      0x03,0x00,0x01,0x00
00001c  02000100          DCB      0x02,0x00,0x01,0x00
000020  05000100          DCB      0x05,0x00,0x01,0x00
000024  02000100          DCB      0x02,0x00,0x01,0x00
000028  03000100          DCB      0x03,0x00,0x01,0x00
00002c  02000100          DCB      0x02,0x00,0x01,0x00
000030  04000100          DCB      0x04,0x00,0x01,0x00
000034  02000100          DCB      0x02,0x00,0x01,0x00
000038  03000100          DCB      0x03,0x00,0x01,0x00
00003c  02000100          DCB      0x02,0x00,0x01,0x00
000040  06000100          DCB      0x06,0x00,0x01,0x00
000044  02000100          DCB      0x02,0x00,0x01,0x00
000048  03000100          DCB      0x03,0x00,0x01,0x00
00004c  02000100          DCB      0x02,0x00,0x01,0x00
000050  04000100          DCB      0x04,0x00,0x01,0x00
000054  02000100          DCB      0x02,0x00,0x01,0x00
000058  03000100          DCB      0x03,0x00,0x01,0x00
00005c  02000100          DCB      0x02,0x00,0x01,0x00
000060  05000100          DCB      0x05,0x00,0x01,0x00
000064  02000100          DCB      0x02,0x00,0x01,0x00
000068  03000100          DCB      0x03,0x00,0x01,0x00
00006c  02000100          DCB      0x02,0x00,0x01,0x00
000070  04000100          DCB      0x04,0x00,0x01,0x00
000074  02000100          DCB      0x02,0x00,0x01,0x00
000078  03000100          DCB      0x03,0x00,0x01,0x00
00007c  02000100          DCB      0x02,0x00,0x01,0x00
000080  07000100          DCB      0x07,0x00,0x01,0x00
000084  02000100          DCB      0x02,0x00,0x01,0x00
000088  03000100          DCB      0x03,0x00,0x01,0x00
00008c  02000100          DCB      0x02,0x00,0x01,0x00
000090  04000100          DCB      0x04,0x00,0x01,0x00
000094  02000100          DCB      0x02,0x00,0x01,0x00
000098  03000100          DCB      0x03,0x00,0x01,0x00
00009c  02000100          DCB      0x02,0x00,0x01,0x00
0000a0  05000100          DCB      0x05,0x00,0x01,0x00
0000a4  02000100          DCB      0x02,0x00,0x01,0x00
0000a8  03000100          DCB      0x03,0x00,0x01,0x00
0000ac  02000100          DCB      0x02,0x00,0x01,0x00
0000b0  04000100          DCB      0x04,0x00,0x01,0x00
0000b4  02000100          DCB      0x02,0x00,0x01,0x00
0000b8  03000100          DCB      0x03,0x00,0x01,0x00
0000bc  02000100          DCB      0x02,0x00,0x01,0x00
0000c0  06000100          DCB      0x06,0x00,0x01,0x00
0000c4  02000100          DCB      0x02,0x00,0x01,0x00
0000c8  03000100          DCB      0x03,0x00,0x01,0x00
0000cc  02000100          DCB      0x02,0x00,0x01,0x00
0000d0  04000100          DCB      0x04,0x00,0x01,0x00
0000d4  02000100          DCB      0x02,0x00,0x01,0x00
0000d8  03000100          DCB      0x03,0x00,0x01,0x00
0000dc  02000100          DCB      0x02,0x00,0x01,0x00
0000e0  05000100          DCB      0x05,0x00,0x01,0x00
0000e4  02000100          DCB      0x02,0x00,0x01,0x00
0000e8  03000100          DCB      0x03,0x00,0x01,0x00
0000ec  02000100          DCB      0x02,0x00,0x01,0x00
0000f0  04000100          DCB      0x04,0x00,0x01,0x00
0000f4  02000100          DCB      0x02,0x00,0x01,0x00
0000f8  03000100          DCB      0x03,0x00,0x01,0x00
0000fc  02000100          DCB      0x02,0x00,0x01,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  OSCtxSwCtr
                          DCD      0x00000000
                  OSEventFreeList
                          DCD      0x00000000
                  OSFlagFreeList
                          DCD      0x00000000
                  OSCPUUsage
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  OSIdleCtrMax
                          DCD      0x00000000
                  OSIdleCtrRun
                          DCD      0x00000000
                  OSStatRdy
000018  00                DCB      0x00
                  OSIntNesting
000019  00                DCB      0x00
                  OSLockNesting
00001a  00                DCB      0x00
                  OSPrioCur
00001b  00                DCB      0x00
                  OSPrioHighRdy
00001c  00                DCB      0x00
                  OSRdyGrp
00001d  00                DCB      0x00
                  OSRdyTbl
00001e  0000              DCB      0x00,0x00
                          DCD      0x00000000
000024  0000              DCB      0x00,0x00
                  OSRunning
000026  00                DCB      0x00
                  OSTaskCtr
000027  00                DCB      0x00
                  OSIdleCtr
                          DCD      0x00000000
                  OSTCBCur
                          DCD      0x00000000
                  OSTCBFreeList
                          DCD      0x00000000
                  OSTCBHighRdy
                          DCD      0x00000000
                  OSTCBList
                          DCD      0x00000000
                  OSTickStepState
00003c  00000000          DCB      0x00,0x00,0x00,0x00
                  OSMemFreeList
                          DCD      0x00000000
                  OSQFreeList
                          DCD      0x00000000
                  OSTaskRegNextAvailID
000048  00000000          DCB      0x00,0x00,0x00,0x00
                  OSTime
                          DCD      0x00000000
                  OSTmrFree
000050  0000              DCB      0x00,0x00
                  OSTmrUsed
000052  0000              DCB      0x00,0x00
                  OSTmrTime
                          DCD      0x00000000
                  OSTmrSem
                          DCD      0x00000000
                  OSTmrSemSignal
                          DCD      0x00000000
                  OSTmrFreeList
                          DCD      0x00000000
