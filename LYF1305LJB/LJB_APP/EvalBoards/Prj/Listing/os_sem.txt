; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Output\os_sem.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\Output\os_sem.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\BSP -I..\BSP\UCOS-II -I..\BSP\STM32F2xx\inc -I..\BSP\CMSIS -I..\BSP\CMSIS\Device_Support -I..\BSP\UCOS-II -I..\..\uC-CPU -I..\..\uC-CPU\ARM-Cortex-M3 -I..\..\uC-LIB -I..\..\uC-LIB\Ports\ARM-Cortex-M3 -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3 -I..\App -I..\Prj -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DDEBUG -DLJB_CPU_MAIN -DUSE_CPU_F205RC --omf_browse=.\Output\os_sem.crf ..\..\uCOS-II\Source\os_sem.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  OSSemAccept PROC
;;;50     #if OS_SEM_ACCEPT_EN > 0u
;;;51     INT16U  OSSemAccept (OS_EVENT *pevent)
000000  b570              PUSH     {r4-r6,lr}
;;;52     {
000002  4604              MOV      r4,r0
;;;53         INT16U     cnt;
;;;54     #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;55         OS_CPU_SR  cpu_sr = 0u;
000004  f04f0600          MOV      r6,#0
;;;56     #endif
;;;57     
;;;58     
;;;59     
;;;60     #if OS_ARG_CHK_EN > 0u
;;;61         if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;62             return (0u);
;;;63         }
;;;64     #endif
;;;65         if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
000008  7820              LDRB     r0,[r4,#0]
00000a  2803              CMP      r0,#3
00000c  d001              BEQ      |L1.18|
;;;66             return (0u);
00000e  2000              MOVS     r0,#0
                  |L1.16|
;;;67         }
;;;68         OS_ENTER_CRITICAL();
;;;69         cnt = pevent->OSEventCnt;
;;;70         if (cnt > 0u) {                                   /* See if resource is available                  */
;;;71             pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
;;;72         }
;;;73         OS_EXIT_CRITICAL();
;;;74         return (cnt);                                     /* Return semaphore count                        */
;;;75     }
000010  bd70              POP      {r4-r6,pc}
                  |L1.18|
000012  f7fffffe          BL       OS_CPU_SR_Save
000016  4606              MOV      r6,r0                 ;68
000018  8925              LDRH     r5,[r4,#8]            ;69
00001a  b11d              CBZ      r5,|L1.36|
00001c  8920              LDRH     r0,[r4,#8]            ;71
00001e  f1a00001          SUB      r0,r0,#1              ;71
000022  8120              STRH     r0,[r4,#8]            ;71
                  |L1.36|
000024  4630              MOV      r0,r6                 ;73
000026  f7fffffe          BL       OS_CPU_SR_Restore
00002a  4628              MOV      r0,r5                 ;74
00002c  e7f0              B        |L1.16|
;;;76     #endif
                          ENDP

                  OSSemCreate PROC
;;;95     
;;;96     OS_EVENT  *OSSemCreate (INT16U cnt)
00002e  b570              PUSH     {r4-r6,lr}
;;;97     {
000030  4605              MOV      r5,r0
;;;98         OS_EVENT  *pevent;
;;;99     #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;100        OS_CPU_SR  cpu_sr = 0u;
000032  f04f0600          MOV      r6,#0
;;;101    #endif
;;;102    
;;;103    
;;;104    
;;;105    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;106        if (OSSafetyCriticalStartFlag == OS_TRUE) {
;;;107            OS_SAFETY_CRITICAL_EXCEPTION();
;;;108            return ((OS_EVENT *)0);
;;;109        }
;;;110    #endif
;;;111    
;;;112        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
000036  48eb              LDR      r0,|L1.996|
000038  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00003a  b108              CBZ      r0,|L1.64|
;;;113            return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
00003c  2000              MOVS     r0,#0
                  |L1.62|
;;;114        }
;;;115        OS_ENTER_CRITICAL();
;;;116        pevent = OSEventFreeList;                              /* Get next free event control block        */
;;;117        if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
;;;118            OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
;;;119        }
;;;120        OS_EXIT_CRITICAL();
;;;121        if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
;;;122            pevent->OSEventType    = OS_EVENT_TYPE_SEM;
;;;123            pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
;;;124            pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
;;;125    #if OS_EVENT_NAME_EN > 0u
;;;126            pevent->OSEventName    = (INT8U *)(void *)"?";
;;;127    #endif
;;;128            OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
;;;129        }
;;;130        return (pevent);
;;;131    }
00003e  bd70              POP      {r4-r6,pc}
                  |L1.64|
000040  f7fffffe          BL       OS_CPU_SR_Save
000044  4606              MOV      r6,r0                 ;115
000046  48e8              LDR      r0,|L1.1000|
000048  6804              LDR      r4,[r0,#0]            ;116  ; OSEventFreeList
00004a  6800              LDR      r0,[r0,#0]            ;117  ; OSEventFreeList
00004c  b120              CBZ      r0,|L1.88|
00004e  48e6              LDR      r0,|L1.1000|
000050  6800              LDR      r0,[r0,#0]            ;118  ; OSEventFreeList
000052  6840              LDR      r0,[r0,#4]            ;118
000054  49e4              LDR      r1,|L1.1000|
000056  6008              STR      r0,[r1,#0]            ;118  ; OSEventFreeList
                  |L1.88|
000058  4630              MOV      r0,r6                 ;120
00005a  f7fffffe          BL       OS_CPU_SR_Restore
00005e  b15c              CBZ      r4,|L1.120|
000060  f04f0003          MOV      r0,#3                 ;122
000064  7020              STRB     r0,[r4,#0]            ;122
000066  8125              STRH     r5,[r4,#8]            ;123
000068  f04f0000          MOV      r0,#0                 ;124
00006c  6060              STR      r0,[r4,#4]            ;124
00006e  a0df              ADR      r0,|L1.1004|
000070  6160              STR      r0,[r4,#0x14]         ;126
000072  4620              MOV      r0,r4                 ;128
000074  f7fffffe          BL       OS_EventWaitListInit
                  |L1.120|
000078  4620              MOV      r0,r4                 ;130
00007a  e7e0              B        |L1.62|
;;;132    
                          ENDP

                  OSSemDel PROC
;;;173    #if OS_SEM_DEL_EN > 0u
;;;174    OS_EVENT  *OSSemDel (OS_EVENT  *pevent,
00007c  e92d47f0          PUSH     {r4-r10,lr}
;;;175                         INT8U      opt,
;;;176                         INT8U     *perr)
;;;177    {
000080  4604              MOV      r4,r0
000082  4688              MOV      r8,r1
000084  4615              MOV      r5,r2
;;;178        BOOLEAN    tasks_waiting;
;;;179        OS_EVENT  *pevent_return;
;;;180    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;181        OS_CPU_SR  cpu_sr = 0u;
000086  f04f0900          MOV      r9,#0
;;;182    #endif
;;;183    
;;;184    
;;;185    
;;;186    #ifdef OS_SAFETY_CRITICAL
;;;187        if (perr == (INT8U *)0) {
;;;188            OS_SAFETY_CRITICAL_EXCEPTION();
;;;189            return ((OS_EVENT *)0);
;;;190        }
;;;191    #endif
;;;192    
;;;193    #if OS_ARG_CHK_EN > 0u
;;;194        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;195            *perr = OS_ERR_PEVENT_NULL;
;;;196            return (pevent);
;;;197        }
;;;198    #endif
;;;199        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
00008a  7820              LDRB     r0,[r4,#0]
00008c  2803              CMP      r0,#3
00008e  d005              BEQ      |L1.156|
;;;200            *perr = OS_ERR_EVENT_TYPE;
000090  f04f0001          MOV      r0,#1
000094  7028              STRB     r0,[r5,#0]
;;;201            return (pevent);
000096  4620              MOV      r0,r4
                  |L1.152|
;;;202        }
;;;203        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
;;;204            *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
;;;205            return (pevent);
;;;206        }
;;;207        OS_ENTER_CRITICAL();
;;;208        if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on semaphore    */
;;;209            tasks_waiting = OS_TRUE;                           /* Yes                                      */
;;;210        } else {
;;;211            tasks_waiting = OS_FALSE;                          /* No                                       */
;;;212        }
;;;213        switch (opt) {
;;;214            case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
;;;215                 if (tasks_waiting == OS_FALSE) {
;;;216    #if OS_EVENT_NAME_EN > 0u
;;;217                     pevent->OSEventName    = (INT8U *)(void *)"?";
;;;218    #endif
;;;219                     pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;220                     pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
;;;221                     pevent->OSEventCnt     = 0u;
;;;222                     OSEventFreeList        = pevent;          /* Get next free event control block        */
;;;223                     OS_EXIT_CRITICAL();
;;;224                     *perr                  = OS_ERR_NONE;
;;;225                     pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
;;;226                 } else {
;;;227                     OS_EXIT_CRITICAL();
;;;228                     *perr                  = OS_ERR_TASK_WAITING;
;;;229                     pevent_return          = pevent;
;;;230                 }
;;;231                 break;
;;;232    
;;;233            case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
;;;234                 while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for semaphore    */
;;;235                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
;;;236                 }
;;;237    #if OS_EVENT_NAME_EN > 0u
;;;238                 pevent->OSEventName    = (INT8U *)(void *)"?";
;;;239    #endif
;;;240                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;241                 pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
;;;242                 pevent->OSEventCnt     = 0u;
;;;243                 OSEventFreeList        = pevent;              /* Get next free event control block        */
;;;244                 OS_EXIT_CRITICAL();
;;;245                 if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
;;;246                     OS_Sched();                               /* Find highest priority task ready to run  */
;;;247                 }
;;;248                 *perr                  = OS_ERR_NONE;
;;;249                 pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
;;;250                 break;
;;;251    
;;;252            default:
;;;253                 OS_EXIT_CRITICAL();
;;;254                 *perr                  = OS_ERR_INVALID_OPT;
;;;255                 pevent_return          = pevent;
;;;256                 break;
;;;257        }
;;;258        return (pevent_return);
;;;259    }
000098  e8bd87f0          POP      {r4-r10,pc}
                  |L1.156|
00009c  48d1              LDR      r0,|L1.996|
00009e  7800              LDRB     r0,[r0,#0]            ;203  ; OSIntNesting
0000a0  b120              CBZ      r0,|L1.172|
0000a2  f04f000f          MOV      r0,#0xf               ;204
0000a6  7028              STRB     r0,[r5,#0]            ;204
0000a8  4620              MOV      r0,r4                 ;205
0000aa  e7f5              B        |L1.152|
                  |L1.172|
0000ac  f7fffffe          BL       OS_CPU_SR_Save
0000b0  4681              MOV      r9,r0                 ;207
0000b2  7aa0              LDRB     r0,[r4,#0xa]          ;208
0000b4  b110              CBZ      r0,|L1.188|
0000b6  f04f0701          MOV      r7,#1                 ;209
0000ba  e001              B        |L1.192|
                  |L1.188|
0000bc  f04f0700          MOV      r7,#0                 ;211
                  |L1.192|
0000c0  f1b80f00          CMP      r8,#0                 ;213
0000c4  d003              BEQ      |L1.206|
0000c6  f1b80f01          CMP      r8,#1                 ;213
0000ca  d141              BNE      |L1.336|
0000cc  e01d              B        |L1.266|
                  |L1.206|
0000ce  b9a7              CBNZ     r7,|L1.250|
0000d0  a0c6              ADR      r0,|L1.1004|
0000d2  6160              STR      r0,[r4,#0x14]         ;217
0000d4  f04f0000          MOV      r0,#0                 ;219
0000d8  7020              STRB     r0,[r4,#0]            ;219
0000da  48c3              LDR      r0,|L1.1000|
0000dc  6800              LDR      r0,[r0,#0]            ;220  ; OSEventFreeList
0000de  6060              STR      r0,[r4,#4]            ;220
0000e0  f04f0000          MOV      r0,#0                 ;221
0000e4  8120              STRH     r0,[r4,#8]            ;221
0000e6  48c0              LDR      r0,|L1.1000|
0000e8  6004              STR      r4,[r0,#0]            ;222  ; OSEventFreeList
0000ea  4648              MOV      r0,r9                 ;223
0000ec  f7fffffe          BL       OS_CPU_SR_Restore
0000f0  f04f0000          MOV      r0,#0                 ;224
0000f4  7028              STRB     r0,[r5,#0]            ;224
0000f6  4606              MOV      r6,r0                 ;225
0000f8  e006              B        |L1.264|
                  |L1.250|
0000fa  4648              MOV      r0,r9                 ;227
0000fc  f7fffffe          BL       OS_CPU_SR_Restore
000100  f04f0049          MOV      r0,#0x49              ;228
000104  7028              STRB     r0,[r5,#0]            ;228
000106  4626              MOV      r6,r4                 ;229
                  |L1.264|
000108  e02a              B        |L1.352|
                  |L1.266|
00010a  e005              B        |L1.280|
                  |L1.268|
00010c  2302              MOVS     r3,#2                 ;235
00010e  2201              MOVS     r2,#1                 ;235
000110  2100              MOVS     r1,#0                 ;235
000112  4620              MOV      r0,r4                 ;235
000114  f7fffffe          BL       OS_EventTaskRdy
                  |L1.280|
000118  7aa0              LDRB     r0,[r4,#0xa]          ;234
00011a  2800              CMP      r0,#0                 ;234
00011c  d1f6              BNE      |L1.268|
00011e  a0b3              ADR      r0,|L1.1004|
000120  6160              STR      r0,[r4,#0x14]         ;238
000122  f04f0000          MOV      r0,#0                 ;240
000126  7020              STRB     r0,[r4,#0]            ;240
000128  48af              LDR      r0,|L1.1000|
00012a  6800              LDR      r0,[r0,#0]            ;241  ; OSEventFreeList
00012c  6060              STR      r0,[r4,#4]            ;241
00012e  f04f0000          MOV      r0,#0                 ;242
000132  8120              STRH     r0,[r4,#8]            ;242
000134  48ac              LDR      r0,|L1.1000|
000136  6004              STR      r4,[r0,#0]            ;243  ; OSEventFreeList
000138  4648              MOV      r0,r9                 ;244
00013a  f7fffffe          BL       OS_CPU_SR_Restore
00013e  2f01              CMP      r7,#1                 ;245
000140  d101              BNE      |L1.326|
000142  f7fffffe          BL       OS_Sched
                  |L1.326|
000146  f04f0000          MOV      r0,#0                 ;248
00014a  7028              STRB     r0,[r5,#0]            ;248
00014c  4606              MOV      r6,r0                 ;249
00014e  e007              B        |L1.352|
                  |L1.336|
000150  4648              MOV      r0,r9                 ;253
000152  f7fffffe          BL       OS_CPU_SR_Restore
000156  f04f0007          MOV      r0,#7                 ;254
00015a  7028              STRB     r0,[r5,#0]            ;254
00015c  4626              MOV      r6,r4                 ;255
00015e  bf00              NOP                            ;256
                  |L1.352|
000160  bf00              NOP                            ;231
000162  4630              MOV      r0,r6                 ;258
000164  e798              B        |L1.152|
;;;260    #endif
                          ENDP

                  OSSemPend PROC
;;;294    /*$PAGE*/
;;;295    void  OSSemPend (OS_EVENT  *pevent,
000166  e92d41f0          PUSH     {r4-r8,lr}
;;;296                     INT32U     timeout,
;;;297                     INT8U     *perr)
;;;298    {
00016a  4605              MOV      r5,r0
00016c  460e              MOV      r6,r1
00016e  4614              MOV      r4,r2
;;;299    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;300        OS_CPU_SR  cpu_sr = 0u;
000170  f04f0700          MOV      r7,#0
;;;301    #endif
;;;302    
;;;303    
;;;304    
;;;305    #ifdef OS_SAFETY_CRITICAL
;;;306        if (perr == (INT8U *)0) {
;;;307            OS_SAFETY_CRITICAL_EXCEPTION();
;;;308            return;
;;;309        }
;;;310    #endif
;;;311    
;;;312    #if OS_ARG_CHK_EN > 0u
;;;313        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;314            *perr = OS_ERR_PEVENT_NULL;
;;;315            return;
;;;316        }
;;;317    #endif
;;;318        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
000174  7828              LDRB     r0,[r5,#0]
000176  2803              CMP      r0,#3
000178  d004              BEQ      |L1.388|
;;;319            *perr = OS_ERR_EVENT_TYPE;
00017a  f04f0001          MOV      r0,#1
00017e  7020              STRB     r0,[r4,#0]
                  |L1.384|
;;;320            return;
;;;321        }
;;;322        if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
;;;323            *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
;;;324            return;
;;;325        }
;;;326        if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
;;;327            *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
;;;328            return;
;;;329        }
;;;330        OS_ENTER_CRITICAL();
;;;331        if (pevent->OSEventCnt > 0u) {                    /* If sem. is positive, resource available ...   */
;;;332            pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
;;;333            OS_EXIT_CRITICAL();
;;;334            *perr = OS_ERR_NONE;
;;;335            return;
;;;336        }
;;;337                                                          /* Otherwise, must wait until event occurs       */
;;;338        OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
;;;339        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;340        OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
;;;341        OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
;;;342        OS_EXIT_CRITICAL();
;;;343        OS_Sched();                                       /* Find next highest priority task ready         */
;;;344        OS_ENTER_CRITICAL();
;;;345        switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
;;;346            case OS_STAT_PEND_OK:
;;;347                 *perr = OS_ERR_NONE;
;;;348                 break;
;;;349    
;;;350            case OS_STAT_PEND_ABORT:
;;;351                 *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
;;;352                 break;
;;;353    
;;;354            case OS_STAT_PEND_TO:
;;;355            default:
;;;356                 OS_EventTaskRemove(OSTCBCur, pevent);
;;;357                 *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
;;;358                 break;
;;;359        }
;;;360        OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
;;;361        OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
;;;362        OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
;;;363    #if (OS_EVENT_MULTI_EN > 0u)
;;;364        OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
;;;365    #endif
;;;366        OS_EXIT_CRITICAL();
;;;367    }
000180  e8bd81f0          POP      {r4-r8,pc}
                  |L1.388|
000184  4897              LDR      r0,|L1.996|
000186  7800              LDRB     r0,[r0,#0]            ;322  ; OSIntNesting
000188  b118              CBZ      r0,|L1.402|
00018a  f04f0002          MOV      r0,#2                 ;323
00018e  7020              STRB     r0,[r4,#0]            ;323
000190  e7f6              B        |L1.384|
                  |L1.402|
000192  4897              LDR      r0,|L1.1008|
000194  7800              LDRB     r0,[r0,#0]            ;326  ; OSLockNesting
000196  b118              CBZ      r0,|L1.416|
000198  f04f000d          MOV      r0,#0xd               ;327
00019c  7020              STRB     r0,[r4,#0]            ;327
00019e  e7ef              B        |L1.384|
                  |L1.416|
0001a0  f7fffffe          BL       OS_CPU_SR_Save
0001a4  4607              MOV      r7,r0                 ;330
0001a6  8928              LDRH     r0,[r5,#8]            ;331
0001a8  b150              CBZ      r0,|L1.448|
0001aa  8928              LDRH     r0,[r5,#8]            ;332
0001ac  f1a00001          SUB      r0,r0,#1              ;332
0001b0  8128              STRH     r0,[r5,#8]            ;332
0001b2  4638              MOV      r0,r7                 ;333
0001b4  f7fffffe          BL       OS_CPU_SR_Restore
0001b8  f04f0000          MOV      r0,#0                 ;334
0001bc  7020              STRB     r0,[r4,#0]            ;334
0001be  e7df              B        |L1.384|
                  |L1.448|
0001c0  488c              LDR      r0,|L1.1012|
0001c2  6800              LDR      r0,[r0,#0]            ;338  ; OSTCBCur
0001c4  f8900034          LDRB     r0,[r0,#0x34]         ;338
0001c8  f0400001          ORR      r0,r0,#1              ;338
0001cc  4989              LDR      r1,|L1.1012|
0001ce  6809              LDR      r1,[r1,#0]            ;338  ; OSTCBCur
0001d0  f8810034          STRB     r0,[r1,#0x34]         ;338
0001d4  f04f0000          MOV      r0,#0                 ;339
0001d8  4986              LDR      r1,|L1.1012|
0001da  6809              LDR      r1,[r1,#0]            ;339  ; OSTCBCur
0001dc  f8810035          STRB     r0,[r1,#0x35]         ;339
0001e0  4884              LDR      r0,|L1.1012|
0001e2  6800              LDR      r0,[r0,#0]            ;340  ; OSTCBCur
0001e4  6306              STR      r6,[r0,#0x30]         ;340
0001e6  4628              MOV      r0,r5                 ;341
0001e8  f7fffffe          BL       OS_EventTaskWait
0001ec  4638              MOV      r0,r7                 ;342
0001ee  f7fffffe          BL       OS_CPU_SR_Restore
0001f2  f7fffffe          BL       OS_Sched
0001f6  f7fffffe          BL       OS_CPU_SR_Save
0001fa  4607              MOV      r7,r0                 ;344
0001fc  487d              LDR      r0,|L1.1012|
0001fe  6800              LDR      r0,[r0,#0]            ;345  ; OSTCBCur
000200  f8900035          LDRB     r0,[r0,#0x35]         ;345
000204  b120              CBZ      r0,|L1.528|
000206  2801              CMP      r0,#1                 ;345
000208  d00b              BEQ      |L1.546|
00020a  2802              CMP      r0,#2                 ;345
00020c  d108              BNE      |L1.544|
00020e  e003              B        |L1.536|
                  |L1.528|
000210  f04f0000          MOV      r0,#0                 ;347
000214  7020              STRB     r0,[r4,#0]            ;347
000216  e00d              B        |L1.564|
                  |L1.536|
000218  f04f000e          MOV      r0,#0xe               ;351
00021c  7020              STRB     r0,[r4,#0]            ;351
00021e  e009              B        |L1.564|
                  |L1.544|
000220  bf00              NOP                            ;354
                  |L1.546|
000222  4629              MOV      r1,r5                 ;356
000224  4873              LDR      r0,|L1.1012|
000226  6800              LDR      r0,[r0,#0]            ;356  ; OSTCBCur
000228  f7fffffe          BL       OS_EventTaskRemove
00022c  f04f000a          MOV      r0,#0xa               ;357
000230  7020              STRB     r0,[r4,#0]            ;357
000232  bf00              NOP                            ;358
                  |L1.564|
000234  bf00              NOP                            ;348
000236  f04f0000          MOV      r0,#0                 ;360
00023a  496e              LDR      r1,|L1.1012|
00023c  6809              LDR      r1,[r1,#0]            ;360  ; OSTCBCur
00023e  f8810034          STRB     r0,[r1,#0x34]         ;360
000242  496c              LDR      r1,|L1.1012|
000244  6809              LDR      r1,[r1,#0]            ;361  ; OSTCBCur
000246  f8810035          STRB     r0,[r1,#0x35]         ;361
00024a  496a              LDR      r1,|L1.1012|
00024c  6809              LDR      r1,[r1,#0]            ;362  ; OSTCBCur
00024e  61c8              STR      r0,[r1,#0x1c]         ;362
000250  4968              LDR      r1,|L1.1012|
000252  6809              LDR      r1,[r1,#0]            ;364  ; OSTCBCur
000254  6208              STR      r0,[r1,#0x20]         ;364
000256  4638              MOV      r0,r7                 ;366
000258  f7fffffe          BL       OS_CPU_SR_Restore
00025c  bf00              NOP      
00025e  e78f              B        |L1.384|
;;;368    
                          ENDP

                  OSSemPendAbort PROC
;;;403    #if OS_SEM_PEND_ABORT_EN > 0u
;;;404    INT8U  OSSemPendAbort (OS_EVENT  *pevent,
000260  e92d41f0          PUSH     {r4-r8,lr}
;;;405                           INT8U      opt,
;;;406                           INT8U     *perr)
;;;407    {
000264  4604              MOV      r4,r0
000266  460f              MOV      r7,r1
000268  4615              MOV      r5,r2
;;;408        INT8U      nbr_tasks;
;;;409    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;410        OS_CPU_SR  cpu_sr = 0u;
00026a  f04f0800          MOV      r8,#0
;;;411    #endif
;;;412    
;;;413    
;;;414    
;;;415    #ifdef OS_SAFETY_CRITICAL
;;;416        if (perr == (INT8U *)0) {
;;;417            OS_SAFETY_CRITICAL_EXCEPTION();
;;;418            return (0u);
;;;419        }
;;;420    #endif
;;;421    
;;;422    #if OS_ARG_CHK_EN > 0u
;;;423        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;424            *perr = OS_ERR_PEVENT_NULL;
;;;425            return (0u);
;;;426        }
;;;427    #endif
;;;428        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00026e  7820              LDRB     r0,[r4,#0]
000270  2803              CMP      r0,#3
000272  d006              BEQ      |L1.642|
;;;429            *perr = OS_ERR_EVENT_TYPE;
000274  f04f0001          MOV      r0,#1
000278  7028              STRB     r0,[r5,#0]
;;;430            return (0u);
00027a  f04f0000          MOV      r0,#0
                  |L1.638|
;;;431        }
;;;432        OS_ENTER_CRITICAL();
;;;433        if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting on semaphore?         */
;;;434            nbr_tasks = 0u;
;;;435            switch (opt) {
;;;436                case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
;;;437                     while (pevent->OSEventGrp != 0u) {   /* Yes, ready ALL tasks waiting on semaphore     */
;;;438                         (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
;;;439                         nbr_tasks++;
;;;440                     }
;;;441                     break;
;;;442    
;;;443                case OS_PEND_OPT_NONE:
;;;444                default:                                  /* No,  ready HPT       waiting on semaphore     */
;;;445                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
;;;446                     nbr_tasks++;
;;;447                     break;
;;;448            }
;;;449            OS_EXIT_CRITICAL();
;;;450            OS_Sched();                                   /* Find HPT ready to run                         */
;;;451            *perr = OS_ERR_PEND_ABORT;
;;;452            return (nbr_tasks);
;;;453        }
;;;454        OS_EXIT_CRITICAL();
;;;455        *perr = OS_ERR_NONE;
;;;456        return (0u);                                      /* No tasks waiting on semaphore                 */
;;;457    }
00027e  e8bd81f0          POP      {r4-r8,pc}
                  |L1.642|
000282  f7fffffe          BL       OS_CPU_SR_Save
000286  4680              MOV      r8,r0                 ;432
000288  7aa0              LDRB     r0,[r4,#0xa]          ;433
00028a  b340              CBZ      r0,|L1.734|
00028c  f04f0600          MOV      r6,#0                 ;434
000290  b187              CBZ      r7,|L1.692|
000292  2f01              CMP      r7,#1                 ;435
000294  d10d              BNE      |L1.690|
000296  e008              B        |L1.682|
                  |L1.664|
000298  2302              MOVS     r3,#2                 ;438
00029a  2201              MOVS     r2,#1                 ;438
00029c  2100              MOVS     r1,#0                 ;438
00029e  4620              MOV      r0,r4                 ;438
0002a0  f7fffffe          BL       OS_EventTaskRdy
0002a4  f1060001          ADD      r0,r6,#1              ;439
0002a8  b2c6              UXTB     r6,r0                 ;439
                  |L1.682|
0002aa  7aa0              LDRB     r0,[r4,#0xa]          ;437
0002ac  2800              CMP      r0,#0                 ;437
0002ae  d1f3              BNE      |L1.664|
0002b0  e00a              B        |L1.712|
                  |L1.690|
0002b2  bf00              NOP                            ;443
                  |L1.692|
0002b4  2302              MOVS     r3,#2                 ;445
0002b6  2201              MOVS     r2,#1                 ;445
0002b8  2100              MOVS     r1,#0                 ;445
0002ba  4620              MOV      r0,r4                 ;445
0002bc  f7fffffe          BL       OS_EventTaskRdy
0002c0  f1060001          ADD      r0,r6,#1              ;446
0002c4  b2c6              UXTB     r6,r0                 ;446
0002c6  bf00              NOP                            ;447
                  |L1.712|
0002c8  bf00              NOP                            ;441
0002ca  4640              MOV      r0,r8                 ;449
0002cc  f7fffffe          BL       OS_CPU_SR_Restore
0002d0  f7fffffe          BL       OS_Sched
0002d4  f04f000e          MOV      r0,#0xe               ;451
0002d8  7028              STRB     r0,[r5,#0]            ;451
0002da  4630              MOV      r0,r6                 ;452
0002dc  e7cf              B        |L1.638|
                  |L1.734|
0002de  4640              MOV      r0,r8                 ;454
0002e0  f7fffffe          BL       OS_CPU_SR_Restore
0002e4  f04f0000          MOV      r0,#0                 ;455
0002e8  7028              STRB     r0,[r5,#0]            ;455
0002ea  bf00              NOP                            ;456
0002ec  e7c7              B        |L1.638|
;;;458    #endif
                          ENDP

                  OSSemPost PROC
;;;478    
;;;479    INT8U  OSSemPost (OS_EVENT *pevent)
0002ee  b570              PUSH     {r4-r6,lr}
;;;480    {
0002f0  4604              MOV      r4,r0
;;;481    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;482        OS_CPU_SR  cpu_sr = 0u;
0002f2  f04f0500          MOV      r5,#0
;;;483    #endif
;;;484    
;;;485    
;;;486    
;;;487    #if OS_ARG_CHK_EN > 0u
;;;488        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;489            return (OS_ERR_PEVENT_NULL);
;;;490        }
;;;491    #endif
;;;492        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
0002f6  7820              LDRB     r0,[r4,#0]
0002f8  2803              CMP      r0,#3
0002fa  d001              BEQ      |L1.768|
;;;493            return (OS_ERR_EVENT_TYPE);
0002fc  2001              MOVS     r0,#1
                  |L1.766|
;;;494        }
;;;495        OS_ENTER_CRITICAL();
;;;496        if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting for semaphore         */
;;;497                                                          /* Ready HPT waiting on event                    */
;;;498            (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
;;;499            OS_EXIT_CRITICAL();
;;;500            OS_Sched();                                   /* Find HPT ready to run                         */
;;;501            return (OS_ERR_NONE);
;;;502        }
;;;503        if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
;;;504            pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
;;;505            OS_EXIT_CRITICAL();
;;;506            return (OS_ERR_NONE);
;;;507        }
;;;508        OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
;;;509        return (OS_ERR_SEM_OVF);
;;;510    }
0002fe  bd70              POP      {r4-r6,pc}
                  |L1.768|
000300  f7fffffe          BL       OS_CPU_SR_Save
000304  4605              MOV      r5,r0                 ;495
000306  7aa0              LDRB     r0,[r4,#0xa]          ;496
000308  b160              CBZ      r0,|L1.804|
00030a  2300              MOVS     r3,#0                 ;498
00030c  2201              MOVS     r2,#1                 ;498
00030e  4619              MOV      r1,r3                 ;498
000310  4620              MOV      r0,r4                 ;498
000312  f7fffffe          BL       OS_EventTaskRdy
000316  4628              MOV      r0,r5                 ;499
000318  f7fffffe          BL       OS_CPU_SR_Restore
00031c  f7fffffe          BL       OS_Sched
000320  2000              MOVS     r0,#0                 ;501
000322  e7ec              B        |L1.766|
                  |L1.804|
000324  8920              LDRH     r0,[r4,#8]            ;503
000326  f64f71ff          MOV      r1,#0xffff            ;503
00032a  4288              CMP      r0,r1                 ;503
00032c  d208              BCS      |L1.832|
00032e  8920              LDRH     r0,[r4,#8]            ;504
000330  f1000001          ADD      r0,r0,#1              ;504
000334  8120              STRH     r0,[r4,#8]            ;504
000336  4628              MOV      r0,r5                 ;505
000338  f7fffffe          BL       OS_CPU_SR_Restore
00033c  2000              MOVS     r0,#0                 ;506
00033e  e7de              B        |L1.766|
                  |L1.832|
000340  4628              MOV      r0,r5                 ;508
000342  f7fffffe          BL       OS_CPU_SR_Restore
000346  2033              MOVS     r0,#0x33              ;509
000348  e7d9              B        |L1.766|
;;;511    
                          ENDP

                  OSSemQuery PROC
;;;532    #if OS_SEM_QUERY_EN > 0u
;;;533    INT8U  OSSemQuery (OS_EVENT     *pevent,
00034a  e92d47f0          PUSH     {r4-r10,lr}
;;;534                       OS_SEM_DATA  *p_sem_data)
;;;535    {
00034e  4604              MOV      r4,r0
000350  460d              MOV      r5,r1
;;;536        INT8U       i;
;;;537        OS_PRIO    *psrc;
;;;538        OS_PRIO    *pdest;
;;;539    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;540        OS_CPU_SR   cpu_sr = 0u;
000352  f04f0900          MOV      r9,#0
;;;541    #endif
;;;542    
;;;543    
;;;544    
;;;545    #if OS_ARG_CHK_EN > 0u
;;;546        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;547            return (OS_ERR_PEVENT_NULL);
;;;548        }
;;;549        if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
;;;550            return (OS_ERR_PDATA_NULL);
;;;551        }
;;;552    #endif
;;;553        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
000356  7820              LDRB     r0,[r4,#0]
000358  2803              CMP      r0,#3
00035a  d002              BEQ      |L1.866|
;;;554            return (OS_ERR_EVENT_TYPE);
00035c  2001              MOVS     r0,#1
                  |L1.862|
;;;555        }
;;;556        OS_ENTER_CRITICAL();
;;;557        p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
;;;558        psrc                   = &pevent->OSEventTbl[0];
;;;559        pdest                  = &p_sem_data->OSEventTbl[0];
;;;560        for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
;;;561            *pdest++ = *psrc++;
;;;562        }
;;;563        p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
;;;564        OS_EXIT_CRITICAL();
;;;565        return (OS_ERR_NONE);
;;;566    }
00035e  e8bd87f0          POP      {r4-r10,pc}
                  |L1.866|
000362  f7fffffe          BL       OS_CPU_SR_Save
000366  4681              MOV      r9,r0                 ;556
000368  7aa0              LDRB     r0,[r4,#0xa]          ;557
00036a  72a8              STRB     r0,[r5,#0xa]          ;557
00036c  f104070b          ADD      r7,r4,#0xb            ;558
000370  f1050802          ADD      r8,r5,#2              ;559
000374  f04f0600          MOV      r6,#0                 ;560
000378  e006              B        |L1.904|
                  |L1.890|
00037a  f8170b01          LDRB     r0,[r7],#1            ;561
00037e  f8080b01          STRB     r0,[r8],#1            ;561
000382  f1060001          ADD      r0,r6,#1              ;560
000386  b2c6              UXTB     r6,r0                 ;560
                  |L1.904|
000388  2e08              CMP      r6,#8                 ;560
00038a  d3f6              BCC      |L1.890|
00038c  8920              LDRH     r0,[r4,#8]            ;563
00038e  8028              STRH     r0,[r5,#0]            ;563
000390  4648              MOV      r0,r9                 ;564
000392  f7fffffe          BL       OS_CPU_SR_Restore
000396  2000              MOVS     r0,#0                 ;565
000398  e7e1              B        |L1.862|
;;;567    #endif                                                     /* OS_SEM_QUERY_EN                          */
                          ENDP

                  OSSemSet PROC
;;;594    #if OS_SEM_SET_EN > 0u
;;;595    void  OSSemSet (OS_EVENT  *pevent,
00039a  e92d41f0          PUSH     {r4-r8,lr}
;;;596                    INT16U     cnt,
;;;597                    INT8U     *perr)
;;;598    {
00039e  4604              MOV      r4,r0
0003a0  460e              MOV      r6,r1
0003a2  4615              MOV      r5,r2
;;;599    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;600        OS_CPU_SR  cpu_sr = 0u;
0003a4  f04f0700          MOV      r7,#0
;;;601    #endif
;;;602    
;;;603    
;;;604    
;;;605    #ifdef OS_SAFETY_CRITICAL
;;;606        if (perr == (INT8U *)0) {
;;;607            OS_SAFETY_CRITICAL_EXCEPTION();
;;;608            return;
;;;609        }
;;;610    #endif
;;;611    
;;;612    #if OS_ARG_CHK_EN > 0u
;;;613        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;614            *perr = OS_ERR_PEVENT_NULL;
;;;615            return;
;;;616        }
;;;617    #endif
;;;618        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
0003a8  7820              LDRB     r0,[r4,#0]
0003aa  2803              CMP      r0,#3
0003ac  d004              BEQ      |L1.952|
;;;619            *perr = OS_ERR_EVENT_TYPE;
0003ae  f04f0001          MOV      r0,#1
0003b2  7028              STRB     r0,[r5,#0]
                  |L1.948|
;;;620            return;
;;;621        }
;;;622        OS_ENTER_CRITICAL();
;;;623        *perr = OS_ERR_NONE;
;;;624        if (pevent->OSEventCnt > 0u) {                    /* See if semaphore already has a count          */
;;;625            pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
;;;626        } else {                                          /* No                                            */
;;;627            if (pevent->OSEventGrp == 0u) {               /*      See if task(s) waiting?                  */
;;;628                pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
;;;629            } else {
;;;630                *perr              = OS_ERR_TASK_WAITING;
;;;631            }
;;;632        }
;;;633        OS_EXIT_CRITICAL();
;;;634    }
0003b4  e8bd81f0          POP      {r4-r8,pc}
                  |L1.952|
0003b8  f7fffffe          BL       OS_CPU_SR_Save
0003bc  4607              MOV      r7,r0                 ;622
0003be  f04f0000          MOV      r0,#0                 ;623
0003c2  7028              STRB     r0,[r5,#0]            ;623
0003c4  8920              LDRH     r0,[r4,#8]            ;624
0003c6  b108              CBZ      r0,|L1.972|
0003c8  8126              STRH     r6,[r4,#8]            ;625
0003ca  e006              B        |L1.986|
                  |L1.972|
0003cc  7aa0              LDRB     r0,[r4,#0xa]          ;627
0003ce  b908              CBNZ     r0,|L1.980|
0003d0  8126              STRH     r6,[r4,#8]            ;628
0003d2  e002              B        |L1.986|
                  |L1.980|
0003d4  f04f0049          MOV      r0,#0x49              ;630
0003d8  7028              STRB     r0,[r5,#0]            ;630
                  |L1.986|
0003da  4638              MOV      r0,r7                 ;633
0003dc  f7fffffe          BL       OS_CPU_SR_Restore
0003e0  bf00              NOP      
0003e2  e7e7              B        |L1.948|
;;;635    #endif
                          ENDP

                  |L1.996|
                          DCD      OSIntNesting
                  |L1.1000|
                          DCD      OSEventFreeList
                  |L1.1004|
0003ec  3f00              DCB      "?",0
0003ee  00                DCB      0
0003ef  00                DCB      0
                  |L1.1008|
                          DCD      OSLockNesting
                  |L1.1012|
                          DCD      OSTCBCur
