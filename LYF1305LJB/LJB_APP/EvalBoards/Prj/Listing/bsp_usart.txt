; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Output\bsp_usart.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\Output\bsp_usart.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\BSP -I..\BSP\UCOS-II -I..\BSP\STM32F2xx\inc -I..\BSP\CMSIS -I..\BSP\CMSIS\Device_Support -I..\BSP\UCOS-II -I..\..\uC-CPU -I..\..\uC-CPU\ARM-Cortex-M3 -I..\..\uC-LIB -I..\..\uC-LIB\Ports\ARM-Cortex-M3 -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3 -I..\App -I..\Prj -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DDEBUG -DLJB_CPU_MAIN -DUSE_CPU_F205RC --omf_browse=.\Output\bsp_usart.crf ..\BSP\bsp_usart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  USART_DMAConfig PROC
;;;296    ///USART TX DMA设置
;;;297    void USART_DMAConfig(COM_TypeDef COM)
000000  b510              PUSH     {r4,lr}
;;;298    {
000002  b090              SUB      sp,sp,#0x40
000004  4604              MOV      r4,r0
;;;299      	DMA_InitTypeDef DMA_InitStructure;
;;;300    
;;;301    	/* Enable peripheral clocks *************************************************/
;;;302    	if ((COM == COM1) || (COM == COM6))
000006  b10c              CBZ      r4,|L1.12|
000008  2c05              CMP      r4,#5
00000a  d104              BNE      |L1.22|
                  |L1.12|
;;;303    		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2, ENABLE); 
00000c  2101              MOVS     r1,#1
00000e  0588              LSLS     r0,r1,#22
000010  f7fffffe          BL       RCC_AHB1PeriphClockCmd
000014  e003              B        |L1.30|
                  |L1.22|
;;;304    	else
;;;305    		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA1, ENABLE); 
000016  2101              MOVS     r1,#1
000018  0548              LSLS     r0,r1,#21
00001a  f7fffffe          BL       RCC_AHB1PeriphClockCmd
                  |L1.30|
;;;306    
;;;307      	///USART : DMAX Channel Y, stream Z
;;;308      	DMA_InitStructure.DMA_Channel = UsartDmaInfo[COM].DMA_Channel;
00001e  48fe              LDR      r0,|L1.1048|
000020  eb001044          ADD      r0,r0,r4,LSL #5
000024  6880              LDR      r0,[r0,#8]
000026  9001              STR      r0,[sp,#4]
;;;309      	DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)&(BSP_Info.UsartTxBuf[COM][0]);
000028  48fc              LDR      r0,|L1.1052|
00002a  f8500024          LDR      r0,[r0,r4,LSL #2]
00002e  9003              STR      r0,[sp,#0xc]
;;;310      	DMA_InitStructure.DMA_PeripheralBaseAddr = UsartDmaInfo[COM].DataRegAddr;
000030  48f9              LDR      r0,|L1.1048|
000032  eb001044          ADD      r0,r0,r4,LSL #5
000036  6840              LDR      r0,[r0,#4]
000038  9002              STR      r0,[sp,#8]
;;;311      	DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
00003a  f04f0040          MOV      r0,#0x40
00003e  9004              STR      r0,[sp,#0x10]
;;;312      	DMA_InitStructure.DMA_BufferSize = 0;///此处初始化成0
000040  f04f0000          MOV      r0,#0
000044  9005              STR      r0,[sp,#0x14]
;;;313      	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
000046  9006              STR      r0,[sp,#0x18]
;;;314      	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
000048  f44f6080          MOV      r0,#0x400
00004c  9007              STR      r0,[sp,#0x1c]
;;;315      	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
00004e  f04f0000          MOV      r0,#0
000052  9008              STR      r0,[sp,#0x20]
;;;316      	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
000054  9009              STR      r0,[sp,#0x24]
;;;317    
;;;318    	///circular 方式下，数据长度会重新加载，但地址是否重新加载？需要确认
;;;319    	///DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
;;;320    	///Normal 方式下，数据长度每次需要设置，地址似乎自动保持：
;;;321      	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
000056  900a              STR      r0,[sp,#0x28]
;;;322    
;;;323      	DMA_InitStructure.DMA_Priority = DMA_Priority_High;
000058  f44f3000          MOV      r0,#0x20000
00005c  900b              STR      r0,[sp,#0x2c]
;;;324      	DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;         
00005e  f04f0000          MOV      r0,#0
000062  900c              STR      r0,[sp,#0x30]
;;;325      	DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_Full;
000064  f04f0003          MOV      r0,#3
000068  900d              STR      r0,[sp,#0x34]
;;;326      	DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
00006a  f04f0000          MOV      r0,#0
00006e  900e              STR      r0,[sp,#0x38]
;;;327      	DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
000070  900f              STR      r0,[sp,#0x3c]
;;;328      	DMA_Init(UsartDmaInfo[COM].stream, &DMA_InitStructure);
000072  49e9              LDR      r1,|L1.1048|
000074  eb011144          ADD      r1,r1,r4,LSL #5
000078  6808              LDR      r0,[r1,#0]
00007a  a901              ADD      r1,sp,#4
00007c  f7fffffe          BL       DMA_Init
;;;329    
;;;330    	USART_DMACmd(COM_USART[COM], USART_DMAReq_Tx, ENABLE);
000080  49e7              LDR      r1,|L1.1056|
000082  f8510024          LDR      r0,[r1,r4,LSL #2]
000086  2201              MOVS     r2,#1
000088  2180              MOVS     r1,#0x80
00008a  f7fffffe          BL       USART_DMACmd
;;;331    }
00008e  b010              ADD      sp,sp,#0x40
000090  bd10              POP      {r4,pc}
;;;332    
                          ENDP

                  BSP_USART_Init PROC
;;;188      */
;;;189    void BSP_USART_Init(COM_TypeDef COM, USART_InitTypeDef* USART_InitStruct, uint8_t MultiMode, uint8_t Addr)
000092  e92d41fc          PUSH     {r2-r8,lr}
;;;190    {
000096  4604              MOV      r4,r0
000098  460f              MOV      r7,r1
00009a  4615              MOV      r5,r2
00009c  461e              MOV      r6,r3
;;;191    	GPIO_InitTypeDef GPIO_InitStructure;
;;;192    
;;;193    	/* Enable GPIO clock */
;;;194    	RCC_AHB1PeriphClockCmd(COM_TX_PORT_CLK[COM] | COM_RX_PORT_CLK[COM], ENABLE);
00009e  49e1              LDR      r1,|L1.1060|
0000a0  f8511024          LDR      r1,[r1,r4,LSL #2]
0000a4  4ae0              LDR      r2,|L1.1064|
0000a6  f8522024          LDR      r2,[r2,r4,LSL #2]
0000aa  ea410002          ORR      r0,r1,r2
0000ae  f04f0101          MOV      r1,#1
0000b2  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;195    
;;;196    	if ((COM == COM1) || (COM == COM6)){
0000b6  b10c              CBZ      r4,|L1.188|
0000b8  2c05              CMP      r4,#5
0000ba  d106              BNE      |L1.202|
                  |L1.188|
;;;197    		/* Enable UART clock */
;;;198    		RCC_APB2PeriphClockCmd(COM_USART_CLK[COM], ENABLE);
0000bc  49db              LDR      r1,|L1.1068|
0000be  f8510024          LDR      r0,[r1,r4,LSL #2]
0000c2  2101              MOVS     r1,#1
0000c4  f7fffffe          BL       RCC_APB2PeriphClockCmd
0000c8  e005              B        |L1.214|
                  |L1.202|
;;;199    	}
;;;200    	else
;;;201    		RCC_APB1PeriphClockCmd(COM_USART_CLK[COM], ENABLE);
0000ca  49d8              LDR      r1,|L1.1068|
0000cc  f8510024          LDR      r0,[r1,r4,LSL #2]
0000d0  2101              MOVS     r1,#1
0000d2  f7fffffe          BL       RCC_APB1PeriphClockCmd
                  |L1.214|
;;;202    
;;;203    	/* Connect PXx to USARTx_Tx*/
;;;204    	GPIO_PinAFConfig(COM_TX_PORT[COM], COM_TX_PIN_SOURCE[COM], COM_TX_AF[COM]);
0000d6  4bd6              LDR      r3,|L1.1072|
0000d8  5d1a              LDRB     r2,[r3,r4]
0000da  4bd6              LDR      r3,|L1.1076|
0000dc  5d19              LDRB     r1,[r3,r4]
0000de  4bd6              LDR      r3,|L1.1080|
0000e0  f8530024          LDR      r0,[r3,r4,LSL #2]
0000e4  f7fffffe          BL       GPIO_PinAFConfig
;;;205    
;;;206    	/* Connect PXx to USARTx_Rx*/
;;;207    	GPIO_PinAFConfig(COM_RX_PORT[COM], COM_RX_PIN_SOURCE[COM], COM_RX_AF[COM]);
0000e8  4bd4              LDR      r3,|L1.1084|
0000ea  5d1a              LDRB     r2,[r3,r4]
0000ec  4bd4              LDR      r3,|L1.1088|
0000ee  5d19              LDRB     r1,[r3,r4]
0000f0  4bd4              LDR      r3,|L1.1092|
0000f2  f8530024          LDR      r0,[r3,r4,LSL #2]
0000f6  f7fffffe          BL       GPIO_PinAFConfig
;;;208    
;;;209    	/* Configure USART Tx as alternate function  */
;;;210    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
0000fa  f04f0000          MOV      r0,#0
0000fe  f88d0006          STRB     r0,[sp,#6]
;;;211    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
000102  f04f0001          MOV      r0,#1
000106  f88d0007          STRB     r0,[sp,#7]
;;;212    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
00010a  f04f0002          MOV      r0,#2
00010e  f88d0004          STRB     r0,[sp,#4]
;;;213    
;;;214    	GPIO_InitStructure.GPIO_Pin = COM_TX_PIN[COM];
000112  48cd              LDR      r0,|L1.1096|
000114  f8300014          LDRH     r0,[r0,r4,LSL #1]
000118  9000              STR      r0,[sp,#0]
;;;215    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00011a  f04f0002          MOV      r0,#2
00011e  f88d0005          STRB     r0,[sp,#5]
;;;216    	GPIO_Init(COM_TX_PORT[COM], &GPIO_InitStructure);
000122  49c5              LDR      r1,|L1.1080|
000124  f8510024          LDR      r0,[r1,r4,LSL #2]
000128  4669              MOV      r1,sp
00012a  f7fffffe          BL       GPIO_Init
;;;217    
;;;218    	/* Configure USART Rx as alternate function  */
;;;219    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
00012e  f04f0002          MOV      r0,#2
000132  f88d0004          STRB     r0,[sp,#4]
;;;220    	GPIO_InitStructure.GPIO_Pin = COM_RX_PIN[COM];
000136  48c5              LDR      r0,|L1.1100|
000138  f8300014          LDRH     r0,[r0,r4,LSL #1]
00013c  9000              STR      r0,[sp,#0]
;;;221    	GPIO_Init(COM_RX_PORT[COM], &GPIO_InitStructure);
00013e  49c1              LDR      r1,|L1.1092|
000140  f8510024          LDR      r0,[r1,r4,LSL #2]
000144  4669              MOV      r1,sp
000146  f7fffffe          BL       GPIO_Init
;;;222    
;;;223    
;;;224    	///L1205: 为得到高速率，需要8x采样
;;;225    	///本应用中速率 57600BPS，采用 16x 采样即可
;;;226    	USART_OverSampling8Cmd(COM_USART[COM], DISABLE);
00014a  49b5              LDR      r1,|L1.1056|
00014c  f8510024          LDR      r0,[r1,r4,LSL #2]
000150  2100              MOVS     r1,#0
000152  f7fffffe          BL       USART_OverSampling8Cmd
;;;227    
;;;228    	/* USART configuration */
;;;229    	USART_Init(COM_USART[COM], USART_InitStruct);
000156  49b2              LDR      r1,|L1.1056|
000158  f8510024          LDR      r0,[r1,r4,LSL #2]
00015c  4639              MOV      r1,r7
00015e  f7fffffe          BL       USART_Init
;;;230    	
;;;231    	///
;;;232    	if (MultiMode){
000162  b165              CBZ      r5,|L1.382|
;;;233    		USART_SetAddress(COM_USART[COM], Addr);
000164  49ae              LDR      r1,|L1.1056|
000166  f8510024          LDR      r0,[r1,r4,LSL #2]
00016a  4631              MOV      r1,r6
00016c  f7fffffe          BL       USART_SetAddress
;;;234    		USART_WakeUpConfig(COM_USART[COM], USART_WakeUp_AddressMark);
000170  49ab              LDR      r1,|L1.1056|
000172  f8510024          LDR      r0,[r1,r4,LSL #2]
000176  f44f6100          MOV      r1,#0x800
00017a  f7fffffe          BL       USART_WakeUpConfig
                  |L1.382|
;;;235    	}
;;;236    
;;;237      	///L1205: 允许发送完成中断和接收中断
;;;238      	USART_ITConfig(COM_USART[COM], USART_IT_TC, 	ENABLE);
00017e  49a8              LDR      r1,|L1.1056|
000180  f8510024          LDR      r0,[r1,r4,LSL #2]
000184  2201              MOVS     r2,#1
000186  f2406126          MOV      r1,#0x626
00018a  f7fffffe          BL       USART_ITConfig
;;;239    	USART_ITConfig(COM_USART[COM], USART_IT_RXNE, 	ENABLE);
00018e  49a4              LDR      r1,|L1.1056|
000190  f8510024          LDR      r0,[r1,r4,LSL #2]
000194  2201              MOVS     r2,#1
000196  f2405125          MOV      r1,#0x525
00019a  f7fffffe          BL       USART_ITConfig
;;;240    	USART_ITConfig(COM_USART[COM], USART_IT_ORE,	ENABLE);
00019e  49a0              LDR      r1,|L1.1056|
0001a0  f8510024          LDR      r0,[r1,r4,LSL #2]
0001a4  2201              MOVS     r2,#1
0001a6  f44f7158          MOV      r1,#0x360
0001aa  f7fffffe          BL       USART_ITConfig
;;;241    
;;;242      	///L1205：由于不确定接收长度，接收时不能采用 DMA 方式，发送时可采用 DMA 方式
;;;243      	USART_DMAConfig(COM);
0001ae  4620              MOV      r0,r4
0001b0  f7fffffe          BL       USART_DMAConfig
;;;244    #if (USART_USE_DMA_INTERRUPT)
;;;245    	///允许发送DMA中断
;;;246    	DMA_ITConfig(UsartDmaInfo[COM].stream, DMA_IT_TC, ENABLE);
0001b4  4998              LDR      r1,|L1.1048|
0001b6  eb011144          ADD      r1,r1,r4,LSL #5
0001ba  2201              MOVS     r2,#1
0001bc  6808              LDR      r0,[r1,#0]
0001be  2110              MOVS     r1,#0x10
0001c0  f7fffffe          BL       DMA_ITConfig
;;;247    	DMA_ClearFlag(UsartDmaInfo[COM].stream, UsartDmaInfo[COM].DMA_FlagTCIF);
0001c4  4a94              LDR      r2,|L1.1048|
0001c6  eb021244          ADD      r2,r2,r4,LSL #5
0001ca  6991              LDR      r1,[r2,#0x18]
0001cc  4a92              LDR      r2,|L1.1048|
0001ce  eb021244          ADD      r2,r2,r4,LSL #5
0001d2  6810              LDR      r0,[r2,#0]
0001d4  f7fffffe          BL       DMA_ClearFlag
;;;248    	///
;;;249    	BSP_IntVectSet(UsartDmaInfo[COM].DMA_Int_ID, *UsartDmaIsr[COM]);
0001d8  4a9d              LDR      r2,|L1.1104|
0001da  f8521024          LDR      r1,[r2,r4,LSL #2]
0001de  4a8e              LDR      r2,|L1.1048|
0001e0  eb021244          ADD      r2,r2,r4,LSL #5
0001e4  8b90              LDRH     r0,[r2,#0x1c]
0001e6  f7fffffe          BL       BSP_IntVectSet
;;;250        BSP_IntEn(UsartDmaInfo[COM].DMA_Int_ID);
0001ea  498b              LDR      r1,|L1.1048|
0001ec  eb011144          ADD      r1,r1,r4,LSL #5
0001f0  8b88              LDRH     r0,[r1,#0x1c]
0001f2  f7fffffe          BL       BSP_IntEn
;;;251    #endif///USART_USE_DMA_INTERRUPT
;;;252    
;;;253    	///串口接收中断设置
;;;254    	BSP_IntVectSet(UsartIntID[COM], *UsartIsr[COM]);
0001f6  4a97              LDR      r2,|L1.1108|
0001f8  f8521024          LDR      r1,[r2,r4,LSL #2]
0001fc  4a96              LDR      r2,|L1.1112|
0001fe  f8520024          LDR      r0,[r2,r4,LSL #2]
000202  f7fffffe          BL       BSP_IntVectSet
;;;255        BSP_IntEn(UsartIntID[COM]);
000206  4994              LDR      r1,|L1.1112|
000208  f8510024          LDR      r0,[r1,r4,LSL #2]
00020c  f7fffffe          BL       BSP_IntEn
;;;256        
;;;257      	/* Enable USART */
;;;258      	USART_Cmd(COM_USART[COM], ENABLE);	
000210  4983              LDR      r1,|L1.1056|
000212  f8510024          LDR      r0,[r1,r4,LSL #2]
000216  2101              MOVS     r1,#1
000218  f7fffffe          BL       USART_Cmd
;;;259    	USART_ClearFlag(COM_USART[COM], USART_FLAG_TC);
00021c  4980              LDR      r1,|L1.1056|
00021e  f8510024          LDR      r0,[r1,r4,LSL #2]
000222  2140              MOVS     r1,#0x40
000224  f7fffffe          BL       USART_ClearFlag
;;;260    	
;;;261    	///
;;;262    	if (MultiMode)
000228  b12d              CBZ      r5,|L1.566|
;;;263    		USART_ReceiverWakeUpCmd(COM_USART[COM], ENABLE);
00022a  497d              LDR      r1,|L1.1056|
00022c  f8510024          LDR      r0,[r1,r4,LSL #2]
000230  2101              MOVS     r1,#1
000232  f7fffffe          BL       USART_ReceiverWakeUpCmd
                  |L1.566|
;;;264    
;;;265    	///注意：此处不能开！
;;;266    	/* DMA2_Stream7 disable here*/
;;;267      	DMA_Cmd(UsartDmaInfo[COM].stream, DISABLE);
000236  4978              LDR      r1,|L1.1048|
000238  eb011144          ADD      r1,r1,r4,LSL #5
00023c  6808              LDR      r0,[r1,#0]
00023e  2100              MOVS     r1,#0
000240  f7fffffe          BL       DMA_Cmd
;;;268    }
000244  e8bd81fc          POP      {r2-r8,pc}
;;;269    
                          ENDP

                  BSP_USART_TxData PROC
;;;272    ///采用 DMA 方式发送数据
;;;273    void BSP_USART_TxData(COM_TypeDef COM, uint16_t len)
000248  b570              PUSH     {r4-r6,lr}
;;;274    { 
00024a  4604              MOV      r4,r0
00024c  460d              MOV      r5,r1
;;;275    	///设置 DMA 长度并启动 DMA 发送
;;;276    	DMA_SetCurrDataCounter(UsartDmaInfo[COM].stream, len);
00024e  4972              LDR      r1,|L1.1048|
000250  eb011144          ADD      r1,r1,r4,LSL #5
000254  6808              LDR      r0,[r1,#0]
000256  4629              MOV      r1,r5
000258  f7fffffe          BL       DMA_SetCurrDataCounter
;;;277    	/* DMA2_Stream7 enable */
;;;278      	DMA_Cmd(UsartDmaInfo[COM].stream, ENABLE);
00025c  496e              LDR      r1,|L1.1048|
00025e  eb011144          ADD      r1,r1,r4,LSL #5
000262  6808              LDR      r0,[r1,#0]
000264  2101              MOVS     r1,#1
000266  f7fffffe          BL       DMA_Cmd
;;;279    }
00026a  bd70              POP      {r4-r6,pc}
;;;280    
                          ENDP

                  BSP_GetUsartTxStatus PROC
;;;283    ///0--DISABLE；1--ENABLE
;;;284    uint8_t BSP_GetUsartTxStatus(COM_TypeDef COM)
00026c  b510              PUSH     {r4,lr}
;;;285    {
00026e  4604              MOV      r4,r0
;;;286    	if (DMA_GetCmdStatus(UsartDmaInfo[COM].stream) == DISABLE)
000270  4969              LDR      r1,|L1.1048|
000272  eb011144          ADD      r1,r1,r4,LSL #5
000276  6808              LDR      r0,[r1,#0]
000278  f7fffffe          BL       DMA_GetCmdStatus
00027c  b908              CBNZ     r0,|L1.642|
;;;287    		return ENABLE;
00027e  2001              MOVS     r0,#1
                  |L1.640|
;;;288    
;;;289    	return DISABLE;
;;;290    }
000280  bd10              POP      {r4,pc}
                  |L1.642|
000282  2000              MOVS     r0,#0                 ;289
000284  e7fc              B        |L1.640|
;;;291    
                          ENDP

                  Usart1_Isr PROC
;;;338    
;;;339    void Usart1_Isr(void)
000286  b570              PUSH     {r4-r6,lr}
;;;340    {
;;;341    	CPU_REG32  status;
;;;342    	uint16_t data;
;;;343    	uint16_t Index;
;;;344    
;;;345    	status = USART1->SR;
000288  4874              LDR      r0,|L1.1116|
00028a  8804              LDRH     r4,[r0,#0]
;;;346    
;;;347    	///RX
;;;348    	if (status & 0x28){
00028c  f0140f28          TST      r4,#0x28
000290  d028              BEQ      |L1.740|
;;;349    		
;;;350    		if (DEF_BIT_IS_SET(status, DEF_BIT_03))
000292  f3c400c0          UBFX     r0,r4,#3,#1
000296  b120              CBZ      r0,|L1.674|
;;;351    			USART_ClearITPendingBit(USART1, USART_IT_ORE);
000298  f44f7158          MOV      r1,#0x360
00029c  486f              LDR      r0,|L1.1116|
00029e  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.674|
;;;352    
;;;353    
;;;354    		data = USART_ReceiveData(USART1);       			/* Read one byte from the receive data register.      */
0002a2  486e              LDR      r0,|L1.1116|
0002a4  f7fffffe          BL       USART_ReceiveData
0002a8  4605              MOV      r5,r0
;;;355    		Index = BSP_Info.UsartRxIndex[COM1];
0002aa  485c              LDR      r0,|L1.1052|
0002ac  f1a00030          SUB      r0,r0,#0x30
0002b0  f8b06048          LDRH     r6,[r0,#0x48]  ; BSP_Info
;;;356    #if defined USART_1_MULTI_COMMUNICATION
;;;357    		*((uint16_t *)&(BSP_Info.UsartRxBuf[COM1][Index])) = data;
;;;358    #else
;;;359    		BSP_Info.UsartRxBuf[COM1][Index] = data & 0xff;
0002b4  4601              MOV      r1,r0
0002b6  6989              LDR      r1,[r1,#0x18]  ; BSP_Info
0002b8  558d              STRB     r5,[r1,r6]
;;;360    #endif
;;;361    		BSP_Info.UsartRxIndex[COM1]++;
0002ba  f8b00048          LDRH     r0,[r0,#0x48]  ; BSP_Info
0002be  f1000001          ADD      r0,r0,#1
0002c2  4956              LDR      r1,|L1.1052|
0002c4  f1a10130          SUB      r1,r1,#0x30
0002c8  f8a10048          STRH     r0,[r1,#0x48]
;;;362    		BSP_Info.UsartRxIndex[COM1] &= BSP_Info.UsartRxBufMask[COM1];
0002cc  4608              MOV      r0,r1
0002ce  f8b00048          LDRH     r0,[r0,#0x48]  ; BSP_Info
0002d2  f8b11060          LDRH     r1,[r1,#0x60]  ; BSP_Info
0002d6  ea000001          AND      r0,r0,r1
0002da  4950              LDR      r1,|L1.1052|
0002dc  f1a10130          SUB      r1,r1,#0x30
0002e0  f8a10048          STRH     r0,[r1,#0x48]
                  |L1.740|
;;;363    	}
;;;364    
;;;365    	///TXC
;;;366    	if (DEF_BIT_IS_SET(status, DEF_BIT_06)){
0002e4  f3c41080          UBFX     r0,r4,#6,#1
0002e8  b160              CBZ      r0,|L1.772|
;;;367    
;;;368    		USART_ClearITPendingBit(USART1, USART_IT_TC);         /* Clear the USART1 Transmit interrupt.                */
0002ea  f2406126          MOV      r1,#0x626
0002ee  485b              LDR      r0,|L1.1116|
0002f0  f7fffffe          BL       USART_ClearITPendingBit
;;;369    		///关闭发送控制
;;;370    		BSP_EnableUsartTx(COM1, DISABLE);
0002f4  2100              MOVS     r1,#0
0002f6  4608              MOV      r0,r1
0002f8  f7fffffe          BL       BSP_EnableUsartTx
;;;371    		///允许下一帧发送
;;;372    		OSSemPost(Sem_UsartTxRdy[COM1]);
0002fc  4958              LDR      r1,|L1.1120|
0002fe  6808              LDR      r0,[r1,#0]  ; Sem_UsartTxRdy
000300  f7fffffe          BL       OSSemPost
                  |L1.772|
;;;373    	}
;;;374    }
000304  bd70              POP      {r4-r6,pc}
;;;375    
                          ENDP

                  Usart2_Isr PROC
;;;376    
;;;377    void Usart2_Isr(void)
000306  b570              PUSH     {r4-r6,lr}
;;;378    {
;;;379    	CPU_REG32  status;
;;;380    	uint16_t data;
;;;381    	uint16_t Index;
;;;382    
;;;383    	status = USART2->SR;
000308  4856              LDR      r0,|L1.1124|
00030a  8804              LDRH     r4,[r0,#0]
;;;384    
;;;385    	///RX
;;;386    	if (status & 0x28){
00030c  f0140f28          TST      r4,#0x28
000310  d02d              BEQ      |L1.878|
;;;387    		
;;;388    		if (DEF_BIT_IS_SET(status, DEF_BIT_03))
000312  f3c400c0          UBFX     r0,r4,#3,#1
000316  b120              CBZ      r0,|L1.802|
;;;389    			USART_ClearITPendingBit(USART2, USART_IT_ORE);
000318  f44f7158          MOV      r1,#0x360
00031c  4851              LDR      r0,|L1.1124|
00031e  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.802|
;;;390    
;;;391    
;;;392    		data = USART_ReceiveData(USART2);       			/* Read one byte from the receive data register.      */
000322  4850              LDR      r0,|L1.1124|
000324  f7fffffe          BL       USART_ReceiveData
000328  4605              MOV      r5,r0
;;;393    		Index = BSP_Info.UsartRxIndex[COM2];
00032a  483c              LDR      r0,|L1.1052|
00032c  f1a00030          SUB      r0,r0,#0x30
000330  f8b0604a          LDRH     r6,[r0,#0x4a]
;;;394    #if defined USART_2_MULTI_COMMUNICATION
;;;395    		*((uint16_t *)&(BSP_Info.UsartRxBuf[COM2][Index])) = data;
;;;396    #else
;;;397    		BSP_Info.UsartRxBuf[COM2][Index] = data & 0xff;
000334  69c0              LDR      r0,[r0,#0x1c]
000336  5585              STRB     r5,[r0,r6]
;;;398    #endif
;;;399    		BSP_Info.UsartRxIndex[COM2]++;
000338  4838              LDR      r0,|L1.1052|
00033a  f1a00030          SUB      r0,r0,#0x30
00033e  f8b0004a          LDRH     r0,[r0,#0x4a]
000342  f1000001          ADD      r0,r0,#1
000346  b281              UXTH     r1,r0
000348  4834              LDR      r0,|L1.1052|
00034a  f1a00030          SUB      r0,r0,#0x30
00034e  f8a0104a          STRH     r1,[r0,#0x4a]
;;;400    		BSP_Info.UsartRxIndex[COM2] &= BSP_Info.UsartRxBufMask[COM2];
000352  f8b0004a          LDRH     r0,[r0,#0x4a]
000356  4931              LDR      r1,|L1.1052|
000358  f1a10130          SUB      r1,r1,#0x30
00035c  f8b11062          LDRH     r1,[r1,#0x62]
000360  ea000001          AND      r0,r0,r1
000364  492d              LDR      r1,|L1.1052|
000366  f1a10130          SUB      r1,r1,#0x30
00036a  f8a1004a          STRH     r0,[r1,#0x4a]
                  |L1.878|
;;;401    	}
;;;402    
;;;403    	///TXC
;;;404    	if (DEF_BIT_IS_SET(status, DEF_BIT_06)){
00036e  f3c41080          UBFX     r0,r4,#6,#1
000372  b160              CBZ      r0,|L1.910|
;;;405    
;;;406    		USART_ClearITPendingBit(USART2, USART_IT_TC);         /* Clear the USART1 Transmit interrupt.                */
000374  f2406126          MOV      r1,#0x626
000378  483a              LDR      r0,|L1.1124|
00037a  f7fffffe          BL       USART_ClearITPendingBit
;;;407    		///关闭发送控制
;;;408    		BSP_EnableUsartTx(COM2, DISABLE);
00037e  2100              MOVS     r1,#0
000380  2001              MOVS     r0,#1
000382  f7fffffe          BL       BSP_EnableUsartTx
;;;409    		///允许下一帧发送
;;;410    		OSSemPost(Sem_UsartTxRdy[COM2]);
000386  4936              LDR      r1,|L1.1120|
000388  6848              LDR      r0,[r1,#4]  ; Sem_UsartTxRdy
00038a  f7fffffe          BL       OSSemPost
                  |L1.910|
;;;411    	}
;;;412    }
00038e  bd70              POP      {r4-r6,pc}
;;;413    
                          ENDP

                  Usart3_Isr PROC
;;;414    
;;;415    void Usart3_Isr(void)
000390  b570              PUSH     {r4-r6,lr}
;;;416    {
;;;417    	CPU_REG32  status;
;;;418    	uint16_t data;
;;;419    	uint16_t Index;
;;;420    
;;;421    	status = USART3->SR;
000392  4835              LDR      r0,|L1.1128|
000394  8804              LDRH     r4,[r0,#0]
;;;422    
;;;423    	///RX
;;;424    	if (status & 0x28){
000396  f0140f28          TST      r4,#0x28
00039a  d02d              BEQ      |L1.1016|
;;;425    		
;;;426    		if (DEF_BIT_IS_SET(status, DEF_BIT_03))
00039c  f3c400c0          UBFX     r0,r4,#3,#1
0003a0  b120              CBZ      r0,|L1.940|
;;;427    			USART_ClearITPendingBit(USART3, USART_IT_ORE);
0003a2  f44f7158          MOV      r1,#0x360
0003a6  4830              LDR      r0,|L1.1128|
0003a8  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.940|
;;;428    
;;;429    
;;;430    		data = USART_ReceiveData(USART3);       			/* Read one byte from the receive data register.      */
0003ac  482e              LDR      r0,|L1.1128|
0003ae  f7fffffe          BL       USART_ReceiveData
0003b2  4605              MOV      r5,r0
;;;431    		Index = BSP_Info.UsartRxIndex[COM3];
0003b4  4819              LDR      r0,|L1.1052|
0003b6  f1a00030          SUB      r0,r0,#0x30
0003ba  f8b0604c          LDRH     r6,[r0,#0x4c]
;;;432    #if defined USART_3_MULTI_COMMUNICATION
;;;433    		*((uint16_t *)&(BSP_Info.UsartRxBuf[COM3][Index])) = data;
;;;434    #else
;;;435    		BSP_Info.UsartRxBuf[COM3][Index] = data & 0xff;
0003be  6a00              LDR      r0,[r0,#0x20]
0003c0  5585              STRB     r5,[r0,r6]
;;;436    #endif
;;;437    		BSP_Info.UsartRxIndex[COM3]++;
0003c2  4816              LDR      r0,|L1.1052|
0003c4  f1a00030          SUB      r0,r0,#0x30
0003c8  f8b0004c          LDRH     r0,[r0,#0x4c]
0003cc  f1000001          ADD      r0,r0,#1
0003d0  b281              UXTH     r1,r0
0003d2  4812              LDR      r0,|L1.1052|
0003d4  f1a00030          SUB      r0,r0,#0x30
0003d8  f8a0104c          STRH     r1,[r0,#0x4c]
;;;438    		BSP_Info.UsartRxIndex[COM3] &= BSP_Info.UsartRxBufMask[COM3];
0003dc  f8b0004c          LDRH     r0,[r0,#0x4c]
0003e0  490e              LDR      r1,|L1.1052|
0003e2  f1a10130          SUB      r1,r1,#0x30
0003e6  f8b11064          LDRH     r1,[r1,#0x64]
0003ea  ea000001          AND      r0,r0,r1
0003ee  490b              LDR      r1,|L1.1052|
0003f0  f1a10130          SUB      r1,r1,#0x30
0003f4  f8a1004c          STRH     r0,[r1,#0x4c]
                  |L1.1016|
;;;439    	}
;;;440    
;;;441    	///TXC
;;;442    	if (DEF_BIT_IS_SET(status, DEF_BIT_06)){
0003f8  f3c41080          UBFX     r0,r4,#6,#1
0003fc  b158              CBZ      r0,|L1.1046|
;;;443    
;;;444    		USART_ClearITPendingBit(USART3, USART_IT_TC);         /* Clear the USART1 Transmit interrupt.                */
0003fe  f2406126          MOV      r1,#0x626
000402  4819              LDR      r0,|L1.1128|
000404  f7fffffe          BL       USART_ClearITPendingBit
;;;445    		///关闭发送控制
;;;446    		BSP_EnableUsartTx(COM3, DISABLE);
000408  2100              MOVS     r1,#0
00040a  2002              MOVS     r0,#2
00040c  f7fffffe          BL       BSP_EnableUsartTx
;;;447    		///允许下一帧发送
;;;448    		OSSemPost(Sem_UsartTxRdy[COM3]);
000410  4913              LDR      r1,|L1.1120|
000412  6888              LDR      r0,[r1,#8]  ; Sem_UsartTxRdy
000414  e02a              B        |L1.1132|
                  |L1.1046|
000416  e02b              B        |L1.1136|
                  |L1.1048|
                          DCD      UsartDmaInfo
                  |L1.1052|
                          DCD      BSP_Info+0x30
                  |L1.1056|
                          DCD      COM_USART
                  |L1.1060|
                          DCD      COM_TX_PORT_CLK
                  |L1.1064|
                          DCD      COM_RX_PORT_CLK
                  |L1.1068|
                          DCD      COM_USART_CLK
                  |L1.1072|
                          DCD      COM_TX_AF
                  |L1.1076|
                          DCD      COM_TX_PIN_SOURCE
                  |L1.1080|
                          DCD      COM_TX_PORT
                  |L1.1084|
                          DCD      COM_RX_AF
                  |L1.1088|
                          DCD      COM_RX_PIN_SOURCE
                  |L1.1092|
                          DCD      COM_RX_PORT
                  |L1.1096|
                          DCD      COM_TX_PIN
                  |L1.1100|
                          DCD      COM_RX_PIN
                  |L1.1104|
                          DCD      UsartDmaIsr
                  |L1.1108|
                          DCD      UsartIsr
                  |L1.1112|
                          DCD      UsartIntID
                  |L1.1116|
                          DCD      0x40011000
                  |L1.1120|
                          DCD      Sem_UsartTxRdy
                  |L1.1124|
                          DCD      0x40004400
                  |L1.1128|
                          DCD      0x40004800
                  |L1.1132|
00046c  f7fffffe          BL       OSSemPost
                  |L1.1136|
;;;449    	}
;;;450    }
000470  bd70              POP      {r4-r6,pc}
;;;451    
                          ENDP

                  Usart4_Isr PROC
;;;452    
;;;453    void Usart4_Isr(void)
000472  b570              PUSH     {r4-r6,lr}
;;;454    {
;;;455    	CPU_REG32  status;
;;;456    	uint16_t data;
;;;457    	uint16_t Index;
;;;458    
;;;459    	status = UART4->SR;
000474  48b1              LDR      r0,|L1.1852|
000476  8804              LDRH     r4,[r0,#0]
;;;460    
;;;461    	///RX
;;;462    	if (status & 0x28){
000478  f0140f28          TST      r4,#0x28
00047c  d023              BEQ      |L1.1222|
;;;463    		
;;;464    		if (DEF_BIT_IS_SET(status, DEF_BIT_03))
00047e  f3c400c0          UBFX     r0,r4,#3,#1
000482  b120              CBZ      r0,|L1.1166|
;;;465    			USART_ClearITPendingBit(UART4, USART_IT_ORE);
000484  f44f7158          MOV      r1,#0x360
000488  48ac              LDR      r0,|L1.1852|
00048a  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.1166|
;;;466    
;;;467    
;;;468    		data = USART_ReceiveData(UART4);       			/* Read one byte from the receive data register.      */
00048e  48ab              LDR      r0,|L1.1852|
000490  f7fffffe          BL       USART_ReceiveData
000494  4605              MOV      r5,r0
;;;469    		Index = BSP_Info.UsartRxIndex[COM4];
000496  48aa              LDR      r0,|L1.1856|
000498  f8b0604e          LDRH     r6,[r0,#0x4e]
;;;470    #if defined USART_4_MULTI_COMMUNICATION
;;;471    		*((uint16_t *)&(BSP_Info.UsartRxBuf[COM4][Index])) = data;
;;;472    #else
;;;473    		BSP_Info.UsartRxBuf[COM4][Index] = data & 0xff;
00049c  6a40              LDR      r0,[r0,#0x24]
00049e  5585              STRB     r5,[r0,r6]
;;;474    #endif
;;;475    		BSP_Info.UsartRxIndex[COM4]++;
0004a0  48a7              LDR      r0,|L1.1856|
0004a2  f8b0004e          LDRH     r0,[r0,#0x4e]
0004a6  f1000001          ADD      r0,r0,#1
0004aa  b281              UXTH     r1,r0
0004ac  48a4              LDR      r0,|L1.1856|
0004ae  f8a0104e          STRH     r1,[r0,#0x4e]
;;;476    		BSP_Info.UsartRxIndex[COM4] &= BSP_Info.UsartRxBufMask[COM4];
0004b2  f8b0004e          LDRH     r0,[r0,#0x4e]
0004b6  49a2              LDR      r1,|L1.1856|
0004b8  f8b11066          LDRH     r1,[r1,#0x66]
0004bc  ea000001          AND      r0,r0,r1
0004c0  499f              LDR      r1,|L1.1856|
0004c2  f8a1004e          STRH     r0,[r1,#0x4e]
                  |L1.1222|
;;;477    	}
;;;478    
;;;479    	///TXC
;;;480    	if (DEF_BIT_IS_SET(status, DEF_BIT_06)){
0004c6  f3c41080          UBFX     r0,r4,#6,#1
0004ca  b160              CBZ      r0,|L1.1254|
;;;481    
;;;482    		USART_ClearITPendingBit(UART4, USART_IT_TC);         /* Clear the USART1 Transmit interrupt.                */
0004cc  f2406126          MOV      r1,#0x626
0004d0  489a              LDR      r0,|L1.1852|
0004d2  f7fffffe          BL       USART_ClearITPendingBit
;;;483    		///关闭发送控制
;;;484    		BSP_EnableUsartTx(COM4, DISABLE);
0004d6  2100              MOVS     r1,#0
0004d8  2003              MOVS     r0,#3
0004da  f7fffffe          BL       BSP_EnableUsartTx
;;;485    		///允许下一帧发送
;;;486    		OSSemPost(Sem_UsartTxRdy[COM4]);
0004de  4999              LDR      r1,|L1.1860|
0004e0  68c8              LDR      r0,[r1,#0xc]  ; Sem_UsartTxRdy
0004e2  f7fffffe          BL       OSSemPost
                  |L1.1254|
;;;487    	}
;;;488    }
0004e6  bd70              POP      {r4-r6,pc}
;;;489    
                          ENDP

                  Usart5_Isr PROC
;;;490    
;;;491    void Usart5_Isr(void)
0004e8  b570              PUSH     {r4-r6,lr}
;;;492    {
;;;493    	CPU_REG32  status;
;;;494    	uint16_t data;
;;;495    	uint16_t Index;
;;;496    
;;;497    	status = UART5->SR;
0004ea  4897              LDR      r0,|L1.1864|
0004ec  8804              LDRH     r4,[r0,#0]
;;;498    
;;;499    	///RX
;;;500    	if (status & 0x28){
0004ee  f0140f28          TST      r4,#0x28
0004f2  d023              BEQ      |L1.1340|
;;;501    		
;;;502    		if (DEF_BIT_IS_SET(status, DEF_BIT_03))
0004f4  f3c400c0          UBFX     r0,r4,#3,#1
0004f8  b120              CBZ      r0,|L1.1284|
;;;503    			USART_ClearITPendingBit(UART5, USART_IT_ORE);
0004fa  f44f7158          MOV      r1,#0x360
0004fe  4892              LDR      r0,|L1.1864|
000500  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.1284|
;;;504    
;;;505    
;;;506    		data = USART_ReceiveData(UART5);       			/* Read one byte from the receive data register.      */
000504  4890              LDR      r0,|L1.1864|
000506  f7fffffe          BL       USART_ReceiveData
00050a  4605              MOV      r5,r0
;;;507    		Index = BSP_Info.UsartRxIndex[COM5];
00050c  488c              LDR      r0,|L1.1856|
00050e  f8b06050          LDRH     r6,[r0,#0x50]
;;;508    #if defined USART_5_MULTI_COMMUNICATION
;;;509    		*((uint16_t *)&(BSP_Info.UsartRxBuf[COM5][Index])) = data;
;;;510    #else
;;;511    		BSP_Info.UsartRxBuf[COM5][Index] = data & 0xff;
000512  6a80              LDR      r0,[r0,#0x28]
000514  5585              STRB     r5,[r0,r6]
;;;512    #endif
;;;513    		BSP_Info.UsartRxIndex[COM5]++;
000516  488a              LDR      r0,|L1.1856|
000518  f8b00050          LDRH     r0,[r0,#0x50]
00051c  f1000001          ADD      r0,r0,#1
000520  b281              UXTH     r1,r0
000522  4887              LDR      r0,|L1.1856|
000524  f8a01050          STRH     r1,[r0,#0x50]
;;;514    		BSP_Info.UsartRxIndex[COM5] &= BSP_Info.UsartRxBufMask[COM5];
000528  f8b00050          LDRH     r0,[r0,#0x50]
00052c  4984              LDR      r1,|L1.1856|
00052e  f8b11068          LDRH     r1,[r1,#0x68]
000532  ea000001          AND      r0,r0,r1
000536  4982              LDR      r1,|L1.1856|
000538  f8a10050          STRH     r0,[r1,#0x50]
                  |L1.1340|
;;;515    	}
;;;516    
;;;517    	///TXC
;;;518    	if (DEF_BIT_IS_SET(status, DEF_BIT_06)){
00053c  f3c41080          UBFX     r0,r4,#6,#1
000540  b160              CBZ      r0,|L1.1372|
;;;519    
;;;520    		USART_ClearITPendingBit(UART5, USART_IT_TC);         /* Clear the USART1 Transmit interrupt.                */
000542  f2406126          MOV      r1,#0x626
000546  4880              LDR      r0,|L1.1864|
000548  f7fffffe          BL       USART_ClearITPendingBit
;;;521    		///关闭发送控制
;;;522    		BSP_EnableUsartTx(COM5, DISABLE);
00054c  2100              MOVS     r1,#0
00054e  2004              MOVS     r0,#4
000550  f7fffffe          BL       BSP_EnableUsartTx
;;;523    		///允许下一帧发送
;;;524    		OSSemPost(Sem_UsartTxRdy[COM5]);
000554  497b              LDR      r1,|L1.1860|
000556  6908              LDR      r0,[r1,#0x10]  ; Sem_UsartTxRdy
000558  f7fffffe          BL       OSSemPost
                  |L1.1372|
;;;525    	}
;;;526    }
00055c  bd70              POP      {r4-r6,pc}
;;;527    
                          ENDP

                  Usart6_Isr PROC
;;;528    
;;;529    void Usart6_Isr(void)
00055e  b570              PUSH     {r4-r6,lr}
;;;530    {
;;;531    	CPU_REG32  status;
;;;532    	uint16_t data;
;;;533    	uint16_t Index;
;;;534    
;;;535    	status = USART6->SR;
000560  487a              LDR      r0,|L1.1868|
000562  8804              LDRH     r4,[r0,#0]
;;;536    
;;;537    	///RX
;;;538    	if (status & 0x28){
000564  f0140f28          TST      r4,#0x28
000568  d023              BEQ      |L1.1458|
;;;539    		
;;;540    		if (DEF_BIT_IS_SET(status, DEF_BIT_03))
00056a  f3c400c0          UBFX     r0,r4,#3,#1
00056e  b120              CBZ      r0,|L1.1402|
;;;541    			USART_ClearITPendingBit(USART6, USART_IT_ORE);
000570  f44f7158          MOV      r1,#0x360
000574  4875              LDR      r0,|L1.1868|
000576  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.1402|
;;;542    
;;;543    
;;;544    		data = USART_ReceiveData(USART6);       			/* Read one byte from the receive data register.      */
00057a  4874              LDR      r0,|L1.1868|
00057c  f7fffffe          BL       USART_ReceiveData
000580  4605              MOV      r5,r0
;;;545    		Index = BSP_Info.UsartRxIndex[COM6];
000582  486f              LDR      r0,|L1.1856|
000584  f8b06052          LDRH     r6,[r0,#0x52]
;;;546    #if defined USART_6_MULTI_COMMUNICATION
;;;547    		*((uint16_t *)&(BSP_Info.UsartRxBuf[COM6][Index])) = data;
;;;548    #else
;;;549    		BSP_Info.UsartRxBuf[COM6][Index] = data & 0xff;
000588  6ac0              LDR      r0,[r0,#0x2c]
00058a  5585              STRB     r5,[r0,r6]
;;;550    #endif
;;;551    		BSP_Info.UsartRxIndex[COM6]++;
00058c  486c              LDR      r0,|L1.1856|
00058e  f8b00052          LDRH     r0,[r0,#0x52]
000592  f1000001          ADD      r0,r0,#1
000596  b281              UXTH     r1,r0
000598  4869              LDR      r0,|L1.1856|
00059a  f8a01052          STRH     r1,[r0,#0x52]
;;;552    		BSP_Info.UsartRxIndex[COM6] &= BSP_Info.UsartRxBufMask[COM6];
00059e  f8b00052          LDRH     r0,[r0,#0x52]
0005a2  4967              LDR      r1,|L1.1856|
0005a4  f8b1106a          LDRH     r1,[r1,#0x6a]
0005a8  ea000001          AND      r0,r0,r1
0005ac  4964              LDR      r1,|L1.1856|
0005ae  f8a10052          STRH     r0,[r1,#0x52]
                  |L1.1458|
;;;553    	}
;;;554    
;;;555    	///TXC
;;;556    	if (DEF_BIT_IS_SET(status, DEF_BIT_06)){
0005b2  f3c41080          UBFX     r0,r4,#6,#1
0005b6  b160              CBZ      r0,|L1.1490|
;;;557    
;;;558    		USART_ClearITPendingBit(USART6, USART_IT_TC);         /* Clear the USART1 Transmit interrupt.                */
0005b8  f2406126          MOV      r1,#0x626
0005bc  4863              LDR      r0,|L1.1868|
0005be  f7fffffe          BL       USART_ClearITPendingBit
;;;559    		///关闭发送控制
;;;560    		BSP_EnableUsartTx(COM6, DISABLE);
0005c2  2100              MOVS     r1,#0
0005c4  2005              MOVS     r0,#5
0005c6  f7fffffe          BL       BSP_EnableUsartTx
;;;561    		///允许下一帧发送
;;;562    		OSSemPost(Sem_UsartTxRdy[COM6]);
0005ca  495e              LDR      r1,|L1.1860|
0005cc  6948              LDR      r0,[r1,#0x14]  ; Sem_UsartTxRdy
0005ce  f7fffffe          BL       OSSemPost
                  |L1.1490|
;;;563    	}
;;;564    }
0005d2  bd70              POP      {r4-r6,pc}
;;;565    
                          ENDP

                  Usart1_Dma_Isr PROC
;;;573    ///DMA2, Stream7, channel 4
;;;574    void Usart1_Dma_Isr(void)
0005d4  b510              PUSH     {r4,lr}
;;;575    {
;;;576    	CPU_REG32  status;
;;;577    
;;;578    	status = DMA2->HISR;
0005d6  485e              LDR      r0,|L1.1872|
0005d8  6804              LDR      r4,[r0,#0]
;;;579    
;;;580    	///DMA 传送完成
;;;581    	if (DEF_BIT_IS_SET(status, DEF_BIT_27)){
0005da  f3c460c0          UBFX     r0,r4,#27,#1
0005de  b120              CBZ      r0,|L1.1514|
;;;582    		DMA_ClearITPendingBit(UsartDmaInfo[COM1].stream, UsartDmaInfo[COM1].DMA_ItTCIF);
0005e0  4a5c              LDR      r2,|L1.1876|
0005e2  68d1              LDR      r1,[r2,#0xc]  ; UsartDmaInfo
0005e4  6810              LDR      r0,[r2,#0]  ; UsartDmaInfo
0005e6  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.1514|
;;;583    		
;;;584    	}
;;;585    
;;;586    	///DMA 传送错误
;;;587    	if (DEF_BIT_IS_SET(status, DEF_BIT_25))
0005ea  f3c46040          UBFX     r0,r4,#25,#1
0005ee  b120              CBZ      r0,|L1.1530|
;;;588    		DMA_ClearITPendingBit(UsartDmaInfo[COM1].stream, UsartDmaInfo[COM1].DMA_ItTEIF);	
0005f0  4a58              LDR      r2,|L1.1876|
0005f2  6911              LDR      r1,[r2,#0x10]  ; UsartDmaInfo
0005f4  6810              LDR      r0,[r2,#0]  ; UsartDmaInfo
0005f6  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.1530|
;;;589    
;;;590    	///DMA FIFO 错误
;;;591    	if (DEF_BIT_IS_SET(status, DEF_BIT_22))
0005fa  f3c45080          UBFX     r0,r4,#22,#1
0005fe  b120              CBZ      r0,|L1.1546|
;;;592    		DMA_ClearITPendingBit(UsartDmaInfo[COM1].stream, UsartDmaInfo[COM1].DMA_ItFEIF);	
000600  4a54              LDR      r2,|L1.1876|
000602  6951              LDR      r1,[r2,#0x14]  ; UsartDmaInfo
000604  6810              LDR      r0,[r2,#0]  ; UsartDmaInfo
000606  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.1546|
;;;593    }
00060a  bd10              POP      {r4,pc}
;;;594    
                          ENDP

                  Usart2_Dma_Isr PROC
;;;596    ///DMA1, Stream6, channel 4
;;;597    void Usart2_Dma_Isr(void)
00060c  b510              PUSH     {r4,lr}
;;;598    {
;;;599    	CPU_REG32  status;
;;;600    
;;;601    	status = DMA1->HISR;
00060e  4852              LDR      r0,|L1.1880|
000610  6844              LDR      r4,[r0,#4]
;;;602    
;;;603    	///DMA 传送完成
;;;604    	if (DEF_BIT_IS_SET(status, DEF_BIT_21)){
000612  f3c45040          UBFX     r0,r4,#21,#1
000616  b120              CBZ      r0,|L1.1570|
;;;605    		DMA_ClearITPendingBit(UsartDmaInfo[COM2].stream, UsartDmaInfo[COM2].DMA_ItTCIF);
000618  4a4e              LDR      r2,|L1.1876|
00061a  6ad1              LDR      r1,[r2,#0x2c]
00061c  6a10              LDR      r0,[r2,#0x20]  ; UsartDmaInfo
00061e  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.1570|
;;;606    		
;;;607    	}
;;;608    
;;;609    	///DMA 传送错误
;;;610    	if (DEF_BIT_IS_SET(status, DEF_BIT_19))
000622  f3c440c0          UBFX     r0,r4,#19,#1
000626  b120              CBZ      r0,|L1.1586|
;;;611    		DMA_ClearITPendingBit(UsartDmaInfo[COM2].stream, UsartDmaInfo[COM2].DMA_ItTEIF);	
000628  4a4a              LDR      r2,|L1.1876|
00062a  6b11              LDR      r1,[r2,#0x30]
00062c  6a10              LDR      r0,[r2,#0x20]  ; UsartDmaInfo
00062e  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.1586|
;;;612    
;;;613    	///DMA FIFO 错误
;;;614    	if (DEF_BIT_IS_SET(status, DEF_BIT_16))
000632  f3c44000          UBFX     r0,r4,#16,#1
000636  b120              CBZ      r0,|L1.1602|
;;;615    		DMA_ClearITPendingBit(UsartDmaInfo[COM2].stream, UsartDmaInfo[COM2].DMA_ItFEIF);	
000638  4a46              LDR      r2,|L1.1876|
00063a  6b51              LDR      r1,[r2,#0x34]
00063c  6a10              LDR      r0,[r2,#0x20]  ; UsartDmaInfo
00063e  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.1602|
;;;616    }
000642  bd10              POP      {r4,pc}
;;;617    
                          ENDP

                  Usart3_Dma_Isr PROC
;;;619    ///DMA1, Stream3, channel 4
;;;620    void Usart3_Dma_Isr(void)
000644  b510              PUSH     {r4,lr}
;;;621    {
;;;622    	CPU_REG32  status;
;;;623    
;;;624    	status = DMA1->LISR;
000646  4844              LDR      r0,|L1.1880|
000648  6804              LDR      r4,[r0,#0]
;;;625    
;;;626    	///DMA 传送完成
;;;627    	if (DEF_BIT_IS_SET(status, DEF_BIT_27)){
00064a  f3c460c0          UBFX     r0,r4,#27,#1
00064e  b120              CBZ      r0,|L1.1626|
;;;628    		DMA_ClearITPendingBit(UsartDmaInfo[COM3].stream, UsartDmaInfo[COM3].DMA_ItTCIF);
000650  4a40              LDR      r2,|L1.1876|
000652  6cd1              LDR      r1,[r2,#0x4c]
000654  6c10              LDR      r0,[r2,#0x40]  ; UsartDmaInfo
000656  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.1626|
;;;629    		
;;;630    	}
;;;631    
;;;632    	///DMA 传送错误
;;;633    	if (DEF_BIT_IS_SET(status, DEF_BIT_25))
00065a  f3c46040          UBFX     r0,r4,#25,#1
00065e  b120              CBZ      r0,|L1.1642|
;;;634    		DMA_ClearITPendingBit(UsartDmaInfo[COM3].stream, UsartDmaInfo[COM3].DMA_ItTEIF);	
000660  4a3c              LDR      r2,|L1.1876|
000662  6d11              LDR      r1,[r2,#0x50]
000664  6c10              LDR      r0,[r2,#0x40]  ; UsartDmaInfo
000666  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.1642|
;;;635    
;;;636    	///DMA FIFO 错误
;;;637    	if (DEF_BIT_IS_SET(status, DEF_BIT_22))
00066a  f3c45080          UBFX     r0,r4,#22,#1
00066e  b120              CBZ      r0,|L1.1658|
;;;638    		DMA_ClearITPendingBit(UsartDmaInfo[COM3].stream, UsartDmaInfo[COM3].DMA_ItFEIF);	
000670  4a38              LDR      r2,|L1.1876|
000672  6d51              LDR      r1,[r2,#0x54]
000674  6c10              LDR      r0,[r2,#0x40]  ; UsartDmaInfo
000676  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.1658|
;;;639    }
00067a  bd10              POP      {r4,pc}
;;;640    
                          ENDP

                  Usart4_Dma_Isr PROC
;;;642    ///DMA1, Stream4, channel 4
;;;643    void Usart4_Dma_Isr(void)
00067c  b510              PUSH     {r4,lr}
;;;644    {
;;;645    	CPU_REG32  status;
;;;646    
;;;647    	status = DMA1->HISR;
00067e  4836              LDR      r0,|L1.1880|
000680  6844              LDR      r4,[r0,#4]
;;;648    
;;;649    	///DMA 传送完成
;;;650    	if (DEF_BIT_IS_SET(status, DEF_BIT_05)){
000682  f3c41040          UBFX     r0,r4,#5,#1
000686  b120              CBZ      r0,|L1.1682|
;;;651    		DMA_ClearITPendingBit(UsartDmaInfo[COM4].stream, UsartDmaInfo[COM4].DMA_ItTCIF);
000688  4a32              LDR      r2,|L1.1876|
00068a  6ed1              LDR      r1,[r2,#0x6c]
00068c  6e10              LDR      r0,[r2,#0x60]  ; UsartDmaInfo
00068e  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.1682|
;;;652    		
;;;653    	}
;;;654    
;;;655    	///DMA 传送错误
;;;656    	if (DEF_BIT_IS_SET(status, DEF_BIT_03))
000692  f3c400c0          UBFX     r0,r4,#3,#1
000696  b120              CBZ      r0,|L1.1698|
;;;657    		DMA_ClearITPendingBit(UsartDmaInfo[COM4].stream, UsartDmaInfo[COM4].DMA_ItTEIF);	
000698  4a2e              LDR      r2,|L1.1876|
00069a  6f11              LDR      r1,[r2,#0x70]
00069c  6e10              LDR      r0,[r2,#0x60]  ; UsartDmaInfo
00069e  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.1698|
;;;658    
;;;659    	///DMA FIFO 错误
;;;660    	if (DEF_BIT_IS_SET(status, DEF_BIT_00))
0006a2  f0140f01          TST      r4,#1
0006a6  d004              BEQ      |L1.1714|
;;;661    		DMA_ClearITPendingBit(UsartDmaInfo[COM4].stream, UsartDmaInfo[COM4].DMA_ItFEIF);	
0006a8  4a2a              LDR      r2,|L1.1876|
0006aa  6f51              LDR      r1,[r2,#0x74]
0006ac  6e10              LDR      r0,[r2,#0x60]  ; UsartDmaInfo
0006ae  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.1714|
;;;662    }
0006b2  bd10              POP      {r4,pc}
;;;663    
                          ENDP

                  Usart5_Dma_Isr PROC
;;;665    ///DMA1, Stream7, channel 4
;;;666    void Usart5_Dma_Isr(void)
0006b4  b510              PUSH     {r4,lr}
;;;667    {
;;;668    	CPU_REG32  status;
;;;669    
;;;670    	status = DMA1->HISR;
0006b6  4828              LDR      r0,|L1.1880|
0006b8  6844              LDR      r4,[r0,#4]
;;;671    
;;;672    	///DMA 传送完成
;;;673    	if (DEF_BIT_IS_SET(status, DEF_BIT_27)){
0006ba  f3c460c0          UBFX     r0,r4,#27,#1
0006be  b130              CBZ      r0,|L1.1742|
;;;674    		DMA_ClearITPendingBit(UsartDmaInfo[COM5].stream, UsartDmaInfo[COM5].DMA_ItTCIF);
0006c0  4a24              LDR      r2,|L1.1876|
0006c2  f8d2108c          LDR      r1,[r2,#0x8c]
0006c6  f8d20080          LDR      r0,[r2,#0x80]  ; UsartDmaInfo
0006ca  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.1742|
;;;675    		
;;;676    	}
;;;677    
;;;678    	///DMA 传送错误
;;;679    	if (DEF_BIT_IS_SET(status, DEF_BIT_25))
0006ce  f3c46040          UBFX     r0,r4,#25,#1
0006d2  b130              CBZ      r0,|L1.1762|
;;;680    		DMA_ClearITPendingBit(UsartDmaInfo[COM5].stream, UsartDmaInfo[COM5].DMA_ItTEIF);	
0006d4  4a1f              LDR      r2,|L1.1876|
0006d6  f8d21090          LDR      r1,[r2,#0x90]
0006da  f8d20080          LDR      r0,[r2,#0x80]  ; UsartDmaInfo
0006de  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.1762|
;;;681    
;;;682    	///DMA FIFO 错误
;;;683    	if (DEF_BIT_IS_SET(status, DEF_BIT_22))
0006e2  f3c45080          UBFX     r0,r4,#22,#1
0006e6  b130              CBZ      r0,|L1.1782|
;;;684    		DMA_ClearITPendingBit(UsartDmaInfo[COM5].stream, UsartDmaInfo[COM5].DMA_ItFEIF);	
0006e8  4a1a              LDR      r2,|L1.1876|
0006ea  f8d21094          LDR      r1,[r2,#0x94]
0006ee  f8d20080          LDR      r0,[r2,#0x80]  ; UsartDmaInfo
0006f2  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.1782|
;;;685    }
0006f6  bd10              POP      {r4,pc}
;;;686    
                          ENDP

                  Usart6_Dma_Isr PROC
;;;688    ///DMA2, Stream6, channel 5
;;;689    void Usart6_Dma_Isr(void)
0006f8  b510              PUSH     {r4,lr}
;;;690    {
;;;691    	CPU_REG32  status;
;;;692    
;;;693    	status = DMA2->HISR;
0006fa  4815              LDR      r0,|L1.1872|
0006fc  6804              LDR      r4,[r0,#0]
;;;694    
;;;695    	///DMA 传送完成
;;;696    	if (DEF_BIT_IS_SET(status, DEF_BIT_21)){
0006fe  f3c45040          UBFX     r0,r4,#21,#1
000702  b130              CBZ      r0,|L1.1810|
;;;697    		DMA_ClearITPendingBit(UsartDmaInfo[COM6].stream, UsartDmaInfo[COM6].DMA_ItTCIF);
000704  4a13              LDR      r2,|L1.1876|
000706  f8d210ac          LDR      r1,[r2,#0xac]
00070a  f8d200a0          LDR      r0,[r2,#0xa0]  ; UsartDmaInfo
00070e  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.1810|
;;;698    		
;;;699    	}
;;;700    
;;;701    	///DMA 传送错误
;;;702    	if (DEF_BIT_IS_SET(status, DEF_BIT_19))
000712  f3c440c0          UBFX     r0,r4,#19,#1
000716  b130              CBZ      r0,|L1.1830|
;;;703    		DMA_ClearITPendingBit(UsartDmaInfo[COM6].stream, UsartDmaInfo[COM6].DMA_ItTEIF);	
000718  4a0e              LDR      r2,|L1.1876|
00071a  f8d210b0          LDR      r1,[r2,#0xb0]
00071e  f8d200a0          LDR      r0,[r2,#0xa0]  ; UsartDmaInfo
000722  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.1830|
;;;704    
;;;705    	///DMA FIFO 错误
;;;706    	if (DEF_BIT_IS_SET(status, DEF_BIT_16))
000726  f3c44000          UBFX     r0,r4,#16,#1
00072a  b130              CBZ      r0,|L1.1850|
;;;707    		DMA_ClearITPendingBit(UsartDmaInfo[COM6].stream, UsartDmaInfo[COM6].DMA_ItFEIF);	
00072c  4a09              LDR      r2,|L1.1876|
00072e  f8d210b4          LDR      r1,[r2,#0xb4]
000732  f8d200a0          LDR      r0,[r2,#0xa0]  ; UsartDmaInfo
000736  f7fffffe          BL       DMA_ClearITPendingBit
                  |L1.1850|
;;;708    }
00073a  bd10              POP      {r4,pc}
;;;709    #endif ///(USART_USE_DMA_INTERRUPT==ENABLE)
                          ENDP

                  |L1.1852|
                          DCD      0x40004c00
                  |L1.1856|
                          DCD      BSP_Info
                  |L1.1860|
                          DCD      Sem_UsartTxRdy
                  |L1.1864|
                          DCD      0x40005000
                  |L1.1868|
                          DCD      0x40011400
                  |L1.1872|
                          DCD      0x40026404
                  |L1.1876|
                          DCD      UsartDmaInfo
                  |L1.1880|
                          DCD      0x40026000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Sem_UsartTxRdy
                          %        24

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  COM_USART_CLK
                          DCD      0x00000010
                          DCD      0x00020000
                          DCD      0x00040000
                          DCD      0x00080000
                          DCD      0x00100000
                          DCD      0x00000020
                  COM_TX_PORT_CLK
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000002
                          DCD      0x00000004
                          DCD      0x00000004
                          DCD      0x00000004
                  COM_RX_PORT_CLK
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000002
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x00000004
                  COM_TX_PIN
000048  02000004          DCW      0x0200,0x0004
00004c  04000400          DCW      0x0400,0x0400
000050  10000040          DCW      0x1000,0x0040
                  COM_RX_PIN
000054  04000008          DCW      0x0400,0x0008
000058  08000800          DCW      0x0800,0x0800
00005c  00040080          DCW      0x0004,0x0080
                  COM_TX_PIN_SOURCE
000060  09020a0a          DCB      0x09,0x02,0x0a,0x0a
000064  0c06              DCB      0x0c,0x06
                  COM_RX_PIN_SOURCE
000066  0a03              DCB      0x0a,0x03
000068  0b0b0207          DCB      0x0b,0x0b,0x02,0x07
                  COM_TX_AF
00006c  07070708          DCB      0x07,0x07,0x07,0x08
000070  0808              DCB      0x08,0x08
                  COM_RX_AF
000072  0707              DCB      0x07,0x07
000074  07080808          DCB      0x07,0x08,0x08,0x08
                  UsartDmaInfo
                          DCD      0x400264b8
                          DCD      0x40011004
                          DCD      0x08000000
                          DCD      0x28008000
                          DCD      0x22002000
                          DCD      0xa0400000
                          DCD      0x28000000
000094  0046              DCW      0x0046
000096  0000              DCB      0x00,0x00
                          DCD      0x400260a0
                          DCD      0x40004404
                          DCD      0x08000000
                          DCD      0x20208000
                          DCD      0x20082000
                          DCD      0xa0010000
                          DCD      0x20200000
0000b4  0011              DCW      0x0011
0000b6  0000              DCB      0x00,0x00
                          DCD      0x40026058
                          DCD      0x40004804
                          DCD      0x08000000
                          DCD      0x18008000
                          DCD      0x12002000
                          DCD      0x90400000
                          DCD      0x18000000
0000d4  000e              DCW      0x000e
0000d6  0000              DCB      0x00,0x00
                          DCD      0x40026070
                          DCD      0x40004c04
                          DCD      0x08000000
                          DCD      0x20008020
                          DCD      0x20002008
                          DCD      0xa0000001
                          DCD      0x20000020
0000f4  000f              DCW      0x000f
0000f6  0000              DCB      0x00,0x00
                          DCD      0x400260b8
                          DCD      0x40005004
                          DCD      0x08000000
                          DCD      0x28008000
                          DCD      0x22002000
                          DCD      0xa0400000
                          DCD      0x28000000
000114  002f              DCW      0x002f
000116  0000              DCB      0x00,0x00
                          DCD      0x400264a0
                          DCD      0x40011404
                          DCD      0x0a000000
                          DCD      0x20208000
                          DCD      0x20082000
                          DCD      0xa0010000
                          DCD      0x20200000
000134  0045              DCW      0x0045
000136  0000              DCB      0x00,0x00
                  UsartIntID
                          DCD      0x00000025
                          DCD      0x00000026
                          DCD      0x00000027
                          DCD      0x00000034
                          DCD      0x00000035
                          DCD      0x00000047

                          AREA ||.data||, DATA, ALIGN=2

                  COM_USART
                          DCD      0x40011000
                          DCD      0x40004400
                          DCD      0x40004800
                          DCD      0x40004c00
                          DCD      0x40005000
                          DCD      0x40011400
                  COM_TX_PORT
                          DCD      0x40020000
                          DCD      0x40020000
                          DCD      0x40020400
                          DCD      0x40020800
                          DCD      0x40020800
                          DCD      0x40020800
                  COM_RX_PORT
                          DCD      0x40020000
                          DCD      0x40020000
                          DCD      0x40020400
                          DCD      0x40020800
                          DCD      0x40020c00
                          DCD      0x40020800
                  UsartDmaIsr
                          DCD      Usart1_Dma_Isr
                          DCD      Usart2_Dma_Isr
                          DCD      Usart3_Dma_Isr
                          DCD      Usart4_Dma_Isr
                          DCD      Usart5_Dma_Isr
                          DCD      Usart6_Dma_Isr
                  UsartIsr
                          DCD      Usart1_Isr
                          DCD      Usart2_Isr
                          DCD      Usart3_Isr
                          DCD      Usart4_Isr
                          DCD      Usart5_Isr
                          DCD      Usart6_Isr

;*** Start embedded assembler ***

#line 1 "..\\BSP\\bsp_usart.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_bsp_usart_c_9537f88d____REV16|
#line 112 "..\\BSP\\CMSIS\\core_cmInstr.h"
|__asm___11_bsp_usart_c_9537f88d____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_bsp_usart_c_9537f88d____REVSH|
#line 130
|__asm___11_bsp_usart_c_9537f88d____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
