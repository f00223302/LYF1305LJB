; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Output\bsp_gpio.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\Output\bsp_gpio.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\BSP -I..\BSP\UCOS-II -I..\BSP\STM32F2xx\inc -I..\BSP\CMSIS -I..\BSP\CMSIS\Device_Support -I..\BSP\UCOS-II -I..\..\uC-CPU -I..\..\uC-CPU\ARM-Cortex-M3 -I..\..\uC-LIB -I..\..\uC-LIB\Ports\ARM-Cortex-M3 -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3 -I..\App -I..\Prj -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DDEBUG -DLJB_CPU_MAIN -DUSE_CPU_F205RC --omf_browse=.\Output\bsp_gpio.crf ..\BSP\bsp_gpio.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  BSP_EnableUsartTx PROC
;;;190    #if defined LJB_CPU_MAIN
;;;191    void 	BSP_EnableUsartTx(COM_TypeDef com, uint8_t enable)
000000  b110              CBZ      r0,|L1.8|
;;;192    {
;;;193    	switch (com)
000002  2805              CMP      r0,#5
000004  d116              BNE      |L1.52|
000006  e00a              B        |L1.30|
                  |L1.8|
;;;194    	{
;;;195    		case COM1:
;;;196    			if (enable)
000008  b121              CBZ      r1,|L1.20|
;;;197    			{
;;;198    				GPIOA->BSRRH = GPIO_Pin_12;//BSRRH
00000a  f44f5280          MOV      r2,#0x1000
00000e  4b76              LDR      r3,|L1.488|
000010  835a              STRH     r2,[r3,#0x1a]
000012  e003              B        |L1.28|
                  |L1.20|
;;;199    			}
;;;200    			else
;;;201    			{
;;;202    				GPIOA->BSRRL = GPIO_Pin_12;//BSRRL
000014  f44f5280          MOV      r2,#0x1000
000018  4b73              LDR      r3,|L1.488|
00001a  831a              STRH     r2,[r3,#0x18]
                  |L1.28|
;;;203    			}
;;;204    			break;
00001c  e00b              B        |L1.54|
                  |L1.30|
;;;205    		
;;;206    		case COM6:
;;;207    			if (enable)
00001e  b121              CBZ      r1,|L1.42|
;;;208    			{	
;;;209    			    GPIOB->BSRRH = GPIO_Pin_10;//BSRRH
000020  f44f6280          MOV      r2,#0x400
000024  4b71              LDR      r3,|L1.492|
000026  801a              STRH     r2,[r3,#0]
000028  e003              B        |L1.50|
                  |L1.42|
;;;210    			}
;;;211    			else
;;;212    			{
;;;213    				GPIOB->BSRRL = GPIO_Pin_10;//BSRRL
00002a  f44f6280          MOV      r2,#0x400
00002e  4b70              LDR      r3,|L1.496|
000030  801a              STRH     r2,[r3,#0]
                  |L1.50|
;;;214    			}
;;;215    			break;
000032  e000              B        |L1.54|
                  |L1.52|
;;;216    		
;;;217    		default:
;;;218    			return;
;;;219    	}
;;;220    	
;;;221    	///需要等待一段时间：50us，此处最少 1000！
;;;222        ///Deleted by zhanggong 20140324
;;;223    	/*if (enable)
;;;224    	{
;;;225    		Delay(1000);
;;;226    	}  */
;;;227    }
000034  4770              BX       lr
                  |L1.54|
000036  bf00              NOP                            ;204
000038  bf00              NOP      
00003a  e7fb              B        |L1.52|
;;;228    #endif
                          ENDP

                  BSP_GPIO_Init PROC
;;;26     
;;;27     void BSP_GPIO_Init(void)
00003c  b51c              PUSH     {r2-r4,lr}
;;;28     {
;;;29     	GPIO_InitTypeDef  GPIO_InitStructure;	  
;;;30     
;;;31     ///////////////////////////////////////////////////////////
;;;32     ///连接板
;;;33     ///////////////////////////////////////////////////////////
;;;34     #if defined LJB_CPU_MAIN
;;;35     	///PA2, 11, 12: OUT
;;;36     	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
00003e  2101              MOVS     r1,#1
000040  4608              MOV      r0,r1
000042  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;37     			
;;;38       	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_11 | GPIO_Pin_12;
000046  f6410004          MOV      r0,#0x1804
00004a  9000              STR      r0,[sp,#0]
;;;39       	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
00004c  f04f0001          MOV      r0,#1
000050  f88d0004          STRB     r0,[sp,#4]
;;;40       	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000054  f04f0000          MOV      r0,#0
000058  f88d0006          STRB     r0,[sp,#6]
;;;41       	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00005c  f04f0002          MOV      r0,#2
000060  f88d0005          STRB     r0,[sp,#5]
;;;42       	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
000064  f04f0001          MOV      r0,#1
000068  f88d0007          STRB     r0,[sp,#7]
;;;43       	GPIO_Init(GPIOA, &GPIO_InitStructure);
00006c  4669              MOV      r1,sp
00006e  485e              LDR      r0,|L1.488|
000070  f7fffffe          BL       GPIO_Init
;;;44     
;;;45     
;;;46     	///PB8, 9，10 : OUT
;;;47     	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
000074  2101              MOVS     r1,#1
000076  2002              MOVS     r0,#2
000078  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;48     
;;;49     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10;
00007c  f44f60e0          MOV      r0,#0x700
000080  9000              STR      r0,[sp,#0]
;;;50       	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
000082  f04f0001          MOV      r0,#1
000086  f88d0004          STRB     r0,[sp,#4]
;;;51       	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00008a  f04f0000          MOV      r0,#0
00008e  f88d0006          STRB     r0,[sp,#6]
;;;52       	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000092  f04f0002          MOV      r0,#2
000096  f88d0005          STRB     r0,[sp,#5]
;;;53       	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
00009a  f04f0001          MOV      r0,#1
00009e  f88d0007          STRB     r0,[sp,#7]
;;;54       	GPIO_Init(GPIOB, &GPIO_InitStructure);
0000a2  4669              MOV      r1,sp
0000a4  4853              LDR      r0,|L1.500|
0000a6  f7fffffe          BL       GPIO_Init
;;;55     	
;;;56     	///串口供电
;;;57     	USART_CTRL_ENABLE;
0000aa  f44f6000          MOV      r0,#0x800
0000ae  494e              LDR      r1,|L1.488|
0000b0  8348              STRH     r0,[r1,#0x1a]
0000b2  f44f7000          MOV      r0,#0x200
0000b6  494d              LDR      r1,|L1.492|
0000b8  8008              STRH     r0,[r1,#0]
;;;58     
;;;59     	///I2C写保护
;;;60     	FLASH_WP_ENABLE;//FLASH_WP_DISABLE;
0000ba  f04f0004          MOV      r0,#4
0000be  494a              LDR      r1,|L1.488|
0000c0  8308              STRH     r0,[r1,#0x18]
;;;61     
;;;62     
;;;63     	//先使能串口接收，但还得在后面的每次接收前先使能，就像发送那样
;;;64     	BSP_EnableUsartTx(COM1, DISABLE);
0000c2  f04f0100          MOV      r1,#0
0000c6  4608              MOV      r0,r1
0000c8  f7fffffe          BL       BSP_EnableUsartTx
;;;65     	BSP_EnableUsartTx(COM6, DISABLE);
0000cc  2100              MOVS     r1,#0
0000ce  2005              MOVS     r0,#5
0000d0  f7fffffe          BL       BSP_EnableUsartTx
;;;66     
;;;67     #endif
;;;68     
;;;69     ///////////////////////////////////////////////////////////
;;;70     ///记录采集板
;;;71     ///////////////////////////////////////////////////////////
;;;72     #if defined JLB_CPU_SAMPLE
;;;73     	///PA8, 9, 10: OUT
;;;74     	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
;;;75     			
;;;76       	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10;
;;;77       	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;78       	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;79       	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;80       	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
;;;81       	GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;82     
;;;83     	///PB2, 5, 8, 9 : OUT
;;;84     	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
;;;85     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_5 | GPIO_Pin_8 | GPIO_Pin_9;
;;;86       	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;87     	
;;;88     	///
;;;89     	SELECT_ADC_L_CH;
;;;90     	
;;;91     ///////////////////////////////////////////////////////////
;;;92     ///记录控制板
;;;93     ///////////////////////////////////////////////////////////
;;;94     #elif defined JLB_CPU_MAIN
;;;95     	///PA2, 8, 11, 12: OUT
;;;96     	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
;;;97     			
;;;98       	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_8 | GPIO_Pin_11 | GPIO_Pin_12;
;;;99       	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;100      	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;101      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;102      	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
;;;103      	GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;104    
;;;105    	///PB2, 8, 9, 14 : OUT
;;;106    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
;;;107    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_14;
;;;108      	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;109    	///PB15 : IN
;;;110    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;
;;;111      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
;;;112      	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;113    	
;;;114    	///PC13: ?
;;;115    	
;;;116    	///PF7~11: OUT
;;;117    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);
;;;118    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11;
;;;119      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;120      	GPIO_Init(GPIOF, &GPIO_InitStructure);
;;;121    	
;;;122    	
;;;123    	///PG8~15: IN
;;;124    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOG, ENABLE);
;;;125    	GPIO_InitStructure.GPIO_Pin = 	GPIO_Pin_8  | GPIO_Pin_9  | GPIO_Pin_10 | GPIO_Pin_11 | \
;;;126    									GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
;;;127      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;128      	GPIO_Init(GPIOF, &GPIO_InitStructure);
;;;129    	
;;;130    ///////////////////////////////////////////////////////////
;;;131    ///	解码板
;;;132    ///////////////////////////////////////////////////////////
;;;133    #elif defined JMB_CPU_MAIN
;;;134    	///PA4, 5, 6, 7: OUT
;;;135    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
;;;136    			
;;;137      	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;
;;;138      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;139      	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;140      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;141      	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
;;;142      	GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;143    
;;;144    	///PB12, 13, 14 : OUT
;;;145    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
;;;146    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14;
;;;147      	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;148    	
;;;149    	///PC8: OUT
;;;150    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
;;;151    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
;;;152      	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;153    	
;;;154    	///PC0, 1, 2, 3, 4, 5 : IN
;;;155    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;
;;;156      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
;;;157      	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;158    	
;;;159    	///设置中断
;;;160    	EXTILine6_Config();
;;;161    	EXTILine7_Config();
;;;162    	EXTI_ClearITPendingBit(EXTI_Line6);
;;;163    	EXTI_ClearITPendingBit(EXTI_Line7);
;;;164    	/* Enable and set EXTI Line6 Interrupt*/
;;;165    	BSP_IntVectSet(BSP_INT_ID_EXTI9_5, BSP_EXTI9_5_ISRHandler);
;;;166        BSP_IntEn( BSP_INT_ID_EXTI9_5);
;;;167    #endif
;;;168    }
0000d4  bd1c              POP      {r2-r4,pc}
;;;169    
                          ENDP

                  BSP_FeedDog PROC
;;;172    
;;;173    void BSP_FeedDog(void)
0000d6  4848              LDR      r0,|L1.504|
;;;174    {
;;;175    #if defined JMB_CPU_MAIN
;;;176    	///PB14:
;;;177    	GPIOB->ODR ^= GPIO_Pin_14;
;;;178    #else
;;;179    	///PB8:
;;;180    	GPIOB->ODR ^= GPIO_Pin_8;
0000d8  6800              LDR      r0,[r0,#0]
0000da  f4807080          EOR      r0,r0,#0x100
0000de  4946              LDR      r1,|L1.504|
0000e0  6008              STR      r0,[r1,#0]
;;;181    #endif
;;;182    }
0000e2  4770              BX       lr
;;;183    
                          ENDP

                  BSP_DetectSD PROC
;;;184    uint8_t		BSP_DetectSD(void)
0000e4  b510              PUSH     {r4,lr}
;;;185    {
;;;186    	return (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_15));
0000e6  f44f4100          MOV      r1,#0x8000
0000ea  4842              LDR      r0,|L1.500|
0000ec  f7fffffe          BL       GPIO_ReadInputDataBit
;;;187    }
0000f0  bd10              POP      {r4,pc}
;;;188    
                          ENDP

                  EXTILine6_Config PROC
;;;349    ///PF6
;;;350    void EXTILine6_Config(void)
0000f2  b51f              PUSH     {r0-r4,lr}
;;;351    {
;;;352    	EXTI_InitTypeDef   EXTI_InitStructure;
;;;353    	GPIO_InitTypeDef   GPIO_InitStructure;
;;;354    
;;;355    	/* Enable GPIOF clock */
;;;356    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);
0000f4  2101              MOVS     r1,#1
0000f6  2020              MOVS     r0,#0x20
0000f8  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;357    	/* Enable SYSCFG clock */
;;;358    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
0000fc  2101              MOVS     r1,#1
0000fe  0388              LSLS     r0,r1,#14
000100  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;359      
;;;360    	/* Configure PF6 pin as input floating */
;;;361    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
000104  f04f0000          MOV      r0,#0
000108  f88d0004          STRB     r0,[sp,#4]
;;;362    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
00010c  f88d0007          STRB     r0,[sp,#7]
;;;363    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
000110  f04f0040          MOV      r0,#0x40
000114  9000              STR      r0,[sp,#0]
;;;364    	GPIO_Init(GPIOF, &GPIO_InitStructure);
000116  4669              MOV      r1,sp
000118  4838              LDR      r0,|L1.508|
00011a  f7fffffe          BL       GPIO_Init
;;;365    
;;;366    	/* Connect EXTI Line6 to PF6 pin */
;;;367    	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOF, EXTI_PinSource6);
00011e  2106              MOVS     r1,#6
000120  2005              MOVS     r0,#5
000122  f7fffffe          BL       SYSCFG_EXTILineConfig
;;;368    
;;;369    	/* Configure EXTI Line6 */
;;;370    	EXTI_InitStructure.EXTI_Line = EXTI_Line6;
000126  f04f0040          MOV      r0,#0x40
00012a  9002              STR      r0,[sp,#8]
;;;371    	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
00012c  f04f0000          MOV      r0,#0
000130  f88d000c          STRB     r0,[sp,#0xc]
;;;372    	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  
000134  f04f000c          MOV      r0,#0xc
000138  f88d000d          STRB     r0,[sp,#0xd]
;;;373    	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
00013c  f04f0001          MOV      r0,#1
000140  f88d000e          STRB     r0,[sp,#0xe]
;;;374    	EXTI_Init(&EXTI_InitStructure);
000144  a802              ADD      r0,sp,#8
000146  f7fffffe          BL       EXTI_Init
;;;375    }
00014a  bd1f              POP      {r0-r4,pc}
;;;376    
                          ENDP

                  EXTILine7_Config PROC
;;;378    ///PF7
;;;379    void EXTILine7_Config(void)
00014c  b51f              PUSH     {r0-r4,lr}
;;;380    {
;;;381    	EXTI_InitTypeDef   EXTI_InitStructure;
;;;382    	GPIO_InitTypeDef   GPIO_InitStructure;
;;;383    
;;;384    	/* Enable GPIOF clock */
;;;385    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);
00014e  2101              MOVS     r1,#1
000150  2020              MOVS     r0,#0x20
000152  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;386    	/* Enable SYSCFG clock */
;;;387    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
000156  2101              MOVS     r1,#1
000158  0388              LSLS     r0,r1,#14
00015a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;388      
;;;389    	/* Configure PF7 pin as input floating */
;;;390    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
00015e  f04f0000          MOV      r0,#0
000162  f88d0004          STRB     r0,[sp,#4]
;;;391    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
000166  f88d0007          STRB     r0,[sp,#7]
;;;392    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;
00016a  f04f0080          MOV      r0,#0x80
00016e  9000              STR      r0,[sp,#0]
;;;393    	GPIO_Init(GPIOF, &GPIO_InitStructure);
000170  4669              MOV      r1,sp
000172  4822              LDR      r0,|L1.508|
000174  f7fffffe          BL       GPIO_Init
;;;394    
;;;395    	/* Connect EXTI Line6 to PF7 pin */
;;;396    	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOF, EXTI_PinSource7);
000178  2107              MOVS     r1,#7
00017a  2005              MOVS     r0,#5
00017c  f7fffffe          BL       SYSCFG_EXTILineConfig
;;;397    
;;;398    	/* Configure EXTI Line7 */
;;;399    	EXTI_InitStructure.EXTI_Line = EXTI_Line7;
000180  f04f0080          MOV      r0,#0x80
000184  9002              STR      r0,[sp,#8]
;;;400    	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
000186  f04f0000          MOV      r0,#0
00018a  f88d000c          STRB     r0,[sp,#0xc]
;;;401    	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  
00018e  f04f000c          MOV      r0,#0xc
000192  f88d000d          STRB     r0,[sp,#0xd]
;;;402    	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
000196  f04f0001          MOV      r0,#1
00019a  f88d000e          STRB     r0,[sp,#0xe]
;;;403    	EXTI_Init(&EXTI_InitStructure);
00019e  a802              ADD      r0,sp,#8
0001a0  f7fffffe          BL       EXTI_Init
;;;404    }
0001a4  bd1f              POP      {r0-r4,pc}
;;;405    
                          ENDP

                  BSP_EXTI9_5_ISRHandler PROC
;;;406    
;;;407    void BSP_EXTI9_5_ISRHandler(void)
0001a6  b510              PUSH     {r4,lr}
;;;408    {
;;;409    	uint8_t status = 0;
0001a8  f04f0400          MOV      r4,#0
;;;410    	
;;;411    	if(EXTI_GetITStatus(EXTI_Line6) != RESET)
0001ac  f04f0040          MOV      r0,#0x40
0001b0  f7fffffe          BL       EXTI_GetITStatus
0001b4  b120              CBZ      r0,|L1.448|
;;;412    	{    
;;;413    		/* Clear the EXTI line 6 pending bit */
;;;414    		EXTI_ClearITPendingBit(EXTI_Line6);
0001b6  2040              MOVS     r0,#0x40
0001b8  f7fffffe          BL       EXTI_ClearITPendingBit
;;;415    		status = 1;
0001bc  f04f0401          MOV      r4,#1
                  |L1.448|
;;;416    	}
;;;417    	
;;;418    	if(EXTI_GetITStatus(EXTI_Line7) != RESET)
0001c0  2080              MOVS     r0,#0x80
0001c2  f7fffffe          BL       EXTI_GetITStatus
0001c6  b120              CBZ      r0,|L1.466|
;;;419    	{    
;;;420    		/* Clear the EXTI line 6 pending bit */
;;;421    		EXTI_ClearITPendingBit(EXTI_Line7);
0001c8  2080              MOVS     r0,#0x80
0001ca  f7fffffe          BL       EXTI_ClearITPendingBit
;;;422    		status |= 2;
0001ce  f0440402          ORR      r4,r4,#2
                  |L1.466|
;;;423    	}
;;;424    	
;;;425    	if (BSP_Info.EXTI9_5_CallBack)
0001d2  480b              LDR      r0,|L1.512|
0001d4  f8d00130          LDR      r0,[r0,#0x130]  ; BSP_Info
0001d8  b128              CBZ      r0,|L1.486|
;;;426    		BSP_Info.EXTI9_5_CallBack(status, NULL);
0001da  4809              LDR      r0,|L1.512|
0001dc  2100              MOVS     r1,#0
0001de  f8d02130          LDR      r2,[r0,#0x130]  ; BSP_Info
0001e2  4620              MOV      r0,r4
0001e4  4790              BLX      r2
                  |L1.486|
;;;427    }
0001e6  bd10              POP      {r4,pc}
;;;428    
                          ENDP

                  |L1.488|
                          DCD      0x40020000
                  |L1.492|
                          DCD      0x4002041a
                  |L1.496|
                          DCD      0x40020418
                  |L1.500|
                          DCD      0x40020400
                  |L1.504|
                          DCD      0x40020414
                  |L1.508|
                          DCD      0x40021400
                  |L1.512|
                          DCD      BSP_Info

;*** Start embedded assembler ***

#line 1 "..\\BSP\\bsp_gpio.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_bsp_gpio_c_94e83328____REV16|
#line 112 "..\\BSP\\CMSIS\\core_cmInstr.h"
|__asm___10_bsp_gpio_c_94e83328____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_bsp_gpio_c_94e83328____REVSH|
#line 130
|__asm___10_bsp_gpio_c_94e83328____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
