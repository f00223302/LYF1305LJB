; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Output\stm32f2xx_spi.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\Output\stm32f2xx_spi.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\BSP -I..\BSP\UCOS-II -I..\BSP\STM32F2xx\inc -I..\BSP\CMSIS -I..\BSP\CMSIS\Device_Support -I..\BSP\UCOS-II -I..\..\uC-CPU -I..\..\uC-CPU\ARM-Cortex-M3 -I..\..\uC-LIB -I..\..\uC-LIB\Ports\ARM-Cortex-M3 -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3 -I..\App -I..\Prj -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\ST\STM32F2xx -DUSE_STDPERIPH_DRIVER -DDEBUG -DLJB_CPU_MAIN -DUSE_CPU_F205RC --omf_browse=.\Output\stm32f2xx_spi.crf ..\BSP\STM32F2xx\src\stm32f2xx_spi.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  SPI_I2S_DeInit PROC
;;;170      */
;;;171    void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
000000  b510              PUSH     {r4,lr}
;;;172    {
000002  4604              MOV      r4,r0
;;;173      /* Check the parameters */
;;;174      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;175    
;;;176      if (SPIx == SPI1)
000004  48f7              LDR      r0,|L1.996|
000006  4284              CMP      r4,r0
000008  d108              BNE      |L1.28|
;;;177      {
;;;178        /* Enable SPI1 reset state */
;;;179        RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  1480              ASRS     r0,r0,#18
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;180        /* Release SPI1 from reset state */
;;;181        RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
000012  2100              MOVS     r1,#0
000014  14a0              ASRS     r0,r4,#18
000016  f7fffffe          BL       RCC_APB2PeriphResetCmd
00001a  e016              B        |L1.74|
                  |L1.28|
;;;182      }
;;;183      else if (SPIx == SPI2)
00001c  48f2              LDR      r0,|L1.1000|
00001e  4284              CMP      r4,r0
000020  d108              BNE      |L1.52|
;;;184      {
;;;185        /* Enable SPI2 reset state */
;;;186        RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
000022  2101              MOVS     r1,#1
000024  1400              ASRS     r0,r0,#16
000026  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;187        /* Release SPI2 from reset state */
;;;188        RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
00002a  2100              MOVS     r1,#0
00002c  1420              ASRS     r0,r4,#16
00002e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000032  e00a              B        |L1.74|
                  |L1.52|
;;;189        }
;;;190      else
;;;191      {
;;;192        if (SPIx == SPI3)
000034  48ed              LDR      r0,|L1.1004|
000036  4284              CMP      r4,r0
000038  d107              BNE      |L1.74|
;;;193        {
;;;194          /* Enable SPI3 reset state */
;;;195          RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
00003a  2101              MOVS     r1,#1
00003c  13c0              ASRS     r0,r0,#15
00003e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;196          /* Release SPI3 from reset state */
;;;197          RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
000042  2100              MOVS     r1,#0
000044  13e0              ASRS     r0,r4,#15
000046  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L1.74|
;;;198        }
;;;199      }
;;;200    }
00004a  bd10              POP      {r4,pc}
;;;201    
                          ENDP

                  SPI_Init PROC
;;;209      */
;;;210    void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
00004c  b510              PUSH     {r4,lr}
;;;211    {
;;;212      uint16_t tmpreg = 0;
00004e  f04f0200          MOV      r2,#0
;;;213      
;;;214      /* check the parameters */
;;;215      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;216      
;;;217      /* Check the SPI parameters */
;;;218      assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
;;;219      assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
;;;220      assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
;;;221      assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
;;;222      assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
;;;223      assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
;;;224      assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
;;;225      assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
;;;226      assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
;;;227    
;;;228    /*---------------------------- SPIx CR1 Configuration ------------------------*/
;;;229      /* Get the SPIx CR1 value */
;;;230      tmpreg = SPIx->CR1;
000052  8802              LDRH     r2,[r0,#0]
;;;231      /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
;;;232      tmpreg &= CR1_CLEAR_MASK;
000054  f4025241          AND      r2,r2,#0x3040
;;;233      /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
;;;234         master/salve mode, CPOL and CPHA */
;;;235      /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
;;;236      /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
;;;237      /* Set LSBFirst bit according to SPI_FirstBit value */
;;;238      /* Set BR bits according to SPI_BaudRatePrescaler value */
;;;239      /* Set CPOL bit according to SPI_CPOL value */
;;;240      /* Set CPHA bit according to SPI_CPHA value */
;;;241      tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
000058  880b              LDRH     r3,[r1,#0]
00005a  884c              LDRH     r4,[r1,#2]
00005c  ea430304          ORR      r3,r3,r4
000060  888c              LDRH     r4,[r1,#4]
000062  ea430304          ORR      r3,r3,r4
000066  88cc              LDRH     r4,[r1,#6]
000068  ea430304          ORR      r3,r3,r4
00006c  890c              LDRH     r4,[r1,#8]
00006e  ea430304          ORR      r3,r3,r4
000072  894c              LDRH     r4,[r1,#0xa]
000074  ea430304          ORR      r3,r3,r4
000078  898c              LDRH     r4,[r1,#0xc]
00007a  ea430304          ORR      r3,r3,r4
00007e  89cc              LDRH     r4,[r1,#0xe]
000080  ea430304          ORR      r3,r3,r4
000084  ea430202          ORR      r2,r3,r2
;;;242                      SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
;;;243                      SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
;;;244                      SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
;;;245      /* Write to SPIx CR1 */
;;;246      SPIx->CR1 = tmpreg;
000088  8002              STRH     r2,[r0,#0]
;;;247    
;;;248      /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
;;;249      SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
00008a  8b83              LDRH     r3,[r0,#0x1c]
00008c  f24f74ff          MOV      r4,#0xf7ff
000090  ea030304          AND      r3,r3,r4
000094  8383              STRH     r3,[r0,#0x1c]
;;;250    /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
;;;251      /* Write to SPIx CRCPOLY */
;;;252      SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
000096  8a0b              LDRH     r3,[r1,#0x10]
000098  8203              STRH     r3,[r0,#0x10]
;;;253    }
00009a  bd10              POP      {r4,pc}
;;;254    
                          ENDP

                  I2S_Init PROC
;;;273      */
;;;274    void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
00009c  e92d4ff0          PUSH     {r4-r11,lr}
;;;275    {
;;;276      uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
0000a0  f04f0500          MOV      r5,#0
0000a4  f04f0302          MOV      r3,#2
0000a8  f04f0400          MOV      r4,#0
0000ac  f04f0701          MOV      r7,#1
;;;277      uint32_t tmp = 0, i2sclk = 0;
0000b0  f04f0200          MOV      r2,#0
0000b4  4616              MOV      r6,r2
;;;278    #ifndef I2S_EXTERNAL_CLOCK_VAL
;;;279      uint32_t pllm = 0, plln = 0, pllr = 0;
0000b6  4694              MOV      r12,r2
0000b8  4690              MOV      r8,r2
0000ba  4691              MOV      r9,r2
;;;280    #endif /* I2S_EXTERNAL_CLOCK_VAL */
;;;281      
;;;282      /* Check the I2S parameters */
;;;283      assert_param(IS_SPI_23_PERIPH(SPIx));
;;;284      assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
;;;285      assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
;;;286      assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
;;;287      assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
;;;288      assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
;;;289      assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
;;;290    
;;;291    /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
;;;292      /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
;;;293      SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
0000bc  f8b0a01c          LDRH     r10,[r0,#0x1c]
0000c0  f24f0b40          MOV      r11,#0xf040
0000c4  ea0a0a0b          AND      r10,r10,r11
0000c8  f8a0a01c          STRH     r10,[r0,#0x1c]
;;;294      SPIx->I2SPR = 0x0002;
0000cc  f04f0a02          MOV      r10,#2
0000d0  f8a0a020          STRH     r10,[r0,#0x20]
;;;295      
;;;296      /* Get the I2SCFGR register value */
;;;297      tmpreg = SPIx->I2SCFGR;
0000d4  8b85              LDRH     r5,[r0,#0x1c]
;;;298      
;;;299      /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
;;;300      if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
0000d6  f8d1a008          LDR      r10,[r1,#8]
0000da  f1ba0f02          CMP      r10,#2
0000de  d101              BNE      |L1.228|
;;;301      {
;;;302        i2sodd = (uint16_t)0;
0000e0  bf00              NOP      
;;;303        i2sdiv = (uint16_t)2;   
0000e2  e064              B        |L1.430|
                  |L1.228|
;;;304      }
;;;305      /* If the requested audio frequency is not the default, compute the prescaler */
;;;306      else
;;;307      {
;;;308        /* Check the frame length (For the Prescaler computing) *******************/
;;;309        if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
0000e4  f8b1a004          LDRH     r10,[r1,#4]
0000e8  f1ba0f00          CMP      r10,#0
0000ec  d102              BNE      |L1.244|
;;;310        {
;;;311          /* Packet length is 16 bits */
;;;312          packetlength = 1;
0000ee  f04f0701          MOV      r7,#1
0000f2  e001              B        |L1.248|
                  |L1.244|
;;;313        }
;;;314        else
;;;315        {
;;;316          /* Packet length is 32 bits */
;;;317          packetlength = 2;
0000f4  f04f0702          MOV      r7,#2
                  |L1.248|
;;;318        }
;;;319    
;;;320        /* Get I2S source Clock frequency (only in Silicon RevisionB and RevisionY) */
;;;321          
;;;322        /* If an external I2S clock has to be used, this define should be set  
;;;323           in the project configuration or in the stm32f2xx_conf.h file */
;;;324      #ifdef I2S_EXTERNAL_CLOCK_VAL     
;;;325        /* Set external clock as I2S clock source */
;;;326        if ((RCC->CFGR & RCC_CFGR_I2SSRC) == 0)
;;;327        {
;;;328          RCC->CFGR |= (uint32_t)RCC_CFGR_I2SSRC;
;;;329        }
;;;330        
;;;331        /* Set the I2S clock to the external clock  value */
;;;332        i2sclk = I2S_EXTERNAL_CLOCK_VAL;
;;;333    
;;;334      #else /* There is no define for External I2S clock source */
;;;335        /* Set PLLI2S as I2S clock source */
;;;336        if ((RCC->CFGR & RCC_CFGR_I2SSRC) != 0)
0000f8  f8dfa2f4          LDR      r10,|L1.1008|
0000fc  f8daa000          LDR      r10,[r10,#0]
000100  f41a0f00          TST      r10,#0x800000
000104  d009              BEQ      |L1.282|
;;;337        {
;;;338          RCC->CFGR &= ~(uint32_t)RCC_CFGR_I2SSRC;
000106  f8dfa2e8          LDR      r10,|L1.1008|
00010a  f8daa000          LDR      r10,[r10,#0]
00010e  f42a0a00          BIC      r10,r10,#0x800000
000112  f8dfb2dc          LDR      r11,|L1.1008|
000116  f8cba000          STR      r10,[r11,#0]
                  |L1.282|
;;;339        }    
;;;340        
;;;341        /* Get the PLLI2SN value */
;;;342        plln = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & \
00011a  f8dfa2d8          LDR      r10,|L1.1012|
00011e  f8daa000          LDR      r10,[r10,#0]
000122  f3ca1888          UBFX     r8,r10,#6,#9
;;;343                          (RCC_PLLI2SCFGR_PLLI2SN >> 6));
;;;344        
;;;345        /* Get the PLLI2SR value */
;;;346        pllr = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28) & \
000126  f8dfa2cc          LDR      r10,|L1.1012|
00012a  f8daa000          LDR      r10,[r10,#0]
00012e  f3ca7902          UBFX     r9,r10,#28,#3
;;;347                          (RCC_PLLI2SCFGR_PLLI2SR >> 28));
;;;348        
;;;349        /* Get the PLLM value */
;;;350        pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);      
000132  f8dfa2c4          LDR      r10,|L1.1016|
000136  f8daa000          LDR      r10,[r10,#0]
00013a  f00a0c3f          AND      r12,r10,#0x3f
;;;351        
;;;352        /* Get the I2S source clock value */
;;;353        i2sclk = (uint32_t)(((HSE_VALUE / pllm) * plln) / pllr);
00013e  f8dfa2bc          LDR      r10,|L1.1020|
000142  fbbafafc          UDIV     r10,r10,r12
000146  fb0afa08          MUL      r10,r10,r8
00014a  fbbaf6f9          UDIV     r6,r10,r9
;;;354      #endif /* I2S_EXTERNAL_CLOCK_VAL */
;;;355        
;;;356        /* Compute the Real divider depending on the MCLK output state, with a floating point */
;;;357        if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
00014e  f8b1a006          LDRH     r10,[r1,#6]
000152  f5ba7f00          CMP      r10,#0x200
000156  d10e              BNE      |L1.374|
;;;358        {
;;;359          /* MCLK output is enabled */
;;;360          tmp = (uint16_t)(((((i2sclk / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
000158  ea4f2a16          LSR      r10,r6,#8
00015c  eb0a0a8a          ADD      r10,r10,r10,LSL #2
000160  ea4f0a4a          LSL      r10,r10,#1
000164  f8d1b008          LDR      r11,[r1,#8]
000168  fbbafafb          UDIV     r10,r10,r11
00016c  f10a0a05          ADD      r10,r10,#5
000170  fa1ff28a          UXTH     r2,r10
000174  e00f              B        |L1.406|
                  |L1.374|
;;;361        }
;;;362        else
;;;363        {
;;;364          /* MCLK output is disabled */
;;;365          tmp = (uint16_t)(((((i2sclk / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
000176  ea4f1a47          LSL      r10,r7,#5
00017a  fbb6fafa          UDIV     r10,r6,r10
00017e  eb0a0a8a          ADD      r10,r10,r10,LSL #2
000182  ea4f0a4a          LSL      r10,r10,#1
000186  f8d1b008          LDR      r11,[r1,#8]
00018a  fbbafafb          UDIV     r10,r10,r11
00018e  f10a0a05          ADD      r10,r10,#5
000192  fa1ff28a          UXTH     r2,r10
                  |L1.406|
;;;366        }
;;;367        
;;;368        /* Remove the flatting point */
;;;369        tmp = tmp / 10;  
000196  f04f0a0a          MOV      r10,#0xa
00019a  fbb2f2fa          UDIV     r2,r2,r10
;;;370          
;;;371        /* Check the parity of the divider */
;;;372        i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
00019e  f0020401          AND      r4,r2,#1
;;;373       
;;;374        /* Compute the i2sdiv prescaler */
;;;375        i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
0001a2  eba20a04          SUB      r10,r2,r4
0001a6  f3ca034f          UBFX     r3,r10,#1,#16
;;;376       
;;;377        /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
;;;378        i2sodd = (uint16_t) (i2sodd << 8);
0001aa  ea4f2404          LSL      r4,r4,#8
                  |L1.430|
;;;379      }
;;;380    
;;;381      /* Test if the divider is 1 or 0 or greater than 0xFF */
;;;382      if ((i2sdiv < 2) || (i2sdiv > 0xFF))
0001ae  2b02              CMP      r3,#2
0001b0  db01              BLT      |L1.438|
0001b2  2bff              CMP      r3,#0xff
0001b4  dd03              BLE      |L1.446|
                  |L1.438|
;;;383      {
;;;384        /* Set the default values */
;;;385        i2sdiv = 2;
0001b6  f04f0302          MOV      r3,#2
;;;386        i2sodd = 0;
0001ba  f04f0400          MOV      r4,#0
                  |L1.446|
;;;387      }
;;;388    
;;;389      /* Write to SPIx I2SPR register the computed value */
;;;390      SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
0001be  f8b1a006          LDRH     r10,[r1,#6]
0001c2  ea4a0a04          ORR      r10,r10,r4
0001c6  ea4a0a03          ORR      r10,r10,r3
0001ca  f8a0a020          STRH     r10,[r0,#0x20]
;;;391     
;;;392      /* Configure the I2S with the SPI_InitStruct values */
;;;393      tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
0001ce  f8b1a004          LDRH     r10,[r1,#4]
0001d2  f8b1b00c          LDRH     r11,[r1,#0xc]
0001d6  ea4a0a0b          ORR      r10,r10,r11
0001da  f8b1b002          LDRH     r11,[r1,#2]
0001de  ea4a0a0b          ORR      r10,r10,r11
0001e2  f8b1b000          LDRH     r11,[r1,#0]
0001e6  ea4a0a0b          ORR      r10,r10,r11
0001ea  f44a6a00          ORR      r10,r10,#0x800
0001ee  ea4a0505          ORR      r5,r10,r5
;;;394                      (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
;;;395                      (uint16_t)I2S_InitStruct->I2S_CPOL))));
;;;396     
;;;397      /* Write to SPIx I2SCFGR */  
;;;398      SPIx->I2SCFGR = tmpreg;
0001f2  8385              STRH     r5,[r0,#0x1c]
;;;399    }
0001f4  e8bd8ff0          POP      {r4-r11,pc}
;;;400    
                          ENDP

                  SPI_StructInit PROC
;;;405      */
;;;406    void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
0001f8  f04f0100          MOV      r1,#0
;;;407    {
;;;408    /*--------------- Reset SPI init structure parameters values -----------------*/
;;;409      /* Initialize the SPI_Direction member */
;;;410      SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
0001fc  8001              STRH     r1,[r0,#0]
;;;411      /* initialize the SPI_Mode member */
;;;412      SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
0001fe  8041              STRH     r1,[r0,#2]
;;;413      /* initialize the SPI_DataSize member */
;;;414      SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
000200  8081              STRH     r1,[r0,#4]
;;;415      /* Initialize the SPI_CPOL member */
;;;416      SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
000202  80c1              STRH     r1,[r0,#6]
;;;417      /* Initialize the SPI_CPHA member */
;;;418      SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
000204  8101              STRH     r1,[r0,#8]
;;;419      /* Initialize the SPI_NSS member */
;;;420      SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
000206  8141              STRH     r1,[r0,#0xa]
;;;421      /* Initialize the SPI_BaudRatePrescaler member */
;;;422      SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
000208  8181              STRH     r1,[r0,#0xc]
;;;423      /* Initialize the SPI_FirstBit member */
;;;424      SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
00020a  81c1              STRH     r1,[r0,#0xe]
;;;425      /* Initialize the SPI_CRCPolynomial member */
;;;426      SPI_InitStruct->SPI_CRCPolynomial = 7;
00020c  f04f0107          MOV      r1,#7
000210  8201              STRH     r1,[r0,#0x10]
;;;427    }
000212  4770              BX       lr
;;;428    
                          ENDP

                  I2S_StructInit PROC
;;;433      */
;;;434    void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
000214  f04f0100          MOV      r1,#0
;;;435    {
;;;436    /*--------------- Reset I2S init structure parameters values -----------------*/
;;;437      /* Initialize the I2S_Mode member */
;;;438      I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
000218  8001              STRH     r1,[r0,#0]
;;;439      
;;;440      /* Initialize the I2S_Standard member */
;;;441      I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
00021a  8041              STRH     r1,[r0,#2]
;;;442      
;;;443      /* Initialize the I2S_DataFormat member */
;;;444      I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
00021c  8081              STRH     r1,[r0,#4]
;;;445      
;;;446      /* Initialize the I2S_MCLKOutput member */
;;;447      I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
00021e  80c1              STRH     r1,[r0,#6]
;;;448      
;;;449      /* Initialize the I2S_AudioFreq member */
;;;450      I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
000220  f04f0102          MOV      r1,#2
000224  6081              STR      r1,[r0,#8]
;;;451      
;;;452      /* Initialize the I2S_CPOL member */
;;;453      I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
000226  f04f0100          MOV      r1,#0
00022a  8181              STRH     r1,[r0,#0xc]
;;;454    }
00022c  4770              BX       lr
;;;455    
                          ENDP

                  SPI_Cmd PROC
;;;462      */
;;;463    void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
00022e  b121              CBZ      r1,|L1.570|
;;;464    {
;;;465      /* Check the parameters */
;;;466      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;467      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;468      if (NewState != DISABLE)
;;;469      {
;;;470        /* Enable the selected SPI peripheral */
;;;471        SPIx->CR1 |= SPI_CR1_SPE;
000230  8802              LDRH     r2,[r0,#0]
000232  f0420240          ORR      r2,r2,#0x40
000236  8002              STRH     r2,[r0,#0]
000238  e005              B        |L1.582|
                  |L1.570|
;;;472      }
;;;473      else
;;;474      {
;;;475        /* Disable the selected SPI peripheral */
;;;476        SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
00023a  8802              LDRH     r2,[r0,#0]
00023c  f64f73bf          MOV      r3,#0xffbf
000240  ea020203          AND      r2,r2,r3
000244  8002              STRH     r2,[r0,#0]
                  |L1.582|
;;;477      }
;;;478    }
000246  4770              BX       lr
;;;479    
                          ENDP

                  I2S_Cmd PROC
;;;486      */
;;;487    void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
000248  b121              CBZ      r1,|L1.596|
;;;488    {
;;;489      /* Check the parameters */
;;;490      assert_param(IS_SPI_23_PERIPH(SPIx));
;;;491      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;492      
;;;493      if (NewState != DISABLE)
;;;494      {
;;;495        /* Enable the selected SPI peripheral (in I2S mode) */
;;;496        SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
00024a  8b82              LDRH     r2,[r0,#0x1c]
00024c  f4426280          ORR      r2,r2,#0x400
000250  8382              STRH     r2,[r0,#0x1c]
000252  e005              B        |L1.608|
                  |L1.596|
;;;497      }
;;;498      else
;;;499      {
;;;500        /* Disable the selected SPI peripheral in I2S mode */
;;;501        SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
000254  8b82              LDRH     r2,[r0,#0x1c]
000256  f64f33ff          MOV      r3,#0xfbff
00025a  ea020203          AND      r2,r2,r3
00025e  8382              STRH     r2,[r0,#0x1c]
                  |L1.608|
;;;502      }
;;;503    }
000260  4770              BX       lr
;;;504    
                          ENDP

                  SPI_DataSizeConfig PROC
;;;513      */
;;;514    void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
000262  8802              LDRH     r2,[r0,#0]
;;;515    {
;;;516      /* Check the parameters */
;;;517      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;518      assert_param(IS_SPI_DATASIZE(SPI_DataSize));
;;;519      /* Clear DFF bit */
;;;520      SPIx->CR1 &= (uint16_t)~SPI_DataSize_16b;
000264  f24f73ff          MOV      r3,#0xf7ff
000268  ea020203          AND      r2,r2,r3
00026c  8002              STRH     r2,[r0,#0]
;;;521      /* Set new DFF bit value */
;;;522      SPIx->CR1 |= SPI_DataSize;
00026e  8802              LDRH     r2,[r0,#0]
000270  ea420201          ORR      r2,r2,r1
000274  8002              STRH     r2,[r0,#0]
;;;523    }
000276  4770              BX       lr
;;;524    
                          ENDP

                  SPI_BiDirectionalLineConfig PROC
;;;533      */
;;;534    void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
000278  f5b14f80          CMP      r1,#0x4000
;;;535    {
;;;536      /* Check the parameters */
;;;537      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;538      assert_param(IS_SPI_DIRECTION(SPI_Direction));
;;;539      if (SPI_Direction == SPI_Direction_Tx)
00027c  d104              BNE      |L1.648|
;;;540      {
;;;541        /* Set the Tx only mode */
;;;542        SPIx->CR1 |= SPI_Direction_Tx;
00027e  8802              LDRH     r2,[r0,#0]
000280  f4424280          ORR      r2,r2,#0x4000
000284  8002              STRH     r2,[r0,#0]
000286  e005              B        |L1.660|
                  |L1.648|
;;;543      }
;;;544      else
;;;545      {
;;;546        /* Set the Rx only mode */
;;;547        SPIx->CR1 &= SPI_Direction_Rx;
000288  8802              LDRH     r2,[r0,#0]
00028a  f64b73ff          MOV      r3,#0xbfff
00028e  ea020203          AND      r2,r2,r3
000292  8002              STRH     r2,[r0,#0]
                  |L1.660|
;;;548      }
;;;549    }
000294  4770              BX       lr
;;;550    
                          ENDP

                  SPI_NSSInternalSoftwareConfig PROC
;;;559      */
;;;560    void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
000296  f5a1427e          SUB      r2,r1,#0xfe00
;;;561    {
;;;562      /* Check the parameters */
;;;563      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;564      assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
;;;565      if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
00029a  3aff              SUBS     r2,r2,#0xff
00029c  d004              BEQ      |L1.680|
;;;566      {
;;;567        /* Set NSS pin internally by software */
;;;568        SPIx->CR1 |= SPI_NSSInternalSoft_Set;
00029e  8802              LDRH     r2,[r0,#0]
0002a0  f4427280          ORR      r2,r2,#0x100
0002a4  8002              STRH     r2,[r0,#0]
0002a6  e005              B        |L1.692|
                  |L1.680|
;;;569      }
;;;570      else
;;;571      {
;;;572        /* Reset NSS pin internally by software */
;;;573        SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
0002a8  8802              LDRH     r2,[r0,#0]
0002aa  f64f63ff          MOV      r3,#0xfeff
0002ae  ea020203          AND      r2,r2,r3
0002b2  8002              STRH     r2,[r0,#0]
                  |L1.692|
;;;574      }
;;;575    }
0002b4  4770              BX       lr
;;;576    
                          ENDP

                  SPI_SSOutputCmd PROC
;;;583      */
;;;584    void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
0002b6  b121              CBZ      r1,|L1.706|
;;;585    {
;;;586      /* Check the parameters */
;;;587      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;588      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;589      if (NewState != DISABLE)
;;;590      {
;;;591        /* Enable the selected SPI SS output */
;;;592        SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
0002b8  8882              LDRH     r2,[r0,#4]
0002ba  f0420204          ORR      r2,r2,#4
0002be  8082              STRH     r2,[r0,#4]
0002c0  e005              B        |L1.718|
                  |L1.706|
;;;593      }
;;;594      else
;;;595      {
;;;596        /* Disable the selected SPI SS output */
;;;597        SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
0002c2  8882              LDRH     r2,[r0,#4]
0002c4  f64f73fb          MOV      r3,#0xfffb
0002c8  ea020203          AND      r2,r2,r3
0002cc  8082              STRH     r2,[r0,#4]
                  |L1.718|
;;;598      }
;;;599    }
0002ce  4770              BX       lr
;;;600    
                          ENDP

                  SPI_TIModeCmd PROC
;;;614      */
;;;615    void SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
0002d0  b121              CBZ      r1,|L1.732|
;;;616    {
;;;617      /* Check the parameters */
;;;618      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;619      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;620    
;;;621      if (NewState != DISABLE)
;;;622      {
;;;623        /* Enable the TI mode for the selected SPI peripheral */
;;;624        SPIx->CR2 |= SPI_CR2_FRF;
0002d2  8882              LDRH     r2,[r0,#4]
0002d4  f0420210          ORR      r2,r2,#0x10
0002d8  8082              STRH     r2,[r0,#4]
0002da  e005              B        |L1.744|
                  |L1.732|
;;;625      }
;;;626      else
;;;627      {
;;;628        /* Disable the TI mode for the selected SPI peripheral */
;;;629        SPIx->CR2 &= (uint16_t)~SPI_CR2_FRF;
0002dc  8882              LDRH     r2,[r0,#4]
0002de  f64f73ef          MOV      r3,#0xffef
0002e2  ea020203          AND      r2,r2,r3
0002e6  8082              STRH     r2,[r0,#4]
                  |L1.744|
;;;630      }
;;;631    }
0002e8  4770              BX       lr
;;;632    
                          ENDP

                  SPI_I2S_ReceiveData PROC
;;;665      */
;;;666    uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
0002ea  4601              MOV      r1,r0
;;;667    {
;;;668      /* Check the parameters */
;;;669      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;670      
;;;671      /* Return the data in the DR register */
;;;672      return SPIx->DR;
0002ec  8988              LDRH     r0,[r1,#0xc]
;;;673    }
0002ee  4770              BX       lr
;;;674    
                          ENDP

                  SPI_I2S_SendData PROC
;;;681      */
;;;682    void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
0002f0  8181              STRH     r1,[r0,#0xc]
;;;683    {
;;;684      /* Check the parameters */
;;;685      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;686      
;;;687      /* Write in the DR register the data to be sent */
;;;688      SPIx->DR = Data;
;;;689    }
0002f2  4770              BX       lr
;;;690    
                          ENDP

                  SPI_CalculateCRC PROC
;;;770      */
;;;771    void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
0002f4  b121              CBZ      r1,|L1.768|
;;;772    {
;;;773      /* Check the parameters */
;;;774      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;775      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;776      if (NewState != DISABLE)
;;;777      {
;;;778        /* Enable the selected SPI CRC calculation */
;;;779        SPIx->CR1 |= SPI_CR1_CRCEN;
0002f6  8802              LDRH     r2,[r0,#0]
0002f8  f4425200          ORR      r2,r2,#0x2000
0002fc  8002              STRH     r2,[r0,#0]
0002fe  e005              B        |L1.780|
                  |L1.768|
;;;780      }
;;;781      else
;;;782      {
;;;783        /* Disable the selected SPI CRC calculation */
;;;784        SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
000300  8802              LDRH     r2,[r0,#0]
000302  f64d73ff          MOV      r3,#0xdfff
000306  ea020203          AND      r2,r2,r3
00030a  8002              STRH     r2,[r0,#0]
                  |L1.780|
;;;785      }
;;;786    }
00030c  4770              BX       lr
;;;787    
                          ENDP

                  SPI_TransmitCRC PROC
;;;792      */
;;;793    void SPI_TransmitCRC(SPI_TypeDef* SPIx)
00030e  8801              LDRH     r1,[r0,#0]
;;;794    {
;;;795      /* Check the parameters */
;;;796      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;797      
;;;798      /* Enable the selected SPI CRC transmission */
;;;799      SPIx->CR1 |= SPI_CR1_CRCNEXT;
000310  f4415180          ORR      r1,r1,#0x1000
000314  8001              STRH     r1,[r0,#0]
;;;800    }
000316  4770              BX       lr
;;;801    
                          ENDP

                  SPI_GetCRC PROC
;;;810      */
;;;811    uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)
000318  4602              MOV      r2,r0
;;;812    {
;;;813      uint16_t crcreg = 0;
00031a  f04f0000          MOV      r0,#0
;;;814      /* Check the parameters */
;;;815      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;816      assert_param(IS_SPI_CRC(SPI_CRC));
;;;817      if (SPI_CRC != SPI_CRC_Rx)
00031e  2901              CMP      r1,#1
000320  d001              BEQ      |L1.806|
;;;818      {
;;;819        /* Get the Tx CRC register */
;;;820        crcreg = SPIx->TXCRCR;
000322  8b10              LDRH     r0,[r2,#0x18]
000324  e000              B        |L1.808|
                  |L1.806|
;;;821      }
;;;822      else
;;;823      {
;;;824        /* Get the Rx CRC register */
;;;825        crcreg = SPIx->RXCRCR;
000326  8a90              LDRH     r0,[r2,#0x14]
                  |L1.808|
;;;826      }
;;;827      /* Return the selected CRC register */
;;;828      return crcreg;
;;;829    }
000328  4770              BX       lr
;;;830    
                          ENDP

                  SPI_GetCRCPolynomial PROC
;;;835      */
;;;836    uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
00032a  4601              MOV      r1,r0
;;;837    {
;;;838      /* Check the parameters */
;;;839      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;840      
;;;841      /* Return the CRC polynomial register */
;;;842      return SPIx->CRCPR;
00032c  8a08              LDRH     r0,[r1,#0x10]
;;;843    }
00032e  4770              BX       lr
;;;844    
                          ENDP

                  SPI_I2S_DMACmd PROC
;;;872      */
;;;873    void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
000330  b510              PUSH     {r4,lr}
;;;874    {
;;;875      /* Check the parameters */
;;;876      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;877      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;878      assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
;;;879    
;;;880      if (NewState != DISABLE)
000332  b122              CBZ      r2,|L1.830|
;;;881      {
;;;882        /* Enable the selected SPI DMA requests */
;;;883        SPIx->CR2 |= SPI_I2S_DMAReq;
000334  8883              LDRH     r3,[r0,#4]
000336  ea430301          ORR      r3,r3,r1
00033a  8083              STRH     r3,[r0,#4]
00033c  e006              B        |L1.844|
                  |L1.830|
;;;884      }
;;;885      else
;;;886      {
;;;887        /* Disable the selected SPI DMA requests */
;;;888        SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
00033e  8883              LDRH     r3,[r0,#4]
000340  ea6f0401          MVN      r4,r1
000344  b2a4              UXTH     r4,r4
000346  ea030304          AND      r3,r3,r4
00034a  8083              STRH     r3,[r0,#4]
                  |L1.844|
;;;889      }
;;;890    }
00034c  bd10              POP      {r4,pc}
;;;891    
                          ENDP

                  SPI_I2S_ITConfig PROC
;;;981      */
;;;982    void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
00034e  b570              PUSH     {r4-r6,lr}
;;;983    {
;;;984      uint16_t itpos = 0, itmask = 0 ;
000350  f04f0400          MOV      r4,#0
000354  4623              MOV      r3,r4
;;;985      
;;;986      /* Check the parameters */
;;;987      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;988      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;989      assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
;;;990    
;;;991      /* Get the SPI IT index */
;;;992      itpos = SPI_I2S_IT >> 4;
000356  ea4f1421          ASR      r4,r1,#4
;;;993    
;;;994      /* Set the IT mask */
;;;995      itmask = (uint16_t)1 << (uint16_t)itpos;
00035a  f04f0501          MOV      r5,#1
00035e  fa05f504          LSL      r5,r5,r4
000362  b2ab              UXTH     r3,r5
;;;996    
;;;997      if (NewState != DISABLE)
000364  b122              CBZ      r2,|L1.880|
;;;998      {
;;;999        /* Enable the selected SPI interrupt */
;;;1000       SPIx->CR2 |= itmask;
000366  8885              LDRH     r5,[r0,#4]
000368  ea450503          ORR      r5,r5,r3
00036c  8085              STRH     r5,[r0,#4]
00036e  e006              B        |L1.894|
                  |L1.880|
;;;1001     }
;;;1002     else
;;;1003     {
;;;1004       /* Disable the selected SPI interrupt */
;;;1005       SPIx->CR2 &= (uint16_t)~itmask;
000370  8885              LDRH     r5,[r0,#4]
000372  ea6f0603          MVN      r6,r3
000376  b2b6              UXTH     r6,r6
000378  ea050506          AND      r5,r5,r6
00037c  8085              STRH     r5,[r0,#4]
                  |L1.894|
;;;1006     }
;;;1007   }
00037e  bd70              POP      {r4-r6,pc}
;;;1008   
                          ENDP

                  SPI_I2S_GetFlagStatus PROC
;;;1025     */
;;;1026   FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
000380  4602              MOV      r2,r0
;;;1027   {
;;;1028     FlagStatus bitstatus = RESET;
000382  f04f0000          MOV      r0,#0
;;;1029     /* Check the parameters */
;;;1030     assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;1031     assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
;;;1032     
;;;1033     /* Check the status of the specified SPI flag */
;;;1034     if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
000386  8913              LDRH     r3,[r2,#8]
000388  420b              TST      r3,r1
00038a  d002              BEQ      |L1.914|
;;;1035     {
;;;1036       /* SPI_I2S_FLAG is set */
;;;1037       bitstatus = SET;
00038c  f04f0001          MOV      r0,#1
000390  e001              B        |L1.918|
                  |L1.914|
;;;1038     }
;;;1039     else
;;;1040     {
;;;1041       /* SPI_I2S_FLAG is reset */
;;;1042       bitstatus = RESET;
000392  f04f0000          MOV      r0,#0
                  |L1.918|
;;;1043     }
;;;1044     /* Return the SPI_I2S_FLAG status */
;;;1045     return  bitstatus;
;;;1046   }
000396  4770              BX       lr
;;;1047   
                          ENDP

                  SPI_I2S_ClearFlag PROC
;;;1066     */
;;;1067   void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
000398  ea6f0201          MVN      r2,r1
;;;1068   {
;;;1069     /* Check the parameters */
;;;1070     assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;1071     assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
;;;1072       
;;;1073     /* Clear the selected SPI CRC Error (CRCERR) flag */
;;;1074     SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
00039c  8102              STRH     r2,[r0,#8]
;;;1075   }
00039e  4770              BX       lr
;;;1076   
                          ENDP

                  SPI_I2S_GetITStatus PROC
;;;1091     */
;;;1092   ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
0003a0  b5f0              PUSH     {r4-r7,lr}
;;;1093   {
0003a2  4602              MOV      r2,r0
;;;1094     ITStatus bitstatus = RESET;
0003a4  f04f0000          MOV      r0,#0
;;;1095     uint16_t itpos = 0, itmask = 0, enablestatus = 0;
0003a8  4604              MOV      r4,r0
0003aa  4603              MOV      r3,r0
0003ac  4605              MOV      r5,r0
;;;1096   
;;;1097     /* Check the parameters */
;;;1098     assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;1099     assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
;;;1100   
;;;1101     /* Get the SPI_I2S_IT index */
;;;1102     itpos = 0x01 << (SPI_I2S_IT & 0x0F);
0003ae  f001070f          AND      r7,r1,#0xf
0003b2  f04f0601          MOV      r6,#1
0003b6  fa06f607          LSL      r6,r6,r7
0003ba  b2b4              UXTH     r4,r6
;;;1103   
;;;1104     /* Get the SPI_I2S_IT IT mask */
;;;1105     itmask = SPI_I2S_IT >> 4;
0003bc  ea4f1321          ASR      r3,r1,#4
;;;1106   
;;;1107     /* Set the IT mask */
;;;1108     itmask = 0x01 << itmask;
0003c0  f04f0601          MOV      r6,#1
0003c4  fa06f603          LSL      r6,r6,r3
0003c8  b2b3              UXTH     r3,r6
;;;1109   
;;;1110     /* Get the SPI_I2S_IT enable bit status */
;;;1111     enablestatus = (SPIx->CR2 & itmask) ;
0003ca  8896              LDRH     r6,[r2,#4]
0003cc  ea060503          AND      r5,r6,r3
;;;1112   
;;;1113     /* Check the status of the specified SPI interrupt */
;;;1114     if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
0003d0  8916              LDRH     r6,[r2,#8]
0003d2  4226              TST      r6,r4
0003d4  d003              BEQ      |L1.990|
0003d6  b115              CBZ      r5,|L1.990|
;;;1115     {
;;;1116       /* SPI_I2S_IT is set */
;;;1117       bitstatus = SET;
0003d8  f04f0001          MOV      r0,#1
0003dc  e001              B        |L1.994|
                  |L1.990|
;;;1118     }
;;;1119     else
;;;1120     {
;;;1121       /* SPI_I2S_IT is reset */
;;;1122       bitstatus = RESET;
0003de  f04f0000          MOV      r0,#0
                  |L1.994|
;;;1123     }
;;;1124     /* Return the SPI_I2S_IT status */
;;;1125     return bitstatus;
;;;1126   }
0003e2  bdf0              POP      {r4-r7,pc}
                  |L1.996|
                          DCD      0x40013000
                  |L1.1000|
                          DCD      0x40003800
                  |L1.1004|
                          DCD      0x40003c00
                  |L1.1008|
                          DCD      0x40023808
                  |L1.1012|
                          DCD      0x40023884
                  |L1.1016|
                          DCD      0x40023804
                  |L1.1020|
                          DCD      0x017d7840
                          ENDP

                  SPI_I2S_ClearITPendingBit PROC
;;;1146     */
;;;1147   void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
000400  b510              PUSH     {r4,lr}
;;;1148   {
;;;1149     uint16_t itpos = 0;
000402  f04f0200          MOV      r2,#0
;;;1150     /* Check the parameters */
;;;1151     assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;1152     assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
;;;1153   
;;;1154     /* Get the SPI_I2S IT index */
;;;1155     itpos = 0x01 << (SPI_I2S_IT & 0x0F);
000406  f001040f          AND      r4,r1,#0xf
00040a  f04f0301          MOV      r3,#1
00040e  fa03f304          LSL      r3,r3,r4
000412  b29a              UXTH     r2,r3
;;;1156   
;;;1157     /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
;;;1158     SPIx->SR = (uint16_t)~itpos;
000414  ea6f0302          MVN      r3,r2
000418  8103              STRH     r3,[r0,#8]
;;;1159   }
00041a  bd10              POP      {r4,pc}
;;;1160   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\BSP\\STM32F2xx\\src\\stm32f2xx_spi.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f2xx_spi_c_2b928927____REV16|
#line 112 "..\\BSP\\CMSIS\\core_cmInstr.h"
|__asm___15_stm32f2xx_spi_c_2b928927____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f2xx_spi_c_2b928927____REVSH|
#line 130
|__asm___15_stm32f2xx_spi_c_2b928927____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
